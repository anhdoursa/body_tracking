(function(){var OC={924:function(xt,$e,l0){"use strict";var t0=l0(210),W0=l0(559),z0=W0(t0("String.prototype.indexOf"));xt.exports=function(V0,Z0){var ft=t0(V0,!!Z0);return typeof ft=="function"&&z0(V0,".prototype.")>-1?W0(ft):ft}},559:function(xt,$e,l0){"use strict";var t0=l0(612),W0=l0(210),z0=W0("%Function.prototype.apply%"),w0=W0("%Function.prototype.call%"),V0=W0("%Reflect.apply%",!0)||t0.call(w0,z0),Z0=W0("%Object.getOwnPropertyDescriptor%",!0),ft=W0("%Object.defineProperty%",!0),G=W0("%Math.max%");if(ft)try{ft({},"a",{value:1})}catch{ft=null}xt.exports=function(be){var T0=V0(t0,w0,arguments);if(Z0&&ft){var Lt=Z0(T0,"length");Lt.configurable&&ft(T0,"length",{value:1+G(0,be.length-(arguments.length-1))})}return T0};var F0=function(){return V0(t0,z0,arguments)};ft?ft(xt.exports,"apply",{value:F0}):xt.exports.apply=F0},187:function(xt){"use strict";var $e=typeof Reflect=="object"?Reflect:null,l0=$e&&typeof $e.apply=="function"?$e.apply:function(Ke,a0,X0){return Function.prototype.apply.call(Ke,a0,X0)},t0;$e&&typeof $e.ownKeys=="function"?t0=$e.ownKeys:Object.getOwnPropertySymbols?t0=function(Ke){return Object.getOwnPropertyNames(Ke).concat(Object.getOwnPropertySymbols(Ke))}:t0=function(Ke){return Object.getOwnPropertyNames(Ke)};function W0(Je){console&&console.warn&&console.warn(Je)}var z0=Number.isNaN||function(Ke){return Ke!==Ke};function w0(){w0.init.call(this)}xt.exports=w0,xt.exports.once=Wt,w0.EventEmitter=w0,w0.prototype._events=void 0,w0.prototype._eventsCount=0,w0.prototype._maxListeners=void 0;var V0=10;function Z0(Je){if(typeof Je!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof Je)}Object.defineProperty(w0,"defaultMaxListeners",{enumerable:!0,get:function(){return V0},set:function(Je){if(typeof Je!="number"||Je<0||z0(Je))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+Je+".");V0=Je}}),w0.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},w0.prototype.setMaxListeners=function(Ke){if(typeof Ke!="number"||Ke<0||z0(Ke))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+Ke+".");return this._maxListeners=Ke,this};function ft(Je){return Je._maxListeners===void 0?w0.defaultMaxListeners:Je._maxListeners}w0.prototype.getMaxListeners=function(){return ft(this)},w0.prototype.emit=function(Ke){for(var a0=[],X0=1;X0<arguments.length;X0++)a0.push(arguments[X0]);var Q0=Ke==="error",Nt=this._events;if(Nt!==void 0)Q0=Q0&&Nt.error===void 0;else if(!Q0)return!1;if(Q0){var it;if(a0.length>0&&(it=a0[0]),it instanceof Error)throw it;var kx=new Error("Unhandled error."+(it?" ("+it.message+")":""));throw kx.context=it,kx}var tx=Nt[Ke];if(tx===void 0)return!1;if(typeof tx=="function")l0(tx,this,a0);else for(var Dt=tx.length,vx=Lt(tx,Dt),X0=0;X0<Dt;++X0)l0(vx[X0],this,a0);return!0};function G(Je,Ke,a0,X0){var Q0,Nt,it;if(Z0(a0),Nt=Je._events,Nt===void 0?(Nt=Je._events=Object.create(null),Je._eventsCount=0):(Nt.newListener!==void 0&&(Je.emit("newListener",Ke,a0.listener?a0.listener:a0),Nt=Je._events),it=Nt[Ke]),it===void 0)it=Nt[Ke]=a0,++Je._eventsCount;else if(typeof it=="function"?it=Nt[Ke]=X0?[a0,it]:[it,a0]:X0?it.unshift(a0):it.push(a0),Q0=ft(Je),Q0>0&&it.length>Q0&&!it.warned){it.warned=!0;var kx=new Error("Possible EventEmitter memory leak detected. "+it.length+" "+String(Ke)+" listeners added. Use emitter.setMaxListeners() to increase limit");kx.name="MaxListenersExceededWarning",kx.emitter=Je,kx.type=Ke,kx.count=it.length,W0(kx)}return Je}w0.prototype.addListener=function(Ke,a0){return G(this,Ke,a0,!1)},w0.prototype.on=w0.prototype.addListener,w0.prototype.prependListener=function(Ke,a0){return G(this,Ke,a0,!0)};function F0(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function nt(Je,Ke,a0){var X0={fired:!1,wrapFn:void 0,target:Je,type:Ke,listener:a0},Q0=F0.bind(X0);return Q0.listener=a0,X0.wrapFn=Q0,Q0}w0.prototype.once=function(Ke,a0){return Z0(a0),this.on(Ke,nt(this,Ke,a0)),this},w0.prototype.prependOnceListener=function(Ke,a0){return Z0(a0),this.prependListener(Ke,nt(this,Ke,a0)),this},w0.prototype.removeListener=function(Ke,a0){var X0,Q0,Nt,it,kx;if(Z0(a0),Q0=this._events,Q0===void 0)return this;if(X0=Q0[Ke],X0===void 0)return this;if(X0===a0||X0.listener===a0)--this._eventsCount===0?this._events=Object.create(null):(delete Q0[Ke],Q0.removeListener&&this.emit("removeListener",Ke,X0.listener||a0));else if(typeof X0!="function"){for(Nt=-1,it=X0.length-1;it>=0;it--)if(X0[it]===a0||X0[it].listener===a0){kx=X0[it].listener,Nt=it;break}if(Nt<0)return this;Nt===0?X0.shift():ex(X0,Nt),X0.length===1&&(Q0[Ke]=X0[0]),Q0.removeListener!==void 0&&this.emit("removeListener",Ke,kx||a0)}return this},w0.prototype.off=w0.prototype.removeListener,w0.prototype.removeAllListeners=function(Ke){var a0,X0,Q0;if(X0=this._events,X0===void 0)return this;if(X0.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):X0[Ke]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete X0[Ke]),this;if(arguments.length===0){var Nt=Object.keys(X0),it;for(Q0=0;Q0<Nt.length;++Q0)it=Nt[Q0],it!=="removeListener"&&this.removeAllListeners(it);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(a0=X0[Ke],typeof a0=="function")this.removeListener(Ke,a0);else if(a0!==void 0)for(Q0=a0.length-1;Q0>=0;Q0--)this.removeListener(Ke,a0[Q0]);return this};function be(Je,Ke,a0){var X0=Je._events;if(X0===void 0)return[];var Q0=X0[Ke];return Q0===void 0?[]:typeof Q0=="function"?a0?[Q0.listener||Q0]:[Q0]:a0?yt(Q0):Lt(Q0,Q0.length)}w0.prototype.listeners=function(Ke){return be(this,Ke,!0)},w0.prototype.rawListeners=function(Ke){return be(this,Ke,!1)},w0.listenerCount=function(Je,Ke){return typeof Je.listenerCount=="function"?Je.listenerCount(Ke):T0.call(Je,Ke)},w0.prototype.listenerCount=T0;function T0(Je){var Ke=this._events;if(Ke!==void 0){var a0=Ke[Je];if(typeof a0=="function")return 1;if(a0!==void 0)return a0.length}return 0}w0.prototype.eventNames=function(){return this._eventsCount>0?t0(this._events):[]};function Lt(Je,Ke){for(var a0=new Array(Ke),X0=0;X0<Ke;++X0)a0[X0]=Je[X0];return a0}function ex(Je,Ke){for(;Ke+1<Je.length;Ke++)Je[Ke]=Je[Ke+1];Je.pop()}function yt(Je){for(var Ke=new Array(Je.length),a0=0;a0<Ke.length;++a0)Ke[a0]=Je[a0].listener||Je[a0];return Ke}function Wt(Je,Ke){return new Promise(function(a0,X0){function Q0(it){Je.removeListener(Ke,Nt),X0(it)}function Nt(){typeof Je.removeListener=="function"&&Je.removeListener("error",Q0),a0([].slice.call(arguments))}_0(Je,Ke,Nt,{once:!0}),Ke!=="error"&&It(Je,Q0,{once:!0})})}function It(Je,Ke,a0){typeof Je.on=="function"&&_0(Je,"error",Ke,a0)}function _0(Je,Ke,a0,X0){if(typeof Je.on=="function")X0.once?Je.once(Ke,a0):Je.on(Ke,a0);else if(typeof Je.addEventListener=="function")Je.addEventListener(Ke,function Q0(Nt){X0.once&&Je.removeEventListener(Ke,Q0),a0(Nt)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof Je)}},29:function(xt,$e,l0){"use strict";var t0=l0(320),W0=Object.prototype.toString,z0=Object.prototype.hasOwnProperty,w0=function(F0,nt,be){for(var T0=0,Lt=F0.length;T0<Lt;T0++)z0.call(F0,T0)&&(be==null?nt(F0[T0],T0,F0):nt.call(be,F0[T0],T0,F0))},V0=function(F0,nt,be){for(var T0=0,Lt=F0.length;T0<Lt;T0++)be==null?nt(F0.charAt(T0),T0,F0):nt.call(be,F0.charAt(T0),T0,F0)},Z0=function(F0,nt,be){for(var T0 in F0)z0.call(F0,T0)&&(be==null?nt(F0[T0],T0,F0):nt.call(be,F0[T0],T0,F0))},ft=function(F0,nt,be){if(!t0(nt))throw new TypeError("iterator must be a function");var T0;arguments.length>=3&&(T0=be),W0.call(F0)==="[object Array]"?w0(F0,nt,T0):typeof F0=="string"?V0(F0,nt,T0):Z0(F0,nt,T0)};xt.exports=ft},648:function(xt){"use strict";var $e="Function.prototype.bind called on incompatible ",l0=Array.prototype.slice,t0=Object.prototype.toString,W0="[object Function]";xt.exports=function(w0){var V0=this;if(typeof V0!="function"||t0.call(V0)!==W0)throw new TypeError($e+V0);for(var Z0=l0.call(arguments,1),ft,G=function(){if(this instanceof ft){var Lt=V0.apply(this,Z0.concat(l0.call(arguments)));return Object(Lt)===Lt?Lt:this}else return V0.apply(w0,Z0.concat(l0.call(arguments)))},F0=Math.max(0,V0.length-Z0.length),nt=[],be=0;be<F0;be++)nt.push("$"+be);if(ft=Function("binder","return function ("+nt.join(",")+"){ return binder.apply(this,arguments); }")(G),V0.prototype){var T0=function(){};T0.prototype=V0.prototype,ft.prototype=new T0,T0.prototype=null}return ft}},612:function(xt,$e,l0){"use strict";var t0=l0(648);xt.exports=Function.prototype.bind||t0},210:function(xt,$e,l0){"use strict";var t0,W0=SyntaxError,z0=Function,w0=TypeError,V0=function(tx){try{return z0('"use strict"; return ('+tx+").constructor;")()}catch{}},Z0=Object.getOwnPropertyDescriptor;if(Z0)try{Z0({},"")}catch{Z0=null}var ft=function(){throw new w0},G=Z0?function(){try{return arguments.callee,ft}catch{try{return Z0(arguments,"callee").get}catch{return ft}}}():ft,F0=l0(405)(),nt=Object.getPrototypeOf||function(tx){return tx.__proto__},be={},T0=typeof Uint8Array>"u"?t0:nt(Uint8Array),Lt={"%AggregateError%":typeof AggregateError>"u"?t0:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?t0:ArrayBuffer,"%ArrayIteratorPrototype%":F0?nt([][Symbol.iterator]()):t0,"%AsyncFromSyncIteratorPrototype%":t0,"%AsyncFunction%":be,"%AsyncGenerator%":be,"%AsyncGeneratorFunction%":be,"%AsyncIteratorPrototype%":be,"%Atomics%":typeof Atomics>"u"?t0:Atomics,"%BigInt%":typeof BigInt>"u"?t0:BigInt,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?t0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":typeof Float32Array>"u"?t0:Float32Array,"%Float64Array%":typeof Float64Array>"u"?t0:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?t0:FinalizationRegistry,"%Function%":z0,"%GeneratorFunction%":be,"%Int8Array%":typeof Int8Array>"u"?t0:Int8Array,"%Int16Array%":typeof Int16Array>"u"?t0:Int16Array,"%Int32Array%":typeof Int32Array>"u"?t0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":F0?nt(nt([][Symbol.iterator]())):t0,"%JSON%":typeof JSON=="object"?JSON:t0,"%Map%":typeof Map>"u"?t0:Map,"%MapIteratorPrototype%":typeof Map>"u"||!F0?t0:nt(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?t0:Promise,"%Proxy%":typeof Proxy>"u"?t0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":typeof Reflect>"u"?t0:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?t0:Set,"%SetIteratorPrototype%":typeof Set>"u"||!F0?t0:nt(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?t0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":F0?nt(""[Symbol.iterator]()):t0,"%Symbol%":F0?Symbol:t0,"%SyntaxError%":W0,"%ThrowTypeError%":G,"%TypedArray%":T0,"%TypeError%":w0,"%Uint8Array%":typeof Uint8Array>"u"?t0:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?t0:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?t0:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?t0:Uint32Array,"%URIError%":URIError,"%WeakMap%":typeof WeakMap>"u"?t0:WeakMap,"%WeakRef%":typeof WeakRef>"u"?t0:WeakRef,"%WeakSet%":typeof WeakSet>"u"?t0:WeakSet},ex=function tx(Dt){var vx;if(Dt==="%AsyncFunction%")vx=V0("async function () {}");else if(Dt==="%GeneratorFunction%")vx=V0("function* () {}");else if(Dt==="%AsyncGeneratorFunction%")vx=V0("async function* () {}");else if(Dt==="%AsyncGenerator%"){var Gt=tx("%AsyncGeneratorFunction%");Gt&&(vx=Gt.prototype)}else if(Dt==="%AsyncIteratorPrototype%"){var gx=tx("%AsyncGenerator%");gx&&(vx=nt(gx.prototype))}return Lt[Dt]=vx,vx},yt={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},Wt=l0(612),It=l0(642),_0=Wt.call(Function.call,Array.prototype.concat),Je=Wt.call(Function.apply,Array.prototype.splice),Ke=Wt.call(Function.call,String.prototype.replace),a0=Wt.call(Function.call,String.prototype.slice),X0=Wt.call(Function.call,RegExp.prototype.exec),Q0=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Nt=/\\(\\)?/g,it=function(Dt){var vx=a0(Dt,0,1),Gt=a0(Dt,-1);if(vx==="%"&&Gt!=="%")throw new W0("invalid intrinsic syntax, expected closing `%`");if(Gt==="%"&&vx!=="%")throw new W0("invalid intrinsic syntax, expected opening `%`");var gx=[];return Ke(Dt,Q0,function(Bx,U0,wx,lx){gx[gx.length]=wx?Ke(lx,Nt,"$1"):U0||Bx}),gx},kx=function(Dt,vx){var Gt=Dt,gx;if(It(yt,Gt)&&(gx=yt[Gt],Gt="%"+gx[0]+"%"),It(Lt,Gt)){var Bx=Lt[Gt];if(Bx===be&&(Bx=ex(Gt)),typeof Bx>"u"&&!vx)throw new w0("intrinsic "+Dt+" exists, but is not available. Please file an issue!");return{alias:gx,name:Gt,value:Bx}}throw new W0("intrinsic "+Dt+" does not exist!")};xt.exports=function(Dt,vx){if(typeof Dt!="string"||Dt.length===0)throw new w0("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof vx!="boolean")throw new w0('"allowMissing" argument must be a boolean');if(X0(/^%?[^%]*%?$/,Dt)===null)throw new W0("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Gt=it(Dt),gx=Gt.length>0?Gt[0]:"",Bx=kx("%"+gx+"%",vx),U0=Bx.name,wx=Bx.value,lx=!1,A2=Bx.alias;A2&&(gx=A2[0],Je(Gt,_0([0,1],A2)));for(var l2=1,Ae=!0;l2<Gt.length;l2+=1){var He=Gt[l2],x0=a0(He,0,1),J0=a0(He,-1);if((x0==='"'||x0==="'"||x0==="`"||J0==='"'||J0==="'"||J0==="`")&&x0!==J0)throw new W0("property names with quotes must have matching quotes");if((He==="constructor"||!Ae)&&(lx=!0),gx+="."+He,U0="%"+gx+"%",It(Lt,U0))wx=Lt[U0];else if(wx!=null){if(!(He in wx)){if(!vx)throw new w0("base intrinsic for "+Dt+" exists, but the property is not available.");return}if(Z0&&l2+1>=Gt.length){var bt=Z0(wx,He);Ae=!!bt,Ae&&"get"in bt&&!("originalValue"in bt.get)?wx=bt.get:wx=wx[He]}else Ae=It(wx,He),wx=wx[He];Ae&&!lx&&(Lt[U0]=wx)}}return wx}},296:function(xt,$e,l0){"use strict";var t0=l0(210),W0=t0("%Object.getOwnPropertyDescriptor%",!0);if(W0)try{W0([],"length")}catch{W0=null}xt.exports=W0},405:function(xt,$e,l0){"use strict";var t0=typeof Symbol<"u"&&Symbol,W0=l0(419);xt.exports=function(){return typeof t0!="function"||typeof Symbol!="function"||typeof t0("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:W0()}},419:function(xt){"use strict";xt.exports=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var l0={},t0=Symbol("test"),W0=Object(t0);if(typeof t0=="string"||Object.prototype.toString.call(t0)!=="[object Symbol]"||Object.prototype.toString.call(W0)!=="[object Symbol]")return!1;var z0=42;l0[t0]=z0;for(t0 in l0)return!1;if(typeof Object.keys=="function"&&Object.keys(l0).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(l0).length!==0)return!1;var w0=Object.getOwnPropertySymbols(l0);if(w0.length!==1||w0[0]!==t0||!Object.prototype.propertyIsEnumerable.call(l0,t0))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var V0=Object.getOwnPropertyDescriptor(l0,t0);if(V0.value!==z0||V0.enumerable!==!0)return!1}return!0}},410:function(xt,$e,l0){"use strict";var t0=l0(419);xt.exports=function(){return t0()&&!!Symbol.toStringTag}},642:function(xt,$e,l0){"use strict";var t0=l0(612);xt.exports=t0.call(Function.call,Object.prototype.hasOwnProperty)},717:function(xt){typeof Object.create=="function"?xt.exports=function(l0,t0){t0&&(l0.super_=t0,l0.prototype=Object.create(t0.prototype,{constructor:{value:l0,enumerable:!1,writable:!0,configurable:!0}}))}:xt.exports=function(l0,t0){if(t0){l0.super_=t0;var W0=function(){};W0.prototype=t0.prototype,l0.prototype=new W0,l0.prototype.constructor=l0}}},584:function(xt,$e,l0){"use strict";var t0=l0(410)(),W0=l0(924),z0=W0("Object.prototype.toString"),w0=function(G){return t0&&G&&typeof G=="object"&&Symbol.toStringTag in G?!1:z0(G)==="[object Arguments]"},V0=function(G){return w0(G)?!0:G!==null&&typeof G=="object"&&typeof G.length=="number"&&G.length>=0&&z0(G)!=="[object Array]"&&z0(G.callee)==="[object Function]"},Z0=function(){return w0(arguments)}();w0.isLegacyArguments=V0,xt.exports=Z0?w0:V0},320:function(xt){"use strict";var $e=Function.prototype.toString,l0=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,t0,W0;if(typeof l0=="function"&&typeof Object.defineProperty=="function")try{t0=Object.defineProperty({},"length",{get:function(){throw W0}}),W0={},l0(function(){throw 42},null,t0)}catch(It){It!==W0&&(l0=null)}else l0=null;var z0=/^\s*class\b/,w0=function(_0){try{var Je=$e.call(_0);return z0.test(Je)}catch{return!1}},V0=function(_0){try{return w0(_0)?!1:($e.call(_0),!0)}catch{return!1}},Z0=Object.prototype.toString,ft="[object Object]",G="[object Function]",F0="[object GeneratorFunction]",nt="[object HTMLAllCollection]",be="[object HTML document.all class]",T0="[object HTMLCollection]",Lt=typeof Symbol=="function"&&!!Symbol.toStringTag,ex=!(0 in[,]),yt=function(){return!1};if(typeof document=="object"){var Wt=document.all;Z0.call(Wt)===Z0.call(document.all)&&(yt=function(_0){if((ex||!_0)&&(typeof _0>"u"||typeof _0=="object"))try{var Je=Z0.call(_0);return(Je===nt||Je===be||Je===T0||Je===ft)&&_0("")==null}catch{}return!1})}xt.exports=l0?function(_0){if(yt(_0))return!0;if(!_0||typeof _0!="function"&&typeof _0!="object")return!1;try{l0(_0,null,t0)}catch(Je){if(Je!==W0)return!1}return!w0(_0)&&V0(_0)}:function(_0){if(yt(_0))return!0;if(!_0||typeof _0!="function"&&typeof _0!="object")return!1;if(Lt)return V0(_0);if(w0(_0))return!1;var Je=Z0.call(_0);return Je!==G&&Je!==F0&&!/^\[object HTML/.test(Je)?!1:V0(_0)}},662:function(xt,$e,l0){"use strict";var t0=Object.prototype.toString,W0=Function.prototype.toString,z0=/^\s*(?:function)?\*/,w0=l0(410)(),V0=Object.getPrototypeOf,Z0=function(){if(!w0)return!1;try{return Function("return function*() {}")()}catch{}},ft;xt.exports=function(F0){if(typeof F0!="function")return!1;if(z0.test(W0.call(F0)))return!0;if(!w0){var nt=t0.call(F0);return nt==="[object GeneratorFunction]"}if(!V0)return!1;if(typeof ft>"u"){var be=Z0();ft=be?V0(be):!1}return V0(F0)===ft}},692:function(xt,$e,l0){"use strict";var t0=l0(29),W0=l0(83),z0=l0(924),w0=z0("Object.prototype.toString"),V0=l0(410)(),Z0=l0(296),ft=typeof globalThis>"u"?l0.g:globalThis,G=W0(),F0=z0("Array.prototype.indexOf",!0)||function(yt,Wt){for(var It=0;It<yt.length;It+=1)if(yt[It]===Wt)return It;return-1},nt=z0("String.prototype.slice"),be={},T0=Object.getPrototypeOf;V0&&Z0&&T0&&t0(G,function(ex){var yt=new ft[ex];if(Symbol.toStringTag in yt){var Wt=T0(yt),It=Z0(Wt,Symbol.toStringTag);if(!It){var _0=T0(Wt);It=Z0(_0,Symbol.toStringTag)}be[ex]=It.get}});var Lt=function(yt){var Wt=!1;return t0(be,function(It,_0){if(!Wt)try{Wt=It.call(yt)===_0}catch{}}),Wt};xt.exports=function(yt){if(!yt||typeof yt!="object")return!1;if(!V0||!(Symbol.toStringTag in yt)){var Wt=nt(w0(yt),8,-1);return F0(G,Wt)>-1}return Z0?Lt(yt):!1}},300:function(xt,$e,l0){"use strict";var t0=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof l0.g<"u")return l0.g;throw new Error("unable to locate global object")},W0=t0();xt.exports=$e=W0.fetch,W0.fetch&&($e.default=W0.fetch.bind(W0)),$e.Headers=W0.Headers,$e.Request=W0.Request,$e.Response=W0.Response},384:function(xt){xt.exports=function(l0){return l0&&typeof l0=="object"&&typeof l0.copy=="function"&&typeof l0.fill=="function"&&typeof l0.readUInt8=="function"}},955:function(xt,$e,l0){"use strict";var t0=l0(584),W0=l0(662),z0=l0(430),w0=l0(692);function V0(je){return je.call.bind(je)}var Z0=typeof BigInt<"u",ft=typeof Symbol<"u",G=V0(Object.prototype.toString),F0=V0(Number.prototype.valueOf),nt=V0(String.prototype.valueOf),be=V0(Boolean.prototype.valueOf);if(Z0)var T0=V0(BigInt.prototype.valueOf);if(ft)var Lt=V0(Symbol.prototype.valueOf);function ex(je,Po){if(typeof je!="object")return!1;try{return Po(je),!0}catch{return!1}}$e.isArgumentsObject=t0,$e.isGeneratorFunction=W0,$e.isTypedArray=w0;function yt(je){return typeof Promise<"u"&&je instanceof Promise||je!==null&&typeof je=="object"&&typeof je.then=="function"&&typeof je.catch=="function"}$e.isPromise=yt;function Wt(je){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(je):w0(je)||He(je)}$e.isArrayBufferView=Wt;function It(je){return z0(je)==="Uint8Array"}$e.isUint8Array=It;function _0(je){return z0(je)==="Uint8ClampedArray"}$e.isUint8ClampedArray=_0;function Je(je){return z0(je)==="Uint16Array"}$e.isUint16Array=Je;function Ke(je){return z0(je)==="Uint32Array"}$e.isUint32Array=Ke;function a0(je){return z0(je)==="Int8Array"}$e.isInt8Array=a0;function X0(je){return z0(je)==="Int16Array"}$e.isInt16Array=X0;function Q0(je){return z0(je)==="Int32Array"}$e.isInt32Array=Q0;function Nt(je){return z0(je)==="Float32Array"}$e.isFloat32Array=Nt;function it(je){return z0(je)==="Float64Array"}$e.isFloat64Array=it;function kx(je){return z0(je)==="BigInt64Array"}$e.isBigInt64Array=kx;function tx(je){return z0(je)==="BigUint64Array"}$e.isBigUint64Array=tx;function Dt(je){return G(je)==="[object Map]"}Dt.working=typeof Map<"u"&&Dt(new Map);function vx(je){return typeof Map>"u"?!1:Dt.working?Dt(je):je instanceof Map}$e.isMap=vx;function Gt(je){return G(je)==="[object Set]"}Gt.working=typeof Set<"u"&&Gt(new Set);function gx(je){return typeof Set>"u"?!1:Gt.working?Gt(je):je instanceof Set}$e.isSet=gx;function Bx(je){return G(je)==="[object WeakMap]"}Bx.working=typeof WeakMap<"u"&&Bx(new WeakMap);function U0(je){return typeof WeakMap>"u"?!1:Bx.working?Bx(je):je instanceof WeakMap}$e.isWeakMap=U0;function wx(je){return G(je)==="[object WeakSet]"}wx.working=typeof WeakSet<"u"&&wx(new WeakSet);function lx(je){return wx(je)}$e.isWeakSet=lx;function A2(je){return G(je)==="[object ArrayBuffer]"}A2.working=typeof ArrayBuffer<"u"&&A2(new ArrayBuffer);function l2(je){return typeof ArrayBuffer>"u"?!1:A2.working?A2(je):je instanceof ArrayBuffer}$e.isArrayBuffer=l2;function Ae(je){return G(je)==="[object DataView]"}Ae.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&Ae(new DataView(new ArrayBuffer(1),0,1));function He(je){return typeof DataView>"u"?!1:Ae.working?Ae(je):je instanceof DataView}$e.isDataView=He;var x0=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function J0(je){return G(je)==="[object SharedArrayBuffer]"}function bt(je){return typeof x0>"u"?!1:(typeof J0.working>"u"&&(J0.working=J0(new x0)),J0.working?J0(je):je instanceof x0)}$e.isSharedArrayBuffer=bt;function Bt(je){return G(je)==="[object AsyncFunction]"}$e.isAsyncFunction=Bt;function Tt(je){return G(je)==="[object Map Iterator]"}$e.isMapIterator=Tt;function Vt(je){return G(je)==="[object Set Iterator]"}$e.isSetIterator=Vt;function sx(je){return G(je)==="[object Generator]"}$e.isGeneratorObject=sx;function In(je){return G(je)==="[object WebAssembly.Module]"}$e.isWebAssemblyCompiledModule=In;function Er(je){return ex(je,F0)}$e.isNumberObject=Er;function Ce(je){return ex(je,nt)}$e.isStringObject=Ce;function Cr(je){return ex(je,be)}$e.isBooleanObject=Cr;function li(je){return Z0&&ex(je,T0)}$e.isBigIntObject=li;function ci(je){return ft&&ex(je,Lt)}$e.isSymbolObject=ci;function Ac(je){return Er(je)||Ce(je)||Cr(je)||li(je)||ci(je)}$e.isBoxedPrimitive=Ac;function Qh(je){return typeof Uint8Array<"u"&&(l2(je)||bt(je))}$e.isAnyArrayBuffer=Qh,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(je){Object.defineProperty($e,je,{enumerable:!1,value:function(){throw new Error(je+" is not supported in userland")}})})},539:function(xt,$e,l0){var t0=Object.getOwnPropertyDescriptors||function(He){for(var x0=Object.keys(He),J0={},bt=0;bt<x0.length;bt++)J0[x0[bt]]=Object.getOwnPropertyDescriptor(He,x0[bt]);return J0},W0=/%[sdj%]/g;$e.format=function(Ae){if(!a0(Ae)){for(var He=[],x0=0;x0<arguments.length;x0++)He.push(Z0(arguments[x0]));return He.join(" ")}for(var x0=1,J0=arguments,bt=J0.length,Bt=String(Ae).replace(W0,function(Vt){if(Vt==="%%")return"%";if(x0>=bt)return Vt;switch(Vt){case"%s":return String(J0[x0++]);case"%d":return Number(J0[x0++]);case"%j":try{return JSON.stringify(J0[x0++])}catch{return"[Circular]"}default:return Vt}}),Tt=J0[x0];x0<bt;Tt=J0[++x0])_0(Tt)||!it(Tt)?Bt+=" "+Tt:Bt+=" "+Z0(Tt);return Bt},$e.deprecate=function(Ae,He){if(typeof process<"u"&&process.noDeprecation===!0)return Ae;if(typeof process>"u")return function(){return $e.deprecate(Ae,He).apply(this,arguments)};var x0=!1;function J0(){if(!x0){if(process.throwDeprecation)throw new Error(He);process.traceDeprecation?console.trace(He):console.error(He),x0=!0}return Ae.apply(this,arguments)}return J0};var z0={},w0=/^$/;if(process.env.NODE_DEBUG){var V0=process.env.NODE_DEBUG;V0=V0.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),w0=new RegExp("^"+V0+"$","i")}$e.debuglog=function(Ae){if(Ae=Ae.toUpperCase(),!z0[Ae])if(w0.test(Ae)){var He=process.pid;z0[Ae]=function(){var x0=$e.format.apply($e,arguments);console.error("%s %d: %s",Ae,He,x0)}}else z0[Ae]=function(){};return z0[Ae]};function Z0(Ae,He){var x0={seen:[],stylize:G};return arguments.length>=3&&(x0.depth=arguments[2]),arguments.length>=4&&(x0.colors=arguments[3]),It(He)?x0.showHidden=He:He&&$e._extend(x0,He),Q0(x0.showHidden)&&(x0.showHidden=!1),Q0(x0.depth)&&(x0.depth=2),Q0(x0.colors)&&(x0.colors=!1),Q0(x0.customInspect)&&(x0.customInspect=!0),x0.colors&&(x0.stylize=ft),nt(x0,Ae,x0.depth)}$e.inspect=Z0,Z0.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},Z0.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function ft(Ae,He){var x0=Z0.styles[He];return x0?"\x1B["+Z0.colors[x0][0]+"m"+Ae+"\x1B["+Z0.colors[x0][1]+"m":Ae}function G(Ae,He){return Ae}function F0(Ae){var He={};return Ae.forEach(function(x0,J0){He[x0]=!0}),He}function nt(Ae,He,x0){if(Ae.customInspect&&He&&Dt(He.inspect)&&He.inspect!==$e.inspect&&!(He.constructor&&He.constructor.prototype===He)){var J0=He.inspect(x0,Ae);return a0(J0)||(J0=nt(Ae,J0,x0)),J0}var bt=be(Ae,He);if(bt)return bt;var Bt=Object.keys(He),Tt=F0(Bt);if(Ae.showHidden&&(Bt=Object.getOwnPropertyNames(He)),tx(He)&&(Bt.indexOf("message")>=0||Bt.indexOf("description")>=0))return T0(He);if(Bt.length===0){if(Dt(He)){var Vt=He.name?": "+He.name:"";return Ae.stylize("[Function"+Vt+"]","special")}if(Nt(He))return Ae.stylize(RegExp.prototype.toString.call(He),"regexp");if(kx(He))return Ae.stylize(Date.prototype.toString.call(He),"date");if(tx(He))return T0(He)}var sx="",In=!1,Er=["{","}"];if(Wt(He)&&(In=!0,Er=["[","]"]),Dt(He)){var Ce=He.name?": "+He.name:"";sx=" [Function"+Ce+"]"}if(Nt(He)&&(sx=" "+RegExp.prototype.toString.call(He)),kx(He)&&(sx=" "+Date.prototype.toUTCString.call(He)),tx(He)&&(sx=" "+T0(He)),Bt.length===0&&(!In||He.length==0))return Er[0]+sx+Er[1];if(x0<0)return Nt(He)?Ae.stylize(RegExp.prototype.toString.call(He),"regexp"):Ae.stylize("[Object]","special");Ae.seen.push(He);var Cr;return In?Cr=Lt(Ae,He,x0,Tt,Bt):Cr=Bt.map(function(li){return ex(Ae,He,x0,Tt,li,In)}),Ae.seen.pop(),yt(Cr,sx,Er)}function be(Ae,He){if(Q0(He))return Ae.stylize("undefined","undefined");if(a0(He)){var x0="'"+JSON.stringify(He).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return Ae.stylize(x0,"string")}if(Ke(He))return Ae.stylize(""+He,"number");if(It(He))return Ae.stylize(""+He,"boolean");if(_0(He))return Ae.stylize("null","null")}function T0(Ae){return"["+Error.prototype.toString.call(Ae)+"]"}function Lt(Ae,He,x0,J0,bt){for(var Bt=[],Tt=0,Vt=He.length;Tt<Vt;++Tt)wx(He,String(Tt))?Bt.push(ex(Ae,He,x0,J0,String(Tt),!0)):Bt.push("");return bt.forEach(function(sx){sx.match(/^\d+$/)||Bt.push(ex(Ae,He,x0,J0,sx,!0))}),Bt}function ex(Ae,He,x0,J0,bt,Bt){var Tt,Vt,sx;if(sx=Object.getOwnPropertyDescriptor(He,bt)||{value:He[bt]},sx.get?sx.set?Vt=Ae.stylize("[Getter/Setter]","special"):Vt=Ae.stylize("[Getter]","special"):sx.set&&(Vt=Ae.stylize("[Setter]","special")),wx(J0,bt)||(Tt="["+bt+"]"),Vt||(Ae.seen.indexOf(sx.value)<0?(_0(x0)?Vt=nt(Ae,sx.value,null):Vt=nt(Ae,sx.value,x0-1),Vt.indexOf(`
`)>-1&&(Bt?Vt=Vt.split(`
`).map(function(In){return"  "+In}).join(`
`).slice(2):Vt=`
`+Vt.split(`
`).map(function(In){return"   "+In}).join(`
`))):Vt=Ae.stylize("[Circular]","special")),Q0(Tt)){if(Bt&&bt.match(/^\d+$/))return Vt;Tt=JSON.stringify(""+bt),Tt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(Tt=Tt.slice(1,-1),Tt=Ae.stylize(Tt,"name")):(Tt=Tt.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),Tt=Ae.stylize(Tt,"string"))}return Tt+": "+Vt}function yt(Ae,He,x0){var J0=0,bt=Ae.reduce(function(Bt,Tt){return J0++,Tt.indexOf(`
`)>=0&&J0++,Bt+Tt.replace(/\u001b\[\d\d?m/g,"").length+1},0);return bt>60?x0[0]+(He===""?"":He+`
 `)+" "+Ae.join(`,
  `)+" "+x0[1]:x0[0]+He+" "+Ae.join(", ")+" "+x0[1]}$e.types=l0(955);function Wt(Ae){return Array.isArray(Ae)}$e.isArray=Wt;function It(Ae){return typeof Ae=="boolean"}$e.isBoolean=It;function _0(Ae){return Ae===null}$e.isNull=_0;function Je(Ae){return Ae==null}$e.isNullOrUndefined=Je;function Ke(Ae){return typeof Ae=="number"}$e.isNumber=Ke;function a0(Ae){return typeof Ae=="string"}$e.isString=a0;function X0(Ae){return typeof Ae=="symbol"}$e.isSymbol=X0;function Q0(Ae){return Ae===void 0}$e.isUndefined=Q0;function Nt(Ae){return it(Ae)&&Gt(Ae)==="[object RegExp]"}$e.isRegExp=Nt,$e.types.isRegExp=Nt;function it(Ae){return typeof Ae=="object"&&Ae!==null}$e.isObject=it;function kx(Ae){return it(Ae)&&Gt(Ae)==="[object Date]"}$e.isDate=kx,$e.types.isDate=kx;function tx(Ae){return it(Ae)&&(Gt(Ae)==="[object Error]"||Ae instanceof Error)}$e.isError=tx,$e.types.isNativeError=tx;function Dt(Ae){return typeof Ae=="function"}$e.isFunction=Dt;function vx(Ae){return Ae===null||typeof Ae=="boolean"||typeof Ae=="number"||typeof Ae=="string"||typeof Ae=="symbol"||typeof Ae>"u"}$e.isPrimitive=vx,$e.isBuffer=l0(384);function Gt(Ae){return Object.prototype.toString.call(Ae)}function gx(Ae){return Ae<10?"0"+Ae.toString(10):Ae.toString(10)}var Bx=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function U0(){var Ae=new Date,He=[gx(Ae.getHours()),gx(Ae.getMinutes()),gx(Ae.getSeconds())].join(":");return[Ae.getDate(),Bx[Ae.getMonth()],He].join(" ")}$e.log=function(){console.log("%s - %s",U0(),$e.format.apply($e,arguments))},$e.inherits=l0(717),$e._extend=function(Ae,He){if(!He||!it(He))return Ae;for(var x0=Object.keys(He),J0=x0.length;J0--;)Ae[x0[J0]]=He[x0[J0]];return Ae};function wx(Ae,He){return Object.prototype.hasOwnProperty.call(Ae,He)}var lx=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;$e.promisify=function(He){if(typeof He!="function")throw new TypeError('The "original" argument must be of type Function');if(lx&&He[lx]){var x0=He[lx];if(typeof x0!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(x0,lx,{value:x0,enumerable:!1,writable:!1,configurable:!0}),x0}function x0(){for(var J0,bt,Bt=new Promise(function(sx,In){J0=sx,bt=In}),Tt=[],Vt=0;Vt<arguments.length;Vt++)Tt.push(arguments[Vt]);Tt.push(function(sx,In){sx?bt(sx):J0(In)});try{He.apply(this,Tt)}catch(sx){bt(sx)}return Bt}return Object.setPrototypeOf(x0,Object.getPrototypeOf(He)),lx&&Object.defineProperty(x0,lx,{value:x0,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(x0,t0(He))},$e.promisify.custom=lx;function A2(Ae,He){if(!Ae){var x0=new Error("Promise was rejected with a falsy value");x0.reason=Ae,Ae=x0}return He(Ae)}function l2(Ae){if(typeof Ae!="function")throw new TypeError('The "original" argument must be of type Function');function He(){for(var x0=[],J0=0;J0<arguments.length;J0++)x0.push(arguments[J0]);var bt=x0.pop();if(typeof bt!="function")throw new TypeError("The last argument must be of type Function");var Bt=this,Tt=function(){return bt.apply(Bt,arguments)};Ae.apply(this,x0).then(function(Vt){process.nextTick(Tt.bind(null,null,Vt))},function(Vt){process.nextTick(A2.bind(null,Vt,Tt))})}return Object.setPrototypeOf(He,Object.getPrototypeOf(Ae)),Object.defineProperties(He,t0(Ae)),He}$e.callbackify=l2},430:function(xt,$e,l0){"use strict";var t0=l0(29),W0=l0(83),z0=l0(924),w0=l0(296),V0=z0("Object.prototype.toString"),Z0=l0(410)(),ft=typeof globalThis>"u"?l0.g:globalThis,G=W0(),F0=z0("String.prototype.slice"),nt={},be=Object.getPrototypeOf;Z0&&w0&&be&&t0(G,function(ex){if(typeof ft[ex]=="function"){var yt=new ft[ex];if(Symbol.toStringTag in yt){var Wt=be(yt),It=w0(Wt,Symbol.toStringTag);if(!It){var _0=be(Wt);It=w0(_0,Symbol.toStringTag)}nt[ex]=It.get}}});var T0=function(yt){var Wt=!1;return t0(nt,function(It,_0){if(!Wt)try{var Je=It.call(yt);Je===_0&&(Wt=Je)}catch{}}),Wt},Lt=l0(692);xt.exports=function(yt){return Lt(yt)?!Z0||!(Symbol.toStringTag in yt)?F0(V0(yt),8,-1):T0(yt):!1}},653:function(){},83:function(xt,$e,l0){"use strict";var t0=["BigInt64Array","BigUint64Array","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray"],W0=typeof globalThis>"u"?l0.g:globalThis;xt.exports=function(){for(var w0=[],V0=0;V0<t0.length;V0++)typeof W0[t0[V0]]=="function"&&(w0[w0.length]=t0[V0]);return w0}}},My={};function o2(xt){var $e=My[xt];if($e!==void 0)return $e.exports;var l0=My[xt]={exports:{}};return OC[xt](l0,l0.exports,o2),l0.exports}(function(){o2.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}()})();var Tne={};(function(){"use strict";function xt(s,x){return x.forEach(function(n){n&&typeof n!="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(r){if(r!=="default"&&!(r in s)){var a=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(s,r,a.get?a:{enumerable:!0,get:function(){return n[r]}})}})}),Object.freeze(s)}const $e=1e-7,l0=1e-4;class t0{constructor(x,n){this.backend=x,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(x){return this.data.has(x)||this.dataMover.moveData(this.backend,x),this.data.get(x)}set(x,n){this.dataIdsCount++,this.data.set(x,n)}has(x){return this.data.has(x)}delete(x){return this.dataIdsCount--,this.data.delete(x)}numDataIds(){return this.dataIdsCount}}class W0{refCount(x){return z0("refCount")}incRef(x){return z0("incRef")}timerAvailable(){return!0}time(x){return z0("time")}read(x){return z0("read")}readSync(x){return z0("readSync")}readToGPU(x,n){return z0("readToGPU")}numDataIds(){return z0("numDataIds")}disposeData(x,n){return z0("disposeData")}write(x,n,r){return z0("write")}move(x,n,r,a,i){return z0("move")}createTensorFromGPUData(x,n,r){return z0("createTensorFromGPUData")}memory(){return z0("memory")}floatPrecision(){return z0("floatPrecision")}epsilon(){return this.floatPrecision()===32?$e:l0}dispose(){return z0("dispose")}}function z0(s){throw new Error("'"+s+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function w0(s,x,n){return Math.max(s,Math.min(x,n))}function V0(s){return s%2===0?s:s+1}function Z0(s,x,n){const r=s[x];s[x]=s[n],s[n]=r}function ft(s){let x=0;for(let n=0;n<s.length;n++)x+=s[n];return x}function G(s,x){if(!s)throw new Error(typeof x=="string"?x:x())}function F0(s,x,n=""){G(T0(s,x),()=>n+(" Shapes "+s+" and "+x+" must match"))}function nt(s){G(s!=null,()=>"The input to the tensor constructor must be a non-null value.")}function be(s){if(s.length===0)return 1;let x=s[0];for(let n=1;n<s.length;n++)x*=s[n];return x}function T0(s,x){if(s===x)return!0;if(s==null||x==null||s.length!==x.length)return!1;for(let n=0;n<s.length;n++)if(s[n]!==x[n])return!1;return!0}function Lt(s){return s%1===0}function ex(s){const x=Math.ceil(Math.sqrt(s));return[x,Math.ceil(s/x)]}function yt(s,x){return x<=s.length?s:s+" ".repeat(x-s.length)}function Wt(s,x=a=>0,n,r){return new Promise((a,i)=>{let o=0;const l=()=>{if(s()){a();return}o++;const c=x(o);if(n!=null&&o>=n){i();return}r!=null?r(l,c):setTimeout(l,c)};l()})}function It(s,x){let n=1,r=-1;for(let i=0;i<s.length;++i)if(s[i]>=0)n*=s[i];else if(s[i]===-1){if(r!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+i);r=i}else if(s[i]<0)throw Error("Shapes can not be < 0. Found "+s[i]+" at dim "+i);if(r===-1){if(x>0&&x!==n)throw Error("Size("+x+") must match the product of shape "+s);return s}if(n===0)throw Error("Cannot infer the missing size in ["+s+"] when there are 0 elements");if(x%n!==0)throw Error("The implicit shape can't be a fractional number. Got "+x+" / "+n);const a=s.slice();return a[r]=x/n,a}function _0(s,x){const n=x.length;return s=s==null?x.map((r,a)=>a):[].concat(s),G(s.every(r=>r>=-n&&r<n),()=>"All values in axis param must be in range [-"+n+", "+n+") but got axis "+s),G(s.every(r=>Lt(r)),()=>"All values in axis param must be integers but got axis "+s),s.map(r=>r<0?n+r:r)}function Je(s,x){const n=[],r=[],a=x!=null&&Array.isArray(x)&&x.length===0,i=x==null||a?null:_0(x,s).sort();let o=0;for(let l=0;l<s.length;++l){if(i!=null){if(i[o]===l&&s[l]!==1)throw new Error("Can't squeeze axis "+l+" since its dim '"+s[l]+"' is not 1");(i[o]==null||i[o]>l)&&s[l]===1&&(n.push(s[l]),r.push(l)),i[o]<=l&&o++}s[l]!==1&&(n.push(s[l]),r.push(l))}return{newShape:n,keptDims:r}}function Ke(s,x){let n=null;if(s==null||s==="float32")n=new Float32Array(x);else if(s==="int32")n=new Int32Array(x);else if(s==="bool")n=new Uint8Array(x);else throw new Error("Unknown data type "+s);return n}function a0(s,x){let n=null;if(s==null||s==="float32")n=new Float32Array(x);else if(s==="int32")n=new Int32Array(x);else if(s==="bool")n=new Uint8Array(x);else if(s==="string")n=new Array(x);else throw new Error("Unknown data type "+s);return n}function X0(s,x){for(let n=0;n<s.length;n++){const r=s[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+x+" being uploaded contains "+r+".")}}function Q0(s){return s==="bool"||s==="complex64"||s==="float32"||s==="int32"||s==="string"}function Nt(s,x){return!(x==="complex64"||x==="float32"&&s!=="complex64"||x==="int32"&&s!=="float32"&&s!=="complex64"||x==="bool"&&s==="bool")}function it(s){if(s==="float32"||s==="int32")return 4;if(s==="complex64")return 8;if(s==="bool")return 1;throw new Error("Unknown dtype "+s)}function kx(s){if(s==null)return 0;let x=0;return s.forEach(n=>x+=n.length),x}function tx(s){return typeof s=="string"||s instanceof String}function Dt(s){return typeof s=="boolean"}function vx(s){return typeof s=="number"}function Gt(s){return Array.isArray(s)?Gt(s[0]):s instanceof Float32Array?"float32":s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray?"int32":vx(s)?"float32":tx(s)?"string":Dt(s)?"bool":"float32"}function gx(s){return!!(s&&s.constructor&&s.call&&s.apply)}function Bx(s,x){for(let n=x;n<s;++n)if(s%n===0)return n;return s}function U0(s){const x=s.length;if(x<2)return[];const n=new Array(x-1);n[x-2]=s[x-1];for(let r=x-3;r>=0;--r)n[r]=n[r+1]*s[r+1];return n}function wx(s,x,n,r=!1){const a=new Array;if(x.length===1){const i=x[0]*(r?2:1);for(let o=0;o<i;o++)a[o]=n[s+o]}else{const i=x[0],o=x.slice(1),l=o.reduce((c,d)=>c*d)*(r?2:1);for(let c=0;c<i;c++)a[c]=wx(s+c*l,o,n,r)}return a}function lx(s,x,n=!1){if(s.length===0)return x[0];const r=s.reduce((a,i)=>a*i)*(n?2:1);if(r===0)return[];if(r!==x.length)throw new Error("["+s+"] does not match the input size "+x.length+(n?" for a complex tensor":"")+".");return wx(0,s,x,n)}function A2(s,x){if(Array.isArray(s))return s;if(x==="float32")return s instanceof Float32Array?s:new Float32Array(s);if(x==="int32")return s instanceof Int32Array?s:new Int32Array(s);if(x==="bool"||x==="string")return Uint8Array.from(new Int32Array(s));throw new Error("Unknown dtype "+x)}function l2(s,x){const n=Ae(s,x);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ae(s,x){if(x==null||x==="float32"||x==="complex64")return new Float32Array(s);if(x==="int32")return new Int32Array(s);if(x==="bool")return new Uint8Array(s);throw new Error("Unknown data type "+x)}function He(s,x){const n=s.reduce((r,a)=>r*a,1);if(x==null||x==="float32")return lx(s,new Float32Array(n));if(x==="int32")return lx(s,new Int32Array(n));if(x==="bool")return lx(s,new Uint8Array(n));throw new Error("Unknown data type "+x)}function x0(s){s.forEach(x=>{G(Number.isInteger(x)&&x>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+s+"].")})}function J0(s,x,n){if(x===0)return 0;if(x===1)return s[0];let r=s[s.length-1];for(let a=0;a<s.length-1;++a)r+=n[a]*s[a];return r}function bt(s,x,n){if(x===0)return[];if(x===1)return[s];const r=new Array(x);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(s/n[a]),s-=r[a]*n[a];return r[r.length-1]=s,r}function Bt(s){return s&&s.then&&typeof s.then=="function"}const Tt="tfjsflags";class Vt{constructor(x){this.global=x,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=sx,this.populateURLFlags()}setPlatform(x,n){this.platform!=null&&(Ce().getBool("IS_TEST")||Ce().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+x+".")),this.platformName=x,this.platform=n}registerFlag(x,n,r){if(this.flagRegistry[x]={evaluationFn:n,setHook:r},this.urlFlags[x]!=null){const a=this.urlFlags[x];Ce().getBool("IS_TEST")||Ce().getBool("PROD")||console.warn("Setting feature override from URL "+x+": "+a+"."),this.set(x,a)}}async getAsync(x){return x in this.flags?this.flags[x]:(this.flags[x]=await this.evaluateFlag(x),this.flags[x])}get(x){if(x in this.flags)return this.flags[x];const n=this.evaluateFlag(x);if(Bt(n))throw new Error("Flag "+x+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[x]=n,this.flags[x]}getNumber(x){return this.get(x)}getBool(x){return this.get(x)}getFlags(){return this.flags}get features(){return this.flags}set(x,n){if(this.flagRegistry[x]==null)throw new Error("Cannot set flag "+x+" as it has not been registered.");this.flags[x]=n,this.flagRegistry[x].setHook!=null&&this.flagRegistry[x].setHook(n)}evaluateFlag(x){if(this.flagRegistry[x]==null)throw new Error("Cannot evaluate flag '"+x+"': no evaluation function found.");return this.flagRegistry[x].evaluationFn()}setFlags(x){this.flags=Object.assign({},x)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const x=this.getQueryParams(this.global.location.search);Tt in x&&x[Tt].split(",").forEach(n=>{const[r,a]=n.split(":");this.urlFlags[r]=Er(r,a)})}}function sx(s){const x={};return s.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(In(x,r[0],r[1]),r.join("="))),x}function In(s,x,n){s[decodeURIComponent(x)]=decodeURIComponent(n||"")}function Er(s,x){if(x=x.toLowerCase(),x==="true"||x==="false")return x==="true";if(""+ +x===x)return+x;throw new Error("Could not parse value flag value "+x+" for flag "+s+".")}function Ce(){return Cr}let Cr=null;function li(s){Cr=s}let ci;function Ac(){if(ci==null){let s;if(typeof window<"u")s=window;else if(typeof o2.g<"u")s=o2.g;else if(typeof process<"u")s=process;else if(typeof self<"u")s=self;else throw new Error("Could not find a global object");ci=s}return ci}function Qh(){const s=Ac();return s._tfGlobals==null&&(s._tfGlobals=new Map),s._tfGlobals}function je(s,x){const n=Qh();if(n.has(s))return n.get(s);{const r=x();return n.set(s,r),n.get(s)}}const Po="Abs",Lo="Acos",Ec="Acosh",Do="Add",jh="AddN",ep="All",tp="Any",xp="ArgMax",np="ArgMin",Cc="Asin",Mc="Asinh",Ic="Atan",kc="Atanh",Nc="Atan2",rp="AvgPool",Iy="AvgPoolGrad",sp="AvgPool3D",ky="AvgPool3DGrad",ap="BatchMatMul",ip="BatchToSpaceND",op="Bincount",lp="BroadcastArgs",Rc="Cast",Pc="Ceil",Lc="ClipByValue",cp="Complex",up="ComplexAbs",dp="Concat",hp="Conv2D",pp="Conv2DBackpropFilter",fp="Conv2DBackpropInput",mp="Conv3D",Ny="Conv3DBackpropFilterV2",gp="Conv3DBackpropInputV2",Dc="Cos",Oc="Cosh",yp="Cumprod",bp="Cumsum",vp="CropAndResize",wp="DenseBincount",_p="DepthToSpace",Sp="DepthwiseConv2dNative",Tp="DepthwiseConv2dNativeBackpropFilter",Ap="DepthwiseConv2dNativeBackpropInput",Ep="Diag",Cp="Dilation2D",Ry="Dilation2DBackpropInput",Py="Dilation2DBackpropFilter",Fc="RealDiv",Mp="Einsum",Uc="Elu",Ly="EluGrad",Bc="Erf",zc="Equal",Wc="Exp",Ip="ExpandDims",Gc="Expm1",kp="FFT",Np="Fill",Rp="FlipLeftRight",Vc="Floor",Hc="FloorDiv",Pp="FusedBatchNorm",Lp="GatherV2",Dp="GatherNd",Yc="Greater",qc="GreaterEqual",Xc="Identity",Op="IFFT",Fp="Imag",Kc="IsFinite",$c="IsInf",Zc="IsNan",Up="LeakyRelu",Jc="Less",Qc="LessEqual",Bp="LinSpace",jc="Log",eu="Log1p",tu="LogicalAnd",xu="LogicalNot",nu="LogicalOr",zp="LRN",Dy="LRNGrad",Wp="Max",ru="Maximum",Gp="MaxPool",Oy="MaxPoolGrad",Vp="MaxPool3D",Fy="MaxPool3DGrad",Hp="MaxPoolWithArgmax",Yp="Mean",qp="Min",su="Minimum",Xp="MirrorPad",au="Mod",Kp="Multinomial",iu="Multiply",$p="Neg",ou="NotEqual",Zp="NonMaxSuppressionV3",Jp="NonMaxSuppressionV4",Qp="NonMaxSuppressionV5",jp="OnesLike",ef="OneHot",tf="Pack",xf="PadV2",lu="Pow",nf="Prelu",rf="Prod",sf="RaggedGather",af="RaggedRange",of="RaggedTensorToTensor",lf="Range",cf="Real",cu="Reciprocal",uu="Relu",uf="Reshape",df="ResizeNearestNeighbor",Uy="ResizeNearestNeighborGrad",hf="ResizeBilinear",By="ResizeBilinearGrad",du="Relu6",pf="Reverse",hu="Round",pu="Rsqrt",ff="ScatterNd",mf="SearchSorted",gf="Select",fu="Selu",yf="Slice",mu="Sin",gu="Sinh",yu="Sign",bu="Sigmoid",vu="Softplus",wu="Sqrt",bf="Sum",vf="SpaceToBatchND",wf="SplitV",_f="Softmax",Sf="SparseFillEmptyRows",Tf="SparseReshape",Af="SparseSegmentMean",Ef="SparseSegmentSum",Cf="SparseToDense",_u="SquaredDifference",zy="Square",Mf="StridedSlice",If="StringNGrams",kf="StringSplit",Nf="StringToHashBucketFast",Su="Sub",Tu="Tan",Au="Tanh",Eu="Tile",Rf="TopK",Pf="Transform",Oo="Transpose",Lf="Unique",Df="Unpack",Of="UnsortedSegmentSum",Ff="ZerosLike",Cu="Step",Uf="FromPixels",Bf="RotateWithOffset",Mu="_FusedMatMul",Iu="FusedConv2D",ku="FusedDepthwiseConv2D";function E2(...s){Ce().getBool("IS_TEST")||Ce().getBool("PROD")||console.warn(...s)}function FC(...s){Ce().getBool("IS_TEST")||Ce().getBool("PROD")||console.log(...s)}const Nu=je("kernelRegistry",()=>new Map),UC=je("gradRegistry",()=>new Map);function zf(s,x){const n=Hy(s,x);return Nu.get(n)}function Wy(s){return UC.get(s)}function Gy(s){const x=Nu.entries(),n=[];for(;;){const{done:r,value:a}=x.next();if(r)break;const[i,o]=a,[l]=i.split("_");l===s&&n.push(o)}return n}function Vy(s){const{kernelName:x,backendName:n}=s,r=Hy(x,n);Nu.has(r)&&E2("The kernel '"+x+"' for backend '"+n+"' is already registered"),Nu.set(r,s)}function Hy(s,x){return x+"_"+s}var qs=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof o2.g<"u"?o2.g:typeof self<"u"?self:{},Wf=hx,C2=null;try{C2=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function hx(s,x,n){this.low=s|0,this.high=x|0,this.unsigned=!!n}hx.prototype.__isLong__,Object.defineProperty(hx.prototype,"__isLong__",{value:!0});function t2(s){return(s&&s.__isLong__)===!0}hx.isLong=t2;var Yy={},qy={};function Xs(s,x){var n,r,a;return x?(s>>>=0,(a=0<=s&&s<256)&&(r=qy[s],r)?r:(n=px(s,(s|0)<0?-1:0,!0),a&&(qy[s]=n),n)):(s|=0,(a=-128<=s&&s<128)&&(r=Yy[s],r)?r:(n=px(s,s<0?-1:0,!1),a&&(Yy[s]=n),n))}hx.fromInt=Xs;function M2(s,x){if(isNaN(s))return x?Ks:I2;if(x){if(s<0)return Ks;if(s>=Ky)return jy}else{if(s<=-$y)return x2;if(s+1>=$y)return Qy}return s<0?M2(-s,x).neg():px(s%ui|0,s/ui|0,x)}hx.fromNumber=M2;function px(s,x,n){return new hx(s,x,n)}hx.fromBits=px;var Ru=Math.pow;function Gf(s,x,n){if(s.length===0)throw Error("empty string");if(s==="NaN"||s==="Infinity"||s==="+Infinity"||s==="-Infinity")return I2;if(typeof x=="number"?(n=x,x=!1):x=!!x,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=s.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Gf(s.substring(1),x,n).neg();for(var a=M2(Ru(n,8)),i=I2,o=0;o<s.length;o+=8){var l=Math.min(8,s.length-o),c=parseInt(s.substring(o,o+l),n);if(l<8){var d=M2(Ru(n,l));i=i.mul(d).add(M2(c))}else i=i.mul(a),i=i.add(M2(c))}return i.unsigned=x,i}hx.fromString=Gf;function V2(s,x){return typeof s=="number"?M2(s,x):typeof s=="string"?Gf(s,x):px(s.low,s.high,typeof x=="boolean"?x:s.unsigned)}hx.fromValue=V2;var Xy=1<<16,BC=1<<24,ui=Xy*Xy,Ky=ui*ui,$y=Ky/2,Zy=Xs(BC),I2=Xs(0);hx.ZERO=I2;var Ks=Xs(0,!0);hx.UZERO=Ks;var di=Xs(1);hx.ONE=di;var Jy=Xs(1,!0);hx.UONE=Jy;var Vf=Xs(-1);hx.NEG_ONE=Vf;var Qy=px(-1,2147483647,!1);hx.MAX_VALUE=Qy;var jy=px(-1,-1,!0);hx.MAX_UNSIGNED_VALUE=jy;var x2=px(0,-2147483648,!1);hx.MIN_VALUE=x2;var S0=hx.prototype;S0.toInt=function(){return this.unsigned?this.low>>>0:this.low},S0.toNumber=function(){return this.unsigned?(this.high>>>0)*ui+(this.low>>>0):this.high*ui+(this.low>>>0)},S0.toString=function(s){if(s=s||10,s<2||36<s)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(x2)){var x=M2(s),n=this.div(x),r=n.mul(x).sub(this);return n.toString(s)+r.toInt().toString(s)}else return"-"+this.neg().toString(s);for(var a=M2(Ru(s,6),this.unsigned),i=this,o="";;){var l=i.div(a),c=i.sub(l.mul(a)).toInt()>>>0,d=c.toString(s);if(i=l,i.isZero())return d+o;for(;d.length<6;)d="0"+d;o=""+d+o}},S0.getHighBits=function(){return this.high},S0.getHighBitsUnsigned=function(){return this.high>>>0},S0.getLowBits=function(){return this.low},S0.getLowBitsUnsigned=function(){return this.low>>>0},S0.getNumBitsAbs=function(){if(this.isNegative())return this.eq(x2)?64:this.neg().getNumBitsAbs();for(var s=this.high!=0?this.high:this.low,x=31;x>0&&(s&1<<x)==0;x--);return this.high!=0?x+33:x+1},S0.isZero=function(){return this.high===0&&this.low===0},S0.eqz=S0.isZero,S0.isNegative=function(){return!this.unsigned&&this.high<0},S0.isPositive=function(){return this.unsigned||this.high>=0},S0.isOdd=function(){return(this.low&1)===1},S0.isEven=function(){return(this.low&1)===0},S0.equals=function(s){return t2(s)||(s=V2(s)),this.unsigned!==s.unsigned&&this.high>>>31===1&&s.high>>>31===1?!1:this.high===s.high&&this.low===s.low},S0.eq=S0.equals,S0.notEquals=function(s){return!this.eq(s)},S0.neq=S0.notEquals,S0.ne=S0.notEquals,S0.lessThan=function(s){return this.comp(s)<0},S0.lt=S0.lessThan,S0.lessThanOrEqual=function(s){return this.comp(s)<=0},S0.lte=S0.lessThanOrEqual,S0.le=S0.lessThanOrEqual,S0.greaterThan=function(s){return this.comp(s)>0},S0.gt=S0.greaterThan,S0.greaterThanOrEqual=function(s){return this.comp(s)>=0},S0.gte=S0.greaterThanOrEqual,S0.ge=S0.greaterThanOrEqual,S0.compare=function(s){if(t2(s)||(s=V2(s)),this.eq(s))return 0;var x=this.isNegative(),n=s.isNegative();return x&&!n?-1:!x&&n?1:this.unsigned?s.high>>>0>this.high>>>0||s.high===this.high&&s.low>>>0>this.low>>>0?-1:1:this.sub(s).isNegative()?-1:1},S0.comp=S0.compare,S0.negate=function(){return!this.unsigned&&this.eq(x2)?x2:this.not().add(di)},S0.neg=S0.negate,S0.add=function(s){t2(s)||(s=V2(s));var x=this.high>>>16,n=this.high&65535,r=this.low>>>16,a=this.low&65535,i=s.high>>>16,o=s.high&65535,l=s.low>>>16,c=s.low&65535,d=0,h=0,p=0,m=0;return m+=a+c,p+=m>>>16,m&=65535,p+=r+l,h+=p>>>16,p&=65535,h+=n+o,d+=h>>>16,h&=65535,d+=x+i,d&=65535,px(p<<16|m,d<<16|h,this.unsigned)},S0.subtract=function(s){return t2(s)||(s=V2(s)),this.add(s.neg())},S0.sub=S0.subtract,S0.multiply=function(s){if(this.isZero())return I2;if(t2(s)||(s=V2(s)),C2){var x=C2.mul(this.low,this.high,s.low,s.high);return px(x,C2.get_high(),this.unsigned)}if(s.isZero())return I2;if(this.eq(x2))return s.isOdd()?x2:I2;if(s.eq(x2))return this.isOdd()?x2:I2;if(this.isNegative())return s.isNegative()?this.neg().mul(s.neg()):this.neg().mul(s).neg();if(s.isNegative())return this.mul(s.neg()).neg();if(this.lt(Zy)&&s.lt(Zy))return M2(this.toNumber()*s.toNumber(),this.unsigned);var n=this.high>>>16,r=this.high&65535,a=this.low>>>16,i=this.low&65535,o=s.high>>>16,l=s.high&65535,c=s.low>>>16,d=s.low&65535,h=0,p=0,m=0,g=0;return g+=i*d,m+=g>>>16,g&=65535,m+=a*d,p+=m>>>16,m&=65535,m+=i*c,p+=m>>>16,m&=65535,p+=r*d,h+=p>>>16,p&=65535,p+=a*c,h+=p>>>16,p&=65535,p+=i*l,h+=p>>>16,p&=65535,h+=n*d+r*c+a*l+i*o,h&=65535,px(m<<16|g,h<<16|p,this.unsigned)},S0.mul=S0.multiply,S0.divide=function(s){if(t2(s)||(s=V2(s)),s.isZero())throw Error("division by zero");if(C2){if(!this.unsigned&&this.high===-2147483648&&s.low===-1&&s.high===-1)return this;var x=(this.unsigned?C2.div_u:C2.div_s)(this.low,this.high,s.low,s.high);return px(x,C2.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ks:I2;var n,r,a;if(this.unsigned){if(s.unsigned||(s=s.toUnsigned()),s.gt(this))return Ks;if(s.gt(this.shru(1)))return Jy;a=Ks}else{if(this.eq(x2)){if(s.eq(di)||s.eq(Vf))return x2;if(s.eq(x2))return di;var i=this.shr(1);return n=i.div(s).shl(1),n.eq(I2)?s.isNegative()?di:Vf:(r=this.sub(s.mul(n)),a=n.add(r.div(s)),a)}else if(s.eq(x2))return this.unsigned?Ks:I2;if(this.isNegative())return s.isNegative()?this.neg().div(s.neg()):this.neg().div(s).neg();if(s.isNegative())return this.div(s.neg()).neg();a=I2}for(r=this;r.gte(s);){n=Math.max(1,Math.floor(r.toNumber()/s.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),l=o<=48?1:Ru(2,o-48),c=M2(n),d=c.mul(s);d.isNegative()||d.gt(r);)n-=l,c=M2(n,this.unsigned),d=c.mul(s);c.isZero()&&(c=di),a=a.add(c),r=r.sub(d)}return a},S0.div=S0.divide,S0.modulo=function(s){if(t2(s)||(s=V2(s)),C2){var x=(this.unsigned?C2.rem_u:C2.rem_s)(this.low,this.high,s.low,s.high);return px(x,C2.get_high(),this.unsigned)}return this.sub(this.div(s).mul(s))},S0.mod=S0.modulo,S0.rem=S0.modulo,S0.not=function(){return px(~this.low,~this.high,this.unsigned)},S0.and=function(s){return t2(s)||(s=V2(s)),px(this.low&s.low,this.high&s.high,this.unsigned)},S0.or=function(s){return t2(s)||(s=V2(s)),px(this.low|s.low,this.high|s.high,this.unsigned)},S0.xor=function(s){return t2(s)||(s=V2(s)),px(this.low^s.low,this.high^s.high,this.unsigned)},S0.shiftLeft=function(s){return t2(s)&&(s=s.toInt()),(s&=63)===0?this:s<32?px(this.low<<s,this.high<<s|this.low>>>32-s,this.unsigned):px(0,this.low<<s-32,this.unsigned)},S0.shl=S0.shiftLeft,S0.shiftRight=function(s){return t2(s)&&(s=s.toInt()),(s&=63)===0?this:s<32?px(this.low>>>s|this.high<<32-s,this.high>>s,this.unsigned):px(this.high>>s-32,this.high>=0?0:-1,this.unsigned)},S0.shr=S0.shiftRight,S0.shiftRightUnsigned=function(s){if(t2(s)&&(s=s.toInt()),s&=63,s===0)return this;var x=this.high;if(s<32){var n=this.low;return px(n>>>s|x<<32-s,x>>>s,this.unsigned)}else return s===32?px(x,0,this.unsigned):px(x>>>s-32,0,this.unsigned)},S0.shru=S0.shiftRightUnsigned,S0.shr_u=S0.shiftRightUnsigned,S0.toSigned=function(){return this.unsigned?px(this.low,this.high,!1):this},S0.toUnsigned=function(){return this.unsigned?this:px(this.low,this.high,!0)},S0.toBytes=function(s){return s?this.toBytesLE():this.toBytesBE()},S0.toBytesLE=function(){var s=this.high,x=this.low;return[x&255,x>>>8&255,x>>>16&255,x>>>24,s&255,s>>>8&255,s>>>16&255,s>>>24]},S0.toBytesBE=function(){var s=this.high,x=this.low;return[s>>>24,s>>>16&255,s>>>8&255,s&255,x>>>24,x>>>16&255,x>>>8&255,x&255]},hx.fromBytes=function(s,x,n){return n?hx.fromBytesLE(s,x):hx.fromBytesBE(s,x)},hx.fromBytesLE=function(s,x){return new hx(s[0]|s[1]<<8|s[2]<<16|s[3]<<24,s[4]|s[5]<<8|s[6]<<16|s[7]<<24,x)},hx.fromBytesBE=function(s,x){return new hx(s[4]<<24|s[5]<<16|s[6]<<8|s[7],s[0]<<24|s[1]<<16|s[2]<<8|s[3],x)};var zC=xt({__proto__:null,default:Wf},[Wf]);const $s=Wf||zC;function Pu(s){return $s.fromString(s,!0,16)}const eb=Pu("c3a5c85c97cb3127"),Zs=Pu("b492b66fbe98f273"),kn=Pu("9ae16a3b2f90404f");function Hf(s){return s.xor(s.shru(47))}function tb(s,x,n){const r=s.slice(x,x+n);return $s.fromBytes(Array.from(r),!0,!0)}function cx(s,x){return tb(s,x,8)}function xb(s,x){return tb(s,x,4)}function nn(s,x){return x===0?s:s.shru(x).or(s.shl(64-x))}function ss(s,x,n=Pu("9ddfea08eb382d69")){let r=s.xor(x).mul(n);r=r.xor(r.shru(47));let a=x.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function WC(s,x,n,r,a,i){a=a.add(s),i=nn(i.add(a).add(r),21);const o=a;return a=a.add(x),a=a.add(n),i=i.add(nn(a,44)),[a.add(r),i.add(o)]}function Lu(s,x,n,r){return WC(cx(s,x),cx(s,x+8),cx(s,x+16),cx(s,x+24),n,r)}function GC(s,x=s.length){if(x>=8){const n=kn.add(x*2),r=cx(s,0).add(kn),a=cx(s,x-8),i=nn(a,37).mul(n).add(r),o=nn(r,25).add(a).mul(n);return ss(i,o,n)}if(x>=4){const n=kn.add(x*2),r=xb(s,0);return ss(r.shl(3).add(x),xb(s,x-4),n)}if(x>0){const n=s[0],r=s[x>>1],a=s[x-1],i=n+(r<<8),o=x+(a<<2);return Hf(kn.mul(i).xor(eb.mul(o))).mul(kn)}return kn}function VC(s,x=s.length){const n=kn.add(x*2),r=cx(s,0).mul(Zs),a=cx(s,8),i=cx(s,x-8).mul(n),o=cx(s,x-16).mul(kn);return ss(nn(r.add(a),43).add(nn(i,30)).add(o),r.add(nn(a.add(kn),18)).add(i),n)}function HC(s,x=s.length){const n=kn.add(x*2),r=cx(s,0).mul(kn),a=cx(s,8),i=cx(s,x-8).mul(n),o=cx(s,x-16).mul(kn),l=nn(r.add(a),43).add(nn(i,30)).add(o),c=ss(l,r.add(nn(a.add(kn),18)).add(i),n),d=cx(s,16).mul(n),h=cx(s,24),p=l.add(cx(s,x-32)).mul(n),m=c.add(cx(s,x-24)).mul(n);return ss(nn(d.add(h),43).add(nn(p,30)).add(m),d.add(nn(h.add(r),18)).add(p),n)}function YC(s,x=s.length){const n=$s.fromNumber(81,!0);if(x<=32)return x<=16?GC(s,x):VC(s,x);if(x<=64)return HC(s,x);let r=n,a=n.mul(Zs).add(113),i=Hf(a.mul(kn).add(113)).mul(kn),o=[$s.UZERO,$s.UZERO],l=[$s.UZERO,$s.UZERO];r=r.mul(kn).add(cx(s,0));let c=0;const d=(x-1>>6)*64,h=d+(x-1&63)-63;do r=nn(r.add(a).add(o[0]).add(cx(s,c+8)),37).mul(Zs),a=nn(a.add(o[1]).add(cx(s,c+48)),42).mul(Zs),r=r.xor(l[1]),a=a.add(o[0]).add(cx(s,c+40)),i=nn(i.add(l[0]),33).mul(Zs),o=Lu(s,c,o[1].mul(Zs),r.add(l[0])),l=Lu(s,c+32,i.add(l[1]),a.add(cx(s,c+16))),[i,r]=[r,i],c+=64;while(c!==d);const p=Zs.add(i.and(255).shl(1));return c=h,l[0]=l[0].add(x-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),r=nn(r.add(a).add(o[0]).add(cx(s,c+8)),37).mul(p),a=nn(a.add(o[1]).add(cx(s,c+48)),42).mul(p),r=r.xor(l[1].mul(9)),a=a.add(o[0].mul(9).add(cx(s,c+40))),i=nn(i.add(l[0]),33).mul(p),o=Lu(s,c,o[1].mul(p),r.add(l[0])),l=Lu(s,c+32,i.add(l[1]),a.add(cx(s,c+16))),[i,r]=[r,i],ss(ss(o[0],l[0],p).add(Hf(a).mul(eb)).add(i),ss(o[1],l[1],p).add(r),p)}function as(s,x){return x==="string"?is(s):Js([s],x)}function qC(s,x){return s instanceof Float32Array&&x==="float32"||s instanceof Int32Array&&x==="int32"||s instanceof Uint8Array&&x==="bool"}function Js(s,x){if(x==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(s)&&(s=Qs(s)),Ce().getBool("DEBUG")&&X0(s,x),qC(s,x))return s;if(x==null||x==="float32"||x==="complex64")return new Float32Array(s);if(x==="int32")return new Int32Array(s);if(x==="bool"){const n=new Uint8Array(s.length);for(let r=0;r<n.length;++r)Math.round(s[r])!==0&&(n[r]=1);return n}else throw new Error("Unknown data type "+x)}function c2(){return Ce().platform.now()}function is(s,x="utf-8"){return x=x||"utf-8",Ce().platform.encode(s,x)}function os(s,x="utf-8"){return x=x||"utf-8",Ce().platform.decode(s,x)}function H2(s){return Ce().platform.isTypedArray(s)}function Qs(s,x=[],n=!1){if(x==null&&(x=[]),typeof s=="boolean"||typeof s=="number"||typeof s=="string"||Bt(s)||s==null||H2(s)&&n)x.push(s);else if(Array.isArray(s)||H2(s))for(let r=0;r<s.length;++r)Qs(s[r],x,n);else{let r=-1;for(const a of Object.keys(s))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)Qs(s[a],x,n)}return x}class XC{constructor(x,n){this.backendTimer=x,this.logger=n,n==null&&(this.logger=new $C)}profileKernel(x,n,r){let a;const i=()=>{a=r()};let o;const l=c2();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of a)c.dataSync();o=Promise.resolve({kernelMs:c2()-l})}if(Ce().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<a.length;c++){const d=a[c];d.data().then(h=>{KC(h,d.dtype,x)})}return{kernelName:x,outputs:a,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(x){const{kernelName:n,outputs:r,timeMs:a,inputs:i,extraInfo:o}=x;r.forEach(l=>{Promise.all([l.data(),a,o]).then(c=>{this.logger.logKernelProfile(n,l,c[0],c[1],i,c[2])})})}}function KC(s,x,n){if(x!=="float32")return!1;for(let r=0;r<s.length;r++){const a=s[r];if(isNaN(a)||!isFinite(a))return console.warn("Found "+a+" in the result of '"+n+"'"),!0}return!1}class $C{logKernelProfile(x,n,r,a,i,o){const l=typeof a=="number"?yt(a+"ms",9):a.error,c=yt(x,25),d=n.rank,h=n.size,p=yt(n.shape.toString(),14);let m="";for(const g in i){const y=i[g];if(y!=null){const b=y.shape||n.shape,v=b.length;m+=g+": "+v+"D "+(v>0?b:"")+" "}}console.log("%c"+c+"	%c"+l+"	%c"+d+"D "+p+"	%c"+h+"	%c"+m+"	%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ZC(s,x,n){const r={},a={};for(let c=0;c<x.length;c++)r[x[c].id]=!0;for(let c=0;c<s.length;c++){const d=s[c],h=d.inputs;for(const p in h){const m=h[p];let g=!1;for(let y=0;y<x.length;y++)if(r[m.id]){d.outputs.forEach(b=>r[b.id]=!0),g=!0,a[d.id]=!0;break}if(g)break}}const i={};i[n.id]=!0;const o={};for(let c=s.length-1;c>=0;c--){const d=s[c],h=d.inputs;for(let p=0;p<d.outputs.length;p++)if(i[d.outputs[p].id]){for(const m in h)i[h[m].id]=!0,o[d.id]=!0;break}}const l=[];for(let c=0;c<s.length;c++){const d=s[c];if(a[d.id]&&o[d.id]){const h={};for(const m in d.inputs){const g=d.inputs[m];r[g.id]&&(h[m]=g)}const p=Object.assign({},d);p.inputs=h,p.outputs=d.outputs,l.push(p)}}return l}function JC(s,x,n,r){for(let a=x.length-1;a>=0;a--){const i=x[a],o=[];if(i.outputs.forEach(c=>{const d=s[c.id];d!=null?o.push(d):o.push(null)}),i.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+i.kernelName+".");const l=i.gradient(o);for(const c in i.inputs){if(!(c in l))throw new Error("Cannot backprop through input "+c+". Available gradients found: "+Object.keys(l)+".");const d=n(()=>l[c]());if(d.dtype!=="float32")throw new Error("Error in gradient for op "+i.kernelName+". The gradient of input "+c+" must have 'float32' dtype, but has '"+d.dtype+"'");const h=i.inputs[c];if(!T0(d.shape,h.shape))throw new Error("Error in gradient for op "+i.kernelName+". The gradient of input '"+c+"' has shape '"+d.shape+"', which does not match the shape of the input '"+h.shape+"'");if(s[h.id]==null)s[h.id]=d;else{const p=s[h.id];s[h.id]=r(p,d),p.dispose()}}}}const nb=20,Fo=3,Yf=7;function QC(s,x,n,r){const a=U0(x),i=jC(s,x,n,a),o=x.length,l=Du(s,x,n,a,i),c=["Tensor"];return r&&(c.push("  dtype: "+n),c.push("  rank: "+o),c.push("  shape: ["+x+"]"),c.push("  values:")),c.push(l.map(d=>"    "+d).join(`
`)),c.join(`
`)}function jC(s,x,n,r){const a=be(x),i=r[r.length-1],o=new Array(i).fill(0),l=x.length,c=n==="complex64"?Bo(s):s;if(l>1)for(let d=0;d<a/i;d++){const h=d*i;for(let p=0;p<i;p++)o[p]=Math.max(o[p],Uo(c[h+p],0,n).length)}return o}function Uo(s,x,n){let r;return Array.isArray(s)?r=parseFloat(s[0].toFixed(Yf))+" + "+parseFloat(s[1].toFixed(Yf))+"j":tx(s)?r="'"+s+"'":n==="bool"?r=rb(s):r=parseFloat(s.toFixed(Yf)).toString(),yt(r,x)}function rb(s){return s===0?"false":"true"}function Du(s,x,n,r,a,i=!0){const o=n==="complex64"?2:1,l=x[0],c=x.length;if(c===0){if(n==="complex64"){const b=Bo(s);return[Uo(b[0],0,n)]}return n==="bool"?[rb(s[0])]:[s[0].toString()]}if(c===1){if(l>nb){const v=Fo*o;let w=Array.from(s.slice(0,v)),_=Array.from(s.slice((l-Fo)*o,l*o));return n==="complex64"&&(w=Bo(w),_=Bo(_)),["["+w.map((T,A)=>Uo(T,a[A],n)).join(", ")+", ..., "+_.map((T,A)=>Uo(T,a[l-Fo+A],n)).join(", ")+"]"]}const b=n==="complex64"?Bo(s):Array.from(s);return["["+b.map((v,w)=>Uo(v,a[w],n)).join(", ")+"]"]}const d=x.slice(1),h=r.slice(1),p=r[0]*o,m=[];if(l>nb){for(let b=0;b<Fo;b++){const v=b*p,w=v+p;m.push(...Du(s.slice(v,w),d,n,h,a,!1))}m.push("...");for(let b=l-Fo;b<l;b++){const v=b*p,w=v+p;m.push(...Du(s.slice(v,w),d,n,h,a,b===l-1))}}else for(let b=0;b<l;b++){const v=b*p,w=v+p;m.push(...Du(s.slice(v,w),d,n,h,a,b===l-1))}const g=c===2?",":"";m[0]="["+(l>0?m[0]+g:"");for(let b=1;b<m.length-1;b++)m[b]=" "+m[b]+g;let y=`,
`;for(let b=2;b<c;b++)y+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":y),m}function Bo(s){const x=[];for(let n=0;n<s.length;n+=2)x.push([s[n],s[n+1]]);return x}class rn{constructor(x,n,r){if(this.dtype=n,this.shape=x.slice(),this.size=be(x),r!=null){const a=r.length;G(a===this.size,()=>"Length of values '"+a+"' does not match the size inferred by the shape '"+this.size+"'.")}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||a0(n,this.size),this.strides=U0(x)}set(x,...n){n.length===0&&(n=[0]),G(n.length===this.rank,()=>"The number of provided coordinates ("+n.length+") must match the rank ("+this.rank+")");const r=this.locToIndex(n);this.values[r]=x}get(...x){x.length===0&&(x=[0]);let n=0;for(const a of x){if(a<0||a>=this.shape[n]){const i="Requested out of range element at "+x+".   Buffer shape="+this.shape;throw new Error(i)}n++}let r=x[x.length-1];for(let a=0;a<x.length-1;++a)r+=this.strides[a]*x[a];return this.values[r]}locToIndex(x){if(this.rank===0)return 0;if(this.rank===1)return x[0];let n=x[x.length-1];for(let r=0;r<x.length-1;++r)n+=this.strides[r]*x[r];return n}indexToLoc(x){if(this.rank===0)return[];if(this.rank===1)return[x];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(x/this.strides[r]),x-=n[r]*this.strides[r];return n[n.length-1]=x,n}get rank(){return this.shape.length}toTensor(){return Y2().makeTensor(this.values,this.shape,this.dtype)}}let Y2=null,hi=null;function eM(s){Y2=s}function tM(s){hi=s}class _n{constructor(x,n,r,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=x.slice(),this.dtype=n||"float32",this.size=be(x),this.strides=U0(x),this.dataId=r,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const x=await this.data();return hi.buffer(this.shape,this.dtype,x)}bufferSync(){return hi.buffer(this.shape,this.dtype,this.dataSync())}async array(){const x=await this.data();return lx(this.shape,x,this.dtype==="complex64")}arraySync(){return lx(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const x=Y2().read(this.dataId);if(this.dtype==="string"){const n=await x;try{return n.map(r=>os(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return x}dataToGPU(x){return this.throwIfDisposed(),Y2().readToGPU(this.dataId,x)}dataSync(){this.throwIfDisposed();const x=Y2().readSync(this.dataId);if(this.dtype==="string")try{return x.map(n=>os(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return x}async bytes(){this.throwIfDisposed();const x=await Y2().read(this.dataId);return this.dtype==="string"?x:new Uint8Array(x.buffer)}dispose(){this.isDisposed||(Y2().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(x=!1){return hi.print(this,x)}clone(){return this.throwIfDisposed(),hi.clone(this)}toString(x=!1){const n=this.dataSync();return QC(n,this.shape,this.dtype,x)}cast(x){return this.throwIfDisposed(),hi.cast(this,x)}variable(x=!0,n,r){return this.throwIfDisposed(),Y2().makeVariable(this,x,n,r)}}Object.defineProperty(_n,Symbol.hasInstance,{value:s=>!!s&&s.data!=null&&s.dataSync!=null&&s.throwIfDisposed!=null});function xM(){return je("Tensor",()=>_n)}xM();class Ou extends _n{constructor(x,n,r,a){super(x.shape,x.dtype,x.dataId,a),this.trainable=n,this.name=r}assign(x){if(x.dtype!==this.dtype)throw new Error("dtype of the new value ("+x.dtype+") and previous value ("+this.dtype+") must match");if(!T0(x.shape,this.shape))throw new Error("shape of the new value ("+x.shape+") and previous value ("+this.shape+") must match");Y2().disposeTensor(this),this.dataId=x.dataId,Y2().incRef(this,null)}dispose(){Y2().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ou,Symbol.hasInstance,{value:s=>s instanceof _n&&s.assign!=null&&s.assign instanceof Function});var sb;(function(s){s.R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6"})(sb||(sb={}));var qf;(function(s){s.float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64"})(qf||(qf={}));var Xf;(function(s){s.float32="float32",s.int32="int32",s.bool="bool",s.complex64="complex64"})(Xf||(Xf={}));var Kf;(function(s){s.float32="float32",s.int32="float32",s.bool="float32",s.complex64="complex64"})(Kf||(Kf={}));var $f;(function(s){s.float32="complex64",s.int32="complex64",s.bool="complex64",s.complex64="complex64"})($f||($f={}));const nM={float32:Kf,int32:qf,bool:Xf,complex64:$f};function n2(s,x){if(s==="string"||x==="string"){if(s==="string"&&x==="string")return"string";throw new Error("Can not upcast "+s+" with "+x)}return nM[s][x]}function Zf(s){return n2(s,"int32")}function Ax(s,x){if(s.dtype===x.dtype)return[s,x];const n=n2(s.dtype,x.dtype);return[s.cast(n),x.cast(n)]}function rM(s,x){G(s.dtype===x.dtype,()=>"The dtypes of the first("+s.dtype+") and second("+x.dtype+") input must match")}function ab(s){const x=[];return ib(s,x,new Set),x}function ib(s,x,n){if(s==null)return;if(s instanceof _n){x.push(s);return}if(!sM(s))return;const r=s;for(const a in r){const i=r[a];n.has(i)||(n.add(i),ib(i,x,n))}}function sM(s){return Array.isArray(s)||typeof s=="object"}function Jf(s){return s.kernelName!=null}class ob{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(x=>x.name)))}}}dispose(){for(const x in this.registeredVariables)this.registeredVariables[x].dispose()}}class pi{constructor(x){this.ENV=x,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ob}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const x=this.getSortedBackends();for(let n=0;n<x.length;n++){const r=x[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:x,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error("The highest priority backend '"+x+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(x)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(x){if(!(x in this.registry))if(x in this.registryFactory){const{asyncInit:n}=this.initializeBackend(x);if(n)return null}else return null;return this.registry[x]}findBackendFactory(x){return x in this.registryFactory?this.registryFactory[x].factory:null}registerBackend(x,n,r=1){return x in this.registryFactory?(E2(x+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[x]={factory:n,priority:r},!0)}async setBackend(x){if(this.registryFactory[x]==null)throw new Error("Backend name '"+x+"' not found in registry");if(this.backendName=x,this.registry[x]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(x);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[x],this.setupRegisteredKernels(),this.profiler=new XC(this.backendInstance),!0}setupRegisteredKernels(){Gy(this.backendName).forEach(x=>{x.setupFunc!=null&&x.setupFunc(this.backendInstance)})}disposeRegisteredKernels(x){Gy(x).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[x])})}initializeBackend(x){const n=this.registryFactory[x];if(n==null)throw new Error("Cannot initialize backend "+x+", no registration found.");try{const r=n.factory();if(r&&!(r instanceof W0)&&typeof r.then=="function"){const a=++this.pendingBackendInitId,i=r.then(o=>a<this.pendingBackendInitId?!1:(this.registry[x]=o,this.pendingBackendInit=null,!0)).catch(o=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,E2("Initialization of backend "+x+" failed"),E2(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[x]=r,{success:!0,asyncInit:!1}}catch(r){return E2("Initialization of backend "+x+" failed"),E2(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(x){if(!(x in this.registryFactory))throw new Error(x+" backend not found in registry");this.backendName===x&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,x in this.registry&&(this.disposeRegisteredKernels(x),this.registry[x].dispose(),delete this.registry[x]),delete this.registryFactory[x],this.backendName===x&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((x,n)=>this.registryFactory[n].priority-this.registryFactory[x].priority)}initializeBackendsAndReturnBest(){const x=this.getSortedBackends();for(let n=0;n<x.length;n++){const r=x[n],{success:a,asyncInit:i}=this.initializeBackend(r);if(i||a)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(x,n){const r=this.state.tensorInfo.get(n),a=r.backend,i=this.readSync(n),o=a.refCount(n);a.disposeData(n,!0),r.backend=x,x.move(n,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(x,n){let r=null;if(n==null){if(typeof x!="function")throw new Error("Please provide a function to tidy()");n=x}else{if(typeof x!="string"&&!(x instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=x}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(x,n,r){x();try{const a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return pi.nextTensorId++}nextVariableId(){return pi.nextVariableId++}clone(x){const n=he.runKernel(Xc,{x}),r={x},a=o=>({x:()=>{const l="float32",c={x:o},d={dtype:l};return he.runKernel(Rc,c,d)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[n],a,i,{}),n}runKernel(x,n,r){if(this.backendName==null&&this.backend,zf(x,this.backendName)==null)throw new Error("Kernel '"+x+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:x,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(x,n,r){const a=this.backend.numDataIds();let i=0;r.forEach(c=>{i+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=a-n-i-o;if(l>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+l+" data ids) after running '"+x+"'")}runKernelFunc(x){let n,r=[];const a=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c;const d=Jf(x)?x.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Jf(x)){const{kernelName:y,inputs:b,attrs:v}=x;this.backendName==null&&this.backend;const w=zf(y,this.backendName);G(w!=null,()=>"Cannot find registered kernel '"+y+"' for backend '"+this.backendName+"'"),l=()=>{const _=this.backend.numDataIds();c=w.kernelFunc({inputs:b,attrs:v,backend:this.backend});const T=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,_,T);const A=T.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(a){const E=this.getTensorsForGradient(y,b,A);r=this.saveTensorsForBackwardMode(E)}return A}}else{const{forwardFunc:y}=x,b=v=>{!a||(r=v.map(w=>this.keep(this.clone(w))))};l=()=>{const v=this.backend.numDataIds();c=this.tidy(()=>y(this.backend,b));const w=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,v,w),w}}const{inputs:h,attrs:p}=x,m=Jf(x)?null:x.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=l():(g=this.profiler.profileKernel(d,h,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),a&&this.addTapeNode(d,h,n,m,r,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(y=>h[y]!=null?h[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(c)?n:n[0]}saveTensorsForBackwardMode(x){return x.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(x,n,r){const a=Wy(x);if(a!=null){const i=a.inputsToSave||[],o=a.outputsToSave||[];let l;a.saveAllInputs?(G(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(n).map(d=>n[d])):l=i.map(d=>n[d]);const c=r.filter((d,h)=>o[h]);return l.concat(c)}return[]}makeTensor(x,n,r,a){if(x==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let i=x;r==="string"&&tx(x[0])&&(i=x.map(c=>is(c)));const o=a.write(i,n,r),l=new _n(n,r,o,this.nextTensorId());if(this.trackTensor(l,a),r==="string"){const c=this.state.tensorInfo.get(o),d=kx(i);this.state.numBytes+=d-c.bytes,c.bytes=d}return l}makeTensorFromDataId(x,n,r,a){r=r||"float32";const i={dataId:x,shape:n,dtype:r};return this.makeTensorFromTensorInfo(i,a)}makeTensorFromTensorInfo(x,n){const{dataId:r,shape:a,dtype:i}=x,o=new _n(a,i,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(x,n=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==x.dtype&&(x=x.cast(a));const i=new Ou(x,n,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error("Variable with name "+i.name+" was already registered");return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(x,n){this.state.numTensors++,x.dtype==="string"&&this.state.numStringTensors++;let r=0;x.dtype!=="complex64"&&x.dtype!=="string"&&(r=x.size*it(x.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(x.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(x.dataId,{backend:n||this.backend,dtype:x.dtype,shape:x.shape,bytes:r})),x instanceof Ou||this.track(x)}incRef(x,n){this.trackTensor(x,n),this.backend.incRef(x.dataId)}removeDataId(x,n){this.state.tensorInfo.has(x)&&this.state.tensorInfo.get(x).backend===n&&(this.state.tensorInfo.delete(x),this.state.numDataBuffers--)}disposeTensor(x){if(!this.state.tensorInfo.has(x.dataId))return;const n=this.state.tensorInfo.get(x.dataId);if(this.state.numTensors--,x.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),x.dtype!=="complex64"&&x.dtype!=="string"){const r=x.size*it(x.dtype);this.state.numBytes-=r}n.backend.disposeData(x.dataId)&&this.removeDataId(x.dataId,n.backend)}disposeVariables(){for(const x in this.state.registeredVariables){const n=this.state.registeredVariables[x];this.disposeVariable(n)}}disposeVariable(x){this.disposeTensor(x),this.state.registeredVariables[x.name]!=null&&delete this.state.registeredVariables[x.name]}memory(){const x=this.backend.memory();return x.numTensors=this.state.numTensors,x.numDataBuffers=this.state.numDataBuffers,x.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(x.unreliable=!0,x.reasons==null&&(x.reasons=[]),x.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),x}async profile(x){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await x(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(x,n,r,a,i,o){const l={id:this.state.nextTapeNodeId++,kernelName:x,inputs:n,outputs:r,saved:i},c=Wy(x);c!=null&&(a=c.gradFunc),a!=null&&(l.gradient=d=>(d=d.map((h,p)=>{if(h==null){const m=r[p],g=Ae(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return h}),a(d.length>1?d:d[0],i,o))),this.state.activeTape.push(l)}keep(x){return x.kept=!0,x}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(x){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};x&&(n.name=x),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(x){const n=ab(x),r=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===a.id&&this.track(i)})}gradients(x,n,r,a=!1){if(G(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+r.dtype+"'");const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",x));G(i instanceof _n,()=>"The result y returned by f() must be a tensor.");const o=ZC(this.state.activeTape,n,i);if(!a&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=r??aM(i.shape),JC(l,o,d=>this.tidy(d),iM);const c=n.map(d=>l[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(const h of d.saved)h.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(x){return G(gx(x),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{G(n.every(l=>l instanceof _n),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const a={};n.forEach((l,c)=>{a[c]=l});const i=(l,c)=>(r=x(...n,c),G(r.value instanceof _n,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),G(gx(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(l,c)=>{const d=r.gradFunc(l,c),h=Array.isArray(d)?d:[d];G(h.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),G(h.every(m=>m instanceof _n),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return h.forEach((m,g)=>{p[g]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:a})}}readSync(x){return this.state.tensorInfo.get(x).backend.readSync(x)}read(x){return this.state.tensorInfo.get(x).backend.read(x)}readToGPU(x,n){return this.state.tensorInfo.get(x).backend.readToGPU(x,n)}async time(x){const n=c2(),r=await this.backend.time(x);return r.wallMs=c2()-n,r}track(x){return this.state.activeScope!=null&&(x.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(x)),x}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ob;for(const x in this.registry)this.disposeRegisteredKernels(x),this.registry[x].dispose(),delete this.registry[x];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}pi.nextTensorId=0,pi.nextVariableId=0;function aM(s){const x=l2(be(s),"float32");return he.makeTensor(x,s,"float32")}function lb(){const s=Ac();if(s._tfengine==null){const x=new Vt(s);s._tfengine=new pi(x)}return li(s._tfengine.ENV),eM(()=>s._tfengine),s._tfengine}const he=lb();function iM(s,x){const n={a:s,b:x};return he.runKernel(Do,n)}function oM(){return typeof navigator<"u"&&navigator!=null}function cb(s){if(s||oM()){if(s||(s=navigator),s.product==="ReactNative")return!0;const x=s.userAgent||s.vendor||(typeof window<"u"?window.opera:"");if(!x){const n=s;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(x)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(x.substr(0,4))}return!1}function ub(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const u2=Ce();u2.registerFlag("DEBUG",()=>!1,s=>{s&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),u2.registerFlag("IS_BROWSER",()=>ub()),u2.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),u2.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),u2.registerFlag("PROD",()=>!1),u2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>u2.getBool("DEBUG")),u2.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),u2.registerFlag("IS_TEST",()=>!1),u2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),u2.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),u2.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),u2.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function ls(s,x){let n=s;if(H2(s))return x==="string"?[]:[s.length];if(typeof s=="object"){if("texture"in s){const a=s.channels||"RGBA";return[s.height,s.width*a.length]}else if("buffer"in s&&!(s.buffer instanceof ArrayBuffer))return[s.buffer.size/(x==null?4:it(x))]}if(!Array.isArray(s))return[];const r=[];for(;Array.isArray(n)||H2(n)&&x!=="string";)r.push(n.length),n=n[0];return Array.isArray(s)&&Ce().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&db(s,r,[]),r}function db(s,x,n){if(n=n||[],!Array.isArray(s)&&!H2(s)){G(x.length===0,()=>"Element arr["+n.join("][")+"] is a primitive, but should be an array/TypedArray of "+x[0]+" elements");return}G(x.length>0,()=>"Element arr["+n.join("][")+"] should be a primitive, but is an array of "+s.length+" elements"),G(s.length===x[0],()=>"Element arr["+n.join("][")+"] should have "+x[0]+" elements, but has "+s.length+" elements");const r=x.slice(1);for(let a=0;a<s.length;++a)db(s[a],r,n.concat(a))}function hb(s,x,n,r){if(s!=="string_or_numeric"){if(s==null)throw new Error("Expected dtype cannot be null.");if(s!=="numeric"&&s!==x||s==="numeric"&&x==="string")throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+s+" tensor, but got "+x+" tensor")}}function q(s,x,n,r="numeric"){if(s instanceof _n)return hb(r,s.dtype,x,n),s;let a=Gt(s);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),hb(r,a,x,n),s==null||!H2(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string"){const l=s==null?"null":s.constructor.name;throw new Error("Argument '"+x+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+l+"'")}const i=ls(s,a);!H2(s)&&!Array.isArray(s)&&(s=[s]);const o=a!=="string"?Js(s,a):Qs(s,[],!0);return he.makeTensor(o,i,a)}function Fu(s,x,n,r="numeric"){if(!Array.isArray(s))throw new Error("Argument "+x+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return s.map((a,i)=>q(a,x+"["+i+"]",n,r))}const pb="__op";function ce(s){const x=Object.keys(s);if(x.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+x.length+" keys.");let n=x[0];const r=s[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+pb;const a=(...i)=>{he.startScope(n);try{const o=r(...i);return Bt(o)&&console.error("Cannot return a Promise inside of tidy."),he.endScope(o),o}catch(o){throw he.endScope(null),o}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function lM(s,x){const n=q(s,"real","complex"),r=q(x,"imag","complex");F0(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex().");const a={real:n,imag:r};return he.runKernel(cp,a)}const cs=ce({complex_:lM});function us(s,x,n,r){if(r==null)r=Gt(s);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof s=="object"&&("texture"in s||"buffer"in s&&!(s.buffer instanceof ArrayBuffer))){if(r!=="float32"&&r!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+r+".");return he.backend.createTensorFromGPUData(s,x||n,r)}if(!H2(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(x!=null){x0(x);const a=be(x),i=be(n);G(a===i,()=>"Based on the provided shape, ["+x+"], the tensor should have "+a+" values but has "+i);for(let o=0;o<n.length;++o){const l=n[o],c=o===n.length-1?l!==be(x.slice(o)):!0;G(n[o]===x[o]||!c,()=>"Error creating a new Tensor. Inferred shape ("+n+") does not match the provided shape ("+x+"). ")}}return!H2(s)&&!Array.isArray(s)&&(s=[s]),x=x||n,s=r!=="string"?Js(s,r):Qs(s,[],!0),he.makeTensor(s,x,r)}function lr(s,x,n){const r=ls(s,n);return us(s,x,r,n)}const Qf={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Uu=4;async function cM(s,x){const n=[],r=[],a=Array.isArray(s)?s.map(o=>o.name):Object.keys(s);for(let o=0;o<a.length;++o){const l=a[o],c=Array.isArray(s)?s[o].tensor:s[l];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+l+"': "+c.dtype);const d={name:l,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const h=new Promise(async p=>{const m=await c.bytes(),g=m.reduce((v,w)=>v+w.length,0)+Uu*m.length,y=new Uint8Array(g);let b=0;for(let v=0;v<m.length;v++){const w=m[v],_=new Uint8Array(new Uint32Array([w.length]).buffer);y.set(_,b),b+=Uu,y.set(w,b),b+=w.length}p(y)});r.push(h)}else r.push(c.data());x!=null&&(d.group=x),n.push(d)}const i=await Promise.all(r);return{data:uM(i),specs:n}}function fb(s,x){const n={};let r,a=0;for(const i of x){const o=i.name,l=i.dtype,c=i.shape,d=be(c);let h;if("quantization"in i){const p=i.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error("Weight "+i.name+" with quantization "+p.dtype+" doesn't have corresponding metadata min and scale.")}else if(p.dtype==="float16"){if(l!=="float32")throw new Error("Weight "+i.name+" is quantized with "+p.dtype+" which only supports weights of type float32 not "+l+".")}else throw new Error("Weight "+i.name+" has unknown quantization dtype "+p.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const m=Qf[p.dtype],g=s.slice(a,a+d*m),y=p.dtype==="uint8"?new Uint8Array(g):new Uint16Array(g);if(l==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){h=new Float32Array(y.length);for(let b=0;b<y.length;b++){const v=y[b];h[b]=v*p.scale+p.min}}else if(p.dtype==="float16")r===void 0&&(r=gM()),h=r(y);else throw new Error("Unsupported quantization type "+p.dtype+" for weight type float32.");else if(l==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error("Unsupported quantization type "+p.dtype+" for weight type int32.");h=new Int32Array(y.length);for(let b=0;b<y.length;b++){const v=y[b];h[b]=Math.round(v*p.scale+p.min)}}else throw new Error("Unsupported dtype in weight '"+o+"': "+l);a+=d*m}else if(l==="string"){const p=be(i.shape);h=[];for(let m=0;m<p;m++){const g=new Uint32Array(s.slice(a,a+Uu))[0];a+=Uu;const y=new Uint8Array(s.slice(a,a+g));h.push(y),a+=g}}else{const p=Qf[l],m=s.slice(a,a+d*p);if(l==="float32")h=new Float32Array(m);else if(l==="int32")h=new Int32Array(m);else if(l==="bool")h=new Uint8Array(m);else if(l==="complex64"){h=new Float32Array(m);const g=new Float32Array(h.length/2),y=new Float32Array(h.length/2);for(let w=0;w<g.length;w++)g[w]=h[w*2],y[w]=h[w*2+1];const b=lr(g,c,"float32"),v=lr(y,c,"float32");n[o]=cs(b,v),b.dispose(),v.dispose()}else throw new Error("Unsupported dtype in weight '"+o+"': "+l);a+=d*p}l!=="complex64"&&(n[o]=lr(h,c,l))}return n}function uM(s){if(s===null)throw new Error("Invalid input value: "+JSON.stringify(s));let x=0;const n=[];s.forEach(i=>{if(x+=i.byteLength,n.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+i.constructor.name)});const r=new Uint8Array(x);let a=0;return n.forEach(i=>{r.set(new Uint8Array(i.buffer),a),a+=i.byteLength}),r.buffer}const jf=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function mb(s){return jf?Buffer.byteLength(s):new Blob([s]).size}function dM(s){if(jf)return Buffer.from(s).toString("base64");const x=new Uint8Array(s);let n="";for(let r=0,a=x.length;r<a;r++)n+=String.fromCharCode(x[r]);return btoa(n)}function hM(s){if(jf){const r=Buffer.from(s,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const x=atob(s),n=new Uint8Array(x.length);for(let r=0;r<x.length;++r)n.set([x.charCodeAt(r)],r);return n.buffer}function em(s){if(s.length===1)return s[0];let x=0;s.forEach(a=>{x+=a.byteLength});const n=new Uint8Array(x);let r=0;return s.forEach(a=>{n.set(new Uint8Array(a),r),r+=a.byteLength}),n.buffer}function gb(s){const x="/";for(s=s.trim();s.endsWith(x);)s=s.slice(0,s.length-1);const n=s.split(x);return n[n.length-1]}function yb(s,x){const n={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy,weightsManifest:x};return s.signature!=null&&(n.signature=s.signature),s.userDefinedMetadata!=null&&(n.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(n.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(n.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(n.trainingConfig=s.trainingConfig),n}function bb(s,x,n){const r={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy};if(s.trainingConfig!=null&&(r.trainingConfig=s.trainingConfig),s.weightsManifest!=null){if(!x)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=x,r.weightData=n}return s.signature!=null&&(r.signature=s.signature),s.userDefinedMetadata!=null&&(r.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(r.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(r.initializerSignature=s.initializerSignature),r}async function tm(s,x){let n,r;return s.weightsManifest!=null&&([n,r]=await x(s.weightsManifest)),bb(s,n,r)}function zo(s){if(s.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:s.modelTopology==null?0:mb(JSON.stringify(s.modelTopology)),weightSpecsBytes:s.weightSpecs==null?0:mb(JSON.stringify(s.weightSpecs)),weightDataBytes:s.weightData==null?0:s.weightData.byteLength}}function vb(s){const x=[];for(const n of s)x.push(...n.weights);return x}function pM(){const s=n=>{let r=n<<13,a=0;for(;(r&8388608)===0;)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},x=new Uint32Array(2048);x[0]=0;for(let n=1;n<1024;n++)x[n]=s(n);for(let n=1024;n<2048;n++)x[n]=939524096+(n-1024<<13);return x}function fM(){const s=new Uint32Array(64);s[0]=0,s[31]=1199570944,s[32]=2147483648,s[63]=3347054592;for(let x=1;x<31;x++)s[x]=x<<23;for(let x=33;x<63;x++)s[x]=2147483648+(x-32<<23);return s}function mM(){const s=new Uint32Array(64);for(let x=0;x<64;x++)s[x]=1024;return s[0]=s[32]=0,s}function gM(){const s=pM(),x=fM(),n=mM();return r=>{const a=new ArrayBuffer(4*r.length),i=new Uint32Array(a);for(let o=0;o<r.length;o++){const l=r[o],c=s[n[l>>10]+(l&1023)]+x[l>>10];i[o]=c}return new Float32Array(a)}}class _x{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _x.instance==null&&(_x.instance=new _x),_x.instance}static registerSaveRouter(x){_x.getInstance().saveRouters.push(x)}static registerLoadRouter(x){_x.getInstance().loadRouters.push(x)}static getSaveHandlers(x){return _x.getHandlers(x,"save")}static getLoadHandlers(x,n){return _x.getHandlers(x,"load",n)}static getHandlers(x,n,r){const a=[];return(n==="load"?_x.getInstance().loadRouters:_x.getInstance().saveRouters).forEach(i=>{const o=i(x,r);o!==null&&a.push(o)}),a}}const yM=s=>_x.registerSaveRouter(s),bM=s=>_x.registerLoadRouter(s),vM=s=>_x.getSaveHandlers(s),wM=(s,x)=>_x.getLoadHandlers(s,x),xm="tensorflowjs",nm=1,js="models_store",ds="model_info_store";function wb(){if(!Ce().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window>"u"?self:window,x=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(x==null)throw new Error("The current browser does not appear to support IndexedDB.");return x}function rm(s){const x=s.result;x.createObjectStore(js,{keyPath:"modelPath"}),x.createObjectStore(ds,{keyPath:"modelPath"})}class ea{constructor(x){if(this.indexedDB=wb(),x==null||!x)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=x}async save(x){if(x.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,x)}async load(){return this.databaseAction(this.modelPath)}databaseAction(x,n){return new Promise((r,a)=>{const i=this.indexedDB.open(xm,nm);i.onupgradeneeded=()=>rm(i),i.onsuccess=()=>{const o=i.result;if(n==null){const l=o.transaction(js,"readonly"),c=l.objectStore(js).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),a(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));r(c.result.modelArtifacts)},c.onerror=d=>(o.close(),a(c.error)),l.oncomplete=()=>o.close()}else{const l=zo(n),c=o.transaction(ds,"readwrite");let d=c.objectStore(ds);const h=d.put({modelPath:this.modelPath,modelArtifactsInfo:l});let p;h.onsuccess=()=>{p=o.transaction(js,"readwrite");const m=p.objectStore(js).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:l});m.onsuccess=()=>r({modelArtifactsInfo:l}),m.onerror=g=>{d=c.objectStore(ds);const y=d.delete(this.modelPath);y.onsuccess=()=>(o.close(),a(m.error)),y.onerror=b=>(o.close(),a(m.error))}},h.onerror=m=>(o.close(),a(h.error)),c.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},i.onerror=o=>a(i.error)})}}ea.URL_SCHEME="indexeddb://";const _b=s=>Ce().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(ea.URL_SCHEME)?_M(s.slice(ea.URL_SCHEME.length)):null;_x.registerSaveRouter(_b),_x.registerLoadRouter(_b);function _M(s){return new ea(s)}function SM(s){return s.startsWith(ea.URL_SCHEME)?s.slice(ea.URL_SCHEME.length):s}class TM{constructor(){this.indexedDB=wb()}async listModels(){return new Promise((x,n)=>{const r=this.indexedDB.open(xm,nm);r.onupgradeneeded=()=>rm(r),r.onsuccess=()=>{const a=r.result,i=a.transaction(ds,"readonly"),o=i.objectStore(ds).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;x(l)},o.onerror=l=>(a.close(),n(o.error)),i.oncomplete=()=>a.close()},r.onerror=a=>n(r.error)})}async removeModel(x){return x=SM(x),new Promise((n,r)=>{const a=this.indexedDB.open(xm,nm);a.onupgradeneeded=()=>rm(a),a.onsuccess=()=>{const i=a.result,o=i.transaction(ds,"readwrite"),l=o.objectStore(ds),c=l.get(x);let d;c.onsuccess=()=>{if(c.result==null)return i.close(),r(new Error("Cannot find model with path '"+x+"' in IndexedDB."));{const h=l.delete(x),p=()=>{d=i.transaction(js,"readwrite");const m=d.objectStore(js).delete(x);m.onsuccess=()=>n(c.result.modelArtifactsInfo),m.onerror=g=>r(c.error)};h.onsuccess=p,h.onerror=m=>(p(),i.close(),r(c.error))}},c.onerror=h=>(i.close(),r(c.error)),o.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}},a.onerror=i=>r(a.error)})}}const Mr="/",fi="tensorflowjs_models",Sb="info",AM="model_topology",EM="weight_specs",CM="weight_data",MM="model_metadata";function Tb(s){return{info:[fi,s,Sb].join(Mr),topology:[fi,s,AM].join(Mr),weightSpecs:[fi,s,EM].join(Mr),weightData:[fi,s,CM].join(Mr),modelMetadata:[fi,s,MM].join(Mr)}}function Ab(s){for(const x of Object.values(s))window.localStorage.removeItem(x)}function IM(s){const x=s.split(Mr);if(x.length<3)throw new Error("Invalid key format: "+s);return x.slice(1,x.length-1).join(Mr)}function kM(s){return s.startsWith(ta.URL_SCHEME)?s.slice(ta.URL_SCHEME.length):s}class ta{constructor(x){if(!Ce().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,x==null||!x)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=x,this.keys=Tb(this.modelPath)}async save(x){if(x.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(x.modelTopology),r=JSON.stringify(x.weightSpecs),a=zo(x);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,dM(x.weightData));const i={format:x.format,generatedBy:x.generatedBy,convertedBy:x.convertedBy,signature:x.signature!=null?x.signature:void 0,userDefinedMetadata:x.userDefinedMetadata!=null?x.userDefinedMetadata:void 0,modelInitializer:x.modelInitializer!=null?x.modelInitializer:void 0,initializerSignature:x.initializerSignature!=null?x.initializerSignature:void 0,trainingConfig:x.trainingConfig!=null?x.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:a}}catch{throw Ab(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+a.modelTopologyBytes+", weightSpecsBytes="+a.weightSpecsBytes+", weightDataBytes="+a.weightDataBytes+".")}}}async load(){const x=JSON.parse(this.LS.getItem(this.keys.info));if(x==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(x.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");n.modelTopology=r;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");n.weightSpecs=a;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const l=JSON.parse(i);n.format=l.format,n.generatedBy=l.generatedBy,n.convertedBy=l.convertedBy,l.signature!=null&&(n.signature=l.signature),l.userDefinedMetadata!=null&&(n.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(n.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(n.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(n.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return n.weightData=hM(o),n}}ta.URL_SCHEME="localstorage://";const Eb=s=>Ce().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(ta.URL_SCHEME)?NM(s.slice(ta.URL_SCHEME.length)):null;_x.registerSaveRouter(Eb),_x.registerLoadRouter(Eb);function NM(s){return new ta(s)}class RM{constructor(){G(Ce().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),G(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const x={},n=fi+Mr,r=Mr+Sb;for(let a=0;a<this.LS.length;++a){const i=this.LS.key(a);if(i.startsWith(n)&&i.endsWith(r)){const o=IM(i);x[o]=JSON.parse(this.LS.getItem(i))}}return x}async removeModel(x){x=kM(x);const n=Tb(x);if(this.LS.getItem(n.info)==null)throw new Error("Cannot find model at path '"+x+"'");const r=JSON.parse(this.LS.getItem(n.info));return Ab(n),r}}const mi="://";class Nn{constructor(){this.managers={}}static getInstance(){return Nn.instance==null&&(Nn.instance=new Nn),Nn.instance}static registerManager(x,n){G(x!=null,()=>"scheme must not be undefined or null."),x.endsWith(mi)&&(x=x.slice(0,x.indexOf(mi))),G(x.length>0,()=>"scheme must not be an empty string.");const r=Nn.getInstance();G(r.managers[x]==null,()=>"A model store manager is already registered for scheme '"+x+"'."),r.managers[x]=n}static getManager(x){const n=Nn.getInstance().managers[x];if(n==null)throw new Error("Cannot find model manager for scheme '"+x+"'");return n}static getSchemes(){return Object.keys(Nn.getInstance().managers)}}function Bu(s){if(s.indexOf(mi)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+Nn.getSchemes().join(","));return{scheme:s.split(mi)[0],path:s.split(mi)[1]}}async function Cb(s,x,n=!1){G(s!==x,()=>"Old path and new path are the same: '"+s+"'");const r=_x.getLoadHandlers(s);G(r.length>0,()=>"Copying failed because no load handler is found for source URL "+s+"."),G(r.length<2,()=>"Copying failed because more than one ("+r.length+") load handlers for source URL "+s+".");const a=r[0],i=_x.getSaveHandlers(x);G(i.length>0,()=>"Copying failed because no save handler is found for destination URL "+x+"."),G(i.length<2,()=>"Copying failed because more than one ("+r.length+") save handlers for destination URL "+x+".");const o=i[0],l=Bu(s).scheme,c=Bu(s).path,d=l===Bu(s).scheme,h=await a.load();n&&d&&await Nn.getManager(l).removeModel(c);const p=await o.save(h);return n&&!d&&await Nn.getManager(l).removeModel(c),p.modelArtifactsInfo}async function PM(){const s=Nn.getSchemes(),x={};for(const n of s){const r=await Nn.getManager(n).listModels();for(const a in r){const i=n+mi+a;x[i]=r[a]}}return x}async function LM(s){const x=Bu(s);return Nn.getManager(x.scheme).removeModel(x.path)}async function DM(s,x){return Cb(s,x,!1)}async function OM(s,x){return Cb(s,x,!0)}class FM{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(x,n){return fetch(x,n)}now(){return performance.now()}encode(x,n){if(n!=="utf-8"&&n!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+n);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(x)}decode(x,n){return new TextDecoder(n).decode(x)}setTimeoutCustom(x,n){if(typeof window>"u"||!Ce().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(x,n);return}this.functionRefs.push(x),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const a=this.functionRefs[r.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(x){return x instanceof Float32Array||x instanceof Int32Array||x instanceof Uint8Array||x instanceof Uint8ClampedArray}}if(Ce().get("IS_BROWSER")){Ce().setPlatform("browser",new FM);try{Nn.registerManager(ta.URL_SCHEME,new RM)}catch{}try{Nn.registerManager(ea.URL_SCHEME,new TM)}catch{}}const UM={importFetch:()=>o2(300)};let sm;class BM{constructor(){this.util=o2(539),this.textEncoder=new this.util.TextEncoder}fetch(x,n){return Ce().global.fetch!=null?Ce().global.fetch(x,n):(sm==null&&(sm=UM.importFetch()),sm(x,n))}now(){const x=process.hrtime();return x[0]*1e3+x[1]/1e6}encode(x,n){if(n!=="utf-8"&&n!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+n);return this.textEncoder.encode(x)}decode(x,n){return x.length===0?"":new this.util.TextDecoder(n).decode(x)}isTypedArray(x){return this.util.types.isFloat32Array(x)||this.util.types.isInt32Array(x)||this.util.types.isUint8Array(x)||this.util.types.isUint8ClampedArray(x)}}Ce().get("IS_NODE")&&!Ce().get("IS_BROWSER")&&Ce().setPlatform("node",new BM);function At(s,x="float32",n){return x=x||"float32",x0(s),new rn(s,x,n)}function zM(s,x){const n=q(s,"x","cast");if(!Q0(x))throw new Error("Failed to cast to unknown dtype "+x);if(x==="string"&&n.dtype!=="string"||x!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:x};return he.runKernel(Rc,r,a)}const zx=ce({cast_:zM});function WM(s){const x={x:q(s,"x","clone","string_or_numeric")};return he.runKernel(Xc,x)}const hs=ce({clone_:WM});function Mb(s,x=!1){console.log(s.toString(x))}lb(),tM({buffer:At,cast:zx,clone:hs,print:Mb});function cr(){return he}function vt(s,x){return he.tidy(s,x)}function Yn(s){ab(s).forEach(x=>x.dispose())}function ur(s){return he.keep(s)}function Ib(s){return he.setBackend(s)}function kb(s,x,n=1){return he.registerBackend(s,x,n)}function GM(s,x){let n=q(s,"a","add"),r=q(x,"b","add");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(Do,a)}const j0=ce({add_:GM});function VM(s,x){let n=q(s,"a","floorDiv"),r=q(x,"b","floorDiv");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(Hc,a)}const Nb=ce({floorDiv_:VM});function HM(s,x){let n=q(s,"a","div"),r=q(x,"b","div");if([n,r]=Ax(n,r),n.dtype==="int32"&&r.dtype==="int32")return Nb(n,r);const a={a:n,b:r},i={};return he.runKernel(Fc,a,i)}const Ht=ce({div_:HM});function YM(s,x){let n=q(s,"a","mul"),r=q(x,"b","mul");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(iu,a)}const A0=ce({mul_:YM});function qM(s){const x=q(s,"x","abs");if(x.dtype==="complex64"){const n={x};return he.runKernel(up,n)}else{const n={x};return he.runKernel(Po,n)}}const d2=ce({abs_:qM});function XM(s){const x={x:q(s,"x","acos")};return he.runKernel(Lo,x)}const KM=ce({acos_:XM});function $M(s){const x={x:q(s,"x","acosh")};return he.runKernel(Ec,x)}const ZM=ce({acosh_:$M});function JM(s){G(Array.isArray(s),()=>"The argument passed to tf.addN() must be a list of tensors"),G(s.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+s.length);const x=s.map((a,i)=>q(a,"tensors"+i,"addN")),n=x[0];x.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),x.forEach(a=>{if(!T0(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=x;return he.runKernel(jh,r)}const QM=ce({addN_:JM});function jM(s,x=null,n=!1){const r={x:q(s,"x","all","bool")},a={axis:x,keepDims:n};return he.runKernel(ep,r,a)}const eI=ce({all_:jM});function tI(s,x=null,n=!1){const r={x:q(s,"x","any","bool")},a={axis:x,keepDims:n};return he.runKernel(tp,r,a)}const xI=ce({any_:tI});function nI(s,x=0){const n={x:q(s,"x","argMax")},r={axis:x};return he.runKernel(xp,n,r)}const rI=ce({argMax_:nI});function sI(s,x=0){const n={x:q(s,"x","argMin")},r={axis:x};return he.runKernel(np,n,r)}const aI=ce({argMin_:sI});function iI(s){const x={x:q(s,"x","asin")};return he.runKernel(Cc,x)}const oI=ce({asin_:iI});function lI(s){const x={x:q(s,"x","asinh")};return he.runKernel(Mc,x)}const cI=ce({asinh_:lI});function uI(s){const x={x:q(s,"x","atan")};return he.runKernel(Ic,x)}const dI=ce({atan_:uI});function hI(s,x){let n=q(s,"a","atan2"),r=q(x,"b","atan2");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(Nc,a)}const pI=ce({atan2_:hI});function fI(s){const x={x:q(s,"x","atanh")};return he.runKernel(kc,x)}const mI=ce({atanh_:fI});function Wo(s,x,n,r,a="NHWC",i){const o=s[3],l=[...x,o],c=kr(a);return sn(s,l,n,i,r,null,null,c)}function k2(s,x,n,r,a,i,o="channelsLast"){const[l,c]=Go(x);let d;if(o==="channelsLast")d=[l,c,s[3],s[3]];else if(o==="channelsFirst")d=[l,c,s[1],s[1]];else throw new Error("Unknown dataFormat "+o);return sn(s,d,n,r,a,i,!1,o)}function Ir(s,x,n,r,a,i,o="NDHWC"){const[l,c,d]=im(x);let h,p;if(o==="NDHWC")p="channelsLast",h=[l,c,d,s[4],s[4]];else if(o==="NCDHW")p="channelsFirst",h=[l,c,d,s[1],s[1]];else throw new Error("Unknown dataFormat "+o);return ps(s,h,n,r,a,!1,p,i)}function sn(s,x,n,r,a,i,o=!1,l="channelsLast"){let[c,d,h,p]=[-1,-1,-1,-1];if(l==="channelsLast")[c,d,h,p]=s;else if(l==="channelsFirst")[c,p,d,h]=s;else throw new Error("Unknown dataFormat "+l);const[m,g,,y]=x,[b,v]=Go(n),[w,_]=Go(r),T=gi(m,w),A=gi(g,_),{padInfo:E,outHeight:M,outWidth:I}=bI(a,d,h,b,v,T,A,i,l),C=o?y*p:y;let k;return l==="channelsFirst"?k=[c,C,M,I]:l==="channelsLast"&&(k=[c,M,I,C]),{batchSize:c,dataFormat:l,inHeight:d,inWidth:h,inChannels:p,outHeight:M,outWidth:I,outChannels:C,padInfo:E,strideHeight:b,strideWidth:v,filterHeight:m,filterWidth:g,effectiveFilterHeight:T,effectiveFilterWidth:A,dilationHeight:w,dilationWidth:_,inShape:s,outShape:k,filterShape:x}}function ps(s,x,n,r,a,i=!1,o="channelsLast",l){let[c,d,h,p,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,d,h,p,m]=s;else if(o==="channelsFirst")[c,m,d,h,p]=s;else throw new Error("Unknown dataFormat "+o);const[g,y,b,,v]=x,[w,_,T]=im(n),[A,E,M]=im(r),I=gi(g,A),C=gi(y,E),k=gi(b,M),{padInfo:O,outDepth:z,outHeight:ee,outWidth:re}=vI(a,d,h,p,w,_,T,I,C,k,l),Y=i?v*m:v;let Q;return o==="channelsFirst"?Q=[c,Y,z,ee,re]:o==="channelsLast"&&(Q=[c,z,ee,re,Y]),{batchSize:c,dataFormat:o,inDepth:d,inHeight:h,inWidth:p,inChannels:m,outDepth:z,outHeight:ee,outWidth:re,outChannels:Y,padInfo:O,strideDepth:w,strideHeight:_,strideWidth:T,filterDepth:g,filterHeight:y,filterWidth:b,effectiveFilterDepth:I,effectiveFilterHeight:C,effectiveFilterWidth:k,dilationDepth:A,dilationHeight:E,dilationWidth:M,inShape:s,outShape:Q,filterShape:x}}function gI(s,x,n,r,a){r==null&&(r=am(s,x,n));const i=s[0],o=s[1],l=Vo((i-x+2*r)/n+1,a),c=Vo((o-x+2*r)/n+1,a);return[l,c]}function yI(s,x,n,r,a,i){a==null&&(a=am(s,x[0],r[0]));const o=[0,0,0,n];for(let l=0;l<3;l++)s[l]+2*a>=x[l]&&(o[l]=Vo((s[l]-x[l]+2*a)/r[l]+1,i));return o}function am(s,x,n,r=1){const a=gi(x,r);return Math.floor((s[0]*(n-1)-n+a)/2)}function Go(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function im(s){return typeof s=="number"?[s,s,s]:s}function gi(s,x){return x<=1?s:s+(s-1)*(x-1)}function bI(s,x,n,r,a,i,o,l,c){let d,h,p;if(typeof s=="number"){d={top:s,bottom:s,left:s,right:s,type:s===0?"VALID":"NUMBER"};const m=gI([x,n],i,r,s,l);h=m[0],p=m[1]}else if(s==="same"){h=Math.ceil(x/r),p=Math.ceil(n/a);const m=Math.max(0,(h-1)*r+i-x),g=Math.max(0,(p-1)*a+o-n),y=Math.floor(m/2),b=m-y,v=Math.floor(g/2),w=g-v;d={top:y,bottom:b,left:v,right:w,type:"SAME"}}else if(s==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((x-i+1)/r),p=Math.ceil((n-o+1)/a);else if(typeof s=="object"){const m=c==="channelsLast"?s[1][0]:s[2][0],g=c==="channelsLast"?s[1][1]:s[2][1],y=c==="channelsLast"?s[2][0]:s[3][0],b=c==="channelsLast"?s[2][1]:s[3][1];d={top:m,bottom:g,left:y,right:b,type:m===0&&g===0&&y===0&&b===0?"VALID":"EXPLICIT"},h=Vo((x-i+m+g)/r+1,l),p=Vo((n-o+y+b)/a+1,l)}else throw Error("Unknown padding parameter: "+s);return{padInfo:d,outHeight:h,outWidth:p}}function vI(s,x,n,r,a,i,o,l,c,d,h){let p,m,g,y;if(s==="valid"&&(s=0),typeof s=="number"){p={top:s,bottom:s,left:s,right:s,front:s,back:s,type:s===0?"VALID":"NUMBER"};const b=yI([x,n,r,1],[l,c,d],1,[a,i,o],s,h);m=b[0],g=b[1],y=b[2]}else if(s==="same"){m=Math.ceil(x/a),g=Math.ceil(n/i),y=Math.ceil(r/o);const b=(m-1)*a+l-x,v=(g-1)*i+c-n,w=(y-1)*o+d-r,_=Math.floor(b/2),T=b-_,A=Math.floor(v/2),E=v-A,M=Math.floor(w/2),I=w-M;p={top:A,bottom:E,left:M,right:I,front:_,back:T,type:"SAME"}}else throw Error("Unknown padding parameter: "+s);return{padInfo:p,outDepth:m,outHeight:g,outWidth:y}}function Vo(s,x){if(!x)return Math.trunc(s);switch(x){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error("Unknown roundingMode "+x)}}function Ho(s){const[x,n,r]=Go(s);return x===1&&n===1&&r===1}function Sn(s,x){return Ho(s)||Ho(x)}function xa(s){return Go(s).every(x=>x>0)}function kr(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+s)}function N2(s,x,n){if(n!=null){if(typeof x=="string")throw Error("Error in "+s+": pad must be an integer when using dimRoundingMode "+n+" but got pad "+x+".");if(typeof x=="number")G(Lt(x),()=>"Error in "+s+": pad must be an integer when using dimRoundingMode "+n+" but got pad "+x+".");else if(typeof x=="object")x.forEach(r=>{r.forEach(a=>{G(Lt(a),()=>"Error in "+s+": pad must be an integer when using dimRoundingMode "+n+" but got pad "+a+".")})});else throw Error("Error in "+s+": Unknown padding parameter: "+x)}}function wI(s,x){const n={x:q(s,"x","reshape","string_or_numeric")},r={shape:x};return he.runKernel(uf,n,r)}const Be=ce({reshape_:wI});function _I(s,x,n,r,a){const i=q(s,"x","avgPool","float32"),o=1;G(Sn(n,o),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+o+"'");let l=i,c=!1;i.rank===3&&(c=!0,l=Be(i,[1,i.shape[0],i.shape[1],i.shape[2]])),G(l.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+l.rank+"."),N2("avgPool",r,a);const d={x:l},h={filterSize:x,strides:n,pad:r,dimRoundingMode:a};let p=he.runKernel(rp,d,h);return p=zx(p,i.dtype),c?Be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Rb=ce({avgPool_:_I});function SI(s,x,n,r,a,i="NDHWC"){const o=q(s,"x","avgPool3d","float32");let l=o,c=!1;o.rank===4&&(c=!0,l=Be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(l.rank===5,()=>"Error in avgPool3d: x must be rank 5 but got rank "+l.rank+"."),G(i==="NDHWC",()=>"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),G(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>"Error in avgPool3d: Stride must be > 0, but got '"+n+"'"),N2("avgPool3d",r,a);const d={x:l},h={filterSize:x,strides:n,pad:r,dimRoundingMode:a,dataFormat:i};let p=he.runKernel(sp,d,h);return p=zx(p,l.dtype),c?Be(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const TI=ce({avgPool3d_:SI});function AI(s,x=0){G(s.length>=1,()=>"Pass at least one tensor to concat");const n=Fu(s,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+i.dtype+". ")}),n.length===1)return hs(n[0]);const r=n,a={axis:x};return he.runKernel(dp,r,a)}const Rn=ce({concat_:AI});function EI(s,x,n=!1,r=!1){let a=q(s,"a","matMul"),i=q(x,"b","matMul");[a,i]=Ax(a,i);const o={a,b:i},l={transposeA:n,transposeB:r};return he.runKernel(ap,o,l)}const ax=ce({matMul_:EI});function CI(s){const x={x:q(s,"x","sigmoid","float32")};return he.runKernel(bu,x)}const fs=ce({sigmoid_:CI});function MI(s,x,n){const r=q(s,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const a={x:r},i={begin:x,size:n};return he.runKernel(yf,a,i)}const Ct=ce({slice_:MI});function II(s){const x={x:q(s,"x","tanh","float32")};return he.runKernel(Au,x)}const om=ce({tanh_:II});function kI(s,x,n,r,a,i){const o=q(s,"forgetBias","basicLSTMCell"),l=q(x,"lstmKernel","basicLSTMCell"),c=q(n,"lstmBias","basicLSTMCell"),d=q(r,"data","basicLSTMCell"),h=q(a,"c","basicLSTMCell"),p=q(i,"h","basicLSTMCell"),m=Rn([d,p],1),g=ax(m,l),y=j0(g,c),b=y.shape[0],v=y.shape[1]/4,w=[b,v],_=Ct(y,[0,0],w),T=Ct(y,[0,v],w),A=Ct(y,[0,v*2],w),E=Ct(y,[0,v*3],w),M=j0(A0(fs(_),om(T)),A0(h,fs(j0(o,A)))),I=A0(om(M),fs(E));return[M,I]}const NI=ce({basicLSTMCell_:kI});function RI(s,x,n){const r=q(s,"x","batchToSpaceND"),a=x.reduce((l,c)=>l*c);G(r.rank>=1+x.length,()=>"input rank is "+r.rank+" but should be > than blockShape.length "+x.length),G(n.length===x.length,()=>"crops.length is "+n.length+" but should be equal to blockShape.length  "+x.length),G(r.shape[0]%a===0,()=>"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+x.join(" * ")+" === "+a);const i={x:r},o={blockShape:x,crops:n};return he.runKernel(ip,i,o)}const Pb=ce({batchToSpaceND_:RI});function PI(s){let x;return s.rank===0||s.rank===1?x=Be(s,[1,1,1,s.size]):s.rank===2?x=Be(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?x=Be(s,[1,s.shape[0],s.shape[1],s.shape[2]]):x=s,x}function LI(s,x,n,r,a,i){i==null&&(i=.001);const o=q(s,"x","batchNorm"),l=q(x,"mean","batchNorm"),c=q(n,"variance","batchNorm");let d;a!=null&&(d=q(a,"scale","batchNorm"));let h;r!=null&&(h=q(r,"offset","batchNorm")),G(l.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:PI(o),scale:d,offset:h,mean:l,variance:c},m={varianceEpsilon:i},g=he.runKernel(Pp,p,m);return Be(g,o.shape)}const zu=ce({batchNorm_:LI});function DI(s,x,n,r,a,i){const o=q(s,"x","batchNorm"),l=q(x,"mean","batchNorm"),c=q(n,"variance","batchNorm");let d;a!=null&&(d=q(a,"scale","batchNorm"));let h;return r!=null&&(h=q(r,"offset","batchNorm")),G(o.rank===2,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+o.rank+"."),G(l.rank===2||l.rank===1,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."),G(c.rank===2||c.rank===1,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+c.rank+"."),d!=null&&G(d.rank===2||d.rank===1,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+d.rank+"."),h!=null&&G(h.rank===2||h.rank===1,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+h.rank+"."),zu(o,l,c,h,d,i)}const OI=ce({batchNorm2d_:DI});function FI(s,x,n,r,a,i){const o=q(s,"x","batchNorm"),l=q(x,"mean","batchNorm"),c=q(n,"variance","batchNorm");let d;a!=null&&(d=q(a,"scale","batchNorm"));let h;return r!=null&&(h=q(r,"offset","batchNorm")),G(o.rank===3,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+o.rank+"."),G(l.rank===3||l.rank===1,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."),G(c.rank===3||c.rank===1,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+c.rank+"."),d!=null&&G(d.rank===3||d.rank===1,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+d.rank+"."),h!=null&&G(h.rank===3||h.rank===1,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+h.rank+"."),zu(o,l,c,h,d,i)}const UI=ce({batchNorm3d_:FI});function BI(s,x,n,r,a,i){const o=q(s,"x","batchNorm"),l=q(x,"mean","batchNorm"),c=q(n,"variance","batchNorm");let d;a!=null&&(d=q(a,"scale","batchNorm"));let h;return r!=null&&(h=q(r,"offset","batchNorm")),G(o.rank===4,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+o.rank+"."),G(l.rank===4||l.rank===1,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."),G(c.rank===4||c.rank===1,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+c.rank+"."),d!=null&&G(d.rank===4||d.rank===1,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+d.rank+"."),h!=null&&G(h.rank===4||h.rank===1,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+h.rank+"."),zu(o,l,c,h,d,i)}const zI=ce({batchNorm4d_:BI});function WI(s,x,n){const r=q(s,"x","bincount"),a=q(x,"weights","bincount");G(r.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+r.dtype),G(n>=0,()=>"size must be non-negative, but got "+n+"."),G(a.size===r.size||a.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+r.shape+", weights shape: "+a.shape+".");const i={x:r,weights:a},o={size:n};return he.runKernel(op,i,o)}const Lb=ce({bincount_:WI});function GI(s,x){const n=q(s,"s0","broadcastArgs","int32"),r=q(x,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error("broadcastArgs(): first input must be a vector (rank=1). Has rank "+n.rank);if(r.rank!==1)throw new Error("broadcastArgs(): second input must be a vector (rank=1). Has rank "+r.rank);const a={s0:n,s1:r};return he.runKernel(lp,a)}const VI=ce({broadcastArgs_:GI});function HI(s,x){let n=q(s,"broadcastTo","x");const r=n.shape;if(x0(x),x.length<n.rank)throw new Error("broadcastTo(): shape.length="+x.length+" < input.rank="+n.rank+".");if(x.length>n.rank){const c=n.shape.slice();for(;c.length<x.length;)c.unshift(1);n=Be(n,c)}const a=n.shape,i=Array.from(x);for(let c=x.length-1;c>=0;c--)if(a[c]===x[c])i[c]=1;else if(n.shape[c]!==1)throw new Error("broadcastTo(): ["+r+"] cannot be broadcast to ["+x+"].");if(i.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return hs(n);const o={x:n},l={reps:i};return he.runKernel(Eu,o,l)}const Yo=ce({broadcastTo_:HI});function YI(s){const x={x:q(s,"x","ceil","float32")};return he.runKernel(Pc,x)}const qI=ce({ceil_:YI});function qo(s,x,n){x0(s);const r={shape:s,value:x,dtype:n};return he.runKernel(Np,{},r)}function XI(s,x,n){const r=q(s,"x","clipByValue");if(G(x<=n,()=>"Error in clip: min ("+x+") must be less than or equal to max ("+n+")."),x===n)return qo(r.shape,x,r.dtype);const a={x:r},i={clipValueMin:x,clipValueMax:n};return he.runKernel(Lc,a,i)}const Db=ce({clipByValue_:XI});function KI(s){return Rn(s,0)}const $I=ce({concat1d_:KI});function ZI(s,x){return Rn(s,x)}const Wu=ce({concat2d_:ZI});function JI(s,x){return Rn(s,x)}const QI=ce({concat3d_:JI});function jI(s,x){return Rn(s,x)}const e3=ce({concat4d_:jI});function t3(s,x,n,r,a="NHWC",i=[1,1],o){const l=q(s,"x","conv2d","float32"),c=q(x,"filter","conv2d","float32");let d=l,h=!1;l.rank===3&&(h=!0,d=Be(l,[1,l.shape[0],l.shape[1],l.shape[2]])),G(d.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+d.rank+"."),G(c.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+c.rank+"."),N2("conv2d",r,o);const p=a==="NHWC"?d.shape[3]:d.shape[1];G(p===c.shape[2],()=>"Error in conv2d: depth of input ("+p+") must match input depth for filter "+c.shape[2]+"."),G(Sn(n,i),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"),G(xa(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),G(xa(n),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:d,filter:c},g={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o},y=he.runKernel(hp,m,g);return h?Be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Gu=ce({conv2d_:t3});function x3(s,x,n,r,a="NWC",i=1,o){const l=q(s,"x","conv1d"),c=q(x,"filter","conv1d");let d=l,h=!1;l.rank===2&&(h=!0,d=Be(l,[1,l.shape[0],l.shape[1]])),G(d.rank===3,()=>"Error in conv1d: input must be rank 3, but got rank "+d.rank+"."),G(c.rank===3,()=>"Error in conv1d: filter must be rank 3, but got rank "+c.rank+"."),N2("conv1d",r,o),G(d.shape[2]===c.shape[1],()=>"Error in conv1d: depth of input ("+d.shape[2]+") must match input depth for filter "+c.shape[1]+"."),G(Sn(n,i),()=>"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+i+"'"),G(xa(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),G(xa(n),()=>"Error in conv1D: Stride should be larger than 0."),G(a==="NWC",()=>"Error in conv1d: got dataFormat of "+a+" but only NWC is currently supported.");const p=Be(c,[1,c.shape[0],c.shape[1],c.shape[2]]),m=Be(d,[d.shape[0],1,d.shape[1],d.shape[2]]),g=Gu(m,p,[1,n],r,"NHWC",[1,i],o);return h?Be(g,[g.shape[2],g.shape[3]]):Be(g,[g.shape[0],g.shape[2],g.shape[3]])}const n3=ce({conv1d_:x3});function r3(s,x,n,r,a,i="NHWC",o){G(s.length===x.rank,()=>"Length of inShape ("+s.length+") and rank of dy ("+x.rank+") must match");let l=s,c=x,d=!1;x.rank===3&&(d=!0,c=Be(x,[1,x.shape[0],x.shape[1],x.shape[2]]),l=[1,s[0],s[1],s[2]]),G(l.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+l.length+"."),G(c.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+c.rank),G(n.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank);const h=i==="NHWC"?l[3]:l[1],p=i==="NHWC"?c.shape[3]:c.shape[1];G(h===n.shape[2],()=>"Error in conv2dDerInput: depth of input ("+h+") must match input depth for filter "+n.shape[2]+"."),G(p===n.shape[3],()=>"Error in conv2dDerInput: depth of output ("+p+") must match output depth for filter "+n.shape[3]+"."),N2("conv2dDerInput",a,o);const m={dy:c,filter:n},g={strides:r,pad:a,dataFormat:i,dimRoundingMode:o,inputShape:l},y=he.runKernel(fp,m,g);return d?Be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Ob=ce({conv2DBackpropInput_:r3});function s3(s,x,n,r,a,i){const o=q(s,"x","conv2dTranspose"),l=q(x,"filter","conv2dTranspose");return Ob(n,o,l,r,a,"NHWC",i)}const a3=ce({conv2dTranspose_:s3});function i3(s,x,n,r,a="NDHWC",i=[1,1,1]){const o=q(s,"x","conv3d"),l=q(x,"filter","conv3d");let c=o,d=!1;o.rank===4&&(d=!0,c=Be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(c.rank===5,()=>"Error in conv3d: input must be rank 5, but got rank "+c.rank+"."),G(l.rank===5,()=>"Error in conv3d: filter must be rank 5, but got rank "+l.rank+"."),G(c.shape[4]===l.shape[3],()=>"Error in conv3d: depth of input ("+c.shape[4]+") must match input depth for filter "+l.shape[3]+"."),G(Sn(n,i),()=>"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"),G(a==="NDHWC",()=>"Error in conv3d: got dataFormat of "+a+" but only NDHWC is currently supported."),G(xa(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),G(xa(n),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:i},m=he.runKernel(mp,h,p);return d?Be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const o3=ce({conv3d_:i3});function l3(s,x,n,r,a){G(s.length===x.rank,()=>"Length of inShape ("+s.length+") and rank of dy ("+x.rank+") must match");let i=s,o=x,l=!1;x.rank===4&&(l=!0,o=Be(x,[1,x.shape[0],x.shape[1],x.shape[2],x.shape[3]]),i=[1,s[0],s[1],s[2],s[3]]);const c=i[4],d=o.shape[4];G(i.length===5,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+i.length+"."),G(o.rank===5,()=>"Error in conv3dDerInput: dy must be rank 5, but got rank "+o.rank),G(n.rank===5,()=>"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank),G(c===n.shape[3],()=>"Error in conv3dDerInput: depth of input ("+c+") must match input depth for filter "+n.shape[3]+"."),G(d===n.shape[4],()=>"Error in conv3dDerInput: depth of output ("+d+") must match output depth for filter "+n.shape[4]+".");const h={dy:o,filter:n},p={pad:a,strides:r,inputShape:i},m=he.runKernel(gp,h,p);return l?Be(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const c3=ce({conv3DBackpropInput_:l3});function u3(s,x,n,r,a){const i=q(s,"x","conv3dTranspose"),o=q(x,"filter","conv3dTranspose");return c3(n,i,o,r,a)}const d3=ce({conv3dTranspose_:u3});function h3(s){const x={x:q(s,"x","cos","float32")};return he.runKernel(Dc,x)}const p3=ce({cos_:h3});function f3(s){const x={x:q(s,"x","cosh","float32")};return he.runKernel(Oc,x)}const m3=ce({cosh_:f3});function g3(s,x=0,n=!1,r=!1){const a={x:q(s,"x","cumprod")},i={axis:x,exclusive:n,reverse:r};return he.runKernel(yp,a,i)}const y3=ce({cumprod_:g3});function b3(s,x=0,n=!1,r=!1){const a={x:q(s,"x","cumsum")},i={axis:x,exclusive:n,reverse:r};return he.runKernel(bp,a,i)}const v3=ce({cumsum_:b3});function w3(s,x,n,r=!1){const a=q(s,"x","denseBincount"),i=q(x,"weights","denseBincount");G(a.dtype==="int32",()=>"Error in denseBincount: input dtype must be int32, but got "+a.dtype),G(a.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got rank "+a.rank+"."),G(n>=0,()=>"size must be non-negative, but got "+n+"."),G(i.size===a.size||i.size===0,()=>"Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: "+a.shape+", weights shape: "+i.shape+".");const o={x:a,weights:i},l={size:n,binaryOutput:r};return he.runKernel(wp,o,l)}const _3=ce({denseBincount_:w3});function S3(s,x,n="NHWC"){const r=q(s,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],i=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];G(x>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+x),G(a*x>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+a+" and "+x+`  for depthToSpace with input shape
    `+r.shape),G(i*x>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+i+" and "+x+` for depthToSpace with input shape
        `+r.shape),G(o%(x*x)===0,()=>"Dimension size must be evenly divisible by "+x*x+" but is "+o+" for depthToSpace with input shape "+r.shape);const l={x:r},c={blockSize:x,dataFormat:n};return he.runKernel(_p,l,c)}const T3=ce({depthToSpace_:S3});function A3(s,x,n,r,a="NHWC",i=[1,1],o){const l=q(s,"x","depthwiseConv2d","float32"),c=q(x,"filter","depthwiseConv2d","float32");let d=l,h=!1;l.rank===3&&(h=!0,d=Be(l,[1,l.shape[0],l.shape[1],l.shape[2]])),G(d.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+d.rank+"."),G(c.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+c.rank+".");const p=a==="NHWC"?d.shape[3]:d.shape[1];G(p===c.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+p+") must match the inChannels dimension in filter "+c.shape[2]+"."),N2("depthwiseConv2d",r,o);const m={x:d,filter:c},g={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o},y=he.runKernel(Sp,m,g);return h?Be(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const lm=ce({depthwiseConv2d_:A3});function E3(s){const x={x:q(s,"x","diag")};return he.runKernel(Ep,x)}const C3=ce({diag_:E3});function M3(s,x,n,r,a=[1,1],i="NHWC"){const o=q(s,"x","dilation2d"),l=q(x,"filter","dilation2d");G(o.rank===3||o.rank===4,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+o.rank+"."),G(l.rank===3,()=>"Error in dilation2d: filter must be rank 3, but got rank "+l.rank+"."),G(i==="NHWC",()=>"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of "+i);let c=o,d=!1;o.rank===3&&(c=Be(o,[1,o.shape[0],o.shape[1],o.shape[2]]),d=!0),G(c.shape[3]===l.shape[2],()=>"Error in dilation2d:  input and filter must have the same depth: "+c.shape[3]+" vs "+l.shape[2]);const h={x:c,filter:l},p={strides:n,pad:r,dilations:a},m=he.runKernel(Cp,h,p);return d?Be(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const I3=ce({dilation2d_:M3});function yi(s,x){const n=s.length,r=[];for(let a=0;a<n;a++){const i=n-1-a,o=s[i]||1;(x[x.length-1-a]||1)>1&&o===1&&r.unshift(i)}return r}function Fb(s,x){const n=[];for(let r=0;r<x.length;r++){const a=s[s.length-r-1],i=x.length-r-1,o=x[i];(a==null||a===1&&o>1)&&n.unshift(i)}return n}function Ot(s,x){const n=[],r=Math.max(s.length,x.length);for(let a=0;a<r;a++){let i=s[s.length-a-1];i==null&&(i=1);let o=x[x.length-a-1];if(o==null&&(o=1),i===1)n.unshift(o);else if(o===1)n.unshift(i);else if(i!==o){const l="Operands could not be broadcast together with shapes "+s+" and "+x+".";throw Error(l)}else n.unshift(i)}return n}function k3(s,x){let n=q(s,"a","equal","string_or_numeric"),r=q(x,"b","equal","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(zc,a)}const Ub=ce({equal_:k3});function N3(s,x,n){const r=q(x,"a","where"),a=q(n,"b","where"),i=q(s,"condition","where","bool"),o=Ot(Ot(i.shape,r.shape),a.shape),l=Yo(i,o),c=Yo(r,o),d=Yo(a,o),h={condition:l,t:c,e:d};return he.runKernel(gf,h)}const bi=ce({where_:N3});function R3(s){const x={x:q(s,"x","zerosLike")};return he.runKernel(Ff,x)}const h2=ce({zerosLike_:R3});function P3(s,x){let n=q(s,"a","div"),r=q(x,"b","div");[n,r]=Ax(n,r);const a=Ht(n,r),i=h2(a),o=Ub(r,i);return bi(o,i,a)}const L3=ce({divNoNan_:P3});function D3(s,x){const n=q(s,"t1","dot"),r=q(x,"t2","dot");G((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+".");const a=n.rank===1?n.size:n.shape[1],i=r.rank===1?r.size:r.shape[0];if(G(a===i,()=>"Error in dot: inner dimensions of inputs must match, but got "+a+" and "+i+"."),n.rank===1&&r.rank===1){const o=Be(n,[1,-1]),l=Be(r,[-1,1]),c=ax(o,l);return Be(c,[])}else if(n.rank===1&&r.rank===2){const o=Be(n,[1,-1]),l=Be(r,[r.shape[0],r.shape[1]]),c=ax(o,l);return Be(c,[c.size])}else if(n.rank===2&&r.rank===1){const o=Be(r,[-1,1]),l=ax(n,o);return Be(l,[l.size])}else{const o=Be(r,[r.shape[0],r.shape[1]]);return ax(n,o)}}const O3=ce({dot_:D3});function F3(s,...x){const n=x.map((a,i)=>q(a,"tensors"+i,"einsum")),r={equation:s};return he.runKernel(Mp,n,r)}const U3=ce({einsum_:F3});function B3(s){const x={x:q(s,"x","elu","float32")};return he.runKernel(Uc,x)}const Bb=ce({elu_:B3});function z3(s){let x=q(s,"x","erf");G(x.dtype==="int32"||x.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),x.dtype==="int32"&&(x=zx(x,"float32"));const n={x};return he.runKernel(Bc,n)}const W3=ce({erf_:z3});function cm(s,x){for(let n=0;n<s.length;++n)if(s[s.length-n-1]!==x-1-n)return!1;return!0}function zb(s,x,n){const r=s.length+x.length,a=[];let i=0,o=0;for(let l=0;l<r;l++)n.indexOf(l)===-1?a.push(s[i++]):a.push(x[o++]);return a}function dn(s,x){const n=[],r=s.length;for(let i=0;i<r;i++)x.indexOf(i)===-1&&n.push(s[i]);const a=x.map(i=>s[i]);return[n,a]}function $x(s,x){const n=x.map(r=>1);return zb(s,n,x)}function hn(s,x,n){G(cm(x,n),()=>s+" supports only inner-most axes for now. Got axes "+x+" and rank-"+n+" input.")}function Nx(s,x){if(cm(s,x))return null;const n=[];for(let r=0;r<x;++r)s.indexOf(r)===-1&&n.push(r);return s.forEach(r=>n.push(r)),n}function Xo(s){return s.map((x,n)=>[n,x]).sort((x,n)=>x[1]-n[1]).map(x=>x[0])}function Rx(s,x){const n=[];for(let r=x-s;r<x;++r)n.push(r);return n}function G3(s,x=null,n=!1){const r={x:q(s,"x","max")},a={reductionIndices:x,keepDims:n};return he.runKernel(Wp,r,a)}const vi=ce({max_:G3});function V3(s,x=null,n=!1){const r={x:q(s,"x","min")},a={axis:x,keepDims:n};return he.runKernel(qp,r,a)}const um=ce({min_:V3});function H3(s,x){let n=q(s,"base","pow"),r=q(x,"exp","pow");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(lu,a)}const Ko=ce({pow_:H3});function Pt(s,x){if((H2(s)&&x!=="string"||Array.isArray(s))&&x!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(x==="string"&&H2(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return us(s,[],[],x)}function Y3(s){const x={x:q(s,"x","sqrt","float32")};return he.runKernel(wu,x)}const Nr=ce({sqrt_:Y3});function q3(s){const x=q(s,"x","square"),n={};return he.runKernel("Square",{x},n)}const q2=ce({square_:q3});function X3(s,x=null,n=!1){let r=q(s,"x","sum");r.dtype==="bool"&&(r=zx(r,"int32"));const a={x:r},i={axis:x,keepDims:n};return he.runKernel(bf,a,i)}const fx=ce({sum_:X3});function K3(s,x="euclidean",n=null,r=!1){s=q(s,"x","norm");const a=Wb(s,x,n);let i=a.shape;if(r){const o=_0(n,s.shape);i=$x(a.shape,o)}return Be(a,i)}function Wb(s,x,n=null){if(s.rank===0)return d2(s);if(s.rank!==1&&n===null)return Wb(Be(s,[-1]),x,n);if(s.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(x===1)return fx(d2(s),n);if(x===1/0)return vi(d2(s),n);if(x===-1/0)return um(d2(s),n);if(x==="euclidean"||x===2)return Nr(fx(Ko(d2(s),Pt(2,"int32")),n));throw new Error("Error in norm: invalid ord value: "+x)}if(Array.isArray(n)&&n.length===2){if(x===1)return vi(fx(d2(s),n[0]),n[1]-1);if(x===1/0)return vi(fx(d2(s),n[1]),n[0]);if(x===-1/0)return um(fx(d2(s),n[1]),n[0]);if(x==="fro"||x==="euclidean")return Nr(fx(q2(s),n));throw new Error("Error in norm: invalid ord value: "+x)}throw new Error("Error in norm: invalid axis: "+n)}const Vu=ce({norm_:K3});function $3(s,x=null,n=!1){return Vu(s,"euclidean",x,n)}const Z3=ce({euclideanNorm_:$3});function J3(s){const x={x:q(s,"x","exp")};return he.runKernel(Wc,x)}const na=ce({exp_:J3});function Q3(s,x=0){const n=q(s,"x","expandDims","string_or_numeric");G(x<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},a={dim:x};return he.runKernel(Ip,r,a)}const Rr=ce({expandDims_:Q3});function j3(s){const x={x:q(s,"x","expm1")};return he.runKernel(Gc,x)}const ek=ce({expm1_:j3});function tk(s,x){const n=q(s,"x","tile","string_or_numeric");G(n.rank===x.length,()=>"Error in transpose: rank of input "+n.rank+" must match length of reps "+x+".");const r={x:n},a={reps:x};return he.runKernel(Eu,r,a)}const $o=ce({tile_:tk});function xk(s,x,n,r="float32"){x==null&&(x=s);const a=At([s,x],r),i=s<=x?s:x;for(let l=0;l<i;++l)a.set(1,l,l);const o=Be(a.toTensor(),[s,x]);if(n==null)return o;if(n.length===1)return $o(Rr(o,0),[n[0],1,1]);if(n.length===2)return $o(Rr(Rr(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return $o(Rr(Rr(Rr(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}const Gb=ce({eye_:xk});function nk(s){const x={x:q(s,"x","floor","float32")};return he.runKernel(Vc,x)}const Vb=ce({floor_:nk});function rk(s,x,n=0,r=0){const a=q(s,"x","gather"),i=q(x,"indices","gather","int32"),o={x:a,indices:i},l={axis:n,batchDims:r};return he.runKernel(Lp,o,l)}const Hb=ce({gather_:rk});function sk(s,x){let n=q(s,"a","greater","string_or_numeric"),r=q(x,"b","greater","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(Yc,a)}const Hu=ce({greater_:sk});function ak(s,x){let n=q(s,"a","greaterEqual","string_or_numeric"),r=q(x,"b","greaterEqual","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(qc,a)}const Yb=ce({greaterEqual_:ak});function ik(s){const x={input:q(s,"input","imag")};return he.runKernel(Fp,x)}const Yu=ce({imag_:ik});function ok(s){const x={x:q(s,"x","isFinite")};return he.runKernel(Kc,x)}const lk=ce({isFinite_:ok});function ck(s){const x={x:q(s,"x","isInf")};return he.runKernel($c,x)}const uk=ce({isInf_:ck});function dk(s){const x={x:q(s,"x","isNaN")};return he.runKernel(Zc,x)}const hk=ce({isNaN_:dk});function pk(s,x=.2){const n={x:q(s,"x","leakyRelu")},r={alpha:x};return he.runKernel(Up,n,r)}const qb=ce({leakyRelu_:pk});function fk(s,x){let n=q(s,"a","less","string_or_numeric"),r=q(x,"b","less","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(Jc,a)}const mk=ce({less_:fk});function gk(s,x){let n=q(s,"a","lessEqual","string_or_numeric"),r=q(x,"b","lessEqual","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(Qc,a)}const dm=ce({lessEqual_:gk});function yk(s,x,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:s,stop:x,num:n};return he.runKernel(Bp,{},r)}function bk(s,x=5,n=1,r=1,a=.5){const i=q(s,"x","localResponseNormalization");G(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank `+i.rank+"."),G(Lt(x),()=>"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+x+".");let o=i,l=!1;i.rank===3&&(l=!0,o=Be(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:o},d={depthRadius:x,bias:n,alpha:r,beta:a},h=he.runKernel(zp,c,d);return l?Be(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const vk=ce({localResponseNormalization_:bk});function wk(s){const x={x:q(s,"x","log","float32")};return he.runKernel(jc,x)}const Zo=ce({log_:wk});function _k(s){const x={x:q(s,"x","log1p")};return he.runKernel(eu,x)}const Xb=ce({log1p_:_k});function Sk(s,x){G(gx(s),()=>"The f passed in variableGrads(f) must be a function"),G(x==null||Array.isArray(x)&&x.every(d=>d instanceof Ou),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=x!=null;if(!n){x=[];for(const d in he.registeredVariables)x.push(he.registeredVariables[d])}const r=n?x.filter(d=>!d.trainable):null,a=x.length;x=x.filter(d=>d.trainable),G(x.length>0,()=>"variableGrads() expects at least one of the input variables to be trainable, but none of the "+a+" variables is trainable.");const i=!0,{value:o,grads:l}=he.gradients(s,x,null,i);G(l.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),G(o.rank===0,()=>"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+o.rank+" tensor");const c={};return x.forEach((d,h)=>{l[h]!=null&&(c[d.name]=l[h])}),r?.forEach(d=>c[d.name]=null),{value:o,grads:c}}function Pr(s){return he.customGrad(s)}function Tk(s){const x={x:q(s,"x","neg")};return he.runKernel($p,x)}const Lr=ce({neg_:Tk});function Ak(s){const x={x:q(s,"x","softplus")};return he.runKernel(vu,x)}const Kb=ce({softplus_:Ak});function Ek(s){const x=q(s,"x","logSigmoid");return Pr(n=>({value:Lr(Kb(Lr(n))),gradFunc:r=>A0(r,fs(Lr(n)))}))(x)}const Ck=ce({logSigmoid_:Ek});function Mk(s,x){let n=q(s,"a","sub"),r=q(x,"b","sub");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(Su,a)}const gt=ce({sub_:Mk});function Ik(s,x=-1){const n=q(s,"logits","logSoftmax");if(x===-1&&(x=n.rank-1),x!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+x);return Pr((r,a)=>{const i=vi(r,x,!0),o=gt(r,i),l=gt(zx(o,"float32"),Zo(fx(na(o),x,!0)));return a([l]),{value:l,gradFunc:(c,d)=>{const[h]=d,p=!0,m=na(h);return gt(c,A0(fx(c,x,p),m))}}})(n)}const kk=ce({logSoftmax_:Ik});function Nk(s,x=null,n=!1){const r=q(s,"x","logSumExp"),a=_0(x,r.shape),i=vi(r,a,!0),o=gt(r,i),l=na(o),c=fx(l,a),d=Zo(c),h=j0(Be(i,d.shape),d);if(n){const p=$x(h.shape,a);return Be(h,p)}return h}const $b=ce({logSumExp_:Nk});function Rk(s,x){const n=q(s,"a","logicalAnd","bool"),r=q(x,"b","logicalAnd","bool");Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(tu,a)}const qu=ce({logicalAnd_:Rk});function Pk(s){const x={x:q(s,"x","logicalNot","bool")};return he.runKernel(xu,x)}const Zb=ce({logicalNot_:Pk});function Lk(s,x){const n=q(s,"a","logicalOr","bool"),r=q(x,"b","logicalOr","bool");Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(nu,a)}const Jb=ce({logicalOr_:Lk});function Dk(s,x){const n=q(s,"a","logicalXor","bool"),r=q(x,"b","logicalXor","bool");return Ot(n.shape,r.shape),qu(Jb(s,x),Zb(qu(s,x)))}const Ok=ce({logicalXor_:Dk}),Xu=2147483648;function Fk(s,x,n="left"){const r=q(s,"sortedSequence","searchSorted"),a=q(x,"values","searchSorted"),i=r.shape[r.shape.length-1],o=a.shape[a.shape.length-1],l=Be(r,[-1,i]),c=Be(a,[-1,o]);if(l.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(l.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(be(c.shape)>=Xu)throw new Error("values tensor size must less than "+Xu);if(l.shape[1]>=Xu)throw new Error("trailing dim_size must less than "+Xu+" for int32 output type, was "+l.shape[1]);const d={sortedSequence:l,values:c},h={side:n};return he.runKernel(mf,d,h)}const hm=ce({searchSorted_:Fk});function Uk(s,x){return hm(s,x,"left")}function Bk(s,x,n,r,a){const i=q(s,"x","maxPool"),o=1;let l=i,c=!1;i.rank===3&&(c=!0,l=Be(i,[1,i.shape[0],i.shape[1],i.shape[2]])),G(l.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+l.rank+"."),G(Sn(n,o),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+o+"'"),N2("maxPool",r,a);const d={x:l},h={filterSize:x,strides:n,pad:r,dimRoundingMode:a},p=he.runKernel(Gp,d,h);return c?Be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Qb=ce({maxPool_:Bk});function zk(s,x=[1,1,1],n,r,a,i="NDHWC"){const o=q(s,"x","maxPool3d");let l=o,c=!1;o.rank===4&&(c=!0,l=Be(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),G(l.rank===5,()=>"Error in maxPool3d: x must be rank 5 but got rank "+l.rank+"."),G(i==="NDHWC",()=>"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),N2("maxPool3d",r,a);const d={x:l},h={filterSize:x,strides:n,pad:r,dimRoundingMode:a,dataFormat:i},p=he.runKernel(Vp,d,h);return c?Be(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Wk=ce({maxPool3d_:zk});function Gk(s,x,n,r,a=!1){const i={x:q(s,"x","maxPoolWithArgmax")},o={filterSize:x,strides:n,pad:r,includeBatchInIndex:a},l=he.runKernel(Hp,i,o);return{result:l[0],indexes:l[1]}}const Vk=ce({maxPoolWithArgmax_:Gk});function Hk(s,x){let n=q(s,"a","maximum"),r=q(x,"b","maximum");[n,r]=Ax(n,r),n.dtype==="bool"&&(n=zx(n,"int32"),r=zx(r,"int32")),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(ru,a)}const jb=ce({maximum_:Hk});function Yk(s,x=null,n=!1){const r={x:q(s,"x","mean")},a={axis:x,keepDims:n};return he.runKernel(Yp,r,a)}const Ku=ce({mean_:Yk});function X2(s,x="float32"){if(x0(s),x==="complex64"){const r=X2(s,"float32"),a=X2(s,"float32");return cs(r,a)}const n=Ae(be(s),x);return he.makeTensor(n,s,x)}function ra(s,x="float32"){if(x0(s),x==="complex64"){const r=ra(s,"float32"),a=X2(s,"float32");return cs(r,a)}const n=l2(be(s),x);return he.makeTensor(n,s,x)}function qk(s,x,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(n+" is not a valid third argument to meshgrid");if(s===void 0)return[];let r=q(s,"x","meshgrid",s instanceof _n?s.dtype:"float32");if(x===void 0)return[r];let a=q(x,"y","meshgrid",x instanceof _n?x.dtype:"float32");const i=be(r.shape),o=be(a.shape);return n==="xy"?(r=Be(r,[1,-1]),a=Be(a,[-1,1]),[ax(ra([o,1],r.dtype),r),ax(a,ra([1,i],a.dtype))]):(r=Be(r,[-1,1]),a=Be(a,[1,-1]),[ax(r,ra([1,o],r.dtype)),ax(ra([i,1],a.dtype),a)])}function Xk(s,x){let n=q(s,"a","minimum"),r=q(x,"b","minimum");[n,r]=Ax(n,r),n.dtype==="bool"&&(n=zx(n,"int32"),r=zx(r,"int32")),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(su,a)}const ev=ce({minimum_:Xk});function Kk(s,x,n){G(n==="reflect"||n==="symmetric",()=>"Invalid mode. Mode must be either reflect or symmetric. Got "+n+".");const r=q(s,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");G(x.length===r.rank,()=>"Padding doesn't match input. Must be "+r.rank+". Got "+x.length+".");const a=n==="reflect"?1:0;for(let l=0;l<r.rank;l++)G(x[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),G(x[l][0]>=0&&x[l][0]<=r.shape[l]-a&&x[l][1]>=0&&x[l][1]<=r.shape[l]-a,()=>"Padding in dimension "+l+" cannot be greater than or equal to "+(r.shape[l]-a)+" or less than 0 for input of shape "+r.shape);const i={paddings:x,mode:n},o={x:r};return he.runKernel(Xp,o,i)}const $k=ce({mirrorPad_:Kk});function Zk(s,x){let n=q(s,"a","mod"),r=q(x,"b","mod");[n,r]=Ax(n,r);const a={a:n,b:r};return he.runKernel(au,a)}const Jk=ce({mod_:Zk});function Qk(s,x=null,n=!1){s=q(s,"x","moments");const r=_0(x,s.shape),a=Ku(s,r,n);let i=a.shape;n||(i=$x(a.shape,r));const o=q2(gt(zx(s,"float32"),Be(a,i))),l=Ku(o,r,n);return{mean:a,variance:l}}const jk=ce({moments_:Qk});function eN(s,x,n,r){const a=q(x,"data","multiRNNCell"),i=Fu(n,"c","multiRNNCell"),o=Fu(r,"h","multiRNNCell");let l=a;const c=[];for(let p=0;p<s.length;p++){const m=s[p](l,i[p],o[p]);c.push(m[0]),c.push(m[1]),l=m[1]}const d=[],h=[];for(let p=0;p<c.length;p+=2)d.push(c[p]),h.push(c[p+1]);return[d,h]}const tN=ce({multiRNNCell_:eN});function xN(s,x,n,r=!1){const a=q(s,"logits","multinomial"),i=a.size,o=a.rank;if(i<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+i+".");if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+o);n=n||Math.random();const l={logits:o===1?Be(a,[1,-1]):a},c={numSamples:x,seed:n,normalized:r},d=he.runKernel(Kp,l,c);return o===1?Be(d,[d.size]):d}const nN=ce({multinomial_:xN});function rN(s,x){let n=q(s,"a","notEqual","string_or_numeric"),r=q(x,"b","notEqual","string_or_numeric");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r};return he.runKernel(ou,a)}const tv=ce({notEqual_:rN});function sN(s,x,n=1,r=0,a="int32"){if(x<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+x);const i={indices:q(s,"indices","oneHot","int32")},o={dtype:a,depth:x,onValue:n,offValue:r};return he.runKernel(ef,i,o)}const aN=ce({oneHot_:sN});function iN(s){const x={x:q(s,"x","onesLike")};return he.runKernel(jp,x)}const oN=ce({onesLike_:iN});function lN(s,x){const n=q(s,"v1","outerProduct"),r=q(x,"v2","outerProduct");G(n.rank===1&&r.rank===1,()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+".");const a=Be(n,[-1,1]),i=Be(r,[1,-1]);return ax(a,i)}const cN=ce({outerProduct_:lN});function uN(s,x,n=0){const r=q(s,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:x,constantValue:n},i={x:r};return he.runKernel(xf,i,a)}const sa=ce({pad_:uN});function dN(s,x,n=0){return G(x.length===2,()=>"Invalid number of paddings. Must be length of 2."),sa(s,[x],n)}const hN=ce({pad1d_:dN});function pN(s,x,n=0){return G(x.length===2&&x[0].length===2&&x[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),sa(s,x,n)}const fN=ce({pad2d_:pN});function mN(s,x,n=0){return G(x.length===3&&x[0].length===2&&x[1].length===2&&x[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),sa(s,x,n)}const gN=ce({pad3d_:mN});function yN(s,x,n=0){return G(x.length===4&&x[0].length===2&&x[1].length===2&&x[2].length===2&&x[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),sa(s,x,n)}const bN=ce({pad4d_:yN});function vN(s,x,n){const r=q(s,"x","spaceToBatchND");G(r.rank>=1+x.length,()=>"input rank "+r.rank+" should be > than [blockShape] "+x.length),G(n.length===x.length,()=>"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+x.length),G(r.shape.reduce((o,l,c)=>c>0&&c<=x.length?o&&(l+n[c-1][0]+n[c-1][1])%x[c-1]===0:o,!0),()=>"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+x.toString());const a={x:r},i={blockShape:x,paddings:n};return he.runKernel(vf,a,i)}const xv=ce({spaceToBatchND_:vN});function wN(s,x,n,r,a,i,o){a==null&&(a=[1,1]),i==null&&(i=1),r===0&&(r="valid");const l=q(s,"x","maxPool");let c=l,d=!1;l.rank===3&&(d=!0,c=Be(l,[1,l.shape[0],l.shape[1],l.shape[2]])),G(Sn(i,a),()=>"Error in pool: Either strides or dilations must be 1. Got strides "+i+" and dilations '"+a+"'");const h=k2(c.shape,x,i,a,r),p=[h.dilationHeight,h.dilationWidth];let m;r==="same"?m=SN([h.filterHeight,h.filterWidth],p):m=[[0,0],[0,0]];const g=p[0]===1&&p[1]===1,[y,b]=_N([h.inHeight,h.inWidth],p,m),v=g?r:"valid",w=g?c:xv(c,p,y),_=(n==="avg"?()=>Rb(w,x,i,v,o):()=>Qb(w,x,i,v,o))(),T=g?_:Pb(_,p,b);return d?Be(T,[T.shape[1],T.shape[2],T.shape[3]]):T}function _N(s,x,n){const r=n.map(h=>h[0]),a=n.map(h=>h[1]),i=s.concat(r,a),o=x.map((h,p)=>(h-i[p]%h)%h),l=a.map((h,p)=>h+o[p]),c=x.map((h,p)=>[r[p],l[p]]),d=x.map((h,p)=>[0,o[p]]);return[c,d]}function SN(s,x){const n=s.map((i,o)=>i+(i-1)*(x[o]-1)).map(i=>i-1),r=n.map(i=>Math.floor(i/2)),a=n.map((i,o)=>i-r[o]);return n.map((i,o)=>[r[o],a[o]])}const TN=ce({pool_:wN});function AN(s,x){const n=q(s,"x","prelu"),r=q(x,"alpha","prelu"),a={x:n,alpha:r};return he.runKernel(nf,a)}const nv=ce({prelu_:AN});function EN(s,x=null,n=!1){let r=q(s,"x","prod");r.dtype==="bool"&&(r=zx(r,"int32"));const a={x:r},i={axis:x,keepDims:n};return he.runKernel(rf,a,i)}const CN=ce({prod_:EN});function MN(s,x,n,r){const a=s.map((h,p)=>q(h,"tensors"+p,"raggedGather","int32")),i=q(x,"paramsDenseValues","raggedGather"),o=q(n,"indices","raggedGather","int32"),l={paramsNestedSplits:a,paramsDenseValues:i,indices:o},c={outputRaggedRank:r},d=he.runKernel(sf,l,c);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}const IN=ce({raggedGather_:MN});function kN(s,x,n){const r=q(s,"starts","raggedRange"),a=q(x,"limits","raggedRange",r.dtype),i=q(n,"deltas","raggedRange",r.dtype),o={starts:r,limits:a,deltas:i},l=he.runKernel(af,o);return{rtNestedSplits:l[0],rtDenseValues:l[1]}}const NN=ce({raggedRange_:kN});function RN(s,x,n,r,a){const i=q(s,"shape","raggedTensorToTensor","int32"),o=q(x,"values","raggedTensorToTensor"),l=q(n,"defaultValue","raggedTensorToTensor",o.dtype),c=r.map((p,m)=>q(p,"tensors"+m,"raggedTensorToTensor","int32")),d={shape:i,values:o,defaultValue:l,rowPartitionTensors:c},h={rowPartitionTypes:a};return he.runKernel(of,d,h)}const PN=ce({raggedTensorToTensor_:RN});function LN(s,x,n){x0(s);const r=be(s);let a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error("Unknown data type "+n);for(let i=0;i<r;i++)a[i]=x();return he.makeTensor(a,s,n)}const DN=ce({rand_:LN});var rv={exports:{}};(function(s){(function(x,n,r){function a(c){var d=this,h=l();d.next=function(){var p=2091639*d.s0+d.c*23283064365386963e-26;return d.s0=d.s1,d.s1=d.s2,d.s2=p-(d.c=p|0)},d.c=1,d.s0=h(" "),d.s1=h(" "),d.s2=h(" "),d.s0-=h(c),d.s0<0&&(d.s0+=1),d.s1-=h(c),d.s1<0&&(d.s1+=1),d.s2-=h(c),d.s2<0&&(d.s2+=1),h=null}function i(c,d){return d.c=c.c,d.s0=c.s0,d.s1=c.s1,d.s2=c.s2,d}function o(c,d){var h=new a(c),p=d&&d.state,m=h.next;return m.int32=function(){return h.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,h),m.state=function(){return i(h,{})}),m}function l(){var c=4022871197,d=function(h){h=String(h);for(var p=0;p<h.length;p++){c+=h.charCodeAt(p);var m=.02519603282416938*c;c=m>>>0,m-=c,m*=c,c=m>>>0,m-=c,c+=m*4294967296}return(c>>>0)*23283064365386963e-26};return d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(qs,s,!1)})(rv);var sv={exports:{}};(function(s){(function(x,n,r){function a(l){var c=this,d="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:d+=l;for(var h=0;h<d.length+64;h++)c.x^=d.charCodeAt(h)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var d=new a(l),h=c&&c.state,p=function(){return(d.next()>>>0)/4294967296};return p.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=d.next,p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(qs,s,!1)})(sv);var av={exports:{}};(function(s){(function(x,n,r){function a(l){var c=this,d="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:d+=l;for(var h=0;h<d.length+64;h++)c.x^=d.charCodeAt(h)|0,h==d.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var d=new a(l),h=c&&c.state,p=function(){return(d.next()>>>0)/4294967296};return p.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=d.next,p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(qs,s,!1)})(av);var iv={exports:{}};(function(s){(function(x,n,r){function a(l){var c=this;c.next=function(){var h=c.x,p=c.i,m,g;return m=h[p],m^=m>>>7,g=m^m<<24,m=h[p+1&7],g^=m^m>>>10,m=h[p+3&7],g^=m^m>>>3,m=h[p+4&7],g^=m^m<<7,m=h[p+7&7],m=m^m<<13,g^=m^m<<9,h[p]=g,c.i=p+1&7,g};function d(h,p){var m,g=[];if(p===(p|0))g[0]=p;else for(p=""+p,m=0;m<p.length;++m)g[m&7]=g[m&7]<<15^p.charCodeAt(m)+g[m+1&7]<<13;for(;g.length<8;)g.push(0);for(m=0;m<8&&g[m]===0;++m);for(m==8?g[7]=-1:g[m],h.x=g,h.i=0,m=256;m>0;--m)h.next()}d(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var d=new a(l),h=c&&c.state,p=function(){return(d.next()>>>0)/4294967296};return p.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=d.next,p.quick=p,h&&(h.x&&i(h,d),p.state=function(){return i(d,{})}),p}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(qs,s,!1)})(iv);var ov={exports:{}};(function(s){(function(x,n,r){function a(l){var c=this;c.next=function(){var h=c.w,p=c.X,m=c.i,g,y;return c.w=h=h+1640531527|0,y=p[m+34&127],g=p[m=m+1&127],y^=y<<13,g^=g<<17,y^=y>>>15,g^=g>>>12,y=p[m]=y^g,c.i=m,y+(h^h>>>16)|0};function d(h,p){var m,g,y,b,v,w=[],_=128;for(p===(p|0)?(g=p,p=null):(p=p+"\0",g=0,_=Math.max(_,p.length)),y=0,b=-32;b<_;++b)p&&(g^=p.charCodeAt((b+32)%p.length)),b===0&&(v=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,b>=0&&(v=v+1640531527|0,m=w[b&127]^=g+v,y=m==0?y+1:0);for(y>=128&&(w[(p&&p.length||0)&127]=-1),y=127,b=4*128;b>0;--b)g=w[y+34&127],m=w[y=y+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,w[y]=g^m;h.w=v,h.X=w,h.i=y}d(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var d=new a(l),h=c&&c.state,p=function(){return(d.next()>>>0)/4294967296};return p.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=d.next,p.quick=p,h&&(h.X&&i(h,d),p.state=function(){return i(d,{})}),p}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(qs,s,!1)})(ov);var lv={exports:{}};(function(s){(function(x,n,r){function a(l){var c=this,d="";c.next=function(){var p=c.b,m=c.c,g=c.d,y=c.a;return p=p<<25^p>>>7^m,m=m-g|0,g=g<<24^g>>>8^y,y=y-p|0,c.b=p=p<<20^p>>>12^m,c.c=m=m-g|0,c.d=g<<16^m>>>16^y,c.a=y-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):d+=l;for(var h=0;h<d.length+20;h++)c.b^=d.charCodeAt(h)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var d=new a(l),h=c&&c.state,p=function(){return(d.next()>>>0)/4294967296};return p.double=function(){do var m=d.next()>>>11,g=(d.next()>>>0)/4294967296,y=(m+g)/(1<<21);while(y===0);return y},p.int32=d.next,p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(qs,s,!1)})(lv);var cv={exports:{}};(function(s){(function(x,n,r){var a=256,i=6,o=52,l="random",c=r.pow(a,i),d=r.pow(2,o),h=d*2,p=a-1,m;function g(A,E,M){var I=[];E=E==!0?{entropy:!0}:E||{};var C=w(v(E.entropy?[A,T(n)]:A??_(),3),I),k=new y(I),O=function(){for(var z=k.g(i),ee=c,re=0;z<d;)z=(z+re)*a,ee*=a,re=k.g(1);for(;z>=h;)z/=2,ee/=2,re>>>=1;return(z+re)/ee};return O.int32=function(){return k.g(4)|0},O.quick=function(){return k.g(4)/4294967296},O.double=O,w(T(k.S),n),(E.pass||M||function(z,ee,re,Y){return Y&&(Y.S&&b(Y,k),z.state=function(){return b(k,{})}),re?(r[l]=z,ee):z})(O,C,"global"in E?E.global:this==r,E.state)}function y(A){var E,M=A.length,I=this,C=0,k=I.i=I.j=0,O=I.S=[];for(M||(A=[M++]);C<a;)O[C]=C++;for(C=0;C<a;C++)O[C]=O[k=p&k+A[C%M]+(E=O[C])],O[k]=E;(I.g=function(z){for(var ee,re=0,Y=I.i,Q=I.j,te=I.S;z--;)ee=te[Y=p&Y+1],re=re*a+te[p&(te[Y]=te[Q=p&Q+ee])+(te[Q]=ee)];return I.i=Y,I.j=Q,re})(a)}function b(A,E){return E.i=A.i,E.j=A.j,E.S=A.S.slice(),E}function v(A,E){var M=[],I=typeof A,C;if(E&&I=="object")for(C in A)try{M.push(v(A[C],E-1))}catch{}return M.length?M:I=="string"?A:A+"\0"}function w(A,E){for(var M=A+"",I,C=0;C<M.length;)E[p&C]=p&(I^=E[p&C]*19)+M.charCodeAt(C++);return T(E)}function _(){try{var A;return m&&(A=m.randomBytes)?A=A(a):(A=new Uint8Array(a),(x.crypto||x.msCrypto).getRandomValues(A)),T(A)}catch{var E=x.navigator,M=E&&E.plugins;return[+new Date,x,M,x.screen,T(n)]}}function T(A){return String.fromCharCode.apply(0,A)}if(w(r.random(),n),s.exports){s.exports=g;try{m=o2(653)}catch{}}else r["seed"+l]=g})(typeof self<"u"?self:qs,[],Math)})(cv);var ON=rv.exports,FN=sv.exports,UN=av.exports,BN=iv.exports,zN=ov.exports,WN=lv.exports,aa=cv.exports;aa.alea=ON,aa.xor128=FN,aa.xorwow=UN,aa.xorshift7=BN,aa.xor4096=zN,aa.tychei=WN;var $u=aa;class pm{constructor(x,n,r,a,i){this.mean=x,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=$u.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const a=this.nextVal;return this.nextVal=NaN,a}let x,n,r=!1;for(;!r;){let a,i,o;do a=2*this.random()-1,i=2*this.random()-1,o=a*a+i*i;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);x=this.mean+this.stdDev*a*l,n=this.mean+this.stdDev*i*l,(!this.truncated||this.isValidTruncated(x))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(x)}convertValue(x){return this.dtype==null||this.dtype==="float32"?x:Math.round(x)}isValidTruncated(x){return x<=this.upper&&x>=this.lower}}class GN{constructor(x,n,r,a){this.alpha=x,this.beta=1/n,this.dtype=r;const i=a||Math.random();this.randu=$u.alea(i.toString()),this.randn=new pm(0,1,r,!1,this.randu()),x<1?this.d=x+2/3:this.d=x-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let x,n,r,a,i,o;for(;;){do a=this.randn.nextValue(),o=1+this.c*a;while(o<=0);if(o*=o*o,x=a*a,n=1-.331*x*x,r=.5*x+this.d*(1-o+Math.log(o)),i=this.randu(),i<n||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(x){return this.dtype==="float32"?x:Math.round(x)}}class VN{constructor(x=0,n=1,r,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=x,this.range=n-x,this.dtype=r,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+x+" - "+n+" <= 1 and dtype is not float");this.random=$u.alea(a)}convertValue(x){return this.canReturnFloat()?x:Math.round(x)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function HN(s,x,n=1,r="float32",a){if(x0(s),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error("Unsupported data type "+r);const i=new GN(x,n,r,a),o=At(s,r);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const YN=ce({randomGamma_:HN});function qN(s,x=0,n=1,r,a){if(x0(s),r!=null&&r==="bool")throw new Error("Unsupported data type "+r);const i=new pm(x,n,r,!1,a),o=At(s,r);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const uv=ce({randomNormal_:qN});function XN(s,x,n){if(x!=null&&x==="bool")throw new Error("Unsupported data type "+x);return uv(s,0,1,x,n)}const KN=ce({randomStandardNormal_:XN});function $N(s,x=0,n=1,r="float32",a){x0(s);const i=At(s,r),o=new VN(x,n,null,a);for(let l=0;l<i.values.length;l++)i.values[l]=o.nextValue();return i.toTensor()}const dv=ce({randomUniform_:$N});function Jo(s,x,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const a={start:s,stop:x,step:n,dtype:r};return he.runKernel(lf,{},a)}function ZN(s){const x={input:q(s,"input","real")};return he.runKernel(cf,x)}const Qo=ce({real_:ZN});function JN(s){const x={x:q(s,"x","reciprocal")};return he.runKernel(cu,x)}const QN=ce({reciprocal_:JN});function jN(s){const x={x:q(s,"x","relu")};return he.runKernel(uu,x)}const Zu=ce({relu_:jN});function eR(s){const x={x:q(s,"x","relu6")};return he.runKernel(du,x)}const hv=ce({relu6_:eR});function tR(s,x){const n={x:q(s,"x","reverse")},r={dims:x};return he.runKernel(pf,n,r)}const ia=ce({reverse_:tR});function xR(s){const x=q(s,"x","reverse");return G(x.rank===1,()=>"Error in reverse1D: x must be rank 1 but got rank "+x.rank+"."),ia(x,0)}const nR=ce({reverse1d_:xR});function rR(s,x){const n=q(s,"x","reverse");return G(n.rank===2,()=>"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."),ia(n,x)}const sR=ce({reverse2d_:rR});function aR(s,x){const n=q(s,"x","reverse");return G(n.rank===3,()=>"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."),ia(n,x)}const iR=ce({reverse3d_:aR});function oR(s,x){const n=q(s,"x","reverse");return G(n.rank===4,()=>"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."),ia(n,x)}const lR=ce({reverse4d_:oR});function cR(s){const x={x:q(s,"x","round")};return he.runKernel(hu,x)}const pv=ce({round_:cR});function uR(s){const x={x:q(s,"x","rsqrt","float32")};return he.runKernel(pu,x)}const dR=ce({rsqrt_:uR});function hR(s){const x={x:q(s,"x","selu")};return he.runKernel(fu,x)}const pR=ce({selu_:hR});function fR(s,x,n,r,a,i=[1,1],o="NHWC"){const l=q(s,"x","separableConv2d"),c=q(x,"depthwiseFilter","separableConv2d"),d=q(n,"pointwiseFilter","separableConv2d");let h=l,p=!1;if(l.rank===3&&(p=!0,h=Be(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");G(h.rank===4,()=>"Error in separableConv2d: input must be rank 4, but got rank "+h.rank+"."),G(c.rank===4,()=>"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+c.rank+"."),G(d.rank===4,()=>"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+c.rank+"."),G(d.shape[0]===1,()=>"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+d.shape[0]+"."),G(d.shape[1]===1,()=>"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+d.shape[1]+".");const m=c.shape[2],g=c.shape[3];G(d.shape[2]===m*g,()=>"Error in separableConv2d: the third dimension of pointwise filter must be "+m*g+", but got "+d.shape[2]+".");const y=lm(h,c,r,a,o,i),b=Gu(y,d,1,"valid",o);return p?Be(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const mR=ce({separableConv2d_:fR});async function gR(s,x){const n=q(s,"x","setdiff1d"),r=q(x,"y","setdiff1d");G(n.dtype===r.dtype,()=>"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+r.dtype+")."),G(n.rank===1,()=>"x should be 1D tensor, but got x ("+n.shape+")."),G(r.rank===1,()=>"y should be 1D tensor, but got y ("+r.shape+").");const a=await n.data(),i=await r.data(),o=new Set(i);let l=0;for(let h=0;h<a.length;h++)o.has(a[h])||l++;const c=new rn([l],n.dtype),d=new rn([l],"int32");for(let h=0,p=0;h<a.length;h++)o.has(a[h])||(c.values[p]=a[h],d.values[p]=h,p++);return[c.toTensor(),d.toTensor()]}const yR=gR;function bR(s){const x={x:q(s,"x","sign")};return he.runKernel(yu,x)}const vR=ce({sign_:bR});function wR(s){const x={x:q(s,"x","sin","float32")};return he.runKernel(mu,x)}const _R=ce({sin_:wR});function SR(s){const x={x:q(s,"x","sinh")};return he.runKernel(gu,x)}const TR=ce({sinh_:SR});function AR(s,x,n){const r=q(s,"x","slice1d");return G(r.rank===1,()=>"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"),Ct(r,[x],[n])}const ER=ce({slice1d_:AR});function CR(s,x,n){const r=q(s,"x","slice2d");return G(r.rank===2,()=>"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"),Ct(r,x,n)}const MR=ce({slice2d_:CR});function IR(s,x,n){const r=q(s,"x","slice3d");return G(r.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"),Ct(r,x,n)}const kR=ce({slice3d_:IR});function NR(s,x,n){const r=q(s,"x","slice4d");return G(r.rank===4,()=>"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"),Ct(r,x,n)}const RR=ce({slice4d_:NR});function PR(s,x=-1){const n=q(s,"logits","softmax","float32");if(x===-1&&(x=n.rank-1),x!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+x);const r={logits:n},a={dim:x};return he.runKernel(_f,r,a)}const LR=ce({softmax_:PR});function DR(s){G(s.dtype==="complex64",()=>"The dtype for tf.spectral.fft() must be complex64 but got "+s.dtype+".");const x={input:s};return he.runKernel(kp,x)}const fm=ce({fft_:DR});function OR(s){G(s.dtype==="complex64",()=>"The dtype for tf.spectral.ifft() must be complex64 but got "+s.dtype+".");const x={input:s};return he.runKernel(Op,x)}const Ju=ce({ifft_:OR});function FR(s){const x=s.shape[s.shape.length-1],n=s.size/x;let r;if(x<=2){const a=Be(s,[n,x]);r=Ju(a)}else{const a=[n,2*(x-1)],i=Be(Qo(s),[n,x]),o=Be(Yu(s),[n,x]),l=ia(Ct(i,[0,1],[n,x-2]),1),c=A0(ia(Ct(o,[0,1],[n,x-2]),1),Pt(-1)),d=Rn([i,l],1),h=Rn([o,c],1),p=Be(cs(d,h),[a[0],a[1]]);r=Ju(p)}if(r=Qo(r),s.rank===3&&s.shape[0]!==0){const a=r,i=s.shape[0];r=Be(r,[i,r.shape[0]/i,r.shape[1]]),a.dispose()}return r}const fv=ce({irfft_:FR});function UR(s,x,n=0){const r={x:q(s,"x","split")},a={numOrSizeSplits:x,axis:n};return he.runKernel(wf,r,a)}const jo=ce({split_:UR});function BR(s,x){G(s.dtype==="float32",()=>"The dtype for rfft() must be real value but got "+s.dtype);let n=s.shape[s.shape.length-1];const r=s.size/n;let a;if(x!=null&&x<n){const y=s.shape.map(v=>0),b=s.shape.map(v=>v);b[s.shape.length-1]=x,a=Ct(s,y,b),n=x}else if(x!=null&&x>n){const y=s.shape.map(b=>b);y[s.shape.length-1]=x-n,a=Rn([s,X2(y)],s.shape.length-1),n=x}else a=s;const i=h2(a),o=Be(cs(a,i),[r,n]),l=fm(o),c=Math.floor(n/2)+1,d=Qo(l),h=Yu(l),p=jo(d,[c,n-c],d.shape.length-1),m=jo(h,[c,n-c],h.shape.length-1),g=a.shape.slice();return g[a.shape.length-1]=c,Be(cs(p[0],m[0]),g)}const mm=ce({rfft_:BR});function zR(s,x){let n=q(s,"a","squaredDifference"),r=q(x,"b","squaredDifference");[n,r]=Ax(n,r),Ot(n.shape,r.shape);const a={a:n,b:r},i={};return he.runKernel(_u,a,i)}const mv=ce({squaredDifference_:zR});function WR(s,x){const n=q(s,"x","squeeze","string_or_numeric");return Be(n,Je(n.shape,x).newShape)}const qn=ce({squeeze_:WR});function GR(s,x=0){const n=Fu(s,"tensors","stack","string_or_numeric");G(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&G(x<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,a={axis:x};return he.runKernel(tf,r,a)}const Dr=ce({stack_:GR});function VR(s,x=0){const n={x:q(s,"x","step")},r={alpha:x};return he.runKernel(Cu,n,r)}const gv=ce({step_:VR});function HR(s,x,n,r,a=0,i=0,o=0,l=0,c=0){const d={x:q(s,"x","stridedSlice","string_or_numeric")},h={begin:x,end:n,strides:r,beginMask:a,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};return he.runKernel(Mf,d,h)}const YR=ce({stridedSlice_:HR});function qR(s){const x={x:q(s,"x","tan","float32")};return he.runKernel(Tu,x)}const XR=ce({tan_:qR});function Xn(s,x){nt(s);const n=ls(s,x);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return us(s,null,n,x)}function oa(s,x,n){if(nt(s),x!=null&&x.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=ls(s,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&x==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return us(s,x,r,n)}function yv(s,x,n){if(nt(s),x!=null&&x.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=ls(s,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&x==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return us(s,x,r,n)}function KR(s,x,n){if(nt(s),x!=null&&x.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=ls(s,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&x==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return us(s,x,r,n)}function $R(s,x,n){if(nt(s),x!=null&&x.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=ls(s,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&x==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return us(s,x,r,n)}function ZR(s,x,n){if(nt(s),x!=null&&x.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=ls(s,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&x==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return x=x||r,us(s,x,r,n)}function JR(s,x=1,n=!0){const r=q(s,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(x<0)throw new Error("'k' passed to topk() must be >= 0 but got "+x);if(x>a)throw new Error("'k' passed to topk() must be <= the last dimension ("+a+") but got "+x);const i={x:r},o={k:x,sorted:n},[l,c]=he.runKernel(Rf,i,o);return{values:l,indices:c}}const QR=ce({topk_:JR});function jR(s,x=0,n=1,r,a){if(x0(s),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new pm(x,n,r,!0,a),o=At(s,r);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const e4=ce({truncatedNormal_:jR});function t4(s,x=0){const n=q(s,"x","unique","string_or_numeric");G(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},a={axis:x},[i,o]=he.runKernel(Lf,r,a);return{values:i,indices:o}}const x4=ce({unique_:t4});function n4(s,x,n){const r=q(s,"x","unsortedSegmentSum"),a=q(x,"segmentIds","unsortedSegmentSum","int32");G(Lt(n),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:a},o={numSegments:n};return he.runKernel(Of,i,o)}const r4=ce({unsortedSegmentSum_:n4});function s4(s,x=0){const n=q(s,"x","unstack","string_or_numeric");G(x>=-n.shape.length&&x<n.shape.length,()=>"Axis = "+x+" is not in [-"+n.shape.length+", "+n.shape.length+")");const r={value:n},a={axis:x};return he.runKernel(Df,r,a)}const la=ce({unstack_:s4});function a4(s,x){return hm(s,x,"right")}function i4(s,x=!0,n,r){return he.makeVariable(s,x,n,r)}function gm(s,x){const n=[];for(let i=0;i<x.length;i++)x[i]&&n.push(i);const r=At(s,"int32"),a=At([n.length,s.length],"int32");for(let i=0;i<n.length;i++){const o=r.indexToLoc(n[i]),l=i*s.length;a.values.set(o,l)}return a.toTensor()}async function o4(s){const x=q(s,"condition","whereAsync","bool"),n=await x.data(),r=gm(x.shape,n);return s!==x&&x.dispose(),r}const bv=o4;async function l4(s,x,n){const r=q(s,"tensor","boolMask"),a=q(x,"mask","boolMask","bool"),i=n??0,o=a.rank,l=r.shape;G(o>0,()=>"mask cannot be scalar"),F0(l.slice(i,i+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let b=i;b<i+o;b++)c*=l[b];const d=l.slice(0,i).concat([c],l.slice(i+o)),h=Be(r,d),p=Be(a,[-1]),m=await bv(p),g=qn(m,[1]),y=Hb(h,g,i);return s!==r&&r.dispose(),x!==a&&a.dispose(),g.dispose(),h.dispose(),p.dispose(),m.dispose(),y}const c4=l4;function u4(s,x,n){const r=q(s,"x","transpose");if(x==null&&(x=r.shape.map((o,l)=>l).reverse()),G(r.rank===x.length,()=>"Error in transpose: rank of input "+r.rank+" must match length of perm "+x+"."),x.forEach(o=>{G(o>=0&&o<r.rank,()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+" but got "+x)}),r.rank<=1)return r.clone();const a={x:r},i={perm:x};return r.dtype==="complex64"?vt(()=>{let o=Qo(r),l=Yu(r);return o=he.runKernel(Oo,{x:o},i),l=he.runKernel(Oo,{x:l},i),n&&(l=Lr(l)),cs(o,l)}):he.runKernel(Oo,a,i)}const ym=ce({transpose_:u4});function d4(s,x,n,r,a=!0){const i=q(s,"v","movingAverage"),o=q(x,"x","movingAverage"),l=q(n,"decay","movingAverage");rM(i,o),G(T0(i.shape,o.shape),()=>"Shape mismatch in v and x");const c=Pt(1),d=gt(c,l);let h=A0(gt(o,i),d);if(a){G(r!=null,()=>"When using zeroDebias: true, step is required.");const p=q(r,"step","movingAverage");h=Ht(h,gt(c,Ko(l,p)))}return j0(i,h)}const h4=ce({movingAverage_:d4});function vv(s,x,n){const r=x.rank>1?x.shape[x.rank-1]:1,a=x.rank>1?x.rank-1:1,i="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+x.shape+", shape: "+s+", sliceDim: "+r+", and batchDim: "+a+".";if(n.rank<a)throw new Error(i+(" update.rank < "+a+". "));if(s.length<r+(n.rank-a))throw new Error(i+(" Output shape length < "+(r+(n.rank-a))));if(n.rank!==a+s.length-r)throw new Error(i+(" update.rank != "+(a+s.length-r)));for(let o=0;o<a;++o)if(n.shape[o]!==x.shape[o])throw new Error(i+(" updates.shape["+o+"] ("+n.shape[o]+") != indices.shape["+o+"] ("+x.shape[o]+")."));for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==s[o+r])throw new Error(i+(" updates.shape["+(o+a)+"] ("+n.shape[o+a]+") != shape["+(o+a)+"] ("+s[o+a]+")"))}function wv(s,x,n){if(x.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+x.rank+".");if(s.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+s.rank+".");if(x.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+x.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(n.length===0){if(x.size===0)throw new Error("Indices specified for empty output. indices shape: "+x.shape);if(s.size===0)throw new Error("Updates specified for empty output. updates shape: "+s.shape)}vv(n,x,s)}function el(s,x,n){const r=x.shape.length,a=r>1?x.shape[r-1]:1,i=n.length;let o=1;for(let p=a;p<i;++p)o*=n[p];const l=a<1?1:a,c=be(x.shape)/l,d=[...U0(n.slice(0,a)),1],h=be(n);return{sliceRank:a,numUpdates:c,sliceSize:o,strides:d,outputSize:h}}function p4(s,x,n){x0(n);const r=q(s,"indices","scatterND","int32"),a=q(x,"updates","scatterND");wv(a,r,n);const i={indices:r,updates:a},o={shape:n};return he.runKernel(ff,i,o)}const f4=ce({scatterND_:p4});function m4(s,x,n,r){if(s.dtype!=="int32")throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+s.dtype+".");if(s.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+s.shape+".");const a=s.rank>0?s.shape[0]:1,i=s.rank>1?s.shape[1]:1;if(n.length!==i)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+i+".");const o=x.size;if(!(x.rank===0||x.rank===1&&o===a))throw new Error("sparseValues has incorrect shape "+x.shape+", should be [] or ["+a+"]");if(x.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function g4(s,x,n,r=0){x0(n);const a=q(s,"sparseIndices","sparseToDense","int32"),i=q(x,"sparseValues","sparseToDense","string_or_numeric"),o=q(r,"defaultValue","sparseToDense",i.dtype);m4(a,i,n,o);const l={sparseIndices:a,sparseValues:i,defaultValue:o},c={outputShape:n};return he.runKernel(Cf,l,c)}const y4=ce({sparseToDense_:g4});function b4(s,x){const n=q(x,"indices","gatherND","int32"),r={params:q(s,"x","gatherND","string_or_numeric"),indices:n};return he.runKernel(Dp,r)}const v4=ce({gatherND_:b4});function w4(s,x){if(x==null)return s.shape.slice();if(T0(s.shape,x))return x;if(s.shape.length===x.length){const n=[];for(let r=0;r<s.shape.length;r++)x[r]==null&&s.shape[r]!=null?n.push(s.shape[r]):n.push(x[r]);return n}return x}function _4(s,x,n,r){const a=q(s,"x","dropout");if(G(a.dtype==="float32",()=>"x has to be a floating point tensor since it's going to be scaled, but got a "+a.dtype+" tensor instead."),G(x>=0&&x<1,()=>"rate must be a float in the range [0, 1), but got "+x+"."),x===0)return s instanceof _n?a.clone():a;const i=w4(a,n),o=1-x,l=Ht(Vb(j0(dv(i,0,1,"float32",r),o)),o);return A0(a,l)}const S4=ce({dropout_:_4});function _v(s){return Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2))))}function bm(s,x,n){const r=1-s%2,a=new Float32Array(s);for(let i=0;i<s;++i){const o=2*Math.PI*i/(s+r-1);a[i]=x-n*Math.cos(o)}return Xn(a,"float32")}async function T4(s,x,n=1){const r=q(s,"predictions","inTopK"),a=q(x,"targets","inTopK");G(r.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, but got "+r.rank),G(r.rank-1===a.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+r.rank+" and targets rank "+a.rank),F0(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];G(n>0&&n<=i,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+i+"), but got "+n);const o=await r.data(),l=await a.data(),[c,d]=[o.length/i,i],h=Ke("bool",c);for(let p=0;p<c;p++){const m=p*d,g=o.subarray(m,m+d),y=[];for(let b=0;b<g.length;b++)y.push({value:g[b],index:b});y.sort((b,v)=>v.value-b.value),h[p]=0;for(let b=0;b<n;b++)if(y[b].index===l[p]){h[p]=1;break}}return s!==r&&r.dispose(),x!==a&&a.dispose(),lr(h,a.shape,"bool")}const A4=T4;function E4(s,x,n,r,a,i="NHWC",o){let l=s;s.rank===3&&(l=Be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c=x;c.rank===3&&(c=Be(x,[1,x.shape[0],x.shape[1],x.shape[2]])),G(l.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+l.shape+"."),G(c.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+c.shape+"."),G(n.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+".");const d=i==="NHWC"?l.shape[3]:l.shape[1],h=i==="NHWC"?c.shape[3]:c.shape[1];G(d===n[2],()=>"Error in conv2dDerFilter: depth of input "+d+") must match input depth in filter ("+n[2]+"."),G(h===n[3],()=>"Error in conv2dDerFilter: depth of dy ("+h+") must match output depth for filter ("+n[3]+")."),N2("conv2dDerFilter",a,o);const p={x:l,dy:c},m={strides:r,pad:a,dataFormat:i,dimRoundingMode:o,filterShape:n};return he.runKernel(pp,p,m)}const C4=ce({conv2DBackpropFilter_:E4});function Qu(s,x,n){if(n==null||n==="linear")return s;if(n==="relu")return A0(s,gv(x));throw new Error("Cannot compute gradient for fused activation "+n+".")}function ju(s,x){let n=x;const r=Fb(s.shape,x.shape);return r.length>0&&(n=fx(n,r)),Be(n,s.shape)}function ed(s,x,n,r){if(x==="linear")return s;if(x==="relu")return Zu(s);if(x==="elu")return Bb(s);if(x==="relu6")return hv(s);if(x==="prelu")return nv(s,n);if(x==="leakyrelu")return qb(s,r);if(x==="sigmoid")return fs(s);throw new Error("Unknown fused activation "+x+".")}const td=(s,x)=>!(s>0)||x==="linear";function M4({x:s,filter:x,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:d,leakyreluAlpha:h}){if(c=c||"linear",td(he.state.gradientDepth,c)===!1){G(a==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+a+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let M=Gu(s,x,n,r,a,i,o);return l!=null&&(M=j0(M,l)),ed(M,c,d,h)}const p=q(s,"x","conv2d","float32"),m=q(x,"filter","conv2d","float32");let g=p,y=!1;p.rank===3&&(y=!0,g=Be(p,[1,p.shape[0],p.shape[1],p.shape[2]])),G(g.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+g.rank+"."),G(m.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+m.rank+"."),N2("fused conv2d",r,o);const b=a==="NHWC"?g.shape[3]:g.shape[1];G(m.shape[2]===b,()=>"Error in conv2d: depth of input ("+b+") must match input depth for filter "+m.shape[2]+"."),G(Sn(n,i),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'");const v=sn(g.shape,m.shape,n,i,r,o);let w;l!=null&&(w=q(l,"bias","fused conv2d"),[w]=Ax(w,p),a==="NHWC"?Ot(v.outShape,w.shape):(G(w.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+w.shape.length+"."),G(w.shape.length===0||w.shape[0]===v.outChannels||w.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+w.shape+") is not compatible with the number of output channels ("+v.outChannels+")")));let _;if(d!=null){const M=d.shape;if(G(M.length<=1||M.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+M.length+"."),M.length===1)G(M[0]===1||M[0]===v.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+M+") is not compatible with the number of output channels ("+v.outChannels+").");else if(M.length===3)try{Ot(M,v.outShape)}catch{const C="Error in fused conv2d: PReLU activation weights ("+M+") is not compatible with the output shape of the conv2d ("+v.outShape+").";throw Error(C)}_=q(d,"prelu weights","fused conv2d")}const T=(M,I)=>{G(a==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+a+" but only NHWC is currently supported.");const[C,k,O,z]=I,ee=Qu(M,O,c);G(Ho(i),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+i+"'");const re=Ob(k.shape,ee,C,n,r),Y=C4(k,ee,C.shape,n,r),Q=[re,Y];if(z!=null){const te=ju(z,ee);Q.push(te)}return Q},A={x:g,filter:m,bias:w,preluActivationWeights:_},E={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o,activation:c,leakyreluAlpha:h};return l==null?Pr((M,I,C)=>{let k=he.runKernel(Iu,A,E);return C([I,M,k]),y&&(k=Be(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:T}})(g,m):Pr((M,I,C,k)=>{let O=he.runKernel(Iu,A,E);return k([I,M,O,C]),y&&(O=Be(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:T}})(g,m,w)}const I4=ce({fusedConv2d_:M4});function k4(s,x,n,r,a,i=[1,1],o){let l=s;s.rank===3&&(l=Be(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c=x;c.rank===3&&(c=Be(x,[1,x.shape[0],x.shape[1],x.shape[2]]));const d={x:l,dy:c},h={strides:r,pad:a,dimRoundingMode:o,dilations:i,filterShape:n};return he.runKernel(Tp,d,h)}const N4=ce({depthwiseConv2dNativeBackpropFilter_:k4});function R4(s,x,n,r,a,i=[1,1],o){let l=x,c=!1;x.rank===3&&(c=!0,l=Be(x,[1,x.shape[0],x.shape[1],x.shape[2]]));const d={dy:l,filter:n},h={strides:r,pad:a,dimRoundingMode:o,dilations:i,inputShape:s},p=he.runKernel(Ap,d,h);return c?Be(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const P4=ce({depthwiseConv2dNativeBackpropInput_:R4});function L4({x:s,filter:x,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:d,leakyreluAlpha:h}){if(td(he.state.gradientDepth,c)===!1){let E=lm(s,x,n,r,a,i,o);return l!=null&&(E=j0(E,l)),ed(E,c,d,h)}const p=q(s,"x","depthwiseConv2d","float32"),m=q(x,"filter","depthwiseConv2d","float32");let g=p,y=!1;p.rank===3&&(y=!0,g=Be(p,[1,p.shape[0],p.shape[1],p.shape[2]])),G(g.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+g.rank+"."),G(m.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+m.rank+"."),G(g.shape[3]===m.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+g.shape[3]+") must match the inChannels dimension in filter "+m.shape[2]+"."),i==null&&(i=[1,1]),G(Sn(n,i),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+i+"'"),N2("fused depthwiseConv2d",r,o);const b=sn(g.shape,m.shape,n,i,r,o,!0);let v;l!=null&&(v=q(l,"bias","fused conv2d"),[v]=Ax(v,p),Ot(b.outShape,v.shape));let w;d!=null&&(w=q(d,"prelu weights","fused depthwiseConv2d"));const _=(E,M)=>{G(Ho(i),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+i+"'");const[I,C,k,O]=M,z=Qu(E,k,c),ee=P4(C.shape,z,I,n,r,i,o),re=N4(C,z,I.shape,n,r,i,o);if(O!=null){const Y=ju(v,z);return[ee,re,Y]}return[ee,re]},T={x:g,filter:m,bias:v,preluActivationWeights:w},A={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o,activation:c,leakyreluAlpha:h};return l==null?Pr((E,M,I)=>{let C=he.runKernel(ku,T,A);return I([M,E,C]),y&&(C=Be(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:_}})(g,m):Pr((E,M,I,C)=>{let k=he.runKernel(ku,T,A);return C([M,E,k,I]),y&&(k=Be(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:_}})(g,m,v)}const D4=ce({fusedDepthwiseConv2d_:L4});function O4({a:s,b:x,transposeA:n=!1,transposeB:r=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(td(he.state.gradientDepth,i)===!1){let O=ax(s,x,n,r);return a!=null&&(O=j0(O,a)),ed(O,i,o,l)}let c=q(s,"a","fused matMul"),d=q(x,"b","fused matMul");[c,d]=Ax(c,d);const h=n?c.shape[c.rank-2]:c.shape[c.rank-1],p=r?d.shape[d.rank-1]:d.shape[d.rank-2],m=n?c.shape[c.rank-1]:c.shape[c.rank-2],g=r?d.shape[d.rank-2]:d.shape[d.rank-1],y=c.shape.slice(0,-2),b=d.shape.slice(0,-2),v=be(y),w=be(b);G(h===p,()=>"Error in fused matMul: inner shapes ("+h+") and ("+p+") of Tensors with shapes "+c.shape+" and "+d.shape+" and transposeA="+n+" and transposeB="+r+" must match.");const _=Ot(c.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,g]),T=n?Be(c,[v,h,m]):Be(c,[v,m,h]),A=r?Be(d,[w,g,p]):Be(d,[w,p,g]);let E;a!=null&&(E=q(a,"bias","fused matMul"),[E]=Ax(E,c),Ot(_,E.shape));let M;o!=null&&(M=q(o,"prelu weights","fused matMul"));const I=(O,z)=>{const[ee,re,Y,Q]=z,te=Qu(Be(O,Y.shape),Y,i);let se,xe;if(!n&&!r?(se=ax(te,re,!1,!0),xe=ax(ee,te,!0,!1)):!n&&r?(se=ax(te,re,!1,!1),xe=ax(te,ee,!0,!1)):n&&!r?(se=ax(re,te,!1,!0),xe=ax(ee,te,!1,!1)):(se=ax(re,te,!0,!0),xe=ax(te,ee,!0,!0)),a!=null){const ae=ju(Q,te);return[se,xe,ae]}else return[se,xe]},C={a:T,b:A,bias:E,preluActivationWeights:M},k={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:l};return a==null?Pr((O,z,ee)=>{const re=he.runKernel(Mu,C,k);return ee([O,z,re]),{value:Be(re,_),gradFunc:I}})(T,A):Pr((O,z,ee,re)=>{const Y=he.runKernel(Mu,C,k);return re([O,z,Y,ee]),{value:Be(Y,_),gradFunc:I}})(T,A,E)}const F4=ce({fusedMatMul_:O4});var U4=Object.freeze({__proto__:null,conv2d:I4,depthwiseConv2d:D4,matMul:F4});function B4(s){return bm(s,.54,.46)}const z4=ce({hammingWindow_:B4});function W4(s){return bm(s,.5,.5)}const Sv=ce({hannWindow_:W4});function G4(s,x,n,r=!1,a=0){let i=0;const o=[];for(;i+x<=s.size;)o.push(Ct(s,i,x)),i+=n;if(r)for(;i<s.size;){const l=i+x-s.size,c=Rn([Ct(s,i,x-l),qo([l],a)]);o.push(c),i+=n}return o.length===0?oa([],[0,x]):Be(Rn(o),[o.length,x])}const Tv=ce({frame_:G4});function V4(s,x,n,r,a=Sv){r==null&&(r=_v(x));const i=Tv(s,x,n),o=A0(i,a(x));return mm(o,r)}const H4=ce({stft_:V4});function Y4(s,x,n,r,a="bilinear",i=0){const o=q(s,"image","cropAndResize"),l=q(x,"boxes","cropAndResize","float32"),c=q(n,"boxInd","cropAndResize","int32"),d=l.shape[0];G(o.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+o.rank+"."),G(l.rank===2&&l.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+d+",4] but had shape "+l.shape+"."),G(c.rank===1&&c.shape[0]===d,()=>"Error in cropAndResize: boxInd must be have size ["+d+"] but had shape "+l.shape+"."),G(r.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."),G(r[0]>=1&&r[1]>=1,()=>"cropSize must be atleast [1,1], but was "+r),G(a==="bilinear"||a==="nearest",()=>"method must be bilinear or nearest, but was "+a);const h={image:o,boxes:l,boxInd:c},p={method:a,extrapolationValue:i,cropSize:r};return he.runKernel(vp,h,p)}const q4=ce({cropAndResize_:Y4});function X4(s){const x=q(s,"image","flipLeftRight","float32");G(x.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+x.rank+".");const n={image:x};return he.runKernel(Rp,n,{})}const K4=ce({flipLeftRight_:X4});function $4(s){const x=q(s,"image","grayscaleToRGB"),n=x.rank-1,r=x.shape[n];G(x.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+x.rank+"."),G(r===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+r+".");const a=new Array(x.rank);return a.fill(1,0,n),a[n]=3,$o(x,a)}const Z4=ce({grayscaleToRGB_:$4});function J4(s,x,n=0,r=.5){const a=q(s,"image","rotateWithOffset","float32");G(a.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+a.rank+".");const i={image:a},o={radians:x,fillValue:n,center:r};return he.runKernel(Bf,i,o)}const Q4=ce({rotateWithOffset_:J4});function wi(s,x,n,r,a,i){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=s.shape[0];return n=Math.min(n,o),G(0<=r&&r<=1,()=>"iouThreshold must be in [0, 1], but was '"+r+"'"),G(s.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+s.rank+"'"),G(s.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+s.shape[1]),G(x.rank===1,()=>"scores must be a 1D tensor"),G(x.shape[0]===o,()=>"scores has incompatible shape with boxes. Expected "+o+", but was "+x.shape[0]),G(0<=i&&i<=1,()=>"softNmsSigma must be in [0, 1], but was '"+i+"'"),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i}}function j4(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY){const i=q(s,"boxes","nonMaxSuppression","float32"),o=q(x,"scores","nonMaxSuppression","float32"),l=wi(i,o,n,r,a);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold;const c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return he.runKernel(Zp,{boxes:i,scores:o},c)}const e8=ce({nonMaxSuppression_:j4});function t8(s,x,n){const r=x8(s,x,n),a=r<0?-(r+1):r;s.splice(a,0,x)}function x8(s,x,n){return r8(s,x,n||n8)}function n8(s,x){return s>x?1:s<x?-1:0}function r8(s,x,n){let r=0,a=s.length,i=0,o=!1;for(;r<a;){i=r+(a-r>>>1);const l=n(x,s[i]);l>0?r=i+1:(a=i,o=!l)}return o?r:-r-1}function vm(s,x,n,r,a){return Sm(s,x,n,r,a,0)}function wm(s,x,n,r,a,i){return Sm(s,x,n,r,a,0,!1,i,!0)}function _m(s,x,n,r,a,i){return Sm(s,x,n,r,a,i,!0)}function Sm(s,x,n,r,a,i,o=!1,l=!1,c=!1){const d=[];for(let v=0;v<x.length;v++)x[v]>a&&d.push({score:x[v],boxIndex:v,suppressBeginIndex:0});d.sort(Av);const h=i>0?-.5/i:0,p=[],m=[];for(;p.length<n&&d.length>0;){const v=d.pop(),{score:w,boxIndex:_,suppressBeginIndex:T}=v;if(w<a)break;let A=!1;for(let E=p.length-1;E>=T;--E){const M=s8(s,_,p[E]);if(M>=r){A=!0;break}if(v.score=v.score*a8(r,h,M),v.score<=a)break}v.suppressBeginIndex=p.length,A||(v.score===w?(p.push(_),m.push(v.score)):v.score>a&&t8(d,v,Av))}const g=p.length,y=n-g;l&&y>0&&(p.push(...new Array(y).fill(0)),m.push(...new Array(y).fill(0)));const b={selectedIndices:p};return o&&(b.selectedScores=m),c&&(b.validOutputs=g),b}function s8(s,x,n){const r=s.subarray(x*4,x*4+4),a=s.subarray(n*4,n*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),l=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),d=Math.min(a[0],a[2]),h=Math.min(a[1],a[3]),p=Math.max(a[0],a[2]),m=Math.max(a[1],a[3]),g=(l-i)*(c-o),y=(p-d)*(m-h);if(g<=0||y<=0)return 0;const b=Math.max(i,d),v=Math.max(o,h),w=Math.min(l,p),_=Math.min(c,m),T=Math.max(w-b,0)*Math.max(_-v,0);return T/(g+y-T)}function a8(s,x,n){const r=Math.exp(x*n*n);return n<=s?r:0}function Av(s,x){return s.score-x.score||s.score===x.score&&x.boxIndex-s.boxIndex}async function i8(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY){const i=q(s,"boxes","nonMaxSuppressionAsync"),o=q(x,"scores","nonMaxSuppressionAsync"),l=wi(i,o,n,r,a);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold;const c=await Promise.all([i.data(),o.data()]),d=c[0],h=c[1],{selectedIndices:p}=vm(d,h,n,r,a);return i!==s&&i.dispose(),o!==x&&o.dispose(),Xn(p,"int32")}const o8=i8;function l8(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){const o=q(s,"boxes","nonMaxSuppression"),l=q(x,"scores","nonMaxSuppression"),c=wi(o,l,n,r,a,i);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,i=c.softNmsSigma;const d={boxes:o,scores:l},h={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i},p=he.runKernel(Qp,d,h);return{selectedIndices:p[0],selectedScores:p[1]}}const c8=ce({nonMaxSuppressionWithScore_:l8});async function u8(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){const o=q(s,"boxes","nonMaxSuppressionAsync"),l=q(x,"scores","nonMaxSuppressionAsync"),c=wi(o,l,n,r,a,i);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,i=c.softNmsSigma;const d=await Promise.all([o.data(),l.data()]),h=d[0],p=d[1],{selectedIndices:m,selectedScores:g}=_m(h,p,n,r,a,i);return o!==s&&o.dispose(),l!==x&&l.dispose(),{selectedIndices:Xn(m,"int32"),selectedScores:Xn(g)}}const d8=u8;function h8(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){const o=q(s,"boxes","nonMaxSuppression"),l=q(x,"scores","nonMaxSuppression"),c=wi(o,l,n,r,a,null),d=c.maxOutputSize,h=c.iouThreshold,p=c.scoreThreshold,m={boxes:o,scores:l},g={maxOutputSize:d,iouThreshold:h,scoreThreshold:p,padToMaxOutputSize:i},y=he.runKernel(Jp,m,g);return{selectedIndices:y[0],validOutputs:y[1]}}const p8=ce({nonMaxSuppressionPadded_:h8});async function f8(s,x,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){const o=q(s,"boxes","nonMaxSuppressionAsync"),l=q(x,"scores","nonMaxSuppressionAsync"),c=wi(o,l,n,r,a,null),d=c.maxOutputSize,h=c.iouThreshold,p=c.scoreThreshold,[m,g]=await Promise.all([o.data(),l.data()]),{selectedIndices:y,validOutputs:b}=wm(m,g,d,h,p,i);return o!==s&&o.dispose(),l!==x&&l.dispose(),{selectedIndices:Xn(y,"int32"),validOutputs:Pt(b,"int32")}}const m8=f8;function g8(s,x,n=!1,r=!1){const a=q(s,"images","resizeBilinear");G(a.rank===3||a.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+a.rank+"."),G(x.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+x+"."),G(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=a,o=!1;a.rank===3&&(o=!0,i=Be(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={images:i},c={alignCorners:n,halfPixelCenters:r,size:x},d=he.runKernel(hf,l,c);return o?Be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const y8=ce({resizeBilinear_:g8});function b8(s,x,n=!1,r=!1){const a=q(s,"images","resizeNearestNeighbor");G(a.rank===3||a.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+a.rank+"."),G(x.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+x+"."),G(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),G(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=a,o=!1;a.rank===3&&(o=!0,i=Be(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={images:i},c={alignCorners:n,halfPixelCenters:r,size:x},d=he.runKernel(df,l,c);return o?Be(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const v8=ce({resizeNearestNeighbor_:b8});function w8(s,x="binary",n=!1,r=.5){const a=q(s,"image","threshold"),i=.2989,o=.587,l=.114,c=a.shape[0]*a.shape[1];let d=A0(Xn([r]),255),h,p,m,g;if(G(a.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+a.rank+"."),G(a.shape[2]===3||a.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+a.shape[2]+"."),G(a.dtype==="int32"||a.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+a.dtype+"."),G(x==="otsu"||x==="binary",()=>"Method must be binary or otsu, but was "+x),a.shape[2]===3){[h,p,m]=jo(a,[1,1,1],-1);const b=A0(h,i),v=A0(p,o),w=A0(m,l);g=j0(j0(b,v),w)}else g=s;if(x==="otsu"){const b=Lb(zx(pv(g),"int32"),lr([]),256);d=_8(b,c)}const y=n?dm(g,d):Hu(g,d);return zx(A0(y,255),"int32")}function _8(s,x){let n=Xn([-1]),r=Xn([0]),a=Xn([0]),i,o,l,c,d,h;for(let p=0;p<s.size-1;p++){i=Ct(s,0,p+1),o=Ct(s,p+1),d=Ht(fx(i),x),h=Ht(fx(o),x);const m=fx(A0(i,Jo(0,i.size)));l=Ht(m,fx(i));const g=qo(o.shape,i.size),y=j0(Jo(0,o.size),g),b=A0(o,y);c=Ht(fx(b),fx(o));const v=gt(l,c),w=gt(l,c),_=A0(d,h);a=A0(A0(_,v),w);const T=Hu(a,r);r=bi(T,a,r),n=bi(T,Xn([p]),n)}return n}const S8=ce({threshold_:w8});function T8(s,x,n="nearest",r="constant",a=0,i){const o=q(s,"image","transform","float32"),l=q(x,"transforms","transform","float32");G(o.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+o.rank+"."),G(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),G(i==null||i.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+i+".");const c={image:o,transforms:l},d={interpolation:n,fillMode:r,fillValue:a,outputShape:i};return he.runKernel(Pf,c,d)}const A8=ce({transform_:T8});function E8(s,x,n){G(x%1===0,()=>"bandPart(): numLower must be an integer, got "+x+"."),G(n%1===0,()=>"bandPart(): numUpper must be an integer, got "+n+".");const r=q(s,"a","bandPart");G(r.rank>=2,()=>"bandPart(): Rank must be at least 2, got "+r.rank+".");const a=r.shape,[i,o]=r.shape.slice(-2);if(!(x<=i))throw new Error("bandPart(): numLower ("+x+") must not be greater than the number of rows ("+i+").");if(!(n<=o))throw new Error("bandPart(): numUpper ("+n+") must not be greater than the number of columns ("+o+").");x<0&&(x=i),n<0&&(n=o);const l=Be(Jo(0,i,1,"int32"),[-1,1]),c=Jo(0,o,1,"int32"),d=gt(l,c),h=qu(dm(d,Pt(+x,"int32")),Yb(d,Pt(-n,"int32"))),p=X2([i,o],r.dtype);return Be(Dr(la(Be(r,[-1,i,o])).map(m=>bi(h,m,p))),a)}const C8=ce({bandPart_:E8});function M8(s){let x;if(Array.isArray(s)){x=!1,G(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const a=s[0].shape[0];for(let i=1;i<s.length;++i)G(s[i].shape[0]===a,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+s[i].shape[0]+" vs. "+a+")")}else x=!0,s=jo(s,s.shape[0],0).map(a=>qn(a,[0]));G(s.length<=s[0].shape[0],()=>"Gram-Schmidt: Number of vectors ("+s.length+") exceeds number of dimensions ("+s[0].shape[0]+").");const n=[],r=s;for(let a=0;a<s.length;++a)n.push(he.tidy(()=>{let i=r[a];if(a>0)for(let o=0;o<a;++o){const l=A0(fx(A0(n[o],i)),n[o]);i=gt(i,l)}return Ht(i,Vu(i,"euclidean"))}));return x?Dr(n,0):n}const I8=ce({gramSchmidt_:M8});function k8(s,x=!1){if(G(s.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank "+s.rank),s.rank===2)return Ev(s,x);{const n=s.shape.slice(0,s.shape.length-2).reduce((c,d)=>c*d),r=la(Be(s,[n,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),a=[],i=[];r.forEach(c=>{const[d,h]=Ev(c,x);a.push(d),i.push(h)});const o=Be(Dr(a,0),s.shape),l=Be(Dr(i,0),s.shape);return[o,l]}}function Ev(s,x=!1){return he.tidy(()=>{G(s.shape.length===2,()=>"qr2d() requires a 2D Tensor, but got a "+s.shape.length+"D Tensor.");const n=s.shape[0],r=s.shape[1];let a=Gb(n),i=hs(s);const o=oa([[1]],[1,1]);let l=hs(o);const c=n>=r?r:n;for(let d=0;d<c;++d){const h=i,p=l,m=a;[l,i,a]=he.tidy(()=>{const g=Ct(i,[d,d],[n-d,1]),y=Vu(g),b=Ct(i,[d,d],[1,1]),v=bi(Hu(b,0),oa([[-1]]),oa([[1]])),w=gt(b,A0(v,y)),_=Ht(g,w);_.shape[0]===1?l=hs(o):l=Rn([o,Ct(_,[1,0],[_.shape[0]-1,_.shape[1]])],0);const T=Lr(Ht(ax(v,w),y)),A=Ct(i,[d,0],[n-d,r]),E=A0(T,l),M=ym(l);if(d===0)i=gt(A,ax(E,ax(M,A)));else{const k=gt(A,ax(E,ax(M,A)));i=Rn([Ct(i,[0,0],[d,r]),k],0)}const I=ym(E),C=Ct(a,[0,d],[n,a.shape[1]-d]);if(d===0)a=gt(C,ax(ax(C,l),I));else{const k=gt(C,ax(ax(C,l),I));a=Rn([Ct(a,[0,0],[n,d]),k],1)}return[l,i,a]}),Yn([h,p,m])}return!x&&n>r&&(a=Ct(a,[0,0],[n,r]),i=Ct(i,[0,0],[r,r])),[a,i]})}const N8=ce({qr_:k8});var Kn;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Kn||(Kn={}));function R8(s,x,n=Kn.SUM_BY_NONZERO_WEIGHTS){const r=q(s,"losses","computeWeightedLoss");let a=null;x!=null&&(a=q(x,"weights","computeWeightedLoss"));const i=a==null?r:A0(r,a);if(n===Kn.NONE)return i;if(n===Kn.SUM)return fx(i);if(n===Kn.MEAN){if(a==null)return Ku(i);{const o=r.size/a.size,l=Ht(fx(i),fx(a));return o>1?Ht(l,Pt(o)):l}}if(n===Kn.SUM_BY_NONZERO_WEIGHTS){if(a==null)return Ht(fx(i),Pt(r.size));{const o=A0(a,ra(r.shape)),l=zx(fx(tv(o,Pt(0))),"float32");return Ht(fx(i),l)}}throw Error("Unknown reduction: "+n)}const Or=ce({computeWeightedLoss_:R8});function P8(s,x,n,r=Kn.SUM_BY_NONZERO_WEIGHTS){const a=q(s,"labels","absoluteDifference"),i=q(x,"predictions","absoluteDifference");let o=null;n!=null&&(o=q(n,"weights","absoluteDifference")),F0(a.shape,i.shape,"Error in absoluteDifference: ");const l=d2(gt(a,i));return Or(l,o,r)}const L8=ce({absoluteDifference_:P8});function D8(s,x,n,r,a=Kn.SUM_BY_NONZERO_WEIGHTS){const i=q(s,"labels","cosineDistance"),o=q(x,"predictions","cosineDistance");let l=null;r!=null&&(l=q(r,"weights","cosineDistance")),F0(i.shape,o.shape,"Error in cosineDistance: ");const c=Pt(1),d=gt(c,fx(A0(i,o),n,!0));return Or(d,l,a)}const O8=ce({cosineDistance_:D8});function F8(s,x,n,r=Kn.SUM_BY_NONZERO_WEIGHTS){let a=q(s,"labels","hingeLoss");const i=q(x,"predictions","hingeLoss");let o=null;n!=null&&(o=q(n,"weights","hingeLoss")),F0(a.shape,i.shape,"Error in hingeLoss: ");const l=Pt(1);a=gt(A0(Pt(2),a),l);const c=Zu(gt(l,A0(a,i)));return Or(c,o,r)}const U8=ce({hingeLoss_:F8});function B8(s,x,n,r=1,a=Kn.SUM_BY_NONZERO_WEIGHTS){const i=q(s,"labels","huberLoss"),o=q(x,"predictions","huberLoss");let l=null;n!=null&&(l=q(n,"weights","huberLoss")),F0(i.shape,o.shape,"Error in huberLoss: ");const c=Pt(r),d=d2(gt(o,i)),h=ev(d,c),p=gt(d,h),m=j0(A0(Pt(.5),q2(h)),A0(c,p));return Or(m,l,a)}const z8=ce({huberLoss_:B8});function W8(s,x,n,r=1e-7,a=Kn.SUM_BY_NONZERO_WEIGHTS){const i=q(s,"labels","logLoss"),o=q(x,"predictions","logLoss");let l=null;n!=null&&(l=q(n,"weights","logLoss")),F0(i.shape,o.shape,"Error in logLoss: ");const c=Pt(1),d=Pt(r),h=Lr(A0(i,Zo(j0(o,d)))),p=A0(gt(c,i),Zo(j0(gt(c,o),d))),m=gt(h,p);return Or(m,l,a)}const G8=ce({logLoss_:W8});function V8(s,x,n,r=Kn.SUM_BY_NONZERO_WEIGHTS){const a=q(s,"labels","meanSquaredError"),i=q(x,"predictions","meanSquaredError");let o=null;n!=null&&(o=q(n,"weights","meanSquaredError")),F0(a.shape,i.shape,"Error in meanSquaredError: ");const l=mv(a,i);return Or(l,o,r)}const H8=ce({meanSquaredError_:V8});function Y8(s,x){const n=q(s,"labels","sigmoidCrossEntropyWithLogits"),r=q(x,"logits","sigmoidCrossEntropyWithLogits");F0(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=Zu(r),i=A0(r,n),o=Xb(na(Lr(d2(r))));return j0(gt(a,i),o)}function q8(s,x,n,r=0,a=Kn.SUM_BY_NONZERO_WEIGHTS){let i=q(s,"multiClassLabels","sigmoidCrossEntropy");const o=q(x,"logits","sigmoidCrossEntropy");let l=null;if(n!=null&&(l=q(n,"weights","sigmoidCrossEntropy")),F0(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const d=Pt(r),h=Pt(1),p=Pt(.5);i=j0(A0(i,gt(h,d)),A0(p,d))}const c=Y8(i,o);return Or(c,l,a)}const X8=ce({sigmoidCrossEntropy_:q8});function K8(s,x,n=-1){if(n===-1&&(n=x.rank-1),n!==x.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+x.rank+" and dim was "+n);return Pr((r,a,i)=>{const o=$b(a,[n],!0),l=gt(zx(a,"float32"),o);i([r,l]);const c=Lr(A0(l,r));return{value:fx(c,[n]),gradFunc:(d,h)=>{const[p,m]=h,g=$x(d.shape,[n]);return[A0(Be(d,g),gt(zx(p,"float32"),na(m))),A0(Be(d,g),gt(na(m),zx(p,"float32")))]}}})(s,x)}function $8(s,x,n,r=0,a=Kn.SUM_BY_NONZERO_WEIGHTS){let i=q(s,"onehotLabels","softmaxCrossEntropy");const o=q(x,"logits","softmaxCrossEntropy");let l=null;if(n!=null&&(l=q(n,"weights","softmaxCrossEntropy")),F0(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const d=Pt(r),h=Pt(1),p=Pt(i.shape[1]);i=j0(A0(i,gt(h,d)),Ht(d,p))}const c=K8(i,o);return Or(c,l,a)}const Z8=ce({softmaxCrossEntropy_:$8});function J8(s,x,n,r){const a=q(s,"indices","sparseFillEmptyRows","int32"),i=q(x,"values","sparseFillEmptyRows"),o=q(n,"denseShape","sparseFillEmptyRows","int32"),l=q(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        `+a.shape);if(i.rank!==1)throw new Error("Values should be Tensor1D but received shape "+i.shape);if(o.rank!==1)throw new Error("Dense shape should be Tensor1D but received shape "+o.shape);if(l.rank!==0)throw new Error("Default value should be a scalar but received shape "+l.shape);const c={indices:a,values:i,denseShape:o,defaultValue:l},d=he.runKernel(Sf,c);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}const Q8=ce({sparseFillEmptyRows_:J8});function j8(s,x,n){const r=q(s,"inputIndices","sparseReshape","int32"),a=q(x,"inputShape","sparseReshape","int32"),i=q(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        `+r.shape);if(a.rank!==1)throw new Error("Input shape should be Tensor1D but received shape "+a.shape);if(i.rank!==1)throw new Error("New shape should be Tensor1D but received shape "+i.shape);const o={inputIndices:r,inputShape:a,newShape:i},l=he.runKernel(Tf,o);return{outputIndices:l[0],outputShape:l[1]}}const e9=ce({sparseReshape_:j8});function t9(s,x,n){const r=q(s,"data","sparseSegmentMean"),a=q(x,"indices","sparseSegmentMean","int32"),i=q(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          `+a.shape);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          `+i.shape);const o={data:r,indices:a,segmentIds:i};return he.runKernel(Af,o)}const x9=ce({sparseSegmentMean_:t9});function n9(s,x,n){const r=q(s,"data","sparseSegmentSum"),a=q(x,"indices","sparseSegmentSum","int32"),i=q(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         `+a.shape);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         `+i.shape);const o={data:r,indices:a,segmentIds:i};return he.runKernel(Ef,o)}const r9=ce({sparseSegmentSum_:n9});function s9(s,x,n,r,a,i,o,l){const c=q(s,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error("Data must be a vector, saw: "+c.shape);const d=q(x,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:r,leftPad:a,rightPad:i,padWidth:o,preserveShortSequences:l},p={data:c,dataSplits:d},m=he.runKernel(If,p,h);return{nGrams:m[0],nGramsSplits:m[1]}}const a9=ce({stringNGrams_:s9});function i9(s,x,n=!0){const r=q(s,"input","stringSplit","string"),a=q(x,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error("Input should be Tensor1D but received shape "+r.shape);if(a.rank!==0)throw new Error("Delimiter should be a scalar but received shape "+a.shape);const i={skipEmpty:n},o={input:r,delimiter:a},l=he.runKernel(kf,o,i);return{indices:l[0],values:l[1],shape:l[2]}}const o9=ce({stringSplit_:i9});function l9(s,x){const n=q(s,"input","stringToHashBucketFast","string"),r={numBuckets:x};if(x<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return he.runKernel(Nf,a,r)}const c9=ce({stringToHashBucketFast_:l9}),u9={fft:fm,ifft:Ju,rfft:mm,irfft:fv},d9={hammingWindow:z4,hannWindow:Sv,frame:Tv,stft:H4},dr={flipLeftRight:K4,grayscaleToRGB:Z4,resizeNearestNeighbor:v8,resizeBilinear:y8,rotateWithOffset:Q4,cropAndResize:q4,nonMaxSuppression:e8,nonMaxSuppressionAsync:o8,nonMaxSuppressionWithScore:c8,nonMaxSuppressionWithScoreAsync:d8,nonMaxSuppressionPadded:p8,nonMaxSuppressionPaddedAsync:m8,threshold:S8,transform:A8},h9={bandPart:C8,gramSchmidt:I8,qr:N8},p9={absoluteDifference:L8,computeWeightedLoss:Or,cosineDistance:O8,hingeLoss:U8,huberLoss:z8,logLoss:G8,meanSquaredError:H8,sigmoidCrossEntropy:X8,softmaxCrossEntropy:Z8},f9={sparseFillEmptyRows:Q8,sparseReshape:e9,sparseSegmentMean:x9,sparseSegmentSum:r9},m9={stringNGrams:a9,stringSplit:o9,stringToHashBucketFast:c9};class g9{getClassName(){return this.constructor.className}static fromConfig(x,n){return new x(n)}}class ca{constructor(){this.classNameMap={}}static getMap(){return ca.instance==null&&(ca.instance=new ca),ca.instance}static register(x){ca.getMap().classNameMap[x.className]=[x,x.fromConfig]}}function y9(s){G(s.className!=null,()=>"Class being registered does not have the static className property defined."),G(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),G(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ca.register(s)}class ua extends g9{minimize(x,n=!1,r){const{value:a,grads:i}=this.computeGradients(x,r);if(r!=null){const o=r.map(l=>({name:l.name,tensor:i[l.name]}));this.applyGradients(o)}else this.applyGradients(i);return Yn(i),n?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(x,n){return Sk(x,n)}dispose(){this.iterations_!=null&&Yn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(x){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(x){return this.iterations_=(await x[0].tensor.data())[0],x.slice(1)}}Object.defineProperty(ua,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});class b9 extends ua{constructor(x,n,r=null){super(),this.learningRate=x,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=he.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(x){(Array.isArray(x)?x.map(n=>n.name):Object.keys(x)).forEach((n,r)=>{const a=he.registeredVariables[n],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:n+"/accum_grad",variable:vt(()=>h2(a).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:n+"/accum_var",variable:vt(()=>h2(a).variable(i))});const o=Array.isArray(x)?x[r].tensor:x[n];if(o==null)return;const l=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;vt(()=>{const d=j0(A0(l,this.rho),A0(q2(o),1-this.rho)),h=A0(Ht(Nr(j0(c,this.epsilon)),Nr(j0(l,this.epsilon))),o),p=j0(A0(c,this.rho),A0(q2(h),1-this.rho));l.assign(d),c.assign(p);const m=j0(A0(h,-this.learningRate),a);a.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Yn(this.accumulatedGrads.map(x=>x.variable)),Yn(this.accumulatedUpdates.map(x=>x.variable)))}async getWeights(){const x=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(x.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(x){x=await this.extractIterations(x);const n=x.length/2,r=!1;this.accumulatedGrads=x.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedUpdates=x.slice(n,n*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(x,n){return new x(n.learningRate,n.rho,n.epsilon)}}class v9 extends ua{constructor(x,n=.1){super(),this.learningRate=x,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(x){(Array.isArray(x)?x.map(n=>n.name):Object.keys(x)).forEach((n,r)=>{const a=he.registeredVariables[n];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:n+"/accumulator",variable:vt(()=>qo(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(x)?x[r].tensor:x[n];if(i==null)return;const o=this.accumulatedGrads[r].variable;vt(()=>{const l=j0(o,q2(i));o.assign(l);const c=j0(A0(Ht(i,Nr(j0(l,he.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Yn(this.accumulatedGrads.map(x=>x.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(x=>({name:x.originalName,tensor:x.variable})))}async setWeights(x){x=await this.extractIterations(x);const n=!1;this.accumulatedGrads=x.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(x,n){return new x(n.learningRate,n.initialAccumulatorValue)}}class w9 extends ua{constructor(x,n,r,a=null){super(),this.learningRate=x,this.beta1=n,this.beta2=r,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],vt(()=>{this.accBeta1=Pt(n).variable(),this.accBeta2=Pt(r).variable()}),a==null&&(this.epsilon=he.backend.epsilon())}static get className(){return"Adam"}applyGradients(x){const n=Array.isArray(x)?x.map(r=>r.name):Object.keys(x);vt(()=>{const r=gt(1,this.accBeta1),a=gt(1,this.accBeta2);n.forEach((i,o)=>{const l=he.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:i+"/m",variable:vt(()=>h2(l).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:i+"/v",variable:vt(()=>h2(l).variable(c))});const d=Array.isArray(x)?x[o].tensor:x[i];if(d==null)return;const h=this.accumulatedFirstMoment[o].variable,p=this.accumulatedSecondMoment[o].variable,m=j0(A0(h,this.beta1),A0(d,1-this.beta1)),g=j0(A0(p,this.beta2),A0(q2(d),1-this.beta2)),y=Ht(m,r),b=Ht(g,a);h.assign(m),p.assign(g);const v=j0(A0(Ht(y,j0(Nr(b),this.epsilon)),-this.learningRate),l);l.assign(v)}),this.accBeta1.assign(A0(this.accBeta1,this.beta1)),this.accBeta2.assign(A0(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Yn(this.accumulatedFirstMoment.map(x=>x.variable)),this.accumulatedSecondMoment!=null&&Yn(this.accumulatedSecondMoment.map(x=>x.variable))}async getWeights(){const x=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(x.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(x){x=await this.extractIterations(x),vt(()=>{this.accBeta1.assign(Ko(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ko(this.beta2,this.iterations_+1))});const n=x.length/2,r=!1;this.accumulatedFirstMoment=x.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedSecondMoment=x.slice(n,n*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(x,n){return new x(n.learningRate,n.beta1,n.beta2,n.epsilon)}}class _9 extends ua{constructor(x,n,r,a=null,i=0){super(),this.learningRate=x,this.beta1=n,this.beta2=r,this.epsilon=a,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],vt(()=>{this.iteration=Pt(0).variable(),this.accBeta1=Pt(n).variable()}),a==null&&(this.epsilon=he.backend.epsilon())}static get className(){return"Adamax"}applyGradients(x){const n=Array.isArray(x)?x.map(r=>r.name):Object.keys(x);vt(()=>{const r=gt(1,this.accBeta1),a=Ht(-this.learningRate,j0(A0(this.iteration,this.decay),1));n.forEach((i,o)=>{const l=he.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:i+"/m",variable:h2(l).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:i+"/v",variable:h2(l).variable(c)});const d=Array.isArray(x)?x[o].tensor:x[i];if(d==null)return;const h=this.accumulatedFirstMoment[o].variable,p=this.accumulatedWeightedInfNorm[o].variable,m=j0(A0(h,this.beta1),A0(d,1-this.beta1)),g=A0(p,this.beta2),y=d2(d),b=jb(g,y);h.assign(m),p.assign(b);const v=j0(A0(Ht(a,r),Ht(m,j0(b,this.epsilon))),l);l.assign(v)}),this.iteration.assign(j0(this.iteration,1)),this.accBeta1.assign(A0(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Yn(this.accumulatedFirstMoment.map(x=>x.variable)),this.accumulatedWeightedInfNorm!=null&&Yn(this.accumulatedWeightedInfNorm.map(x=>x.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(x){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(x,n){return new x(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}class Cv extends ua{constructor(x){super(),this.learningRate=x,this.setLearningRate(x)}static get className(){return"SGD"}applyGradients(x){(Array.isArray(x)?x.map(n=>n.name):Object.keys(x)).forEach((n,r)=>{const a=Array.isArray(x)?x[r].tensor:x[n];if(a==null)return;const i=he.registeredVariables[n];vt(()=>{const o=j0(A0(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(x){this.learningRate=x,this.c!=null&&this.c.dispose(),this.c=ur(Pt(-x))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(x){if(x=await this.extractIterations(x),x.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(x,n){return new x(n.learningRate)}}class S9 extends Cv{constructor(x,n,r=!1){super(x),this.learningRate=x,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Pt(this.momentum)}static get className(){return"Momentum"}applyGradients(x){(Array.isArray(x)?x.map(n=>n.name):Object.keys(x)).forEach((n,r)=>{const a=he.registeredVariables[n];this.accumulations[r]==null&&(this.accumulations[r]={originalName:n+"/momentum",variable:vt(()=>h2(a).variable(!1))});const i=this.accumulations[r].variable,o=Array.isArray(x)?x[r].tensor:x[n];o!=null&&vt(()=>{let l;const c=j0(A0(this.m,i),o);this.useNesterov?l=j0(A0(this.c,j0(o,A0(c,this.m))),a):l=j0(A0(this.c,c),a),i.assign(c),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Yn(this.accumulations.map(x=>x.variable))}setMomentum(x){this.momentum=x}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(x=>({name:x.originalName,tensor:x.variable})))}async setWeights(x){x=await this.extractIterations(x);const n=!1;this.accumulations=x.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(x,n){return new x(n.learningRate,n.momentum,n.useNesterov)}}class T9 extends ua{constructor(x,n=.9,r=0,a=null,i=!1){if(super(),this.learningRate=x,this.decay=n,this.momentum=r,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,a==null&&(this.epsilon=he.backend.epsilon()),x==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(x){(Array.isArray(x)?x.map(n=>n.name):Object.keys(x)).forEach((n,r)=>{const a=he.registeredVariables[n],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:n+"/rms",variable:vt(()=>h2(a).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:n+"/momentum",variable:vt(()=>h2(a).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:n+"/mg",variable:vt(()=>h2(a).variable(i))});const o=Array.isArray(x)?x[r].tensor:x[n];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;vt(()=>{const d=j0(A0(l,this.decay),A0(q2(o),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,p=j0(A0(h,this.decay),A0(o,1-this.decay)),m=Ht(A0(o,this.learningRate),Nr(gt(d,j0(q2(p),this.epsilon)))),g=j0(A0(c,this.momentum),m);l.assign(d),h.assign(p),c.assign(g);const y=gt(a,g);a.assign(y)}else{const h=j0(A0(l,this.decay),A0(q2(o),1-this.decay)),p=j0(A0(c,this.momentum),Ht(A0(o,this.learningRate),Nr(j0(h,this.epsilon))));l.assign(h),c.assign(p);const m=gt(a,p);a.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Yn(this.accumulatedMeanSquares.map(x=>x.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Yn(this.accumulatedMeanGrads.map(x=>x.variable)),this.accumulatedMoments!=null&&Yn(this.accumulatedMoments.map(x=>x.variable))}async getWeights(){const x=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&x.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(x.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(x){x=await this.extractIterations(x);const n=this.centered?x.length/3:x.length/2,r=!1;this.accumulatedMeanSquares=x.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedMoments=x.slice(n,n*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=x.slice(n*2,n*3).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(x,n){return new x(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}const A9=[b9,v9,w9,_9,S9,T9,Cv];function E9(){for(const s of A9)y9(s)}const C9="model",M9=".json",I9=".weights.bin";function Mv(s){return new Promise(x=>setTimeout(x)).then(s)}class da{constructor(x){if(!Ce().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");x.startsWith(da.URL_SCHEME)&&(x=x.slice(da.URL_SCHEME.length)),(x==null||x.length===0)&&(x=C9),this.modelJsonFileName=x+M9,this.weightDataFileName=x+I9}async save(x){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([x.weightData],{type:"application/octet-stream"}));if(x.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:x.weightSpecs}],a=yb(x,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await Mv(()=>o.dispatchEvent(new MouseEvent("click"))),x.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=n,await Mv(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:zo(x)}}}}da.URL_SCHEME="downloads://";class k9{constructor(x){if(x==null||x.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+x);this.jsonFile=x[0],this.weightsFiles=x.slice(1)}async load(){return new Promise((x,n)=>{const r=new FileReader;r.onload=a=>{const i=JSON.parse(a.target.result),o=i.modelTopology;if(o==null){n(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(i.weightsManifest==null){n(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){x({modelTopology:o});return}const l=tm(i,c=>this.loadWeights(c));x(l)},r.onerror=a=>n("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),r.readAsText(this.jsonFile)})}loadWeights(x){const n=[],r=[];for(const o of x)n.push(...o.weights),r.push(...o.paths);const a=this.checkManifestAndWeightFiles(x),i=r.map(o=>this.loadWeightsFile(o,a[o]));return Promise.all(i).then(o=>[n,em(o)])}loadWeightsFile(x,n){return new Promise((r,a)=>{const i=new FileReader;i.onload=o=>{const l=o.target.result;r(l)},i.onerror=o=>a("Failed to weights data from file of path '"+x+"'."),i.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(x){const n=[],r=this.weightsFiles.map(i=>gb(i.name)),a={};for(const i of x)i.paths.forEach(o=>{const l=gb(o);if(n.indexOf(l)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+l+"'");if(n.push(l),r.indexOf(l)===-1)throw new Error("Weight file with basename '"+l+"' is not provided.");a[o]=this.weightsFiles[r.indexOf(l)]});if(n.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return a}}const N9=s=>Ce().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(da.URL_SCHEME)?R9(s.slice(da.URL_SCHEME.length)):null;_x.registerSaveRouter(N9);function R9(s="model"){return new da(s)}function P9(s){return new k9(s)}function Iv(s,x,n,r){o(s),n=n??0,r=r??1,l(n,r);let a=0;const i=c=>(c.then(d=>{const h=n+ ++a/s.length*(r-n);return x(h),d}),c);function o(c){G(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function l(c,d){G(c>=0&&c<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+c),G(d>=0&&d<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+d),G(d>=c,()=>"startFraction must be no more than endFraction, but got startFraction "+c+" and endFraction "+d)}return Promise.all(s.map(i))}async function kv(s,x){x==null&&(x={});const n=x.fetchFunc==null?Ce().platform.fetch:x.fetchFunc,r=s.map(d=>n(d,x.requestInit,{isBinary:!0})),a=0,i=.5,o=(x.onProgress==null?await Promise.all(r):await Iv(r,x.onProgress,a,i)).map(d=>d.arrayBuffer()),l=.5,c=1;return x.onProgress==null?await Promise.all(o):await Iv(o,x.onProgress,l,c)}async function L9(s,x="",n,r){return Nv(a=>kv(a,{requestInit:r}))(s,x,n)}function Nv(s){return async(x,n="",r)=>{const a=x.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],l=[];if(x.forEach((g,y)=>{let b=0;g.weights.forEach(v=>{const w="quantization"in v?v.quantization.dtype:v.dtype,_=Qf[w]*be(v.shape),T=()=>{a[y]=!0,i[y]==null&&(i[y]=[]),i[y].push({manifestEntry:v,groupOffset:b,sizeBytes:_})};r!=null?r.forEach((A,E)=>{A===v.name&&(T(),o[E]=!0)}):T(),l.push(v.name),b+=_})}),!o.every(g=>g)){const g=r.filter((y,b)=>!o[b]);throw new Error("Could not find weights in manifest with names: "+g.join(", ")+`. 
Manifest JSON has weights with names: `+l.join(", ")+".")}const c=a.reduce((g,y,b)=>(y&&g.push(b),g),[]),d=[];c.forEach(g=>{x[g].paths.forEach(y=>{const b=n+(n.endsWith("/")?"":"/")+y;d.push(b)})});const h=await s(d),p={};let m=0;return c.forEach(g=>{const y=x[g].paths.length;let b=0;for(let T=0;T<y;T++)b+=h[m+T].byteLength;const v=new ArrayBuffer(b),w=new Uint8Array(v);let _=0;for(let T=0;T<y;T++){const A=new Uint8Array(h[m+T]);w.set(A,_),_+=A.byteLength}i[g].forEach(T=>{const A=v.slice(T.groupOffset,T.groupOffset+T.sizeBytes),E=fb(A,[T.manifestEntry]);for(const M in E)p[M]=E[M]}),m+=y}),p}}const D9="application/octet-stream",O9="application/json";class Tm{constructor(x,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(G(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=Ce().platform.fetch,G(x!=null&&x.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(x)&&G(x.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+x.length+")."),this.path=x,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(x){if(x.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:x.weightSpecs}],a=yb(x,r);n.body.append("model.json",new Blob([JSON.stringify(a)],{type:O9}),"model.json"),x.weightData!=null&&n.body.append("model.weights.bin",new Blob([x.weightData],{type:D9}),"model.weights.bin");const i=await this.fetch(this.path,n);if(i.ok)return{modelArtifactsInfo:zo(x),responses:[i]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+i.status+".")}async load(){const x=await this.fetch(this.path,this.requestInit);if(!x.ok)throw new Error("Request to "+this.path+" failed with status code "+x.status+". Please verify this URL points to the model JSON of the model to load.");let n;try{n=await x.json()}catch{let o="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,a=n.weightsManifest;if(r==null&&a==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return tm(n,i=>this.loadWeights(i))}async loadWeights(x){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,a]=F9(n),i=this.weightPathPrefix||r,o=vb(x),l=[],c=[];for(const h of x)for(const p of h.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(p)):l.push(i+p+a);this.weightUrlConverter&&l.push(...await Promise.all(c));const d=await kv(l,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,em(d)]}}Tm.URL_SCHEME_REGEX=/^https?:\/\//;function F9(s){const x=s.lastIndexOf("/"),n=s.lastIndexOf("?"),r=s.substring(0,x),a=n>x?s.substring(n):"";return[r+"/",a]}function Am(s){return s.match(Tm.URL_SCHEME_REGEX)!=null}const Rv=(s,x)=>{if(typeof fetch>"u"&&(x==null||x.fetchFunc==null))return null;{let n=!0;if(Array.isArray(s)?n=s.every(r=>Am(r)):n=Am(s),n)return Em(s,x)}return null};_x.registerSaveRouter(Rv),_x.registerLoadRouter(Rv);function Em(s,x){return new Tm(s,x)}function U9(s,x){return Em(s,x)}class Cm{constructor(x){this.modelArtifacts=x}load(){return this.modelArtifacts}}class Pv{constructor(x){this.saveHandler=x}save(x){return this.saveHandler(x)}}class B9{constructor(x){x.load&&(this.load=()=>Promise.resolve(x.load())),x.save&&(this.save=n=>Promise.resolve(x.save(n)))}}function z9(s,x,n,r){const a=arguments;return new B9(Lv(...a))}function Lv(s,x,n,r){return arguments.length===1?s.modelTopology!=null||s.weightSpecs!=null?new Cm(s):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Cm({modelTopology:s})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Cm({modelTopology:s,weightSpecs:x,weightData:n,trainingConfig:r}))}function W9(s){return new Pv(s)}function G9(s){return new Pv(s)}var Dv=Object.freeze({__proto__:null,browserFiles:P9,browserHTTPRequest:U9,concatenateArrayBuffers:em,decodeWeights:fb,encodeWeights:cM,fromMemory:z9,fromMemorySync:Lv,getLoadHandlers:wM,getModelArtifactsForJSON:tm,getModelArtifactsForJSONSync:bb,getModelArtifactsInfoForJSON:zo,getSaveHandlers:vM,getWeightSpecs:vb,http:Em,isHTTPScheme:Am,loadWeights:L9,registerLoadRouter:bM,registerSaveRouter:yM,weightsLoaderFactory:Nv,withSaveHandler:W9,withSaveHandlerSync:G9,copyModel:DM,listModels:PM,moveModel:OM,removeModel:LM});let ha;function V9(s,x=3){if(x>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,i=!1,o=!1,l=!1;if(s.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&s instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)i=!0;else if(s.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&s instanceof ImageBitmap)l=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+s.constructor.name);if(zf(Uf,he.backendName)!=null){const m={pixels:s},g={numChannels:x};return he.runKernel(Uf,m,g)}const[c,d]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height];let h;if(o)h=s.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)h=s.data;else if(i||a||l){if(ha==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ha=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ha=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ha.canvas.width=c,ha.canvas.height=d,ha.drawImage(s,0,0,c,d),h=ha.getImageData(0,0,c,d).data}let p;if(x===4)p=new Int32Array(h);else{const m=c*d;p=new Int32Array(m*x);for(let g=0;g<m;g++)for(let y=0;y<x;++y)p[g*x+y]=h[g*4+y]}return yv(p,[d,c,x],"int32")}const Ov=ce({fromPixels_:V9});function Mm(s,x){const n=s.shape.length,r=x.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+n+".");if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+r+".");if(x.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+x.dtype+".");if(x.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+x.shape[r-1]+" vs. "+n);if(be(s.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+s.shape+".");const a=x.shape,i=a[a.length-1];let o=1;for(let p=0;p<a.length-1;++p)o*=a[p];const l=s.shape,c=a.slice();c.pop();let d=1;for(let p=i;p<n;++p)d*=l[p],c.push(l[p]);const h=[...U0(s.shape).map(p=>p/d),1].slice(0,i);return[c,o,d,h]}const Im=-2,H9=-1;function km(s,x,n){const r=s.shape.length;G(r===x.length,()=>"Error in slice"+r+"D: Length of begin "+x+" must match the rank of the array ("+r+")."),G(r===n.length,()=>"Error in slice"+r+"D: Length of size "+n+" must match the rank of the array ("+r+").");for(let a=0;a<r;++a)G(x[a]+n[a]<=s.shape[a],()=>"Error in slice"+r+"D: begin["+a+"] + size["+a+"] ("+(x[a]+n[a])+") would overflow input.shape["+a+"] ("+s.shape[a]+")")}function Y9(s){const x=[];let n=0;for(;s>0;)s&1&&x.push(n),s/=2,n++;return x}function Nm(s,x,n){const r=[];for(let a=0;a<s.length;a++)r[a]=Math.ceil((x[a]-s[a])/n[a]);return r}function Fv(s,x,n,r){const a=[...s];for(let i=a.length;i<r.length;i++)a.push(1);for(let i=0;i<n;i++)i===0?a[x]=1:(a.splice(x,0,1),a.pop());return a}function Uv(s,x,n){return n<=s?n:n-(x-1)}function Bv(s,x){const n=[];for(let r=0;r<s;r++)n.push(x+r);return n}function q9(s,x,n,r,a,i,o,l,c){const d=s.length;let h=new Array(d),p=new Array(d),m=new Array(d);if(x.length&&n>0){const g=x[0],y=n+1;h=zv(o,g,y,r,s),p=Wv(l,g,y,a,s),m=Fv(i,g,y,s)}else for(let g=0;g<d;g++)h[g]=Vv(o,r,i,s,g,c),p[g]=Hv(l,a,i,s,g,c),m[g]=Gv(i,g,c);return{begin:h,end:p,strides:m}}function zv(s,x,n,r,a){const i=[...a],o=Bv(n,x);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=0;else{const c=Uv(x,n,l);let d=r[c];s&1<<c&&(d=0),i[l]=d}return i}function Wv(s,x,n,r,a){const i=[...a],o=Bv(n,x);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const c=Uv(x,n,l);let d=r[c];s&1<<c&&(d=Number.MAX_SAFE_INTEGER),i[l]=d}for(let l=0;l<i.length;l++){const c=a[l];i[l]<0&&(i[l]+=c),i[l]=w0(0,i[l],a[l])}return i}function Gv(s,x,n){let r=s[x];return(n&1<<x||r==null)&&(r=1),r}function Vv(s,x,n,r,a,i){let o=x[a];const l=n[a]||1;(s&1<<a||i&1<<a||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=r[a];return o<0&&(o+=c),o=w0(0,o,c-1),o}function Hv(s,x,n,r,a,i){let o=x[a];const l=n[a]||1;(s&1<<a||i&1<<a||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=r[a];return o<0&&(o+=c),l>0?o=w0(0,o,c):o=w0(-1,o,c-1),o}function Rm(s,x,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(x[a]>0||n[a]!==s[a])return!1;return!0}function Pm(s,x){let n=s.length>0?s[s.length-1]:1;for(let r=0;r<s.length-1;r++)n+=s[r]*x[r];return n}function Lm(s,x,n){let r;const a=s.shape.length;typeof x=="number"?r=[x,...new Array(a-1).fill(0)]:x.length<a?r=x.concat(new Array(a-x.length).fill(0)):r=x.slice(),r.forEach(o=>{G(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(a).fill(-1):typeof n=="number"?i=[n,...new Array(a-1).fill(-1)]:n.length<a?i=n.concat(new Array(a-n.length).fill(-1)):i=n,i=i.map((o,l)=>o>=0?o:(G(o===-1,()=>"Negative size values should be exactly -1 but got "+o+" for the slice() size at index "+l+"."),s.shape[l]-r[l])),[r,i]}function Dm(s,x,n,r,a,i,o,l,c){let d;if(r==null?(d=new Array(x.length),d.fill(1)):d=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const p={dims:d.length,numAddAxisAfterEllipsis:0,begin:x.slice(),end:n.slice(),strides:d.slice(),beginMask:a,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};for(let _=0;_<p.dims;_++)h&&(1<<_&l)!==0&&p.numAddAxisAfterEllipsis++,1<<_&o&&(h=!0);h||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};X9(p,m);let g=!0,y=!0,b=!0;const v=[],w=[];for(let _=0;_<s.length;++_){if(m.strides[_]===0)throw Error("strides["+_+"] must be non-zero");const T=!!(m.shrinkAxisMask&1<<_),A=s[_];if(A===-1){v.push(T?1:-1);continue}const E=[m.beginMask&1<<_,m.endMask&1<<_],M=[m.strides[_]>0?0:-1,m.strides[_]>0?A:A-1];if(T&&m.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&m.strides[_]===1;const I=!!(m.beginMask&1<<_&&m.endMask&1<<_);if(m.beginValid&&m.endValid){if(T){const z=m.begin[_]<0?A+m.begin[_]:m.begin[_];if(m.begin[_]=z,m.end[_]=m.begin[_]+1,z<0||z>=A)throw Error("slice index "+m.begin[_]+" of dimension "+_+" out of bounds.")}else m.begin[_]=Yv(m.begin[_],0,m.strides[_],A,E,M),m.end[_]=Yv(m.end[_],1,m.strides[_],A,E,M);const O=m.strides[_]===1&&m.begin[_]===0&&m.end[_]===A;g=g&&O,y=y&&(_===0&&m.strides[_]===1||O)}else g=g&&m.strides[_]===1&&I,y=y&&(_===0&&m.strides[_]===1||I);let C,k=!1;if(m.beginValid&&m.endValid?(C=m.end[_]-m.begin[_],k=!0):T?(C=1,k=!0):I&&A>=0&&(m.strides[_]<0?C=-A:C=A,k=!0),k){let O;C===0||C<0!=m.strides[_]<0?O=0:O=Math.trunc(C/m.strides[_])+(C%m.strides[_]!==0?1:0),v.push(O)}else v.push(-1)}for(let _=0;_<m.finalShapeGatherIndices.length;++_){const T=m.finalShapeGatherIndices[_];T>=0?w.push(v[T]):T===Im&&w.push(1)}return{finalShapeSparse:w.filter((_,T)=>m.finalShapeGatherIndices[T]!==Im),finalShape:w,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:m.begin,end:m.end,strides:m.strides}}function X9(s,x){x.beginMask=0,x.endMask=0,x.shrinkAxisMask=0;let n=0;x.beginValid=s.begin!=null,x.endValid=s.end!=null,x.begin=new Array(x.dims),x.end=new Array(x.dims),x.strides=new Array(x.dims),x.finalShapeGatherIndices=[],x.finalShapeGatherIndicesSparse=[],x.inputShapeGatherIndicesSparse=new Array(x.dims);for(let r=0;r<s.dims;r++)if(1<<r&s.ellipsisMask){const a=Math.min(x.dims-(s.dims-r)+1+s.numAddAxisAfterEllipsis,x.dims);for(;n<a;n++)x.begin[n]=0,x.end[n]=0,x.strides[n]=1,x.beginMask|=1<<n,x.endMask|=1<<n,x.finalShapeGatherIndices.push(n),x.finalShapeGatherIndicesSparse.push(-1),x.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&s.newAxisMask)x.finalShapeGatherIndices.push(Im),x.finalShapeGatherIndicesSparse.push(-1);else{if(n===x.begin.length)throw Error("Index out of range using input dim "+n+"; input has only "+x.dims+" dims, "+x.begin.length+".");s.begin!=null&&(x.begin[n]=s.begin[r]),s.end!=null&&(x.end[n]=s.end[r]),x.strides[n]=s.strides[r],s.beginMask&1<<r&&(x.beginMask|=1<<n),s.endMask&1<<r&&(x.endMask|=1<<n),s.shrinkAxisMask&1<<r?(x.finalShapeGatherIndices.push(H9),x.finalShapeGatherIndicesSparse.push(-1),x.shrinkAxisMask|=1<<n):(x.finalShapeGatherIndices.push(n),x.finalShapeGatherIndicesSparse.push(r)),x.inputShapeGatherIndicesSparse[n]=r,n++}}function Yv(s,x,n,r,a,i){if(a[x])return n>0?i[x]:i[x+1&1];{const o=s<0?r+s:s;return o<i[0]?i[0]:o>i[1]?i[1]:o}}var K9=Object.freeze({__proto__:null,assertParamsValid:km,maskToAxes:Y9,computeOutShape:Nm,stridesWithElidedDims:Fv,getNormalizedAxes:q9,startIndicesWithElidedDims:zv,stopIndicesWithElidedDims:Wv,stridesForAxis:Gv,startForAxis:Vv,stopForAxis:Hv,isSliceContinous:Rm,computeFlatOffset:Pm,parseSliceParams:Lm,sliceInfo:Dm});const $9=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:s=>s())();function Z9(){return new Promise(s=>$9(()=>s()))}function Om(s,x){const n=s[0].length;s.forEach((a,i)=>{G(a.length===n,()=>"Error in concat"+n+"D: rank of tensors["+i+"] must be the same as the rank of the rest ("+n+")")}),G(x>=0&&x<n,()=>"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+".");const r=s[0];s.forEach((a,i)=>{for(let o=0;o<n;o++)G(o===x||a[o]===r[o],()=>"Error in concat"+n+"D: Shape of tensors["+i+"] ("+a+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+i+".")})}function hr(s,x){const n=s[0].slice();for(let r=1;r<s.length;r++)n[x]+=s[r][x];return n}var K2;(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(K2||(K2={}));function qv(s,x,n){let r=new Array;if(n==null&&x==null)return r;if(x==null)for(;r.length<s+n.length;)r.push(-1);else r=x.slice();if(n==null)return r;if(s+n.length!==r.length)throw new Error("rt input.shape and shape="+x+" are incompatible: rt input.rank = "+(s+n.length)+", but shape.rank = "+r.length);for(let a=1;a<n.length;++a){const i=n[a],o=r[r.length-n.length+a],l=r[o];if(i>=0)if(l>=0){if(l!==i)throw new Error("rt input.shape and shape="+x+" are incompatible: rt input.shape["+(a+s)+"] = "+i+" but shape["+(a+s)+"] = "+l)}else r[o]=i}return r}function Xv(s){const x={FIRST_DIM_SIZE:K2.FIRST_DIM_SIZE,VALUE_ROWIDS:K2.VALUE_ROWIDS,ROW_LENGTHS:K2.ROW_LENGTHS,ROW_SPLITS:K2.ROW_SPLITS,ROW_LIMITS:K2.ROW_LIMITS,ROW_STARTS:K2.ROW_STARTS},n=[];for(const r of s)if(r in x)n.push(x[r]);else break;return n}function Kv(s){return s.length===0?0:s[0]===K2.FIRST_DIM_SIZE?s.length-1:s.length}function $v(s,x){if(s==null||x==null)return;const n=s.length,r=x.length;if(n>=r)throw new Error("defaultValue.shape="+s+" and ragged tensor flatValues.shape="+x+", are incompatible: defaultValue.rank = "+n+" must be less than ragged tensor input flatValues.rank = "+r+")");for(let a=0;a<Math.min(n,r-1);++a){const i=s[a],o=x[a+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error("defaultValue.shape="+s+", and ragged tensor input flatValues.shape="+x+" are incompatible: defaultValue.shape["+(a-s.length)+"] = "+i+" but ragged tensor input.flatValues.shape["+(a-s.length)+"] = "+o)}}const Fm=30;function xd(s){return s<=Fm?s:Bx(s,Math.floor(Math.sqrt(s)))}function Um(s,x,n){const r=n*(typeof s=="number"?s:s[0]),a=x*(typeof s=="number"?s:s[1]);return[r,a]}function tl(s,x,n,r=!0){let a=[];if(r)a=a.concat(x.slice(0)),a.push(s[0]/n),a=a.concat(s.slice(1));else{a=a.concat(s[0]);const i=x.length;for(let o=0;o<i;++o)a=a.concat([s[o+1]/x[o],x[o]]);a=a.concat(s.slice(i+1))}return a}function xl(s,x,n=!0){const r=[];if(n){r.push(x);for(let a=x+1;a<s;++a)a<=2*x?(r.push(a),r.push(a-(x+1))):r.push(a)}else{const a=[],i=[];for(let o=1;o<s;++o)o>=x*2+1||o%2===1?i.push(o):a.push(o);r.push(...a),r.push(0),r.push(...i)}return r}function nl(s,x,n,r=!0){const a=[];r?a.push(s[0]/n):a.push(s[0]*n);for(let i=1;i<s.length;++i)i<=x.length?r?a.push(x[i-1]*s[i]):a.push(s[i]/x[i-1]):a.push(s[i]);return a}function Bm(s,x){const n=[0];for(let r=0;r<x;++r)n.push(s[r][0]);return n}function zm(s,x,n){const r=s.slice(0,1);for(let a=0;a<n;++a)r.push(s[a+1]-x[a][0]-x[a][1]);return r}const Wm=1.7580993408473768,Gm=1.0507009873554805,Vm=.3275911,Hm=.254829592,Ym=-.284496736,qm=1.421413741,Xm=-1.453152027,Km=1.061405429;function Fr(s,x){if(s.length!==x.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+s.length+", imag: "+x.length+".");const n=new Float32Array(s.length*2);for(let r=0;r<n.length;r+=2)n[r]=s[r/2],n[r+1]=x[r/2];return n}function Zv(s){const x=new Float32Array(s.length/2),n=new Float32Array(s.length/2);for(let r=0;r<s.length;r+=2)x[r/2]=s[r],n[r/2]=s[r+1];return{real:x,imag:n}}function Jv(s){const x=Math.ceil(s.length/4),n=new Float32Array(x),r=new Float32Array(x);for(let a=0;a<s.length;a+=4)n[Math.floor(a/4)]=s[a],r[Math.floor(a/4)]=s[a+1];return{real:n,imag:r}}function Qv(s){const x=Math.floor(s.length/4),n=new Float32Array(x),r=new Float32Array(x);for(let a=2;a<s.length;a+=4)n[Math.floor(a/4)]=s[a],r[Math.floor(a/4)]=s[a+1];return{real:n,imag:r}}function $m(s,x){const n=s[x*2],r=s[x*2+1];return{real:n,imag:r}}function jv(s,x,n,r){s[r*2]=x,s[r*2+1]=n}function ew(s,x){const n=new Float32Array(s/2),r=new Float32Array(s/2);for(let a=0;a<Math.ceil(s/2);a++){const i=(x?2:-2)*Math.PI*(a/s);n[a]=Math.cos(i),r[a]=Math.sin(i)}return{real:n,imag:r}}function tw(s,x,n){const r=(n?2:-2)*Math.PI*(s/x),a=Math.cos(r),i=Math.sin(r);return{real:a,imag:i}}const Zm="->",J9=/->/g,xw=",",nw="...";function Jm(s,x){s=s.replace(/\s/g,"");const n=(s.length-s.replace(J9,"").length)/Zm.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'+Zm+'").');const[r,a]=s.split(Zm);G(r.indexOf(nw)===-1,()=>'The ellipsis notation ("'+nw+'") is not supported yet.');const i=r.split(xw),o=i.length;if(x!==o)throw new Error("Expected "+o+" input tensors, received "+x);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<a.length;++m){const g=a[m];if(!i.some(y=>y.indexOf(g)!==-1))throw new Error("Output subscripts contain the label "+g+" not present in the input subscripts.");l.indexOf(g)===-1&&l.push(g)}for(let m=0;m<r.length;++m){const g=r[m];l.indexOf(g)===-1&&g!==xw&&l.push(g)}const c=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error("Found duplicate axes in input component "+i[m]+". Support for duplicate axes in input is not implemented yet.");c[m]=[];for(let g=0;g<i[m].length;++g)c[m].push(l.indexOf(i[m][g]))}const d=l.length,h=a.length,p=[];for(let m=h;m<d;++m)p.push(m);return{allDims:l,summedDims:p,idDims:c}}function Qm(s,x){let n=new Array(s);n.fill(-1);for(let a=0;a<x.length;++a)n[x[a]]=a;const r=[];for(let a=0;a<s;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function jm(s,x,n){const r=new Array(s);for(let a=0;a<n.length;++a){const i=n[a].shape;for(let o=0;o<x[a].length;++o)r[x[a][o]]===void 0?r[x[a][o]]=i[o]:G(r[x[a][o]]===i[o],()=>"Expected dimension "+r[x[a][o]]+" at axis "+o+" of input shaped "+JSON.stringify(i)+", but got dimension "+i[o])}}function eg(s,x){const n=s,r=[];let a=0;s.length===0&&n.push(-1),a=s.length+1;for(let o=0;o<a;++o)r.push([]);const i=[];for(let o=0;o<n.length;++o){const l=n[o],c=Q9(x,l);for(const d of c)i.indexOf(d)===-1&&(r[o].push(d),i.push(d))}return{path:n,steps:r}}function tg(s){return s.every((x,n)=>x===n)}function Q9(s,x){const n=[];for(let r=0;r<s.length;++r)(s[r].length===0||s[r].indexOf(x)!==-1||x===-1)&&n.push(r);return n}function xg(s,x,n=0){let r=[];if(typeof x=="number")G(s.shape[n]%x===0,()=>"Number of splits must evenly divide the axis."),r=new Array(x).fill(s.shape[n]/x);else{const a=x.reduce((o,l)=>(l===-1&&(o+=1),o),0);G(a<=1,()=>"There should be only one negative value in split array.");const i=x.indexOf(-1);if(i!==-1){const o=x.reduce((l,c)=>c>0?l+c:l);x[i]=s.shape[n]-o}G(s.shape[n]===x.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),r=x}return r}function rw(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+s}function sw(s,x){return"indices("+s+", 0) is invalid: "+x+" < 0"}function aw(s,x,n){return"indices("+s+", 0) is invalid: "+x+" >= "+n}function iw(s,x){return"only one output dimension may be -1, not both "+s+" and "+x}function ow(s,x){return"size "+s+" must be non-negative, not "+x}function lw(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function cw(s,x){const n=be(s),r=be(x);return"Input to reshape is a SparseTensor with "+n+`
  dense values, but the requested shape requires a multiple of `+r+". inputShape="+s+" outputShape= "+x}function uw(s,x){const n=be(s),r=be(x);return"Input to reshape is a tensor with "+n+" dense values, but the requested shape has "+r+". inputShape="+s+" outputShape="+x}function ng(){return"segment ids must be >= 0"}function dw(){return"segment ids are not increasing"}function hw(s,x){return"Segment id "+s+" out of range [0, "+x+"), possibly because segmentIds input is not sorted."}function pw(s,x,n){return"Bad: indices["+s+"] == "+x+" out of range [0, "+n+")"}function fw(s,x){let n=!1,r;for(s<=Fm?(r=s,n=!0):r=Bx(s,Math.floor(Math.sqrt(s)));!n;)r>x||r===s?n=!0:r=Bx(s,r+1);return r}function mw(s,x,n){const r=[],a=s.length;for(let i=0;i<a;i++)i!==x?r.push(s[i]):r.push(n);return r}function rg(s,x,n,r){const a=x.shape.length,i=s.shape.length;if(r!==0&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-"+a+", "+a+"], but got "+r);if(r<0&&(r+=a),r>i)throw new Error("batchDims ("+r+`) must be less than rank(x) (
    `+i+").");if(n<r)throw new Error("batchDims ("+r+") must be less than or equal to axis ("+n+").");for(let p=0;p<r;++p)if(s.shape[p]!==x.shape[p])throw new Error("x.shape["+p+"]: "+s.shape[p]+" should be equal to indices.shape["+p+"]: "+x.shape[p]+".");const o=s.shape[n],l=[];let c=1,d=1,h=1;for(let p=0;p<r;++p)l.push(s.shape[p]),c*=s.shape[p];for(let p=r;p<n;p++)l.push(s.shape[p]),d*=s.shape[p];for(let p=r;p<a;p++)l.push(x.shape[p]);for(let p=n+1;p<i;p++)l.push(s.shape[p]),h*=s.shape[p];return{batchSize:c,sliceSize:h,outerSize:d,dimSize:o,outputShape:l}}var j9=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:fw,computeOutShape:mw,collectGatherOpShapeInfo:rg});function pa(s){try{return s.map(x=>os(x))}catch(x){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+x)}}function gw(s){return s.map(x=>is(x))}var e5=Object.freeze({__proto__:null,slice_util:K9,segment_util:j9,fromUint8ToStringArray:pa,fromStringArrayToUint8:gw,upcastType:n2,axesAreInnerMostDims:cm,combineLocations:zb,computeOutAndReduceShapes:dn,expandShapeToKeepDim:$x,assertAxesAreInnerMostDims:hn,getAxesPermutation:Nx,getUndoAxesPermutation:Xo,getInnerMostAxes:Rx,getBroadcastDims:yi,getReductionAxes:Fb,assertAndGetBroadcastShape:Ot,assertParamsConsistent:Om,computeOutShape:hr,computeDilation2DInfo:Wo,computePool2DInfo:k2,computePool3DInfo:Ir,computeConv2DInfo:sn,computeConv3DInfo:ps,computeDefaultPad:am,tupleValuesAreOne:Ho,eitherStridesOrDilationsAreOne:Sn,stridesOrDilationsArePositive:xa,convertConv2DDataFormat:kr,checkPadOnDimRoundingMode:N2,getFusedDyActivation:Qu,getFusedBiasGradient:ju,applyActivation:ed,shouldFuse:td,get RowPartitionType(){return K2},combineRaggedTensorToTensorShapes:qv,getRowPartitionTypesHelper:Xv,getRaggedRank:Kv,validateDefaultValueShape:$v,PARALLELIZE_THRESHOLD:Fm,computeOptimalWindowSize:xd,getImageCenter:Um,getReshaped:tl,getPermuted:xl,getReshapedPermuted:nl,getSliceBeginCoords:Bm,getSliceSize:zm,prepareAndValidate:Mm,validateUpdateShape:vv,validateInput:wv,calculateShapes:el,SELU_SCALEALPHA:Wm,SELU_SCALE:Gm,ERF_P:Vm,ERF_A1:Hm,ERF_A2:Ym,ERF_A3:qm,ERF_A4:Xm,ERF_A5:Km,warn:E2,log:FC,mergeRealAndImagArrays:Fr,splitRealAndImagArrays:Zv,complexWithEvenIndex:Jv,complexWithOddIndex:Qv,getComplexWithIndex:$m,assignToTypedArray:jv,exponents:ew,exponent:tw,decodeEinsumEquation:Jm,getEinsumPermutation:Qm,checkEinsumDimSizes:jm,getEinsumComputePath:eg,isIdentityPermutation:tg,prepareSplitSize:xg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:rw,getSparseFillEmptyRowsNegativeIndexErrorMessage:sw,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:aw,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:iw,getSparseReshapeNegativeOutputDimErrorMessage:ow,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:lw,getSparseReshapeInputOutputMultipleErrorMessage:cw,getSparseReshapeInputOutputMismatchErrorMessage:uw,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ng,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:dw,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:hw,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:pw});E9();var t5=Object.defineProperty,yw=Object.getOwnPropertySymbols,x5=Object.prototype.hasOwnProperty,n5=Object.prototype.propertyIsEnumerable,bw=(s,x,n)=>x in s?t5(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,r5=(s,x)=>{for(var n in x||(x={}))x5.call(x,n)&&bw(s,n,x[n]);if(yw)for(var n of yw(x))n5.call(x,n)&&bw(s,n,x[n]);return s};class s5{constructor(x){this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=4,this.model=x,this.modelSize=x.inputs[0].shape?{width:x.inputs[0].shape[2],height:x.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=Xn(this.anchorsData.map(n=>n.x)),this.anchorsY=Xn(this.anchorsData.map(n=>n.y))}async process(x){let n={x:0,y:0};const[r,a,i]=vt(()=>{const h={width:x.shape[2],height:x.shape[1]},p=h.width/h.height;let m=r5({},h),g={x:0,y:0};p>this.modelRatio?(m.height=x.shape[2]/this.modelRatio,g.y=Math.floor((m.height-x.shape[1])*.5),n.y=g.y/m.height):p<this.modelRatio&&(m.width=x.shape[1]*this.modelRatio,g.x=Math.floor((m.width-x.shape[2])*.5),n.x=g.x/m.width);const y=sa(x,[[0,0],[g.y,g.y],[g.x,g.x],[0,0]],0),b=dr.resizeBilinear(y,[this.modelSize.height,this.modelSize.width]),v=this.model.execute(b,"person"),w=qn(Ct(v,[0,0,1],[1,-1,-1]));let _=Ct(v,[0,0,0],[1,-1,1]);_=Db(_,-100,100);const T=qn(fs(_));return[this.decodeBoxes(w,[this.anchorsX,this.anchorsY],this.modelSize),T,b]}),o=await r.array(),l=await a.array();let c=[];for(let h=0;h<2254;h++){if(l[h]<.5)continue;const p=o[h][2]-o[h][0],m=o[h][3]-o[h][1];p<0||m<0||c.push({box:[[o[h][0],o[h][1]],[o[h][2],o[h][3]]],points:[[o[h][4],o[h][5]],[o[h][6],o[h][7]],[o[h][8],o[h][9]],[o[h][10],o[h][11]]],score:l[h]})}if(r.dispose(),a.dispose(),i.dispose(),c.length<1)return[];if(c.length>1){const h=oa(c.map(y=>[y.box[0][1],y.box[0][0],y.box[1][1],y.box[1][0]])),p=Xn(c.map(y=>y.score)),m=await dr.nonMaxSuppressionAsync(h,p,this.posesMax,this.iouThresh,this.scoreThresh),g=await m.array();m.dispose(),c=g.map(y=>c[y])}if(c.length<1)return[];const d={width:1-2*n.x,height:1-2*n.y};return c.map(h=>({box:h.box.map(p=>[(p[0]-n.x)/d.width,(p[1]-n.y)/d.height]),points:h.points.map(p=>[(p[0]-n.x)/d.width,(p[1]-n.y)/d.height]),score:h.score}))}decodeBoxes(x,n,r){let a=qn(Ct(x,[0,0],[-1,1])),i=qn(Ct(x,[0,1],[-1,1])),o=qn(Ct(x,[0,2],[-1,1])),l=qn(Ct(x,[0,3],[-1,1]));a=j0(Ht(a,r.width),n[0]),i=j0(Ht(i,r.height),n[1]),o=Ht(o,r.width*2),l=Ht(l,r.height*2);const c=Be(gt(a,o),[2254,1]),d=Be(gt(i,l),[2254,1]),h=Be(j0(a,o),[2254,1]),p=Be(j0(i,l),[2254,1]);let m=Wu([c,d,h,p],1);for(let g=0;g<4;g++){let y=qn(Ct(x,[0,4+g*2],[-1,1])),b=qn(Ct(x,[0,4+g*2+1],[-1,1]));y=Be(j0(Ht(y,r.width),n[0]),[2254,1]),b=Be(j0(Ht(b,r.height),n[1]),[2254,1]),m=Wu([m,y,b],1)}return m}buildAnchors(x){const n=[8,16,32,32,32],r=[];let a=0;for(;a<5;){let i=0,o=a;for(;o<n.length&&n[o]===n[a];)i+=2,o++;const l=n[a],c=Math.ceil(x.height/l),d=Math.ceil(x.width/l);for(let h=0;h<c;++h)for(let p=0;p<d;++p)for(let m=0;m<i;++m)r.push({x:(p+.5)/d,y:(h+.5)/c});a=o}return r}async prepare(){const x=vt(()=>{const{width:n,height:r}=this.modelSize,a=X2([1,r,n,3]);return this.model.execute(a,"person")});await x.array(),x.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class a5{constructor(x,n=!1){this.mask=n,this.sizeFactor=1.25,this.model=x,this.modelSize=x.inputs[0].shape?{width:x.inputs[0].shape[2],height:x.inputs[0].shape[1]}:{width:256,height:256}}async process(x,n){const[r,a]=[x.shape[1],x.shape[2]];return vt(()=>n.map(i=>{const o=[i.center[0]*a,i.center[1]*r],l=[i.top[0]*a,i.top[1]*r],c=[l[0]-o[0],l[1]-o[1]],d=Math.sqrt(c[0]*c[0]+c[1]*c[1])*this.sizeFactor,h=Math.atan2(c[0],-c[1]),p=[o[0]/a,o[1]/r],m=dr.rotateWithOffset(x,h,0,p),g=[(o[1]-d)/r,(o[0]-d)/a,(o[1]+d)/r,(o[0]+d)/a],y=dr.cropAndResize(m,[g],[0],[this.modelSize.height,this.modelSize.width]),b=j0(A0(y,.5),.5),v=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&v.push("activation_segmentation");const[w,_,T,A,E]=this.model.execute(b,v),M=Be(w,[-1,5]).arraySync(),I=Be(_,[-1,3]).arraySync(),C=T.arraySync().flat()[0];let k=M.map(O=>[O[0]/this.modelSize.width,O[1]/this.modelSize.height,O[2]/this.modelSize.width]);return k=this.refinePoints(k,A),{points:k,pointsData:M,metricData:I,mask:E,score:C,center:o,top:l,radius:d,angle:h}})).map(i=>{const{points:o,pointsData:l,metricData:c,mask:d,score:h,center:p,top:m,radius:g,angle:y}=i;let b=l.map((M,I)=>({pixel:o[I],metric:c[I],score:1/(1+Math.exp(-M[3])),visibility:1/(1+Math.exp(-M[4]))}));b.forEach(M=>{M.pixel[0]=(M.pixel[0]-.5)*2*g,M.pixel[1]=(M.pixel[1]-.5)*2*g,M.pixel[2]*=2*g});const v=Math.sin(y),w=Math.cos(y);b.forEach(M=>{const I=M.pixel[0],C=M.pixel[1];M.pixel[0]=(I*w-C*v+p[0])/a,M.pixel[1]=(I*v+C*w+p[1])/r,M.pixel[2]/=a;const k=M.metric[0],O=M.metric[1];M.metric[0]=k*w-O*v,M.metric[1]=k*v+O*w});const _=b.map(M=>M.pixel[0]),T=b.map(M=>M.pixel[1]),A=[[Math.min(..._),Math.min(...T)],[Math.max(..._),Math.max(...T)]],E=d&&{buffer:vt(()=>{const M=dr.rotateWithOffset(d,-y),I=qn(M,[0]);return new Uint8Array(A0(I,255).dataSync())}),size:{width:d.shape[2],height:d.shape[1]},box:[[(p[0]-g)/a,(p[1]-g)/r],[(p[0]+g)/a,(p[1]+g)/r]]};return d?.dispose(),{keypoints:b,score:h,mask:E,center:[b[33].pixel[0],b[33].pixel[1]],top:[b[34].pixel[0],b[34].pixel[1]],debug:{center:p,top:m,box:A,radius:g,angle:y}}})}refinePoints(x,n){const r=qn(n,[0]),a=r.bufferSync(),[i,o,l]=r.shape;return x.map((c,d)=>{const h=c,p=Math.trunc(h[0]*o),m=Math.trunc(h[1]*i);if(p<0||p>=o||m<0||m>=i)return c;const g=Math.trunc((7-1)/2),y=Math.max(p-g,0),b=Math.min(p+g+1,o),v=Math.max(m-g,0),w=Math.min(m+g+1,i);let _=0,T=0,A=0,E=0;for(let M=v;M<w;M++)for(let I=y;I<b;I++){const C=a.get(M,I,d);_+=C,T=Math.max(C,T),A+=I*C,E+=M*C}return T>=.5&&_>0?[A/_/o,E/_/i,h[2]]:c})}async prepare(){const x=vt(()=>{const{width:n,height:r}=this.modelSize,a=X2([1,r,n,3]);return this.model.execute(a)});await Promise.all(x.map(async n=>{await n.array(),n.dispose()}))}async dispose(){var x;(x=this.model)==null||x.dispose()}}var i5=Object.defineProperty,vw=Object.getOwnPropertySymbols,o5=Object.prototype.hasOwnProperty,l5=Object.prototype.propertyIsEnumerable,ww=(s,x,n)=>x in s?i5(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,_w=(s,x)=>{for(var n in x||(x={}))o5.call(x,n)&&ww(s,n,x[n]);if(vw)for(var n of vw(x))l5.call(x,n)&&ww(s,n,x[n]);return s};class c5{constructor(){this.freq=30,this.pixelParams={minCutOff:.2,minCutOffD:1,beta:20},this.metricParams={minCutOff:.1,minCutOffD:1,beta:20},this.boxParams={minCutOff:.05,minCutOffD:1,beta:5},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(x,n,r=1){return this.time>=n?x:(this.time!==0&&(this.freq=1/(n-this.time)),this.time=n,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(x),this.smooth=this.clonePose(x),this.der={keypoints:x.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(x.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,r),this.filterCoord2D(x.center,this.raw.center,this.der.center,this.smooth.center,r,this.boxParams),this.filterCoord2D(x.top,this.raw.top,this.der.top,this.smooth.top,r,this.boxParams),this.smooth.score=x.score,this.smooth.mask=x.mask&&{buffer:x.mask.buffer,size:_w({},x.mask.size),box:[[...x.mask.box[0]],[...x.mask.box[1]]]},this.smooth.debug=x.debug&&{center:[...x.debug.center],top:[...x.debug.top],box:[[...x.debug.box[0]],[...x.debug.box[1]]],radius:x.debug.radius,angle:x.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(x,n,r,a,i){const o=this.alpha(this.visibilityCutOff),l=this.alpha(this.scoreCutOff);for(let c=0;c<x.length;c++)this.filterCoord3D(x[c].pixel,n[c].pixel,r[c].pixel,a[c].pixel,i,this.pixelParams),this.filterCoord3D(x[c].metric,n[c].metric,r[c].metric,a[c].metric,i,this.metricParams),a[c].score=a[c].score+l*(x[c].score-a[c].score),a[c].visibility=a[c].visibility+o*(x[c].visibility-a[c].visibility)}filterCoord3D(x,n,r,a,i,o){const l=[(x[0]-a[0])*i*this.freq,(x[1]-a[1])*i*this.freq,(x[2]-a[2])*i*this.freq],c=this.alpha(o.minCutOffD);r[0]=r[0]+c*(l[0]-r[0]),r[1]=r[1]+c*(l[1]-r[1]),r[2]=r[2]+c*(l[2]-r[2]);const d=[this.alpha(o.minCutOff+o.beta*Math.abs(r[0])),this.alpha(o.minCutOff+o.beta*Math.abs(r[1])),this.alpha(o.minCutOff+o.beta*Math.abs(r[2]))];a[0]=a[0]+d[0]*(x[0]-a[0]),a[1]=a[1]+d[1]*(x[1]-a[1]),a[2]=a[2]+d[2]*(x[2]-a[2]),n[0]=x[0],n[1]=x[1],n[2]=x[2]}filterCoord2D(x,n,r,a,i,o){const l=[(x[0]-a[0])*i*this.freq,(x[1]-a[1])*i*this.freq],c=this.alpha(o.minCutOffD);r[0]=r[0]+c*(l[0]-r[0]),r[1]=r[1]+c*(l[1]-r[1]);const d=[this.alpha(o.minCutOff+o.beta*Math.abs(r[0])),this.alpha(o.minCutOff+o.beta*Math.abs(r[1]))];a[0]=a[0]+d[0]*(x[0]-a[0]),a[1]=a[1]+d[1]*(x[1]-a[1]),n[0]=x[0],n[1]=x[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(x){return 1/(1+this.freq/(2*Math.PI*x))}clonePose(x){return{keypoints:x.keypoints.map(n=>({pixel:[...n.pixel],metric:[...n.metric],score:n.score,visibility:n.visibility})),score:x.score,center:[...x.center],top:[...x.top],mask:x.mask&&{buffer:x.mask.buffer,size:_w({},x.mask.size),box:[[...x.mask.box[0]],[...x.mask.box[1]]]},debug:x.debug&&{box:[[...x.debug.box[0]],[...x.debug.box[1]]],center:[...x.debug.center],top:[...x.debug.top],radius:x.debug.radius,angle:x.debug.angle}}}}function u5(s,x){const n=[Math.max(s.xy.x,x.xy.x),Math.max(s.xy.y,x.xy.y)],r=[Math.min(s.xy.x+s.size.width,s.xy.x+s.size.width),Math.min(s.xy.y+s.size.height,s.xy.y+s.size.height)],a=(r[0]-n[0])*(r[1]-n[1]);return a/(s.size.width*s.size.height+x.size.width*x.size.height-a)}function d5(s,x){const n=[[Math.max(s[0][0],x[0][0]),Math.max(s[0][1],x[0][1])],[Math.min(s[1][0],x[1][0]),Math.min(s[1][1],x[1][1])]],r=(n[1][0]-n[0][0])*(n[1][1]-n[0][1]);return r/((s[1][0]-s[0][0])*(s[1][1]-s[0][1])+(x[1][0]-x[0][0])*(x[1][1]-x[0][1])-r)}var h5=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(x){x=x||{};var n=typeof x<"u"?x:{},r,a;n.ready=new Promise(function(W,F){r=W,a=F});var i=Object.assign({},n),o=!0,l="";function c(W){return n.locateFile?n.locateFile(W,l):l+W}var d;typeof document<"u"&&document.currentScript&&(l=document.currentScript.src),s&&(l=s),l.indexOf("blob:")!==0?l=l.substr(0,l.replace(/[?#].*/,"").lastIndexOf("/")+1):l="",n.print||console.log.bind(console);var h=n.printErr||console.warn.bind(console);Object.assign(n,i),i=null,n.arguments&&n.arguments,n.thisProgram&&n.thisProgram,n.quit&&n.quit;var p;n.wasmBinary&&(p=n.wasmBinary),n.noExitRuntime,typeof WebAssembly!="object"&&Ye("no native wasm support detected");var m,g=!1;function y(W,F){W||Ye(F)}var b=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function v(W,F,oe){for(var Me=F+oe,L=F;W[L]&&!(L>=Me);)++L;if(L-F>16&&W.buffer&&b)return b.decode(W.subarray(F,L));for(var P="";F<L;){var B=W[F++];if(!(B&128)){P+=String.fromCharCode(B);continue}var j=W[F++]&63;if((B&224)==192){P+=String.fromCharCode((B&31)<<6|j);continue}var fe=W[F++]&63;if((B&240)==224?B=(B&15)<<12|j<<6|fe:B=(B&7)<<18|j<<12|fe<<6|W[F++]&63,B<65536)P+=String.fromCharCode(B);else{var _e=B-65536;P+=String.fromCharCode(55296|_e>>10,56320|_e&1023)}}return P}function w(W,F){return W?v(Y,W,F):""}function _(W,F,oe,Me){if(!(Me>0))return 0;for(var L=oe,P=oe+Me-1,B=0;B<W.length;++B){var j=W.charCodeAt(B);if(j>=55296&&j<=57343){var fe=W.charCodeAt(++B);j=65536+((j&1023)<<10)|fe&1023}if(j<=127){if(oe>=P)break;F[oe++]=j}else if(j<=2047){if(oe+1>=P)break;F[oe++]=192|j>>6,F[oe++]=128|j&63}else if(j<=65535){if(oe+2>=P)break;F[oe++]=224|j>>12,F[oe++]=128|j>>6&63,F[oe++]=128|j&63}else{if(oe+3>=P)break;F[oe++]=240|j>>18,F[oe++]=128|j>>12&63,F[oe++]=128|j>>6&63,F[oe++]=128|j&63}}return F[oe]=0,oe-L}function T(W,F,oe){return _(W,Y,F,oe)}function A(W){for(var F=0,oe=0;oe<W.length;++oe){var Me=W.charCodeAt(oe);Me>=55296&&Me<=57343&&(Me=65536+((Me&1023)<<10)|W.charCodeAt(++oe)&1023),Me<=127?++F:Me<=2047?F+=2:Me<=65535?F+=3:F+=4}return F}var E=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function M(W,F){for(var oe=W,Me=oe>>1,L=Me+F/2;!(Me>=L)&&te[Me];)++Me;if(oe=Me<<1,oe-W>32&&E)return E.decode(Y.subarray(W,oe));for(var P="",B=0;!(B>=F/2);++B){var j=Q[W+B*2>>1];if(j==0)break;P+=String.fromCharCode(j)}return P}function I(W,F,oe){if(oe===void 0&&(oe=2147483647),oe<2)return 0;oe-=2;for(var Me=F,L=oe<W.length*2?oe/2:W.length,P=0;P<L;++P){var B=W.charCodeAt(P);Q[F>>1]=B,F+=2}return Q[F>>1]=0,F-Me}function C(W){return W.length*2}function k(W,F){for(var oe=0,Me="";!(oe>=F/4);){var L=se[W+oe*4>>2];if(L==0)break;if(++oe,L>=65536){var P=L-65536;Me+=String.fromCharCode(55296|P>>10,56320|P&1023)}else Me+=String.fromCharCode(L)}return Me}function O(W,F,oe){if(oe===void 0&&(oe=2147483647),oe<4)return 0;for(var Me=F,L=Me+oe-4,P=0;P<W.length;++P){var B=W.charCodeAt(P);if(B>=55296&&B<=57343){var j=W.charCodeAt(++P);B=65536+((B&1023)<<10)|j&1023}if(se[F>>2]=B,F+=4,F+4>L)break}return se[F>>2]=0,F-Me}function z(W){for(var F=0,oe=0;oe<W.length;++oe){var Me=W.charCodeAt(oe);Me>=55296&&Me<=57343&&++oe,F+=4}return F}var ee,re,Y,Q,te,se,xe,ae,le;function de(W){ee=W,n.HEAP8=re=new Int8Array(W),n.HEAP16=Q=new Int16Array(W),n.HEAP32=se=new Int32Array(W),n.HEAPU8=Y=new Uint8Array(W),n.HEAPU16=te=new Uint16Array(W),n.HEAPU32=xe=new Uint32Array(W),n.HEAPF32=ae=new Float32Array(W),n.HEAPF64=le=new Float64Array(W)}n.INITIAL_MEMORY;var ue,ge=[],pe=[],Le=[];function we(){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)i0(n.preRun.shift());$(ge)}function e0(){$(pe)}function Ze(){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;)v0(n.postRun.shift());$(Le)}function i0(W){ge.unshift(W)}function We(W){pe.unshift(W)}function v0(W){Le.unshift(W)}var Te=0,Ie=null;function Xe(W){Te++,n.monitorRunDependencies&&n.monitorRunDependencies(Te)}function c0(W){if(Te--,n.monitorRunDependencies&&n.monitorRunDependencies(Te),Te==0&&Ie){var F=Ie;Ie=null,F()}}function Ye(W){n.onAbort&&n.onAbort(W),W="Aborted("+W+")",h(W),g=!0,W+=". Build with -sASSERTIONS for more info.";var F=new WebAssembly.RuntimeError(W);throw a(F),F}var I0="data:application/octet-stream;base64,";function m0(W){return W.startsWith(I0)}var d0;d0="poseutils.wasm",m0(d0)||(d0=c(d0));function rt(W){try{if(W==d0&&p)return new Uint8Array(p);throw"both async and sync fetching of the wasm failed"}catch(F){Ye(F)}}function ct(){return!p&&o&&typeof fetch=="function"?fetch(d0,{credentials:"same-origin"}).then(function(W){if(!W.ok)throw"failed to load wasm binary file at '"+d0+"'";return W.arrayBuffer()}).catch(function(){return rt(d0)}):Promise.resolve().then(function(){return rt(d0)})}function ie(){var W={a:ko};function F(B,j){var fe=B.exports;n.asm=fe,m=n.asm.y,de(m.buffer),ue=n.asm.C,We(n.asm.z),c0()}Xe();function oe(B){F(B.instance)}function Me(B){return ct().then(function(j){return WebAssembly.instantiate(j,W)}).then(function(j){return j}).then(B,function(j){h("failed to asynchronously prepare wasm: "+j),Ye(j)})}function L(){return!p&&typeof WebAssembly.instantiateStreaming=="function"&&!m0(d0)&&typeof fetch=="function"?fetch(d0,{credentials:"same-origin"}).then(function(B){var j=WebAssembly.instantiateStreaming(B,W);return j.then(oe,function(fe){return h("wasm streaming compile failed: "+fe),h("falling back to ArrayBuffer instantiation"),Me(oe)})}):Me(oe)}if(n.instantiateWasm)try{var P=n.instantiateWasm(W,F);return P}catch(B){return h("Module.instantiateWasm callback failed with error: "+B),!1}return L().catch(a),{}}function $(W){for(;W.length>0;){var F=W.shift();if(typeof F=="function"){F(n);continue}var oe=F.func;typeof oe=="number"?F.arg===void 0?Ge(oe)():Ge(oe)(F.arg):oe(F.arg===void 0?null:F.arg)}}var ke=[];function Ge(W){var F=ke[W];return F||(W>=ke.length&&(ke.length=W+1),ke[W]=F=ue.get(W)),F}function s0(W){return Ys(W+24)+24}function p0(W){this.excPtr=W,this.ptr=W-24,this.set_type=function(F){xe[this.ptr+4>>2]=F},this.get_type=function(){return xe[this.ptr+4>>2]},this.set_destructor=function(F){xe[this.ptr+8>>2]=F},this.get_destructor=function(){return xe[this.ptr+8>>2]},this.set_refcount=function(F){se[this.ptr>>2]=F},this.set_caught=function(F){F=F?1:0,re[this.ptr+12>>0]=F},this.get_caught=function(){return re[this.ptr+12>>0]!=0},this.set_rethrown=function(F){F=F?1:0,re[this.ptr+13>>0]=F},this.get_rethrown=function(){return re[this.ptr+13>>0]!=0},this.init=function(F,oe){this.set_adjusted_ptr(0),this.set_type(F),this.set_destructor(oe),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var F=se[this.ptr>>2];se[this.ptr>>2]=F+1},this.release_ref=function(){var F=se[this.ptr>>2];return se[this.ptr>>2]=F-1,F===1},this.set_adjusted_ptr=function(F){xe[this.ptr+16>>2]=F},this.get_adjusted_ptr=function(){return xe[this.ptr+16>>2]},this.get_exception_ptr=function(){var F=Ro(this.get_type());if(F)return xe[this.excPtr>>2];var oe=this.get_adjusted_ptr();return oe!==0?oe:this.excPtr}}function K0(W,F,oe){var Me=new p0(W);throw Me.init(F,oe),W}var Re={};function L0(W){for(;W.length;){var F=W.pop(),oe=W.pop();oe(F)}}function u0(W){return this.fromWireType(xe[W>>2])}var D0={},b0={},et={},Et=48,xx=57;function ye(W){if(W===void 0)return"_unknown";W=W.replace(/[^a-zA-Z0-9_]/g,"$");var F=W.charCodeAt(0);return F>=Et&&F<=xx?"_"+W:W}function k0(W,F){return W=ye(W),function(){return F.apply(this,arguments)}}function Fe(W,F){var oe=k0(F,function(Me){this.name=F,this.message=Me;var L=new Error(Me).stack;L!==void 0&&(this.stack=this.toString()+`
`+L.replace(/^Error(:[^\n]*)?\n/,""))});return oe.prototype=Object.create(W.prototype),oe.prototype.constructor=oe,oe.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},oe}var h0=void 0;function f0(W){throw new h0(W)}function Y0(W,F,oe){W.forEach(function(j){et[j]=F});function Me(j){var fe=oe(j);fe.length!==W.length&&f0("Mismatched type converter count");for(var _e=0;_e<W.length;++_e)yx(W[_e],fe[_e])}var L=new Array(F.length),P=[],B=0;F.forEach((j,fe)=>{b0.hasOwnProperty(j)?L[fe]=b0[j]:(P.push(j),D0.hasOwnProperty(j)||(D0[j]=[]),D0[j].push(()=>{L[fe]=b0[j],++B,B===P.length&&Me(L)}))}),P.length===0&&Me(L)}function ox(W){var F=Re[W];delete Re[W];var oe=F.rawConstructor,Me=F.rawDestructor,L=F.fields,P=L.map(B=>B.getterReturnType).concat(L.map(B=>B.setterArgumentType));Y0([W],P,B=>{var j={};return L.forEach((fe,_e)=>{var Se=fe.fieldName,ve=B[_e],Ue=fe.getter,Qe=fe.getterContext,g0=B[_e+L.length],E0=fe.setter,ot=fe.setterContext;j[Se]={read:St=>ve.fromWireType(Ue(Qe,St)),write:(St,Kt)=>{var mt=[];E0(ot,St,g0.toWireType(mt,Kt)),L0(mt)}}}),[{name:F.name,fromWireType:function(fe){var _e={};for(var Se in j)_e[Se]=j[Se].read(fe);return Me(fe),_e},toWireType:function(fe,_e){for(var Se in j)if(!(Se in _e))throw new TypeError('Missing field:  "'+Se+'"');var ve=oe();for(Se in j)j[Se].write(ve,_e[Se]);return fe!==null&&fe.push(Me,ve),ve},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:Me}]})}function qt(W,F,oe,Me,L){}function jx(W){switch(W){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+W)}}function Jt(){for(var W=new Array(256),F=0;F<256;++F)W[F]=String.fromCharCode(F);Dx=W}var Dx=void 0;function zt(W){for(var F="",oe=W;Y[oe];)F+=Dx[Y[oe++]];return F}var en=void 0;function o0(W){throw new en(W)}function yx(W,F,oe={}){if(!("argPackAdvance"in F))throw new TypeError("registerType registeredInstance requires argPackAdvance");var Me=F.name;if(W||o0('type "'+Me+'" must have a positive integer typeid pointer'),b0.hasOwnProperty(W)){if(oe.ignoreDuplicateRegistrations)return;o0("Cannot register type '"+Me+"' twice")}if(b0[W]=F,delete et[W],D0.hasOwnProperty(W)){var L=D0[W];delete D0[W],L.forEach(P=>P())}}function ut(W,F,oe,Me,L){var P=jx(oe);F=zt(F),yx(W,{name:F,fromWireType:function(B){return!!B},toWireType:function(B,j){return j?Me:L},argPackAdvance:8,readValueFromPointer:function(B){var j;if(oe===1)j=re;else if(oe===2)j=Q;else if(oe===4)j=se;else throw new TypeError("Unknown boolean type size: "+F);return this.fromWireType(j[B>>P])},destructorFunction:null})}function Cx(W){if(!(this instanceof vn)||!(W instanceof vn))return!1;for(var F=this.$$.ptrType.registeredClass,oe=this.$$.ptr,Me=W.$$.ptrType.registeredClass,L=W.$$.ptr;F.baseClass;)oe=F.upcast(oe),F=F.baseClass;for(;Me.baseClass;)L=Me.upcast(L),Me=Me.baseClass;return F===Me&&oe===L}function Ox(W){return{count:W.count,deleteScheduled:W.deleteScheduled,preservePointerOnDelete:W.preservePointerOnDelete,ptr:W.ptr,ptrType:W.ptrType,smartPtr:W.smartPtr,smartPtrType:W.smartPtrType}}function ne(W){function F(oe){return oe.$$.ptrType.registeredClass.name}o0(F(W)+" instance already deleted")}var Ee=!1;function De(W){}function Ne(W){W.smartPtr?W.smartPtrType.rawDestructor(W.smartPtr):W.ptrType.registeredClass.rawDestructor(W.ptr)}function qe(W){W.count.value-=1;var F=W.count.value===0;F&&Ne(W)}function at(W,F,oe){if(F===oe)return W;if(oe.baseClass===void 0)return null;var Me=at(W,F,oe.baseClass);return Me===null?null:oe.downcast(Me)}var lt={};function ht(){return Object.keys(tn).length}function dt(){var W=[];for(var F in tn)tn.hasOwnProperty(F)&&W.push(tn[F]);return W}var kt=[];function Mt(){for(;kt.length;){var W=kt.pop();W.$$.deleteScheduled=!1,W.delete()}}var pt=void 0;function Xt(W){pt=W,kt.length&&pt&&pt(Mt)}function cn(){n.getInheritedInstanceCount=ht,n.getLiveInheritedInstances=dt,n.flushPendingDeletes=Mt,n.setDelayFunction=Xt}var tn={};function z2(W,F){for(F===void 0&&o0("ptr should not be undefined");W.baseClass;)F=W.upcast(F),W=W.baseClass;return F}function xn(W,F){return F=z2(W,F),tn[F]}function _t(W,F){(!F.ptrType||!F.ptr)&&f0("makeClassHandle requires ptr and ptrType");var oe=!!F.smartPtrType,Me=!!F.smartPtr;return oe!==Me&&f0("Both smartPtrType and smartPtr must be specified"),F.count={value:1},Qt(Object.create(W,{$$:{value:F}}))}function W2(W){var F=this.getPointee(W);if(!F)return this.destructor(W),null;var oe=xn(this.registeredClass,F);if(oe!==void 0){if(oe.$$.count.value===0)return oe.$$.ptr=F,oe.$$.smartPtr=W,oe.clone();var Me=oe.clone();return this.destructor(W),Me}function L(){return this.isSmartPointer?_t(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:F,smartPtrType:this,smartPtr:W}):_t(this.registeredClass.instancePrototype,{ptrType:this,ptr:W})}var P=this.registeredClass.getActualType(F),B=lt[P];if(!B)return L.call(this);var j;this.isConst?j=B.constPointerType:j=B.pointerType;var fe=at(F,this.registeredClass,j.registeredClass);return fe===null?L.call(this):this.isSmartPointer?_t(j.registeredClass.instancePrototype,{ptrType:j,ptr:fe,smartPtrType:this,smartPtr:W}):_t(j.registeredClass.instancePrototype,{ptrType:j,ptr:fe})}function Qt(W){return typeof FinalizationRegistry>"u"?(Qt=F=>F,W):(Ee=new FinalizationRegistry(F=>{qe(F.$$)}),Qt=F=>{var oe=F.$$,Me=!!oe.smartPtr;if(Me){var L={$$:oe};Ee.register(F,L,F)}return F},De=F=>Ee.unregister(F),Qt(W))}function Hx(){if(this.$$.ptr||ne(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var W=Qt(Object.create(Object.getPrototypeOf(this),{$$:{value:Ox(this.$$)}}));return W.$$.count.value+=1,W.$$.deleteScheduled=!1,W}function bn(){this.$$.ptr||ne(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&o0("Object already scheduled for deletion"),De(this),qe(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function e2(){return!this.$$.ptr}function xs(){return this.$$.ptr||ne(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&o0("Object already scheduled for deletion"),kt.push(this),kt.length===1&&pt&&pt(Mt),this.$$.deleteScheduled=!0,this}function Yx(){vn.prototype.isAliasOf=Cx,vn.prototype.clone=Hx,vn.prototype.delete=bn,vn.prototype.isDeleted=e2,vn.prototype.deleteLater=xs}function vn(){}function br(W,F,oe){if(W[F].overloadTable===void 0){var Me=W[F];W[F]=function(){return W[F].overloadTable.hasOwnProperty(arguments.length)||o0("Function '"+oe+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+W[F].overloadTable+")!"),W[F].overloadTable[arguments.length].apply(this,arguments)},W[F].overloadTable=[],W[F].overloadTable[Me.argCount]=Me}}function mx(W,F,oe){n.hasOwnProperty(W)?((oe===void 0||n[W].overloadTable!==void 0&&n[W].overloadTable[oe]!==void 0)&&o0("Cannot register public name '"+W+"' twice"),br(n,W,W),n.hasOwnProperty(oe)&&o0("Cannot register multiple overloads of a function with the same number of arguments ("+oe+")!"),n[W].overloadTable[oe]=F):(n[W]=F,oe!==void 0&&(n[W].numArguments=oe))}function An(W,F,oe,Me,L,P,B,j){this.name=W,this.constructor=F,this.instancePrototype=oe,this.rawDestructor=Me,this.baseClass=L,this.getActualType=P,this.upcast=B,this.downcast=j,this.pureVirtualFunctions=[]}function sr(W,F,oe){for(;F!==oe;)F.upcast||o0("Expected null or instance of "+oe.name+", got an instance of "+F.name),W=F.upcast(W),F=F.baseClass;return W}function Us(W,F){if(F===null)return this.isReference&&o0("null is not a valid "+this.name),0;F.$$||o0('Cannot pass "'+wr(F)+'" as a '+this.name),F.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name);var oe=F.$$.ptrType.registeredClass,Me=sr(F.$$.ptr,oe,this.registeredClass);return Me}function Bs(W,F){var oe;if(F===null)return this.isReference&&o0("null is not a valid "+this.name),this.isSmartPointer?(oe=this.rawConstructor(),W!==null&&W.push(this.rawDestructor,oe),oe):0;F.$$||o0('Cannot pass "'+wr(F)+'" as a '+this.name),F.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&F.$$.ptrType.isConst&&o0("Cannot convert argument of type "+(F.$$.smartPtrType?F.$$.smartPtrType.name:F.$$.ptrType.name)+" to parameter type "+this.name);var Me=F.$$.ptrType.registeredClass;if(oe=sr(F.$$.ptr,Me,this.registeredClass),this.isSmartPointer)switch(F.$$.smartPtr===void 0&&o0("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:F.$$.smartPtrType===this?oe=F.$$.smartPtr:o0("Cannot convert argument of type "+(F.$$.smartPtrType?F.$$.smartPtrType.name:F.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:oe=F.$$.smartPtr;break;case 2:if(F.$$.smartPtrType===this)oe=F.$$.smartPtr;else{var L=F.clone();oe=this.rawShare(oe,wn.toHandle(function(){L.delete()})),W!==null&&W.push(this.rawDestructor,oe)}break;default:o0("Unsupporting sharing policy")}return oe}function zs(W,F){if(F===null)return this.isReference&&o0("null is not a valid "+this.name),0;F.$$||o0('Cannot pass "'+wr(F)+'" as a '+this.name),F.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name),F.$$.ptrType.isConst&&o0("Cannot convert argument of type "+F.$$.ptrType.name+" to parameter type "+this.name);var oe=F.$$.ptrType.registeredClass,Me=sr(F.$$.ptr,oe,this.registeredClass);return Me}function sc(W){return this.rawGetPointee&&(W=this.rawGetPointee(W)),W}function ac(W){this.rawDestructor&&this.rawDestructor(W)}function ic(W){W!==null&&W.delete()}function Ws(){v2.prototype.getPointee=sc,v2.prototype.destructor=ac,v2.prototype.argPackAdvance=8,v2.prototype.readValueFromPointer=u0,v2.prototype.deleteObject=ic,v2.prototype.fromWireType=W2}function v2(W,F,oe,Me,L,P,B,j,fe,_e,Se){this.name=W,this.registeredClass=F,this.isReference=oe,this.isConst=Me,this.isSmartPointer=L,this.pointeeType=P,this.sharingPolicy=B,this.rawGetPointee=j,this.rawConstructor=fe,this.rawShare=_e,this.rawDestructor=Se,!L&&F.baseClass===void 0?Me?(this.toWireType=Us,this.destructorFunction=null):(this.toWireType=zs,this.destructorFunction=null):this.toWireType=Bs}function oc(W,F,oe){n.hasOwnProperty(W)||f0("Replacing nonexistant public symbol"),n[W].overloadTable!==void 0&&oe!==void 0?n[W].overloadTable[oe]=F:(n[W]=F,n[W].argCount=oe)}function w2(W,F,oe){var Me=n["dynCall_"+W];return oe&&oe.length?Me.apply(null,[F].concat(oe)):Me.call(null,F)}function lc(W,F,oe){return W.includes("j")?w2(W,F,oe):Ge(F).apply(null,oe)}function _2(W,F){var oe=[];return function(){return oe.length=0,Object.assign(oe,arguments),lc(W,F,oe)}}function Wn(W,F){W=zt(W);function oe(){return W.includes("j")?_2(W,F):Ge(F)}var Me=oe();return typeof Me!="function"&&o0("unknown function pointer with signature "+W+": "+F),Me}var Ao=void 0;function qx(W){var F=No(W),oe=zt(F);return T2(F),oe}function vr(W,F){var oe=[],Me={};function L(P){if(!Me[P]&&!b0[P]){if(et[P]){et[P].forEach(L);return}oe.push(P),Me[P]=!0}}throw F.forEach(L),new Ao(W+": "+oe.map(qx).join([", "]))}function S2(W,F,oe,Me,L,P,B,j,fe,_e,Se,ve,Ue){Se=zt(Se),P=Wn(L,P),j&&(j=Wn(B,j)),_e&&(_e=Wn(fe,_e)),Ue=Wn(ve,Ue);var Qe=ye(Se);mx(Qe,function(){vr("Cannot construct "+Se+" due to unbound types",[Me])}),Y0([W,F,oe],Me?[Me]:[],function(g0){g0=g0[0];var E0,ot;Me?(E0=g0.registeredClass,ot=E0.instancePrototype):ot=vn.prototype;var St=k0(Qe,function(){if(Object.getPrototypeOf(this)!==Kt)throw new en("Use 'new' to construct "+Se);if(mt.constructor_body===void 0)throw new en(Se+" has no accessible constructor");var Tx=mt.constructor_body[arguments.length];if(Tx===void 0)throw new en("Tried to invoke ctor of "+Se+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(mt.constructor_body).toString()+") parameters instead!");return Tx.apply(this,arguments)}),Kt=Object.create(ot,{constructor:{value:St}});St.prototype=Kt;var mt=new An(Se,St,Kt,Ue,E0,P,j,_e),Mx=new v2(Se,mt,!0,!1,!1),Fx=new v2(Se+"*",mt,!1,!1,!1),Cn=new v2(Se+" const*",mt,!1,!0,!1);return lt[W]={pointerType:Fx,constPointerType:Cn},oc(Qe,St),[Mx,Fx,Cn]})}function ar(W,F){for(var oe=[],Me=0;Me<W;Me++)oe.push(se[(F>>2)+Me]);return oe}function Eo(W,F,oe,Me,L,P){y(F>0);var B=ar(F,oe);L=Wn(Me,L),Y0([],[W],function(j){j=j[0];var fe="constructor "+j.name;if(j.registeredClass.constructor_body===void 0&&(j.registeredClass.constructor_body=[]),j.registeredClass.constructor_body[F-1]!==void 0)throw new en("Cannot register multiple constructors with identical number of parameters ("+(F-1)+") for class '"+j.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return j.registeredClass.constructor_body[F-1]=()=>{vr("Cannot construct "+j.name+" due to unbound types",B)},Y0([],B,function(_e){return _e.splice(1,0,null),j.registeredClass.constructor_body[F-1]=ir(fe,_e,null,L,P),[]}),[]})}function ir(W,F,oe,Me,L){var P=F.length;P<2&&o0("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var B=F[1]!==null&&oe!==null,j=!1,fe=1;fe<F.length;++fe)if(F[fe]!==null&&F[fe].destructorFunction===void 0){j=!0;break}var _e=F[0].name!=="void",Se=P-2,ve=new Array(Se),Ue=[],Qe=[];return function(){arguments.length!==Se&&o0("function "+W+" called with "+arguments.length+" arguments, expected "+Se+" args!"),Qe.length=0;var g0;Ue.length=B?2:1,Ue[0]=L,B&&(g0=F[1].toWireType(Qe,this),Ue[1]=g0);for(var E0=0;E0<Se;++E0)ve[E0]=F[E0+2].toWireType(Qe,arguments[E0]),Ue.push(ve[E0]);var ot=Me.apply(null,Ue);function St(Kt){if(j)L0(Qe);else for(var mt=B?1:2;mt<F.length;mt++){var Mx=mt===1?g0:ve[mt-2];F[mt].destructorFunction!==null&&F[mt].destructorFunction(Mx)}if(_e)return F[0].fromWireType(Kt)}return St(ot)}}function cc(W,F,oe,Me,L,P,B,j){var fe=ar(oe,Me);F=zt(F),P=Wn(L,P),Y0([],[W],function(_e){_e=_e[0];var Se=_e.name+"."+F;F.startsWith("@@")&&(F=Symbol[F.substring(2)]),j&&_e.registeredClass.pureVirtualFunctions.push(F);function ve(){vr("Cannot call "+Se+" due to unbound types",fe)}var Ue=_e.registeredClass.instancePrototype,Qe=Ue[F];return Qe===void 0||Qe.overloadTable===void 0&&Qe.className!==_e.name&&Qe.argCount===oe-2?(ve.argCount=oe-2,ve.className=_e.name,Ue[F]=ve):(br(Ue,F,Se),Ue[F].overloadTable[oe-2]=ve),Y0([],fe,function(g0){var E0=ir(Se,g0,_e,P,B);return Ue[F].overloadTable===void 0?(E0.argCount=oe-2,Ue[F]=E0):Ue[F].overloadTable[oe-2]=E0,[]}),[]})}function Gs(W,F,oe){return W instanceof Object||o0(oe+' with invalid "this": '+W),W instanceof F.registeredClass.constructor||o0(oe+' incompatible with "this" of type '+W.constructor.name),W.$$.ptr||o0("cannot call emscripten binding method "+oe+" on deleted object"),sr(W.$$.ptr,W.$$.ptrType.registeredClass,F.registeredClass)}function ni(W,F,oe,Me,L,P,B,j,fe,_e){F=zt(F),L=Wn(Me,L),Y0([],[W],function(Se){Se=Se[0];var ve=Se.name+"."+F,Ue={get:function(){vr("Cannot access "+ve+" due to unbound types",[oe,B])},enumerable:!0,configurable:!0};return fe?Ue.set=()=>{vr("Cannot access "+ve+" due to unbound types",[oe,B])}:Ue.set=Qe=>{o0(ve+" is a read-only property")},Object.defineProperty(Se.registeredClass.instancePrototype,F,Ue),Y0([],fe?[oe,B]:[oe],function(Qe){var g0=Qe[0],E0={get:function(){var St=Gs(this,Se,ve+" getter");return g0.fromWireType(L(P,St))},enumerable:!0};if(fe){fe=Wn(j,fe);var ot=Qe[1];E0.set=function(St){var Kt=Gs(this,Se,ve+" setter"),mt=[];fe(_e,Kt,ot.toWireType(mt,St)),L0(mt)}}return Object.defineProperty(Se.registeredClass.instancePrototype,F,E0),[]}),[]})}var Vs=[],Gn=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Hs(W){W>4&&--Gn[W].refcount===0&&(Gn[W]=void 0,Vs.push(W))}function Vn(){for(var W=0,F=5;F<Gn.length;++F)Gn[F]!==void 0&&++W;return W}function Co(){for(var W=5;W<Gn.length;++W)if(Gn[W]!==void 0)return Gn[W];return null}function ri(){n.count_emval_handles=Vn,n.get_first_emval=Co}var wn={toValue:W=>(W||o0("Cannot use deleted val. handle = "+W),Gn[W].value),toHandle:W=>{switch(W){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var F=Vs.length?Vs.pop():Gn.length;return Gn[F]={refcount:1,value:W},F}}}};function si(W,F){F=zt(F),yx(W,{name:F,fromWireType:function(oe){var Me=wn.toValue(oe);return Hs(oe),Me},toWireType:function(oe,Me){return wn.toHandle(Me)},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:null})}function wr(W){if(W===null)return"null";var F=typeof W;return F==="object"||F==="array"||F==="function"?W.toString():""+W}function uc(W,F){switch(F){case 2:return function(oe){return this.fromWireType(ae[oe>>2])};case 3:return function(oe){return this.fromWireType(le[oe>>3])};default:throw new TypeError("Unknown float type: "+W)}}function ai(W,F,oe){var Me=jx(oe);F=zt(F),yx(W,{name:F,fromWireType:function(L){return L},toWireType:function(L,P){return P},argPackAdvance:8,readValueFromPointer:uc(F,Me),destructorFunction:null})}function En(W,F,oe){switch(F){case 0:return oe?function(Me){return re[Me]}:function(Me){return Y[Me]};case 1:return oe?function(Me){return Q[Me>>1]}:function(Me){return te[Me>>1]};case 2:return oe?function(Me){return se[Me>>2]}:function(Me){return xe[Me>>2]};default:throw new TypeError("Unknown integer type: "+W)}}function dc(W,F,oe,Me,L){F=zt(F);var P=jx(oe),B=ve=>ve;if(Me===0){var j=32-8*oe;B=ve=>ve<<j>>>j}var fe=F.includes("unsigned"),_e=(ve,Ue)=>{},Se;fe?Se=function(ve,Ue){return _e(Ue,this.name),Ue>>>0}:Se=function(ve,Ue){return _e(Ue,this.name),Ue},yx(W,{name:F,fromWireType:B,toWireType:Se,argPackAdvance:8,readValueFromPointer:En(F,P,Me!==0),destructorFunction:null})}function ii(W,F,oe){var Me=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],L=Me[F];function P(B){B=B>>2;var j=xe,fe=j[B],_e=j[B+1];return new L(ee,_e,fe)}oe=zt(oe),yx(W,{name:oe,fromWireType:P,argPackAdvance:8,readValueFromPointer:P},{ignoreDuplicateRegistrations:!0})}function hc(W,F){F=zt(F);var oe=F==="std::string";yx(W,{name:F,fromWireType:function(Me){var L=xe[Me>>2],P;if(oe)for(var B=Me+4,j=0;j<=L;++j){var fe=Me+4+j;if(j==L||Y[fe]==0){var _e=fe-B,Se=w(B,_e);P===void 0?P=Se:(P+=String.fromCharCode(0),P+=Se),B=fe+1}}else{for(var ve=new Array(L),j=0;j<L;++j)ve[j]=String.fromCharCode(Y[Me+4+j]);P=ve.join("")}return T2(Me),P},toWireType:function(Me,L){L instanceof ArrayBuffer&&(L=new Uint8Array(L));var P,B=typeof L=="string";B||L instanceof Uint8Array||L instanceof Uint8ClampedArray||L instanceof Int8Array||o0("Cannot pass non-string to std::string"),oe&&B?P=()=>A(L):P=()=>L.length;var j=P(),fe=Ys(4+j+1);if(xe[fe>>2]=j,oe&&B)T(L,fe+4,j+1);else if(B)for(var _e=0;_e<j;++_e){var Se=L.charCodeAt(_e);Se>255&&(T2(fe),o0("String has UTF-16 code units that do not fit in 8 bits")),Y[fe+4+_e]=Se}else for(var _e=0;_e<j;++_e)Y[fe+4+_e]=L[_e];return Me!==null&&Me.push(T2,fe),fe},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:function(Me){T2(Me)}})}function pc(W,F,oe){oe=zt(oe);var Me,L,P,B,j;F===2?(Me=M,L=I,B=C,P=()=>te,j=1):F===4&&(Me=k,L=O,B=z,P=()=>xe,j=2),yx(W,{name:oe,fromWireType:function(fe){for(var _e=xe[fe>>2],Se=P(),ve,Ue=fe+4,Qe=0;Qe<=_e;++Qe){var g0=fe+4+Qe*F;if(Qe==_e||Se[g0>>j]==0){var E0=g0-Ue,ot=Me(Ue,E0);ve===void 0?ve=ot:(ve+=String.fromCharCode(0),ve+=ot),Ue=g0+F}}return T2(fe),ve},toWireType:function(fe,_e){typeof _e!="string"&&o0("Cannot pass non-string to C++ string type "+oe);var Se=B(_e),ve=Ys(4+Se+F);return xe[ve>>2]=Se>>j,L(_e,ve+4,Se+F),fe!==null&&fe.push(T2,ve),ve},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:function(fe){T2(fe)}})}function fc(W,F,oe,Me,L,P){Re[W]={name:zt(F),rawConstructor:Wn(oe,Me),rawDestructor:Wn(L,P),fields:[]}}function mc(W,F,oe,Me,L,P,B,j,fe,_e){Re[W].fields.push({fieldName:zt(F),getterReturnType:oe,getter:Wn(Me,L),getterContext:P,setterArgumentType:B,setter:Wn(j,fe),setterContext:_e})}function gc(W,F){F=zt(F),yx(W,{isVoid:!0,name:F,argPackAdvance:0,fromWireType:function(){},toWireType:function(oe,Me){}})}function yc(W){W>4&&(Gn[W].refcount+=1)}function bc(W,F){var oe=b0[W];return oe===void 0&&o0(F+" has unknown type "+qx(W)),oe}function vc(W,F){W=bc(W,"_emval_take_value");var oe=W.readValueFromPointer(F);return wn.toHandle(oe)}function wc(){Ye("")}function Mo(W,F,oe){Y.copyWithin(W,F,F+oe)}function _c(){return 2147483648}function Sc(W){try{return m.grow(W-ee.byteLength+65535>>>16),de(m.buffer),1}catch{}}function Io(W){var F=Y.length;W=W>>>0;var oe=_c();if(W>oe)return!1;let Me=(fe,_e)=>fe+(_e-fe%_e)%_e;for(var L=1;L<=4;L*=2){var P=F*(1+.2/L);P=Math.min(P,W+100663296);var B=Math.min(oe,Me(Math.max(W,P),65536)),j=Sc(B);if(j)return!0}return!1}h0=n.InternalError=Fe(Error,"InternalError"),Jt(),en=n.BindingError=Fe(Error,"BindingError"),Yx(),cn(),Ws(),Ao=n.UnboundTypeError=Fe(Error,"UnboundTypeError"),ri();var ko={c:s0,b:K0,x:ox,q:qt,v:ut,j:S2,i:Eo,d:cc,f:ni,u:si,l:ai,e:dc,a:ii,k:hc,g:pc,m:fc,h:mc,w:gc,n:Hs,o:yc,p:vc,r:wc,t:Mo,s:Io};ie(),n.___wasm_call_ctors=function(){return(n.___wasm_call_ctors=n.asm.z).apply(null,arguments)};var T2=n._free=function(){return(T2=n._free=n.asm.A).apply(null,arguments)},Ys=n._malloc=function(){return(Ys=n._malloc=n.asm.B).apply(null,arguments)},No=n.___getTypeName=function(){return(No=n.___getTypeName=n.asm.D).apply(null,arguments)};n.___embind_register_native_and_builtin_types=function(){return(n.___embind_register_native_and_builtin_types=n.asm.E).apply(null,arguments)};var Ro=n.___cxa_is_pointer_type=function(){return(Ro=n.___cxa_is_pointer_type=n.asm.F).apply(null,arguments)},Hn;Ie=function W(){Hn||_r(),Hn||(Ie=W)};function _r(W){if(Te>0||(we(),Te>0))return;function F(){Hn||(Hn=!0,n.calledRun=!0,!g&&(e0(),r(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),Ze()))}n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),F()},1)):F()}if(n.run=_r,n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);n.preInit.length>0;)n.preInit.pop()();return _r(),x.ready}})(),Sw=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(x){x=x||{};var n=typeof x<"u"?x:{},r,a;n.ready=new Promise(function(D,R){r=D,a=R});var i=Object.assign({},n),o="./this.program",l=(D,R)=>{throw R},c=!0,d=!1,h="";function p(D){return n.locateFile?n.locateFile(D,h):h+D}var m;typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),s&&(h=s),h.indexOf("blob:")!==0?h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):h="",n.print||console.log.bind(console);var g=n.printErr||console.warn.bind(console);Object.assign(n,i),i=null,n.arguments&&n.arguments,n.thisProgram&&(o=n.thisProgram),n.quit&&(l=n.quit);var y;n.wasmBinary&&(y=n.wasmBinary),n.noExitRuntime,typeof WebAssembly!="object"&&ie("no native wasm support detected");var b,v=!1,w;function _(D,R){D||ie(R)}var T=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function A(D,R,J){for(var me=R+J,Oe=R;D[Oe]&&!(Oe>=me);)++Oe;if(Oe-R>16&&D.buffer&&T)return T.decode(D.subarray(R,Oe));for(var ze="";R<Oe;){var Ve=D[R++];if(!(Ve&128)){ze+=String.fromCharCode(Ve);continue}var Pe=D[R++]&63;if((Ve&224)==192){ze+=String.fromCharCode((Ve&31)<<6|Pe);continue}var y0=D[R++]&63;if((Ve&240)==224?Ve=(Ve&15)<<12|Pe<<6|y0:Ve=(Ve&7)<<18|Pe<<12|y0<<6|D[R++]&63,Ve<65536)ze+=String.fromCharCode(Ve);else{var N0=Ve-65536;ze+=String.fromCharCode(55296|N0>>10,56320|N0&1023)}}return ze}function E(D,R){return D?A(le,D,R):""}function M(D,R,J,me){if(!(me>0))return 0;for(var Oe=J,ze=J+me-1,Ve=0;Ve<D.length;++Ve){var Pe=D.charCodeAt(Ve);if(Pe>=55296&&Pe<=57343){var y0=D.charCodeAt(++Ve);Pe=65536+((Pe&1023)<<10)|y0&1023}if(Pe<=127){if(J>=ze)break;R[J++]=Pe}else if(Pe<=2047){if(J+1>=ze)break;R[J++]=192|Pe>>6,R[J++]=128|Pe&63}else if(Pe<=65535){if(J+2>=ze)break;R[J++]=224|Pe>>12,R[J++]=128|Pe>>6&63,R[J++]=128|Pe&63}else{if(J+3>=ze)break;R[J++]=240|Pe>>18,R[J++]=128|Pe>>12&63,R[J++]=128|Pe>>6&63,R[J++]=128|Pe&63}}return R[J]=0,J-Oe}function I(D,R,J){return M(D,le,R,J)}function C(D){for(var R=0,J=0;J<D.length;++J){var me=D.charCodeAt(J);me>=55296&&me<=57343&&(me=65536+((me&1023)<<10)|D.charCodeAt(++J)&1023),me<=127?++R:me<=2047?R+=2:me<=65535?R+=3:R+=4}return R}var k=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function O(D,R){for(var J=D,me=J>>1,Oe=me+R/2;!(me>=Oe)&&ue[me];)++me;if(J=me<<1,J-D>32&&k)return k.decode(le.subarray(D,J));for(var ze="",Ve=0;!(Ve>=R/2);++Ve){var Pe=de[D+Ve*2>>1];if(Pe==0)break;ze+=String.fromCharCode(Pe)}return ze}function z(D,R,J){if(J===void 0&&(J=2147483647),J<2)return 0;J-=2;for(var me=R,Oe=J<D.length*2?J/2:D.length,ze=0;ze<Oe;++ze){var Ve=D.charCodeAt(ze);de[R>>1]=Ve,R+=2}return de[R>>1]=0,R-me}function ee(D){return D.length*2}function re(D,R){for(var J=0,me="";!(J>=R/4);){var Oe=ge[D+J*4>>2];if(Oe==0)break;if(++J,Oe>=65536){var ze=Oe-65536;me+=String.fromCharCode(55296|ze>>10,56320|ze&1023)}else me+=String.fromCharCode(Oe)}return me}function Y(D,R,J){if(J===void 0&&(J=2147483647),J<4)return 0;for(var me=R,Oe=me+J-4,ze=0;ze<D.length;++ze){var Ve=D.charCodeAt(ze);if(Ve>=55296&&Ve<=57343){var Pe=D.charCodeAt(++ze);Ve=65536+((Ve&1023)<<10)|Pe&1023}if(ge[R>>2]=Ve,R+=4,R+4>Oe)break}return ge[R>>2]=0,R-me}function Q(D){for(var R=0,J=0;J<D.length;++J){var me=D.charCodeAt(J);me>=55296&&me<=57343&&++J,R+=4}return R}function te(D,R){ae.set(D,R)}function se(D,R,J){for(var me=0;me<D.length;++me)ae[R++>>0]=D.charCodeAt(me);J||(ae[R>>0]=0)}var xe,ae,le,de,ue,ge,pe,Le,we;function e0(D){xe=D,n.HEAP8=ae=new Int8Array(D),n.HEAP16=de=new Int16Array(D),n.HEAP32=ge=new Int32Array(D),n.HEAPU8=le=new Uint8Array(D),n.HEAPU16=ue=new Uint16Array(D),n.HEAPU32=pe=new Uint32Array(D),n.HEAPF32=Le=new Float32Array(D),n.HEAPF64=we=new Float64Array(D)}n.INITIAL_MEMORY;var Ze,i0=[],We=[],v0=[];function Te(){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)c0(n.preRun.shift());Re(i0)}function Ie(){Re(We)}function Xe(){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;)I0(n.postRun.shift());Re(v0)}function c0(D){i0.unshift(D)}function Ye(D){We.unshift(D)}function I0(D){v0.unshift(D)}var m0=0,d0=null;function rt(D){m0++,n.monitorRunDependencies&&n.monitorRunDependencies(m0)}function ct(D){if(m0--,n.monitorRunDependencies&&n.monitorRunDependencies(m0),m0==0&&d0){var R=d0;d0=null,R()}}function ie(D){n.onAbort&&n.onAbort(D),D="Aborted("+D+")",g(D),v=!0,w=1,D+=". Build with -sASSERTIONS for more info.";var R=new WebAssembly.RuntimeError(D);throw a(R),R}var $="data:application/octet-stream;base64,";function ke(D){return D.startsWith($)}var Ge;Ge="bodyutils.wasm",ke(Ge)||(Ge=p(Ge));function s0(D){try{if(D==Ge&&y)return new Uint8Array(y);throw"both async and sync fetching of the wasm failed"}catch(R){ie(R)}}function p0(){return!y&&c&&typeof fetch=="function"?fetch(Ge,{credentials:"same-origin"}).then(function(D){if(!D.ok)throw"failed to load wasm binary file at '"+Ge+"'";return D.arrayBuffer()}).catch(function(){return s0(Ge)}):Promise.resolve().then(function(){return s0(Ge)})}function K0(){var D={a:$h};function R(Ve,Pe){var y0=Ve.exports;n.asm=y0,b=n.asm.G,e0(b.buffer),Ze=n.asm.J,Ye(n.asm.H),ct()}rt();function J(Ve){R(Ve.instance)}function me(Ve){return p0().then(function(Pe){return WebAssembly.instantiate(Pe,D)}).then(function(Pe){return Pe}).then(Ve,function(Pe){g("failed to asynchronously prepare wasm: "+Pe),ie(Pe)})}function Oe(){return!y&&typeof WebAssembly.instantiateStreaming=="function"&&!ke(Ge)&&typeof fetch=="function"?fetch(Ge,{credentials:"same-origin"}).then(function(Ve){var Pe=WebAssembly.instantiateStreaming(Ve,D);return Pe.then(J,function(y0){return g("wasm streaming compile failed: "+y0),g("falling back to ArrayBuffer instantiation"),me(J)})}):me(J)}if(n.instantiateWasm)try{var ze=n.instantiateWasm(D,R);return ze}catch(Ve){return g("Module.instantiateWasm callback failed with error: "+Ve),!1}return Oe().catch(a),{}}function Re(D){for(;D.length>0;){var R=D.shift();if(typeof R=="function"){R(n);continue}var J=R.func;typeof J=="number"?R.arg===void 0?u0(J)():u0(J)(R.arg):J(R.arg===void 0?null:R.arg)}}var L0=[];function u0(D){var R=L0[D];return R||(D>=L0.length&&(L0.length=D+1),L0[D]=R=Ze.get(D)),R}function D0(D){if(D instanceof Sne||D=="unwind")return w;l(1,D)}function b0(D){return Sr(D+24)+24}function et(D){this.excPtr=D,this.ptr=D-24,this.set_type=function(R){pe[this.ptr+4>>2]=R},this.get_type=function(){return pe[this.ptr+4>>2]},this.set_destructor=function(R){pe[this.ptr+8>>2]=R},this.get_destructor=function(){return pe[this.ptr+8>>2]},this.set_refcount=function(R){ge[this.ptr>>2]=R},this.set_caught=function(R){R=R?1:0,ae[this.ptr+12>>0]=R},this.get_caught=function(){return ae[this.ptr+12>>0]!=0},this.set_rethrown=function(R){R=R?1:0,ae[this.ptr+13>>0]=R},this.get_rethrown=function(){return ae[this.ptr+13>>0]!=0},this.init=function(R,J){this.set_adjusted_ptr(0),this.set_type(R),this.set_destructor(J),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var R=ge[this.ptr>>2];ge[this.ptr>>2]=R+1},this.release_ref=function(){var R=ge[this.ptr>>2];return ge[this.ptr>>2]=R-1,R===1},this.set_adjusted_ptr=function(R){pe[this.ptr+16>>2]=R},this.get_adjusted_ptr=function(){return pe[this.ptr+16>>2]},this.get_exception_ptr=function(){var R=DC(this.get_type());if(R)return pe[this.excPtr>>2];var J=this.get_adjusted_ptr();return J!==0?J:this.excPtr}}function Et(D,R,J){var me=new et(D);throw me.init(R,J),D}function xx(D,R,J,me,Oe){}function ye(D){switch(D){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+D)}}function k0(){for(var D=new Array(256),R=0;R<256;++R)D[R]=String.fromCharCode(R);Fe=D}var Fe=void 0;function h0(D){for(var R="",J=D;le[J];)R+=Fe[le[J++]];return R}var f0={},Y0={},ox={},qt=48,jx=57;function Jt(D){if(D===void 0)return"_unknown";D=D.replace(/[^a-zA-Z0-9_]/g,"$");var R=D.charCodeAt(0);return R>=qt&&R<=jx?"_"+D:D}function Dx(D,R){return D=Jt(D),function(){return R.apply(this,arguments)}}function zt(D,R){var J=Dx(R,function(me){this.name=R,this.message=me;var Oe=new Error(me).stack;Oe!==void 0&&(this.stack=this.toString()+`
`+Oe.replace(/^Error(:[^\n]*)?\n/,""))});return J.prototype=Object.create(D.prototype),J.prototype.constructor=J,J.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},J}var en=void 0;function o0(D){throw new en(D)}var yx=void 0;function ut(D){throw new yx(D)}function Cx(D,R,J){D.forEach(function(Pe){ox[Pe]=R});function me(Pe){var y0=J(Pe);y0.length!==D.length&&ut("Mismatched type converter count");for(var N0=0;N0<D.length;++N0)Ox(D[N0],y0[N0])}var Oe=new Array(R.length),ze=[],Ve=0;R.forEach((Pe,y0)=>{Y0.hasOwnProperty(Pe)?Oe[y0]=Y0[Pe]:(ze.push(Pe),f0.hasOwnProperty(Pe)||(f0[Pe]=[]),f0[Pe].push(()=>{Oe[y0]=Y0[Pe],++Ve,Ve===ze.length&&me(Oe)}))}),ze.length===0&&me(Oe)}function Ox(D,R,J={}){if(!("argPackAdvance"in R))throw new TypeError("registerType registeredInstance requires argPackAdvance");var me=R.name;if(D||o0('type "'+me+'" must have a positive integer typeid pointer'),Y0.hasOwnProperty(D)){if(J.ignoreDuplicateRegistrations)return;o0("Cannot register type '"+me+"' twice")}if(Y0[D]=R,delete ox[D],f0.hasOwnProperty(D)){var Oe=f0[D];delete f0[D],Oe.forEach(ze=>ze())}}function ne(D,R,J,me,Oe){var ze=ye(J);R=h0(R),Ox(D,{name:R,fromWireType:function(Ve){return!!Ve},toWireType:function(Ve,Pe){return Pe?me:Oe},argPackAdvance:8,readValueFromPointer:function(Ve){var Pe;if(J===1)Pe=ae;else if(J===2)Pe=de;else if(J===4)Pe=ge;else throw new TypeError("Unknown boolean type size: "+R);return this.fromWireType(Pe[Ve>>ze])},destructorFunction:null})}function Ee(D){if(!(this instanceof An)||!(D instanceof An))return!1;for(var R=this.$$.ptrType.registeredClass,J=this.$$.ptr,me=D.$$.ptrType.registeredClass,Oe=D.$$.ptr;R.baseClass;)J=R.upcast(J),R=R.baseClass;for(;me.baseClass;)Oe=me.upcast(Oe),me=me.baseClass;return R===me&&J===Oe}function De(D){return{count:D.count,deleteScheduled:D.deleteScheduled,preservePointerOnDelete:D.preservePointerOnDelete,ptr:D.ptr,ptrType:D.ptrType,smartPtr:D.smartPtr,smartPtrType:D.smartPtrType}}function Ne(D){function R(J){return J.$$.ptrType.registeredClass.name}o0(R(D)+" instance already deleted")}var qe=!1;function at(D){}function lt(D){D.smartPtr?D.smartPtrType.rawDestructor(D.smartPtr):D.ptrType.registeredClass.rawDestructor(D.ptr)}function ht(D){D.count.value-=1;var R=D.count.value===0;R&&lt(D)}function dt(D,R,J){if(R===J)return D;if(J.baseClass===void 0)return null;var me=dt(D,R,J.baseClass);return me===null?null:J.downcast(me)}var kt={};function Mt(){return Object.keys(_t).length}function pt(){var D=[];for(var R in _t)_t.hasOwnProperty(R)&&D.push(_t[R]);return D}var Xt=[];function cn(){for(;Xt.length;){var D=Xt.pop();D.$$.deleteScheduled=!1,D.delete()}}var tn=void 0;function z2(D){tn=D,Xt.length&&tn&&tn(cn)}function xn(){n.getInheritedInstanceCount=Mt,n.getLiveInheritedInstances=pt,n.flushPendingDeletes=cn,n.setDelayFunction=z2}var _t={};function W2(D,R){for(R===void 0&&o0("ptr should not be undefined");D.baseClass;)R=D.upcast(R),D=D.baseClass;return R}function Qt(D,R){return R=W2(D,R),_t[R]}function Hx(D,R){(!R.ptrType||!R.ptr)&&ut("makeClassHandle requires ptr and ptrType");var J=!!R.smartPtrType,me=!!R.smartPtr;return J!==me&&ut("Both smartPtrType and smartPtr must be specified"),R.count={value:1},e2(Object.create(D,{$$:{value:R}}))}function bn(D){var R=this.getPointee(D);if(!R)return this.destructor(D),null;var J=Qt(this.registeredClass,R);if(J!==void 0){if(J.$$.count.value===0)return J.$$.ptr=R,J.$$.smartPtr=D,J.clone();var me=J.clone();return this.destructor(D),me}function Oe(){return this.isSmartPointer?Hx(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:R,smartPtrType:this,smartPtr:D}):Hx(this.registeredClass.instancePrototype,{ptrType:this,ptr:D})}var ze=this.registeredClass.getActualType(R),Ve=kt[ze];if(!Ve)return Oe.call(this);var Pe;this.isConst?Pe=Ve.constPointerType:Pe=Ve.pointerType;var y0=dt(R,this.registeredClass,Pe.registeredClass);return y0===null?Oe.call(this):this.isSmartPointer?Hx(Pe.registeredClass.instancePrototype,{ptrType:Pe,ptr:y0,smartPtrType:this,smartPtr:D}):Hx(Pe.registeredClass.instancePrototype,{ptrType:Pe,ptr:y0})}function e2(D){return typeof FinalizationRegistry>"u"?(e2=R=>R,D):(qe=new FinalizationRegistry(R=>{ht(R.$$)}),e2=R=>{var J=R.$$,me=!!J.smartPtr;if(me){var Oe={$$:J};qe.register(R,Oe,R)}return R},at=R=>qe.unregister(R),e2(D))}function xs(){if(this.$$.ptr||Ne(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var D=e2(Object.create(Object.getPrototypeOf(this),{$$:{value:De(this.$$)}}));return D.$$.count.value+=1,D.$$.deleteScheduled=!1,D}function Yx(){this.$$.ptr||Ne(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&o0("Object already scheduled for deletion"),at(this),ht(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function vn(){return!this.$$.ptr}function br(){return this.$$.ptr||Ne(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&o0("Object already scheduled for deletion"),Xt.push(this),Xt.length===1&&tn&&tn(cn),this.$$.deleteScheduled=!0,this}function mx(){An.prototype.isAliasOf=Ee,An.prototype.clone=xs,An.prototype.delete=Yx,An.prototype.isDeleted=vn,An.prototype.deleteLater=br}function An(){}function sr(D,R,J){if(D[R].overloadTable===void 0){var me=D[R];D[R]=function(){return D[R].overloadTable.hasOwnProperty(arguments.length)||o0("Function '"+J+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+D[R].overloadTable+")!"),D[R].overloadTable[arguments.length].apply(this,arguments)},D[R].overloadTable=[],D[R].overloadTable[me.argCount]=me}}function Us(D,R,J){n.hasOwnProperty(D)?((J===void 0||n[D].overloadTable!==void 0&&n[D].overloadTable[J]!==void 0)&&o0("Cannot register public name '"+D+"' twice"),sr(n,D,D),n.hasOwnProperty(J)&&o0("Cannot register multiple overloads of a function with the same number of arguments ("+J+")!"),n[D].overloadTable[J]=R):(n[D]=R,J!==void 0&&(n[D].numArguments=J))}function Bs(D,R,J,me,Oe,ze,Ve,Pe){this.name=D,this.constructor=R,this.instancePrototype=J,this.rawDestructor=me,this.baseClass=Oe,this.getActualType=ze,this.upcast=Ve,this.downcast=Pe,this.pureVirtualFunctions=[]}function zs(D,R,J){for(;R!==J;)R.upcast||o0("Expected null or instance of "+J.name+", got an instance of "+R.name),D=R.upcast(D),R=R.baseClass;return D}function sc(D,R){if(R===null)return this.isReference&&o0("null is not a valid "+this.name),0;R.$$||o0('Cannot pass "'+ii(R)+'" as a '+this.name),R.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name);var J=R.$$.ptrType.registeredClass,me=zs(R.$$.ptr,J,this.registeredClass);return me}function ac(D,R){var J;if(R===null)return this.isReference&&o0("null is not a valid "+this.name),this.isSmartPointer?(J=this.rawConstructor(),D!==null&&D.push(this.rawDestructor,J),J):0;R.$$||o0('Cannot pass "'+ii(R)+'" as a '+this.name),R.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&R.$$.ptrType.isConst&&o0("Cannot convert argument of type "+(R.$$.smartPtrType?R.$$.smartPtrType.name:R.$$.ptrType.name)+" to parameter type "+this.name);var me=R.$$.ptrType.registeredClass;if(J=zs(R.$$.ptr,me,this.registeredClass),this.isSmartPointer)switch(R.$$.smartPtr===void 0&&o0("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:R.$$.smartPtrType===this?J=R.$$.smartPtr:o0("Cannot convert argument of type "+(R.$$.smartPtrType?R.$$.smartPtrType.name:R.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:J=R.$$.smartPtr;break;case 2:if(R.$$.smartPtrType===this)J=R.$$.smartPtr;else{var Oe=R.clone();J=this.rawShare(J,En.toHandle(function(){Oe.delete()})),D!==null&&D.push(this.rawDestructor,J)}break;default:o0("Unsupporting sharing policy")}return J}function ic(D,R){if(R===null)return this.isReference&&o0("null is not a valid "+this.name),0;R.$$||o0('Cannot pass "'+ii(R)+'" as a '+this.name),R.$$.ptr||o0("Cannot pass deleted object as a pointer of type "+this.name),R.$$.ptrType.isConst&&o0("Cannot convert argument of type "+R.$$.ptrType.name+" to parameter type "+this.name);var J=R.$$.ptrType.registeredClass,me=zs(R.$$.ptr,J,this.registeredClass);return me}function Ws(D){return this.fromWireType(pe[D>>2])}function v2(D){return this.rawGetPointee&&(D=this.rawGetPointee(D)),D}function oc(D){this.rawDestructor&&this.rawDestructor(D)}function w2(D){D!==null&&D.delete()}function lc(){_2.prototype.getPointee=v2,_2.prototype.destructor=oc,_2.prototype.argPackAdvance=8,_2.prototype.readValueFromPointer=Ws,_2.prototype.deleteObject=w2,_2.prototype.fromWireType=bn}function _2(D,R,J,me,Oe,ze,Ve,Pe,y0,N0,O0){this.name=D,this.registeredClass=R,this.isReference=J,this.isConst=me,this.isSmartPointer=Oe,this.pointeeType=ze,this.sharingPolicy=Ve,this.rawGetPointee=Pe,this.rawConstructor=y0,this.rawShare=N0,this.rawDestructor=O0,!Oe&&R.baseClass===void 0?me?(this.toWireType=sc,this.destructorFunction=null):(this.toWireType=ic,this.destructorFunction=null):this.toWireType=ac}function Wn(D,R,J){n.hasOwnProperty(D)||ut("Replacing nonexistant public symbol"),n[D].overloadTable!==void 0&&J!==void 0?n[D].overloadTable[J]=R:(n[D]=R,n[D].argCount=J)}function Ao(D,R,J){var me=n["dynCall_"+D];return J&&J.length?me.apply(null,[R].concat(J)):me.call(null,R)}function qx(D,R,J){return D.includes("j")?Ao(D,R,J):u0(R).apply(null,J)}function vr(D,R){var J=[];return function(){return J.length=0,Object.assign(J,arguments),qx(D,R,J)}}function S2(D,R){D=h0(D);function J(){return D.includes("j")?vr(D,R):u0(R)}var me=J();return typeof me!="function"&&o0("unknown function pointer with signature "+D+": "+R),me}var ar=void 0;function Eo(D){var R=LC(D),J=h0(R);return Tr(R),J}function ir(D,R){var J=[],me={};function Oe(ze){if(!me[ze]&&!Y0[ze]){if(ox[ze]){ox[ze].forEach(Oe);return}J.push(ze),me[ze]=!0}}throw R.forEach(Oe),new ar(D+": "+J.map(Eo).join([", "]))}function cc(D,R,J,me,Oe,ze,Ve,Pe,y0,N0,O0,$0,st){O0=h0(O0),ze=S2(Oe,ze),Pe&&(Pe=S2(Ve,Pe)),N0&&(N0=S2(y0,N0)),st=S2($0,st);var $t=Jt(O0);Us($t,function(){ir("Cannot construct "+O0+" due to unbound types",[me])}),Cx([D,R,J],me?[me]:[],function(bx){bx=bx[0];var jt,Ix;me?(jt=bx.registeredClass,Ix=jt.instancePrototype):Ix=An.prototype;var Xx=Dx($t,function(){if(Object.getPrototypeOf(this)!==r0)throw new en("Use 'new' to construct "+O0);if(B0.constructor_body===void 0)throw new en(O0+" has no accessible constructor");var tt=B0.constructor_body[arguments.length];if(tt===void 0)throw new en("Tried to invoke ctor of "+O0+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(B0.constructor_body).toString()+") parameters instead!");return tt.apply(this,arguments)}),r0=Object.create(Ix,{constructor:{value:Xx}});Xx.prototype=r0;var B0=new Bs(O0,Xx,r0,st,jt,ze,Pe,N0),Kx=new _2(O0,B0,!0,!1,!1),Ux=new _2(O0+"*",B0,!1,!1,!1),or=new _2(O0+" const*",B0,!1,!0,!1);return kt[D]={pointerType:Ux,constPointerType:or},Wn($t,Xx),[Kx,Ux,or]})}function Gs(D,R){for(var J=[],me=0;me<D;me++)J.push(ge[(R>>2)+me]);return J}function ni(D){for(;D.length;){var R=D.pop(),J=D.pop();J(R)}}function Vs(D,R,J,me,Oe,ze){_(R>0);var Ve=Gs(R,J);Oe=S2(me,Oe),Cx([],[D],function(Pe){Pe=Pe[0];var y0="constructor "+Pe.name;if(Pe.registeredClass.constructor_body===void 0&&(Pe.registeredClass.constructor_body=[]),Pe.registeredClass.constructor_body[R-1]!==void 0)throw new en("Cannot register multiple constructors with identical number of parameters ("+(R-1)+") for class '"+Pe.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return Pe.registeredClass.constructor_body[R-1]=()=>{ir("Cannot construct "+Pe.name+" due to unbound types",Ve)},Cx([],Ve,function(N0){return N0.splice(1,0,null),Pe.registeredClass.constructor_body[R-1]=Gn(y0,N0,null,Oe,ze),[]}),[]})}function Gn(D,R,J,me,Oe){var ze=R.length;ze<2&&o0("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var Ve=R[1]!==null&&J!==null,Pe=!1,y0=1;y0<R.length;++y0)if(R[y0]!==null&&R[y0].destructorFunction===void 0){Pe=!0;break}var N0=R[0].name!=="void",O0=ze-2,$0=new Array(O0),st=[],$t=[];return function(){arguments.length!==O0&&o0("function "+D+" called with "+arguments.length+" arguments, expected "+O0+" args!"),$t.length=0;var bx;st.length=Ve?2:1,st[0]=Oe,Ve&&(bx=R[1].toWireType($t,this),st[1]=bx);for(var jt=0;jt<O0;++jt)$0[jt]=R[jt+2].toWireType($t,arguments[jt]),st.push($0[jt]);var Ix=me.apply(null,st);function Xx(r0){if(Pe)ni($t);else for(var B0=Ve?1:2;B0<R.length;B0++){var Kx=B0===1?bx:$0[B0-2];R[B0].destructorFunction!==null&&R[B0].destructorFunction(Kx)}if(N0)return R[0].fromWireType(r0)}return Xx(Ix)}}function Hs(D,R,J,me,Oe,ze,Ve,Pe){var y0=Gs(J,me);R=h0(R),ze=S2(Oe,ze),Cx([],[D],function(N0){N0=N0[0];var O0=N0.name+"."+R;R.startsWith("@@")&&(R=Symbol[R.substring(2)]),Pe&&N0.registeredClass.pureVirtualFunctions.push(R);function $0(){ir("Cannot call "+O0+" due to unbound types",y0)}var st=N0.registeredClass.instancePrototype,$t=st[R];return $t===void 0||$t.overloadTable===void 0&&$t.className!==N0.name&&$t.argCount===J-2?($0.argCount=J-2,$0.className=N0.name,st[R]=$0):(sr(st,R,O0),st[R].overloadTable[J-2]=$0),Cx([],y0,function(bx){var jt=Gn(O0,bx,N0,ze,Ve);return st[R].overloadTable===void 0?(jt.argCount=J-2,st[R]=jt):st[R].overloadTable[J-2]=jt,[]}),[]})}function Vn(D,R,J){return D instanceof Object||o0(J+' with invalid "this": '+D),D instanceof R.registeredClass.constructor||o0(J+' incompatible with "this" of type '+D.constructor.name),D.$$.ptr||o0("cannot call emscripten binding method "+J+" on deleted object"),zs(D.$$.ptr,D.$$.ptrType.registeredClass,R.registeredClass)}function Co(D,R,J,me,Oe,ze,Ve,Pe,y0,N0){R=h0(R),Oe=S2(me,Oe),Cx([],[D],function(O0){O0=O0[0];var $0=O0.name+"."+R,st={get:function(){ir("Cannot access "+$0+" due to unbound types",[J,Ve])},enumerable:!0,configurable:!0};return y0?st.set=()=>{ir("Cannot access "+$0+" due to unbound types",[J,Ve])}:st.set=$t=>{o0($0+" is a read-only property")},Object.defineProperty(O0.registeredClass.instancePrototype,R,st),Cx([],y0?[J,Ve]:[J],function($t){var bx=$t[0],jt={get:function(){var Xx=Vn(this,O0,$0+" getter");return bx.fromWireType(Oe(ze,Xx))},enumerable:!0};if(y0){y0=S2(Pe,y0);var Ix=$t[1];jt.set=function(Xx){var r0=Vn(this,O0,$0+" setter"),B0=[];y0(N0,r0,Ix.toWireType(B0,Xx)),ni(B0)}}return Object.defineProperty(O0.registeredClass.instancePrototype,R,jt),[]}),[]})}var ri=[],wn=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function si(D){D>4&&--wn[D].refcount===0&&(wn[D]=void 0,ri.push(D))}function wr(){for(var D=0,R=5;R<wn.length;++R)wn[R]!==void 0&&++D;return D}function uc(){for(var D=5;D<wn.length;++D)if(wn[D]!==void 0)return wn[D];return null}function ai(){n.count_emval_handles=wr,n.get_first_emval=uc}var En={toValue:D=>(D||o0("Cannot use deleted val. handle = "+D),wn[D].value),toHandle:D=>{switch(D){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var R=ri.length?ri.pop():wn.length;return wn[R]={refcount:1,value:D},R}}}};function dc(D,R){R=h0(R),Ox(D,{name:R,fromWireType:function(J){var me=En.toValue(J);return si(J),me},toWireType:function(J,me){return En.toHandle(me)},argPackAdvance:8,readValueFromPointer:Ws,destructorFunction:null})}function ii(D){if(D===null)return"null";var R=typeof D;return R==="object"||R==="array"||R==="function"?D.toString():""+D}function hc(D,R){switch(R){case 2:return function(J){return this.fromWireType(Le[J>>2])};case 3:return function(J){return this.fromWireType(we[J>>3])};default:throw new TypeError("Unknown float type: "+D)}}function pc(D,R,J){var me=ye(J);R=h0(R),Ox(D,{name:R,fromWireType:function(Oe){return Oe},toWireType:function(Oe,ze){return ze},argPackAdvance:8,readValueFromPointer:hc(R,me),destructorFunction:null})}function fc(D,R,J){switch(R){case 0:return J?function(me){return ae[me]}:function(me){return le[me]};case 1:return J?function(me){return de[me>>1]}:function(me){return ue[me>>1]};case 2:return J?function(me){return ge[me>>2]}:function(me){return pe[me>>2]};default:throw new TypeError("Unknown integer type: "+D)}}function mc(D,R,J,me,Oe){R=h0(R);var ze=ye(J),Ve=$0=>$0;if(me===0){var Pe=32-8*J;Ve=$0=>$0<<Pe>>>Pe}var y0=R.includes("unsigned"),N0=($0,st)=>{},O0;y0?O0=function($0,st){return N0(st,this.name),st>>>0}:O0=function($0,st){return N0(st,this.name),st},Ox(D,{name:R,fromWireType:Ve,toWireType:O0,argPackAdvance:8,readValueFromPointer:fc(R,ze,me!==0),destructorFunction:null})}function gc(D,R,J){var me=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],Oe=me[R];function ze(Ve){Ve=Ve>>2;var Pe=pe,y0=Pe[Ve],N0=Pe[Ve+1];return new Oe(xe,N0,y0)}J=h0(J),Ox(D,{name:J,fromWireType:ze,argPackAdvance:8,readValueFromPointer:ze},{ignoreDuplicateRegistrations:!0})}function yc(D,R){R=h0(R);var J=R==="std::string";Ox(D,{name:R,fromWireType:function(me){var Oe=pe[me>>2],ze;if(J)for(var Ve=me+4,Pe=0;Pe<=Oe;++Pe){var y0=me+4+Pe;if(Pe==Oe||le[y0]==0){var N0=y0-Ve,O0=E(Ve,N0);ze===void 0?ze=O0:(ze+=String.fromCharCode(0),ze+=O0),Ve=y0+1}}else{for(var $0=new Array(Oe),Pe=0;Pe<Oe;++Pe)$0[Pe]=String.fromCharCode(le[me+4+Pe]);ze=$0.join("")}return Tr(me),ze},toWireType:function(me,Oe){Oe instanceof ArrayBuffer&&(Oe=new Uint8Array(Oe));var ze,Ve=typeof Oe=="string";Ve||Oe instanceof Uint8Array||Oe instanceof Uint8ClampedArray||Oe instanceof Int8Array||o0("Cannot pass non-string to std::string"),J&&Ve?ze=()=>C(Oe):ze=()=>Oe.length;var Pe=ze(),y0=Sr(4+Pe+1);if(pe[y0>>2]=Pe,J&&Ve)I(Oe,y0+4,Pe+1);else if(Ve)for(var N0=0;N0<Pe;++N0){var O0=Oe.charCodeAt(N0);O0>255&&(Tr(y0),o0("String has UTF-16 code units that do not fit in 8 bits")),le[y0+4+N0]=O0}else for(var N0=0;N0<Pe;++N0)le[y0+4+N0]=Oe[N0];return me!==null&&me.push(Tr,y0),y0},argPackAdvance:8,readValueFromPointer:Ws,destructorFunction:function(me){Tr(me)}})}function bc(D,R,J){J=h0(J);var me,Oe,ze,Ve,Pe;R===2?(me=O,Oe=z,Ve=ee,ze=()=>ue,Pe=1):R===4&&(me=re,Oe=Y,Ve=Q,ze=()=>pe,Pe=2),Ox(D,{name:J,fromWireType:function(y0){for(var N0=pe[y0>>2],O0=ze(),$0,st=y0+4,$t=0;$t<=N0;++$t){var bx=y0+4+$t*R;if($t==N0||O0[bx>>Pe]==0){var jt=bx-st,Ix=me(st,jt);$0===void 0?$0=Ix:($0+=String.fromCharCode(0),$0+=Ix),st=bx+R}}return Tr(y0),$0},toWireType:function(y0,N0){typeof N0!="string"&&o0("Cannot pass non-string to C++ string type "+J);var O0=Ve(N0),$0=Sr(4+O0+R);return pe[$0>>2]=O0>>Pe,Oe(N0,$0+4,O0+R),y0!==null&&y0.push(Tr,$0),$0},argPackAdvance:8,readValueFromPointer:Ws,destructorFunction:function(y0){Tr(y0)}})}function vc(D,R){R=h0(R),Ox(D,{isVoid:!0,name:R,argPackAdvance:0,fromWireType:function(){},toWireType:function(J,me){}})}function wc(D){delete B.xhrs[D-1]}function Mo(D,R){var J=Y0[D];return J===void 0&&o0(R+" has unknown type "+Eo(D)),J}function _c(D,R,J){D=En.toValue(D),R=Mo(R,"emval::as");var me=[],Oe=En.toHandle(me);return ge[J>>2]=Oe,R.toWireType(me,D)}var Sc={};function Io(D){var R=Sc[D];return R===void 0?h0(D):R}function ko(){if(typeof globalThis=="object")return globalThis;function D(R){R.$$$embind_global$$$=R;var J=typeof $$$embind_global$$$=="object"&&R.$$$embind_global$$$==R;return J||delete R.$$$embind_global$$$,J}if(typeof $$$embind_global$$$=="object"||(typeof o2.g=="object"&&D(o2.g)?$$$embind_global$$$=o2.g:typeof self=="object"&&D(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")}function T2(D){return D===0?En.toHandle(ko()):(D=Io(D),En.toHandle(ko()[D]))}function Ys(D,R){return D=En.toValue(D),R=En.toValue(R),En.toHandle(D[R])}function No(D){D>4&&(wn[D].refcount+=1)}function Ro(D){return En.toHandle(Io(D))}function Hn(D){var R=En.toValue(D);ni(R),si(D)}function _r(D,R){D=Mo(D,"_emval_take_value");var J=D.readValueFromPointer(R);return En.toHandle(J)}function W(){ie("")}function F(){return!d}function oe(D,R,J){le.copyWithin(D,R,R+J)}function Me(){return 2147483648}function L(D){try{return b.grow(D-xe.byteLength+65535>>>16),e0(b.buffer),1}catch{}}function P(D){var R=le.length;D=D>>>0;var J=Me();if(D>J)return!1;let me=(y0,N0)=>y0+(N0-y0%N0)%N0;for(var Oe=1;Oe<=4;Oe*=2){var ze=R*(1+.2/Oe);ze=Math.min(ze,D+100663296);var Ve=Math.min(J,me(Math.max(D,ze),65536)),Pe=L(Ve);if(Pe)return!0}return!1}var B={xhrs:[],setu64:function(D,R){pe[D>>2]=R,pe[D+4>>2]=R/4294967296|0},openDatabase:function(D,R,J,me){try{var Oe=indexedDB.open(D,R)}catch(ze){return me(ze)}Oe.onupgradeneeded=ze=>{var Ve=ze.target.result;Ve.objectStoreNames.contains("FILES")&&Ve.deleteObjectStore("FILES"),Ve.createObjectStore("FILES")},Oe.onsuccess=ze=>J(ze.target.result),Oe.onerror=ze=>me(ze)},staticInit:function(){var D=J=>{B.dbInstance=J,ct()},R=()=>{B.dbInstance=!1,ct()};B.openDatabase("emscripten_filesystem",1,D,R),(typeof ENVIRONMENT_IS_FETCH_WORKER>"u"||!ENVIRONMENT_IS_FETCH_WORKER)&&rt()}};function j(D,R,J,me,Oe){var ze=pe[D+8>>2];if(!ze){J(D,0,"no url specified!");return}var Ve=E(ze),Pe=D+112,y0=E(Pe);y0||(y0="GET"),pe[D+4>>2];var N0=pe[Pe+52>>2],O0=pe[Pe+56>>2],$0=!!pe[Pe+60>>2];pe[Pe+64>>2];var st=pe[Pe+68>>2],$t=pe[Pe+72>>2],bx=pe[Pe+76>>2],jt=pe[Pe+80>>2],Ix=pe[Pe+84>>2],Xx=pe[Pe+88>>2],r0=!!(N0&1),B0=!!(N0&2),Kx=!!(N0&64),Ux=st?E(st):void 0,or=$t?E($t):void 0,tt=new XMLHttpRequest;if(tt.withCredentials=$0,tt.open(y0,Ve,!Kx,Ux,or),Kx||(tt.timeout=O0),tt.url_=Ve,tt.responseType="arraybuffer",jt){var un=E(jt);tt.overrideMimeType(un)}if(bx)for(;;){var Ar=pe[bx>>2];if(!Ar)break;var ns=pe[bx+4>>2];if(!ns)break;bx+=8;var Ay=E(Ar),Ey=E(ns);tt.setRequestHeader(Ay,Ey)}B.xhrs.push(tt);var oi=B.xhrs.length;pe[D+0>>2]=oi;var Cy=Ix&&Xx?le.slice(Ix,Ix+Xx):null;function Jh(Mn){var G2=0,rs=0;Mn&&(rs=tt.response?tt.response.byteLength:0,G2=Sr(rs),le.set(new Uint8Array(tt.response),G2)),pe[D+12>>2]=G2,B.setu64(D+16,rs)}tt.onload=Mn=>{Jh(r0&&!B0);var G2=tt.response?tt.response.byteLength:0;B.setu64(D+24,0),G2&&B.setu64(D+32,G2),ue[D+40>>1]=tt.readyState,ue[D+42>>1]=tt.status,tt.statusText&&I(tt.statusText,D+44,64),tt.status>=200&&tt.status<300?R&&R(D,tt,Mn):J&&J(D,tt,Mn)},tt.onerror=Mn=>{Jh(r0);var G2=tt.status;B.setu64(D+24,0),B.setu64(D+32,tt.response?tt.response.byteLength:0),ue[D+40>>1]=tt.readyState,ue[D+42>>1]=G2,J&&J(D,tt,Mn)},tt.ontimeout=Mn=>{J&&J(D,tt,Mn)},tt.onprogress=Mn=>{var G2=r0&&B0&&tt.response?tt.response.byteLength:0,rs=0;r0&&B0&&(rs=Sr(G2),le.set(new Uint8Array(tt.response),rs)),pe[D+12>>2]=rs,B.setu64(D+16,G2),B.setu64(D+24,Mn.loaded-G2),B.setu64(D+32,Mn.total),ue[D+40>>1]=tt.readyState,tt.readyState>=3&&tt.status===0&&Mn.loaded>0&&(tt.status=200),ue[D+42>>1]=tt.status,tt.statusText&&I(tt.statusText,D+44,64),me&&me(D,tt,Mn),rs&&Tr(rs)},tt.onreadystatechange=Mn=>{ue[D+40>>1]=tt.readyState,tt.readyState>=2&&(ue[D+42>>1]=tt.status),Oe&&Oe(D,tt,Mn)};try{tt.send(Cy)}catch(Mn){J&&J(D,tt,Mn)}}function fe(D,R){if(!v){if(R){D();return}try{D()}catch(J){D0(J)}}}function _e(D,R,J,me,Oe){if(!D){Oe(R,0,"IndexedDB not available!");return}var ze=R+112,Ve=pe[ze+64>>2];Ve||(Ve=pe[R+8>>2]);var Pe=E(Ve);try{var y0=D.transaction(["FILES"],"readwrite"),N0=y0.objectStore("FILES"),O0=N0.put(J,Pe);O0.onsuccess=$0=>{ue[R+40>>1]=4,ue[R+42>>1]=200,I("OK",R+44,64),me(R,0,Pe)},O0.onerror=$0=>{ue[R+40>>1]=4,ue[R+42>>1]=413,I("Payload Too Large",R+44,64),Oe(R,0,$0)}}catch($0){Oe(R,0,$0)}}function Se(D,R,J,me){if(!D){me(R,0,"IndexedDB not available!");return}var Oe=R+112,ze=pe[Oe+64>>2];ze||(ze=pe[R+8>>2]);var Ve=E(ze);try{var Pe=D.transaction(["FILES"],"readonly"),y0=Pe.objectStore("FILES"),N0=y0.get(Ve);N0.onsuccess=O0=>{if(O0.target.result){var $0=O0.target.result,st=$0.byteLength||$0.length,$t=Sr(st);le.set(new Uint8Array($0),$t),pe[R+12>>2]=$t,B.setu64(R+16,st),B.setu64(R+24,0),B.setu64(R+32,st),ue[R+40>>1]=4,ue[R+42>>1]=200,I("OK",R+44,64),J(R,0,$0)}else ue[R+40>>1]=4,ue[R+42>>1]=404,I("Not Found",R+44,64),me(R,0,"no data")},N0.onerror=O0=>{ue[R+40>>1]=4,ue[R+42>>1]=404,I("Not Found",R+44,64),me(R,0,O0)}}catch(O0){me(R,0,O0)}}function ve(D,R,J,me){if(!D){me(R,0,"IndexedDB not available!");return}var Oe=R+112,ze=pe[Oe+64>>2];ze||(ze=pe[R+8>>2]);var Ve=E(ze);try{var Pe=D.transaction(["FILES"],"readwrite"),y0=Pe.objectStore("FILES"),N0=y0.delete(Ve);N0.onsuccess=O0=>{var $0=O0.target.result;pe[R+12>>2]=0,B.setu64(R+16,0),B.setu64(R+24,0),B.setu64(R+32,0),ue[R+40>>1]=4,ue[R+42>>1]=200,I("OK",R+44,64),J(R,0,$0)},N0.onerror=O0=>{ue[R+40>>1]=4,ue[R+42>>1]=404,I("Not Found",R+44,64),me(R,0,O0)}}catch(O0){me(R,0,O0)}}function Ue(D,R,J,me,Oe){var ze=D+112,Ve=E(ze),Pe=pe[ze+36>>2],y0=pe[ze+40>>2],N0=pe[ze+44>>2],O0=pe[ze+48>>2],$0=pe[ze+52>>2],st=!!($0&4),$t=!!($0&32),bx=!!($0&16),jt=!!($0&64),Ix=(un,Ar,ns)=>{fe(()=>{Pe?u0(Pe)(un):R&&R(un)},jt)},Xx=(un,Ar,ns)=>{fe(()=>{N0?u0(N0)(un):me&&me(un)},jt)},r0=(un,Ar,ns)=>{fe(()=>{y0?u0(y0)(un):J&&J(un)},jt)},B0=(un,Ar,ns)=>{fe(()=>{O0?u0(O0)(un):Oe&&Oe(un)},jt)},Kx=(un,Ar,ns)=>{j(un,Ix,r0,Xx,B0)},Ux=(un,Ar,ns)=>{var Ay=(oi,Cy,Jh)=>{fe(()=>{Pe?u0(Pe)(oi):R&&R(oi)},jt)},Ey=(oi,Cy,Jh)=>{fe(()=>{Pe?u0(Pe)(oi):R&&R(oi)},jt)};_e(B.dbInstance,un,Ar.response,Ay,Ey)},or=(un,Ar,ns)=>{j(un,Ux,r0,Xx,B0)};if(Ve==="EM_IDB_STORE"){var tt=pe[ze+84>>2];_e(B.dbInstance,D,le.slice(tt,tt+pe[ze+88>>2]),Ix,r0)}else if(Ve==="EM_IDB_DELETE")ve(B.dbInstance,D,Ix,r0);else if(!bx)Se(B.dbInstance,D,Ix,$t?r0:st?or:Kx);else if(!$t)j(D,st?Ux:Ix,r0,Xx,B0);else return 0;return D}var Qe={};function g0(){return o||"./this.program"}function E0(){if(!E0.strings){var D=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",R={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:D,_:g0()};for(var J in Qe)Qe[J]===void 0?delete R[J]:R[J]=Qe[J];var me=[];for(var J in R)me.push(J+"="+R[J]);E0.strings=me}return E0.strings}function ot(D,R){var J=0;return E0().forEach(function(me,Oe){var ze=R+J;pe[D+Oe*4>>2]=ze,se(me,ze),J+=me.length+1}),0}function St(D,R){var J=E0();pe[D>>2]=J.length;var me=0;return J.forEach(function(Oe){me+=Oe.length+1}),pe[R>>2]=me,0}function Kt(D){return D%4===0&&(D%100!==0||D%400===0)}function mt(D,R){for(var J=0,me=0;me<=R;J+=D[me++]);return J}var Mx=[31,29,31,30,31,30,31,31,30,31,30,31],Fx=[31,28,31,30,31,30,31,31,30,31,30,31];function Cn(D,R){for(var J=new Date(D.getTime());R>0;){var me=Kt(J.getFullYear()),Oe=J.getMonth(),ze=(me?Mx:Fx)[Oe];if(R>ze-J.getDate())R-=ze-J.getDate()+1,J.setDate(1),Oe<11?J.setMonth(Oe+1):(J.setMonth(0),J.setFullYear(J.getFullYear()+1));else return J.setDate(J.getDate()+R),J}return J}function Tx(D,R,J,me){var Oe=ge[me+40>>2],ze={tm_sec:ge[me>>2],tm_min:ge[me+4>>2],tm_hour:ge[me+8>>2],tm_mday:ge[me+12>>2],tm_mon:ge[me+16>>2],tm_year:ge[me+20>>2],tm_wday:ge[me+24>>2],tm_yday:ge[me+28>>2],tm_isdst:ge[me+32>>2],tm_gmtoff:ge[me+36>>2],tm_zone:Oe?E(Oe):""},Ve=E(J),Pe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var y0 in Pe)Ve=Ve.replace(new RegExp(y0,"g"),Pe[y0]);var N0=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],O0=["January","February","March","April","May","June","July","August","September","October","November","December"];function $0(r0,B0,Kx){for(var Ux=typeof r0=="number"?r0.toString():r0||"";Ux.length<B0;)Ux=Kx[0]+Ux;return Ux}function st(r0,B0){return $0(r0,B0,"0")}function $t(r0,B0){function Kx(or){return or<0?-1:or>0?1:0}var Ux;return(Ux=Kx(r0.getFullYear()-B0.getFullYear()))===0&&(Ux=Kx(r0.getMonth()-B0.getMonth()))===0&&(Ux=Kx(r0.getDate()-B0.getDate())),Ux}function bx(r0){switch(r0.getDay()){case 0:return new Date(r0.getFullYear()-1,11,29);case 1:return r0;case 2:return new Date(r0.getFullYear(),0,3);case 3:return new Date(r0.getFullYear(),0,2);case 4:return new Date(r0.getFullYear(),0,1);case 5:return new Date(r0.getFullYear()-1,11,31);case 6:return new Date(r0.getFullYear()-1,11,30)}}function jt(r0){var B0=Cn(new Date(r0.tm_year+1900,0,1),r0.tm_yday),Kx=new Date(B0.getFullYear(),0,4),Ux=new Date(B0.getFullYear()+1,0,4),or=bx(Kx),tt=bx(Ux);return $t(or,B0)<=0?$t(tt,B0)<=0?B0.getFullYear()+1:B0.getFullYear():B0.getFullYear()-1}var Ix={"%a":function(r0){return N0[r0.tm_wday].substring(0,3)},"%A":function(r0){return N0[r0.tm_wday]},"%b":function(r0){return O0[r0.tm_mon].substring(0,3)},"%B":function(r0){return O0[r0.tm_mon]},"%C":function(r0){var B0=r0.tm_year+1900;return st(B0/100|0,2)},"%d":function(r0){return st(r0.tm_mday,2)},"%e":function(r0){return $0(r0.tm_mday,2," ")},"%g":function(r0){return jt(r0).toString().substring(2)},"%G":function(r0){return jt(r0)},"%H":function(r0){return st(r0.tm_hour,2)},"%I":function(r0){var B0=r0.tm_hour;return B0==0?B0=12:B0>12&&(B0-=12),st(B0,2)},"%j":function(r0){return st(r0.tm_mday+mt(Kt(r0.tm_year+1900)?Mx:Fx,r0.tm_mon-1),3)},"%m":function(r0){return st(r0.tm_mon+1,2)},"%M":function(r0){return st(r0.tm_min,2)},"%n":function(){return`
`},"%p":function(r0){return r0.tm_hour>=0&&r0.tm_hour<12?"AM":"PM"},"%S":function(r0){return st(r0.tm_sec,2)},"%t":function(){return"	"},"%u":function(r0){return r0.tm_wday||7},"%U":function(r0){var B0=r0.tm_yday+7-r0.tm_wday;return st(Math.floor(B0/7),2)},"%V":function(r0){var B0=Math.floor((r0.tm_yday+7-(r0.tm_wday+6)%7)/7);if((r0.tm_wday+371-r0.tm_yday-2)%7<=2&&B0++,B0){if(B0==53){var Kx=(r0.tm_wday+371-r0.tm_yday)%7;Kx!=4&&(Kx!=3||!Kt(r0.tm_year))&&(B0=1)}}else{B0=52;var Ux=(r0.tm_wday+7-r0.tm_yday-1)%7;(Ux==4||Ux==5&&Kt(r0.tm_year%400-1))&&B0++}return st(B0,2)},"%w":function(r0){return r0.tm_wday},"%W":function(r0){var B0=r0.tm_yday+7-(r0.tm_wday+6)%7;return st(Math.floor(B0/7),2)},"%y":function(r0){return(r0.tm_year+1900).toString().substring(2)},"%Y":function(r0){return r0.tm_year+1900},"%z":function(r0){var B0=r0.tm_gmtoff,Kx=B0>=0;return B0=Math.abs(B0)/60,B0=B0/60*100+B0%60,(Kx?"+":"-")+String("0000"+B0).slice(-4)},"%Z":function(r0){return r0.tm_zone},"%%":function(){return"%"}};Ve=Ve.replace(/%%/g,"\0\0");for(var y0 in Ix)Ve.includes(y0)&&(Ve=Ve.replace(new RegExp(y0,"g"),Ix[y0](ze)));Ve=Ve.replace(/\0\0/g,"%");var Xx=Kh(Ve,!1);return Xx.length>R?0:(te(Xx,D),Xx.length-1)}function Tc(D,R,J,me){return Tx(D,R,J,me)}k0(),en=n.BindingError=zt(Error,"BindingError"),yx=n.InternalError=zt(Error,"InternalError"),mx(),xn(),lc(),ar=n.UnboundTypeError=zt(Error,"UnboundTypeError"),ai(),B.staticInit();function Kh(D,R,J){var me=J>0?J:C(D)+1,Oe=new Array(me),ze=M(D,Oe,0,Oe.length);return R&&(Oe.length=ze),Oe}var $h={b:b0,d:Et,u:xx,B:ne,m:cc,g:Vs,e:Hs,q:Co,A:dc,t:pc,f:mc,a:gc,s:yc,n:bc,C:vc,D:wc,h:_c,c:si,p:T2,i:Ys,o:No,l:Ro,k:Hn,j:_r,r:W,F,z:oe,y:P,E:Ue,w:ot,x:St,v:Tc};K0(),n.___wasm_call_ctors=function(){return(n.___wasm_call_ctors=n.asm.H).apply(null,arguments)};var Sr=n._malloc=function(){return(Sr=n._malloc=n.asm.I).apply(null,arguments)},Tr=n._free=function(){return(Tr=n._free=n.asm.K).apply(null,arguments)},LC=n.___getTypeName=function(){return(LC=n.___getTypeName=n.asm.L).apply(null,arguments)};n.___embind_register_native_and_builtin_types=function(){return(n.___embind_register_native_and_builtin_types=n.asm.M).apply(null,arguments)};var DC=n.___cxa_is_pointer_type=function(){return(DC=n.___cxa_is_pointer_type=n.asm.N).apply(null,arguments)};n.dynCall_viijii=function(){return(n.dynCall_viijii=n.asm.O).apply(null,arguments)},n.dynCall_iiiiij=function(){return(n.dynCall_iiiiij=n.asm.P).apply(null,arguments)},n.dynCall_iiiiijj=function(){return(n.dynCall_iiiiijj=n.asm.Q).apply(null,arguments)},n.dynCall_iiiiiijj=function(){return(n.dynCall_iiiiiijj=n.asm.R).apply(null,arguments)};var Zh;function Sne(D){this.name="ExitStatus",this.message="Program terminated with exit("+D+")",this.status=D}d0=function D(){Zh||Ty(),Zh||(d0=D)};function Ty(D){if(m0>0||(Te(),m0>0))return;function R(){Zh||(Zh=!0,n.calledRun=!0,!v&&(Ie(),r(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),Xe()))}n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),R()},1)):R()}if(n.run=Ty,n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);n.preInit.length>0;)n.preInit.pop()();return Ty(),x.ready}})();Ce().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var R2;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(R2||(R2={}));var Tw;(function(s){(function(x){x[x.LEGACY=0]="LEGACY",x[x.V1=1]="V1",x[x.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(Tw||(Tw={}));const p5={};function Aw(s){return p5[s]}function N(s,x,n,r,a){const i=x.inputParams[s];if(i&&i.inputIndexStart!==void 0){const l=i.inputIndexStart,c=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?l+1:i.inputIndexEnd;if(i.type==="tensor")return Pn(x.inputNames[i.inputIndexStart],n,r,a);if(i.type==="tensors")return x.inputNames.slice(l,c).map(p=>Pn(p,n,r,a));const d=Pn(x.inputNames.slice(l)[0],n,r,a),h=d.dataSync();return i.type==="number"?h[0]:lx(d.shape,h)}const o=x.attrParams[s];return o&&o.value}function Pn(s,x,n,r){const[a,i]=r2(s);if(r!=null){const l=r.getHashTableHandleByName(a);if(l!=null)return l}const o=n.currentContextIds.find(l=>!!x[nd(a,l)]);return o!==void 0?x[nd(a,o)][i]:void 0}function f5(s,x,n){return x[nd(s,n.currentContextId)]}function Ur(s,x){const[n,r,a]=r2(s);return[nd(n,x&&x.currentContextId),r,a]}function nd(s,x){return x?s+"-"+x:s}function r2(s){const x=s.split(":");if(x.length===1)return[s,0,void 0];const n=x[0],r=x.length===3?x[1]:void 0,a=Number(x[x.length-1]);return[n,a,r]}function rd(s,x,n){let r=N("pad",s,x,n);if(r==="explicit"){r=N("explicitPaddings",s,x,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)a[i][0]=r[i*2],a[i][1]=r[i*2+1];return a}return r}function Br(s){return s.kept?s:hs(s)}var m5=Object.freeze({__proto__:null,json:[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),g5=Object.freeze({__proto__:null,json:[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),y5=Object.freeze({__proto__:null,json:[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]}),b5=Object.freeze({__proto__:null,json:[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]}),v5=Object.freeze({__proto__:null,json:[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]}),w5=Object.freeze({__proto__:null,json:[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),_5=Object.freeze({__proto__:null,json:[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]}),S5=Object.freeze({__proto__:null,json:[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]}),T5=Object.freeze({__proto__:null,json:[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]}),A5=Object.freeze({__proto__:null,json:[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]}),E5=Object.freeze({__proto__:null,json:[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]}),C5=Object.freeze({__proto__:null,json:[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}]}),M5=Object.freeze({__proto__:null,json:[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}]}),I5=Object.freeze({__proto__:null,json:[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]}),k5=Object.freeze({__proto__:null,json:[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}]}),N5=Object.freeze({__proto__:null,json:[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]}),R5=Object.freeze({__proto__:null,json:[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]}),P5=Object.freeze({__proto__:null,json:[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]}),L5=Object.freeze({__proto__:null,json:[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]});class Ew{constructor(){const x=[m5,g5,y5,b5,v5,w5,_5,S5,T5,A5,E5,C5,M5,I5,k5,N5,R5,P5,L5],n=[].concat(...x.map(r=>r.json));this.opMappers=n.reduce((r,a)=>(r[a.tfOpName]=a,r),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(x,n={}){const r=x.node,a=[],i=[],o=[],l=r.reduce((b,v)=>(b[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?a.push(b[v.name]):v.op==="Const"?i.push(b[v.name]):(v.input==null||v.input.length===0)&&o.push(b[v.name]),b),{});let c=[];const d=[];let h={},p={};n!=null&&(h=this.mapSignatureEntries(n.inputs),p=this.mapSignatureEntries(n.outputs));const m=Object.keys(l);m.forEach(b=>{const v=l[b];v.inputNames.forEach((w,_)=>{const[T,,A]=Ur(w),E=l[T];if(E.outputs!=null){const M=E.outputs.indexOf(A);if(M!==-1){const I=T+":"+M;v.inputNames[_]=I}}v.inputs.push(E),E.children.push(v)})}),Object.keys(p).length===0?m.forEach(b=>{const v=l[b];v.children.length===0&&d.push(v)}):Object.keys(p).forEach(b=>{const[v]=Ur(b),w=l[v];w!=null&&(w.signatureKey=p[b],d.push(w))}),Object.keys(h).length>0?Object.keys(h).forEach(b=>{const[v]=Ur(b),w=l[v];w&&(w.signatureKey=h[b],c.push(w))}):c=a;let g={};x.library!=null&&x.library.function!=null&&(g=x.library.function.reduce((b,v)=>(b[v.signature.name]=this.mapFunction(v),b),{}));const y={nodes:l,inputs:c,outputs:d,weights:i,placeholders:a,signature:n,functions:g};return o.length>0&&(y.initNodes=o),y}mapSignatureEntries(x){return Object.keys(x||{}).reduce((n,r)=>(n[x[r].name]=r,n),{})}mapNode(x){const n=Aw(x.op)||this.opMappers[x.op]||{};x.attr==null&&(x.attr={});const r={name:x.name,op:x.op,category:n.category,inputNames:(x.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:x.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((a,i)=>(a[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},a),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((a,i)=>{const o=i.type;let l;switch(i.type){case"string":l=sg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=sg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":l=hg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=hg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":l=ig(x.attr,i.tfName,i.defaultValue||0),l===void 0&&!!i.tfDeprecatedName&&(l=ig(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":l=dg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=dg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":l=ag(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=ag(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":l=fg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=fg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":l=ug(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=ug(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":l=pg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=pg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":l=lg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=lg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":l=cg(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=cg(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":l=Mw(x.attr,i.tfName,i.defaultValue),l===void 0&&!!i.tfDeprecatedName&&(l=Mw(x.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+i.type+" for op: "+x.op)}return a[i.name]={value:l,type:o},a},{})),r}mapFunction(x){const n=x.nodeDef,r=[],a=[];let i={};n!=null&&(i=n.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&a.push(h[p.name]),h),{}));const o=[],l=[];x.signature.inputArg.forEach(h=>{const[p]=Ur(h.name),m={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:og(h.type),type:"dtype"}},children:[]};m.signatureKey=h.name,o.push(m),i[p]=m}),Object.keys(i).forEach(h=>{const p=i[h];p.inputNames.forEach((m,g)=>{const[y,,b]=Ur(m),v=i[y];if(v.outputs!=null){const w=v.outputs.indexOf(b);if(w!==-1){const _=y+":"+w;p.inputNames[g]=_}}p.inputs.push(v),v.children.push(p)})});const c=x.ret;x.signature.outputArg.forEach(h=>{const[p,m]=Ur(c[h.name]),g=i[p];g!=null&&(g.defaultOutput=m,l.push(g))});const d=this.mapArgsToSignature(x);return{nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:d}}mapArgsToSignature(x){return{methodName:x.signature.name,inputs:x.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:x.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,x.ret),n),{})}}mapArgToTensorInfo(x,n){let r=x.name;return n!=null&&(r=n[r]),{name:r,dtype:x.type}}}function D5(s){const x=Ce().global;if(typeof x.atob<"u")return x.atob(s);if(typeof Buffer<"u")return new Buffer(s,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Cw(s,x){const n=Array.isArray(s)?String.fromCharCode.apply(null,s):D5(s);return x?n:n.toLowerCase()}function sg(s,x,n,r=!1){const a=s[x];return a!=null?Cw(a.s,r):n}function ag(s,x,n){const r=s[x];return r?r.b:n}function ig(s,x,n){const r=s[x]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function og(s){switch(typeof s=="string"&&(s=R2[s]),s){case R2.DT_FLOAT:case R2.DT_HALF:return"float32";case R2.DT_INT32:case R2.DT_INT64:case R2.DT_INT8:case R2.DT_UINT8:return"int32";case R2.DT_BOOL:return"bool";case R2.DT_DOUBLE:return"float32";case R2.DT_STRING:return"string";default:return null}}function Mw(s,x,n){const r=s[x];return r&&r.func?r.func.name:n}function lg(s,x,n){const r=s[x];return r&&r.type?og(r.type):n}function cg(s,x,n){const r=s[x];return r&&r.list&&r.list.type?r.list.type.map(a=>og(a)):n}function Iw(s){if(!s.unknownRank)return s.dim!=null?s.dim.map(x=>typeof x.size=="number"?x.size:parseInt(x.size,10)):[]}function ug(s,x,n){const r=s[x];return r&&r.shape?Iw(r.shape):n}function dg(s,x,n){const r=s[x];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function hg(s,x,n,r=!1){const a=s[x];return a&&a.list&&a.list.s?a.list.s.map(i=>Cw(i,r)):n}function pg(s,x,n){const r=s[x];return r&&r.list&&r.list.shape?r.list.shape.map(a=>Iw(a)):n}function fg(s,x,n){const r=s[x];return r&&r.list&&r.list.b?r.list.b:n}class O5{constructor(x,n,r){this.node=x,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=x.inputNames.map(a=>this.getInput(a)),x.rawAttrs!=null&&(this.attrs=Object.keys(x.rawAttrs).reduce((a,i)=>(a[i]=this.getAttr(i),a),{}))}getInput(x){return Pn(x,this.tensorMap,this.context)}getAttr(x,n){const r=this.node.rawAttrs[x];if(r.tensor!=null)return Pn(x,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return ig(this.node.rawAttrs,x,n);if(r.s!=null)return sg(this.node.rawAttrs,x,n);if(r.b!=null)return ag(this.node.rawAttrs,x,n);if(r.shape!=null)return ug(this.node.rawAttrs,x,n);if(r.type!=null)return lg(this.node.rawAttrs,x,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return dg(this.node.rawAttrs,x,n);if(r.list.s!=null)return hg(this.node.rawAttrs,x,n);if(r.list.shape!=null)return pg(this.node.rawAttrs,x,n);if(r.list.b!=null)return fg(this.node.rawAttrs,x,n);if(r.list.type!=null)return cg(this.node.rawAttrs,x,n)}return n}}var pn=Object.freeze({__proto__:null,abs:d2,acos:KM,acosh:ZM,add:j0,addN:QM,all:eI,any:xI,argMax:rI,argMin:aI,asin:oI,asinh:cI,atan:dI,atan2:pI,atanh:mI,avgPool:Rb,avgPool3d:TI,basicLSTMCell:NI,batchToSpaceND:Pb,batchNorm:zu,batchNorm2d:OI,batchNorm3d:UI,batchNorm4d:zI,bincount:Lb,broadcastArgs:VI,broadcastTo:Yo,buffer:At,cast:zx,ceil:qI,clipByValue:Db,clone:hs,complex:cs,concat:Rn,concat1d:$I,concat2d:Wu,concat3d:QI,concat4d:e3,conv1d:n3,conv2d:Gu,conv2dTranspose:a3,conv3d:o3,conv3dTranspose:d3,cos:p3,cosh:m3,cumprod:y3,cumsum:v3,denseBincount:_3,depthToSpace:T3,depthwiseConv2d:lm,diag:C3,dilation2d:I3,div:Ht,divNoNan:L3,dot:O3,einsum:U3,elu:Bb,equal:Ub,erf:W3,euclideanNorm:Z3,exp:na,expandDims:Rr,expm1:ek,eye:Gb,fill:qo,floor:Vb,floorDiv:Nb,gather:Hb,greater:Hu,greaterEqual:Yb,imag:Yu,isFinite:lk,isInf:uk,isNaN:hk,leakyRelu:qb,less:mk,lessEqual:dm,linspace:yk,localResponseNormalization:vk,log:Zo,log1p:Xb,logSigmoid:Ck,logSoftmax:kk,logSumExp:$b,logicalAnd:qu,logicalNot:Zb,logicalOr:Jb,logicalXor:Ok,lowerBound:Uk,matMul:ax,max:vi,maxPool:Qb,maxPool3d:Wk,maxPoolWithArgmax:Vk,maximum:jb,mean:Ku,meshgrid:qk,min:um,minimum:ev,mirrorPad:$k,mod:Jk,moments:jk,mul:A0,multiRNNCell:tN,multinomial:nN,neg:Lr,notEqual:tv,oneHot:aN,ones:ra,onesLike:oN,outerProduct:cN,pad:sa,pad1d:hN,pad2d:fN,pad3d:gN,pad4d:bN,pool:TN,pow:Ko,prelu:nv,print:Mb,prod:CN,raggedGather:IN,raggedRange:NN,raggedTensorToTensor:PN,rand:DN,randomGamma:YN,randomNormal:uv,randomStandardNormal:KN,randomUniform:dv,range:Jo,real:Qo,reciprocal:QN,relu:Zu,relu6:hv,reshape:Be,reverse:ia,reverse1d:nR,reverse2d:sR,reverse3d:iR,reverse4d:lR,round:pv,rsqrt:dR,scalar:Pt,selu:pR,separableConv2d:mR,setdiff1dAsync:yR,sigmoid:fs,sign:vR,sin:_R,sinh:TR,slice:Ct,slice1d:ER,slice2d:MR,slice3d:kR,slice4d:RR,softmax:LR,softplus:Kb,spaceToBatchND:xv,fft:fm,ifft:Ju,irfft:fv,rfft:mm,split:jo,sqrt:Nr,square:q2,squaredDifference:mv,squeeze:qn,stack:Dr,step:gv,stridedSlice:YR,sub:gt,sum:fx,tan:XR,tanh:om,tensor:lr,tensor1d:Xn,tensor2d:oa,tensor3d:yv,tensor4d:KR,tensor5d:$R,tensor6d:ZR,tile:$o,topk:QR,truncatedNormal:e4,unique:x4,unsortedSegmentSum:r4,unstack:la,upperBound:a4,variable:i4,where:bi,whereAsync:bv,zeros:X2,zerosLike:h2,op:ce,OP_SCOPE_SUFFIX:pb,booleanMaskAsync:c4,transpose:ym,norm:Vu,movingAverage:h4,scatterND:f4,searchSorted:hm,sparseToDense:y4,gatherND:v4,dropout:S4,enclosingPowerOfTwo:_v,cosineWindow:bm,inTopKAsync:A4,image:dr,linalg:h9,losses:p9,spectral:u9,fused:U4,signal:d9,sparse:f9,string:m9});const F5=(s,x,n,r=pn)=>{switch(s.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(N("a",s,x,n),N("b",s,x,n))];case"AddN":return[r.addN(N("tensors",s,x,n))];case"FloorMod":case"Mod":return[r.mod(N("a",s,x,n),N("b",s,x,n))];case"Mul":return[r.mul(N("a",s,x,n),N("b",s,x,n))];case"RealDiv":case"Div":return[r.div(N("a",s,x,n),N("b",s,x,n))];case"DivNoNan":return[r.divNoNan(N("a",s,x,n),N("b",s,x,n))];case"FloorDiv":return[r.floorDiv(N("a",s,x,n),N("b",s,x,n))];case"Sub":return[r.sub(N("a",s,x,n),N("b",s,x,n))];case"Minimum":return[r.minimum(N("a",s,x,n),N("b",s,x,n))];case"Maximum":return[r.maximum(N("a",s,x,n),N("b",s,x,n))];case"Pow":return[r.pow(N("a",s,x,n),N("b",s,x,n))];case"SquaredDifference":return[r.squaredDifference(N("a",s,x,n),N("b",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},U5=(s,x,n,r=pn)=>{switch(s.op){case"Abs":case"ComplexAbs":return[r.abs(N("x",s,x,n))];case"Acos":return[r.acos(N("x",s,x,n))];case"Acosh":return[r.acosh(N("x",s,x,n))];case"Asin":return[r.asin(N("x",s,x,n))];case"Asinh":return[r.asinh(N("x",s,x,n))];case"Atan":return[r.atan(N("x",s,x,n))];case"Atan2":return[r.atan2(N("x",s,x,n),N("y",s,x,n))];case"Atanh":return[r.atanh(N("x",s,x,n))];case"Ceil":return[r.ceil(N("x",s,x,n))];case"Complex":return[r.complex(N("real",s,x,n),N("imag",s,x,n))];case"Cos":return[r.cos(N("x",s,x,n))];case"Cosh":return[r.cosh(N("x",s,x,n))];case"Elu":return[r.elu(N("x",s,x,n))];case"Erf":return[r.erf(N("x",s,x,n))];case"Exp":return[r.exp(N("x",s,x,n))];case"Expm1":return[r.expm1(N("x",s,x,n))];case"Floor":return[r.floor(N("x",s,x,n))];case"Log":return[r.log(N("x",s,x,n))];case"Log1p":return[r.log1p(N("x",s,x,n))];case"Imag":return[r.imag(N("x",s,x,n))];case"Neg":return[r.neg(N("x",s,x,n))];case"Reciprocal":return[r.reciprocal(N("x",s,x,n))];case"Real":return[r.real(N("x",s,x,n))];case"Relu":return[r.relu(N("x",s,x,n))];case"Round":return[r.round(N("x",s,x,n))];case"Selu":return[r.selu(N("x",s,x,n))];case"Sigmoid":return[r.sigmoid(N("x",s,x,n))];case"Sin":return[r.sin(N("x",s,x,n))];case"Sign":return[r.sign(N("x",s,x,n))];case"Sinh":return[r.sinh(N("x",s,x,n))];case"Softplus":return[r.softplus(N("x",s,x,n))];case"Sqrt":return[r.sqrt(N("x",s,x,n))];case"Square":return[r.square(N("x",s,x,n))];case"Tanh":return[r.tanh(N("x",s,x,n))];case"Tan":return[r.tan(N("x",s,x,n))];case"ClipByValue":return[r.clipByValue(N("x",s,x,n),N("clipValueMin",s,x,n),N("clipValueMax",s,x,n))];case"Relu6":return[r.relu6(N("x",s,x,n))];case"Rsqrt":return[r.rsqrt(Pn(s.inputNames[0],x,n))];case"Prod":return[r.prod(N("x",s,x,n),N("axes",s,x,n))];case"LeakyRelu":return[r.leakyRelu(N("x",s,x,n),N("alpha",s,x,n))];case"Prelu":return[r.prelu(N("x",s,x,n),N("alpha",s,x,n))];case"IsNan":return[r.isNaN(Pn(s.inputNames[0],x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}};function P2(s,x,n=""){if(!(typeof s=="number"||typeof x=="number")){G(s.length===x.length,()=>n+(" Shapes "+s+" and "+x+" must match"));for(let r=0;r<s.length;r++){const a=s[r],i=x[r];G(a<0||i<0||a===i,()=>n+(" Shapes "+s+" and "+x+" must match"))}}}function kw(s){return!(typeof s=="number"||s.some(x=>x<0))}function rl(s,x,n){let r=mg(s,n);const a=!kw(r);if(a&&x.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+r);if(a&&x.forEach(i=>{r=mg(i.shape,r)}),!kw(r))throw new Error("Non-fully-defined elementShape: "+r);return r}function mg(s,x){if(typeof s=="number")return x;if(typeof x=="number")return s;if(s.length!==x.length)throw new Error("Incompatible ranks during merge: "+s+" vs. "+x);const n=[];for(let r=0;r<s.length;++r){const a=s[r],i=x[r];if(a>=0&&i>=0&&a!==i)throw new Error("Incompatible shape during merge: "+s+" vs. "+x);n[r]=a>=0?a:i}return n}class B5{constructor(x,n,r,a,i,o,l){this.name=x,this.dtype=n,this.maxSize=r,this.elementShape=a,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=l,this.tensors=[],this.closed_=!1,this.idTensor=Pt(0),ur(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(x){this.tensors.forEach(n=>{(x==null||!x.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(x){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(x<0||x>=this.size())throw new Error("Tried to read from index "+x+", but array size is: "+this.size());const n=this.tensors[x];if(n.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+x+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(x){return x.map(n=>this.read(n))}write(x,n){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(x<0||!this.dynamicSize&&x>=this.maxSize)throw new Error("Tried to write to index "+x+", but array is not resizeable and size is: "+this.maxSize);const r=this.tensors[x]||{};if(n.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+x+`,
          because the value dtype is `+n.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),P2(this.elementShape,n.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+x+"."),r.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+x+", because it has already been read.");if(r.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+x+", because it has already been written.");r.tensor=n,ur(n),r.written=!0,this.tensors[x]=r}writeMany(x,n){if(x.length!==n.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+x.length+" is not the same as tensors size: "+n.length+".");x.forEach((r,a)=>this.write(r,n[a]))}gather(x,n){if(!!n&&n!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+n);if(x)x=x.slice(0,this.size());else{x=[];for(let a=0;a<this.size();a++)x.push(a)}if(x.length===0)return lr([],[0].concat(this.elementShape));const r=this.readMany(x);return P2(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Dr(r,0)}concat(x){if(!!x&&x!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+x);if(this.size()===0)return lr([],[0].concat(this.elementShape));const n=[];for(let a=0;a<this.size();a++)n.push(a);const r=this.readMany(n);return P2(this.elementShape,r[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+r[0].shape+")"),Rn(r,0)}scatter(x,n){if(n.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+n.dtype);if(x.length!==n.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+x.length+" vs. "+n.shape[0]);const r=Math.max(...x);if(!this.dynamicSize&&r>=this.maxSize)throw new Error("Max index must be < array size ("+r+"  vs. "+this.maxSize+")");this.writeMany(x,la(n,0))}split(x,n){if(n.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+n.dtype);let r=0;const a=x.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+r+", and tensor's shape is: "+n.shape);if(!this.dynamicSize&&x.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+x.length+"), and the TensorArray is not marked as dynamically resizeable");const i=r===0?0:n.size/r,o=[];vt(()=>{n=Be(n,[1,r,i]);for(let c=0;c<x.length;++c){const d=c===0?0:a[c-1],h=[0,d,0],p=[1,x[c],i];o[c]=Be(Ct(n,h,p),this.elementShape)}return o});const l=[];for(let c=0;c<x.length;c++)l[c]=c;this.writeMany(l,o)}}class fa{constructor(x,n,r,a=-1){this.tensors=x,this.elementShape=n,this.elementDtype=r,x?.forEach(i=>{if(r!==i.dtype)throw new Error("Invalid data types; op elements "+r+", but list elements "+i.dtype);P2(n,i.shape,"TensorList shape mismatch: "),ur(i)}),this.idTensor=Pt(0),this.maxNumElements=a,ur(this.idTensor)}get id(){return this.idTensor.id}copy(){return new fa([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(x){this.tensors.forEach(n=>{(x==null||!x.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(x,n,r=-1){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements "+n+", but list elements "+this.elementDtype);if(r!==-1&&this.tensors.length!==r)throw new Error("Operation expected a list with "+r+" elements but got a list with "+this.tensors.length+" elements.");P2(x,this.elementShape,"TensorList shape mismatch: ");const a=rl(this.elementShape,this.tensors,x);return vt(()=>{const i=this.tensors.map(o=>Be(o,a));return Dr(i,0)})}popBack(x,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements "+n+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=rl(this.elementShape,this.tensors,x),a=this.tensors.pop();return a.kept=!1,P2(a.shape,x,"TensorList shape mismatch: "),Be(a,r)}pushBack(x){if(x.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+x.dtype+", but list elements "+this.elementDtype);if(P2(x.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ur(x),this.tensors.push(x)}resize(x){if(x<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+x);if(this.maxNumElements!==-1&&x>this.maxNumElements)throw new Error("TensorListResize input size "+x+" is greater maxNumElement "+this.maxNumElements+".");const n=new fa([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=x;for(let r=0;r<Math.min(this.tensors.length,x);++r)n.tensors[r]=this.tensors[r];return n}getItem(x,n,r){if(r!==this.elementDtype)throw new Error("Invalid data types; op elements "+r+", but list elements "+this.elementDtype);if(x<0||x>this.tensors.length)throw new Error("Trying to access element "+x+" in a list with "+this.tensors.length+" elements.");if(this.tensors[x]==null)throw new Error("element at index "+x+" is null.");P2(this.tensors[x].shape,n,"TensorList shape mismatch: ");const a=rl(this.elementShape,this.tensors,n);return Be(this.tensors[x],a)}setItem(x,n){if(n.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+n.dtype+", but list elements "+this.elementDtype);if(x<0||this.maxNumElements!==-1&&x>=this.maxNumElements)throw new Error("Trying to set element "+x+" in a list with max "+this.maxNumElements+" elements.");P2(this.elementShape,n.shape,"TensorList shape mismatch: "),ur(n),this.tensors[x]!=null&&(this.tensors[x].kept=!1),this.tensors[x]=n}gather(x,n,r){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements "+n+", but list elements "+this.elementDtype);P2(this.elementShape,r,"TensorList shape mismatch: "),x=x.slice(0,this.size());const a=rl(this.elementShape,this.tensors,r);return x.length===0?lr([],[0].concat(a)):vt(()=>{const i=x.map(o=>Be(this.tensors[o],a));return Dr(i,0)})}concat(x,n){if(!!x&&x!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+x);P2(this.elementShape,n,"TensorList shape mismatch: ");const r=rl(this.elementShape,this.tensors,n);return this.size()===0?lr([],[0].concat(r)):vt(()=>{const a=this.tensors.map(i=>Be(i,r));return Rn(a,0)})}}function z5(s,x,n){const r=s.dtype;if(s.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+s.shape);if(s.dtype!==n)throw new Error("Invalid data types; op elements "+s.dtype+", but list elements "+n);const a=s.shape.slice(1);P2(a,x,"TensorList shape mismatch: ");const i=la(s);return new fa(i,x,r)}function W5(s,x,n,r){return new fa([],s,x,r)}function G5(s,x,n,r){if(x.length!==s.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+x.length+" vs. "+s.shape[0]);const a=Math.max(...x);if(r!=null&&r!==-1&&a>=r)throw new Error("Max index must be < array size ("+a+"  vs. "+r+")");const i=new fa([],n,s.dtype,r),o=la(s,0);return x.forEach((l,c)=>{i.setItem(l,o[c])}),i}function V5(s,x,n){let r=0;const a=x.map(h=>(r+=h,r));if(r!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+r+", and tensor's shape is: "+s.shape);const i=s.shape.slice(1),o=mg(i,n),l=r===0?0:s.size/r,c=vt(()=>{const h=[];s=Be(s,[1,r,l]);for(let p=0;p<x.length;++p){const m=p===0?0:a[p-1],g=[0,m,0],y=[1,x[p],l];h[p]=Be(Ct(s,g,y),o)}return s.dispose(),h}),d=new fa([],n,s.dtype,x.length);for(let h=0;h<c.length;h++)d.setItem(h,c[h]);return d}const H5=async(s,x,n)=>{switch(s.op){case"If":case"StatelessIf":{const r=N("thenBranch",s,x,n),a=N("elseBranch",s,x,n),i=N("cond",s,x,n),o=N("args",s,x,n);return(await i.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=N("body",s,x,n),a=N("cond",s,x,n),i=N("args",s,x,n),o=await n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),l=i.map(h=>h.id);let c=await o[0].data();o.forEach(h=>{!h.kept&&l.indexOf(h.id)===-1&&h.dispose()});let d=i;for(;c[0];){const h=d;d=await n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);const p=d.map(g=>g.id);h.forEach(g=>{!g.kept&&l.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()});const m=await n.functionMap[a].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);c=await m[0].data(),m.forEach(g=>{!g.kept&&l.indexOf(g.id)===-1&&p.indexOf(g.id)===-1&&g.dispose()})}return d}case"LoopCond":{const r=N("pred",s,x,n);return[Br(r)]}case"Switch":{const r=N("pred",s,x,n);let a=N("data",s,x,n);return a.kept||(a=Br(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=s.inputNames.find(a=>Pn(a,x,n)!==void 0);if(r){const a=Pn(r,x,n);return[Br(a)]}return}case"Enter":{const r=N("frameName",s,x,n),a=N("tensor",s,x,n);return n.enterFrame(r),[Br(a)]}case"Exit":{const r=N("tensor",s,x,n);return n.exitFrame(),[Br(r)]}case"NextIteration":{const r=N("tensor",s,x,n);return n.nextIteration(),[Br(r)]}case"TensorArrayV3":{const r=N("size",s,x,n),a=N("dtype",s,x,n),i=N("elementShape",s,x,n),o=N("dynamicSize",s,x,n),l=N("clearAfterRead",s,x,n),c=N("identicalElementShapes",s,x,n),d=N("name",s,x,n),h=new B5(d,a,r,i,c,o,l);return n.addTensorArray(h),[h.idTensor,Pt(1)]}case"TensorArrayWriteV3":{const r=N("tensorArrayId",s,x,n),a=N("index",s,x,n),i=N("tensor",s,x,n),o=n.getTensorArray(r.id);return o.write(a,i),[o.idTensor]}case"TensorArrayReadV3":{const r=N("tensorArrayId",s,x,n),a=N("index",s,x,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=N("tensorArrayId",s,x,n),a=N("indices",s,x,n),i=N("dtype",s,x,n);return[n.getTensorArray(r.id).gather(a,i)]}case"TensorArrayScatterV3":{const r=N("tensorArrayId",s,x,n),a=N("indices",s,x,n),i=N("tensor",s,x,n),o=n.getTensorArray(r.id);return o.scatter(a,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=N("tensorArrayId",s,x,n),a=n.getTensorArray(r.id),i=N("dtype",s,x,n);return[a.concat(i)]}case"TensorArraySplitV3":{const r=N("tensorArrayId",s,x,n),a=N("tensor",s,x,n),i=N("lengths",s,x,n),o=n.getTensorArray(r.id);return o.split(i,a),[o.idTensor]}case"TensorArraySizeV3":{const r=N("tensorArrayId",s,x,n),a=n.getTensorArray(r.id);return[Pt(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=N("tensorArrayId",s,x,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=N("tensorListId",s,x,n),a=N("index",s,x,n),i=N("tensor",s,x,n),o=n.getTensorList(r.id);return o.setItem(a,i),[o.idTensor]}case"TensorListGetItem":{const r=N("tensorListId",s,x,n),a=N("index",s,x,n),i=N("elementShape",s,x,n),o=N("elementDType",s,x,n);return[n.getTensorList(r.id).getItem(a,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=N("indices",s,x,n),a=N("tensor",s,x,n),i=N("elementShape",s,x,n),o=N("numElements",s,x,n),l=G5(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=N("elementShape",s,x,n),a=N("elementDType",s,x,n);let i;s.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=N(i,s,x,n),l=s.op==="TensorListReserve"?-1:o,c=W5(r,a,o,l);return n.addTensorList(c),[c.idTensor]}case"TensorListGather":{const r=N("tensorListId",s,x,n),a=N("indices",s,x,n),i=N("elementShape",s,x,n),o=N("elementDType",s,x,n);return[n.getTensorList(r.id).gather(a,o,i)]}case"TensorListStack":{const r=N("tensorListId",s,x,n),a=N("elementShape",s,x,n),i=N("elementDType",s,x,n),o=N("numElements",s,x,n);return[n.getTensorList(r.id).stack(a,i,o)]}case"TensorListFromTensor":{const r=N("tensor",s,x,n),a=N("elementShape",s,x,n),i=N("elementDType",s,x,n),o=z5(r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=N("tensorListId",s,x,n),a=n.getTensorList(r.id),i=N("dtype",s,x,n),o=N("elementShape",s,x,n);return[a.concat(i,o)]}case"TensorListPushBack":{const r=N("tensorListId",s,x,n),a=N("tensor",s,x,n),i=n.getTensorList(r.id);return i.pushBack(a),[i.idTensor]}case"TensorListPopBack":{const r=N("tensorListId",s,x,n),a=N("elementShape",s,x,n),i=N("elementDType",s,x,n);return[n.getTensorList(r.id).popBack(a,i)]}case"TensorListSplit":{const r=N("tensor",s,x,n),a=N("elementShape",s,x,n),i=N("lengths",s,x,n),o=V5(r,i,a);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=N("tensorListId",s,x,n),a=n.getTensorList(r.id);return[Pt(a.size(),"int32")]}case"TensorListResize":{const r=N("tensorListId",s,x,n),a=N("size",s,x,n),i=n.getTensorList(r.id).resize(a);return n.addTensorList(i),[i.idTensor]}default:throw TypeError("Node type "+s.op+" is not implemented")}};function Nw(s,x,n){const[r,a]=N("fusedOps",s,x,n),i=r==="biasadd",o=!i,l=a==="prelu",c=r==="fusedbatchnorm",d=N("numArgs",s,x,n);if(i){if(l&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&i&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=N("strides",s,x,n),p=rd(s,x,n),m=N("dataFormat",s,x,n).toUpperCase(),g=N("dilations",s,x,n);let[y,b]=N("args",s,x,n);o&&(b=y,y=void 0);const v=N("leakyreluAlpha",s,x,n);return{stride:h,pad:p,dataFormat:m,dilations:g,biasArg:y,preluArg:b,activationFunc:a,leakyreluAlpha:v}}const Y5=(s,x,n,r=pn)=>{switch(s.op){case"Conv1D":{const a=N("stride",s,x,n),i=N("pad",s,x,n),o=N("dataFormat",s,x,n).toUpperCase(),l=N("dilation",s,x,n);return[r.conv1d(N("x",s,x,n),N("filter",s,x,n),a,i,o,l)]}case"Conv2D":{const a=N("strides",s,x,n),i=rd(s,x,n),o=N("dataFormat",s,x,n).toUpperCase(),l=N("dilations",s,x,n);return[r.conv2d(N("x",s,x,n),N("filter",s,x,n),[a[1],a[2]],i,o,[l[1],l[2]])]}case"_FusedConv2D":{const{stride:a,pad:i,dataFormat:o,dilations:l,biasArg:c,preluArg:d,activationFunc:h,leakyreluAlpha:p}=Nw(s,x,n);return[r.fused.conv2d({x:N("x",s,x,n),filter:N("filter",s,x,n),strides:[a[1],a[2]],pad:i,dataFormat:o,dilations:[l[1],l[2]],bias:c,activation:h,preluActivationWeights:d,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:i,dataFormat:o,dilations:l,biasArg:c,preluArg:d,activationFunc:h,leakyreluAlpha:p}=Nw(s,x,n);return[r.fused.depthwiseConv2d({x:N("x",s,x,n),filter:N("filter",s,x,n),strides:[a[1],a[2]],pad:i,dataFormat:o,dilations:[l[1],l[2]],bias:c,activation:h,preluActivationWeights:d,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=N("outputShape",s,x,n),i=N("strides",s,x,n),o=rd(s,x,n);return[r.conv2dTranspose(N("x",s,x,n),N("filter",s,x,n),a,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=N("strides",s,x,n),i=rd(s,x,n),o=N("dilations",s,x,n),l=N("dataFormat",s,x,n).toUpperCase();return[r.depthwiseConv2d(N("input",s,x,n),N("filter",s,x,n),[a[1],a[2]],i,l,[o[1],o[2]])]}case"Conv3D":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("dataFormat",s,x,n).toUpperCase(),l=N("dilations",s,x,n);return[r.conv3d(N("x",s,x,n),N("filter",s,x,n),[a[1],a[2],a[3]],i,o,[l[1],l[2],l[3]])]}case"AvgPool":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("kernelSize",s,x,n);return[r.avgPool(N("x",s,x,n),[o[1],o[2]],[a[1],a[2]],i)]}case"MaxPool":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("kernelSize",s,x,n);return[r.maxPool(N("x",s,x,n),[o[1],o[2]],[a[1],a[2]],i)]}case"MaxPoolWithArgmax":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("kernelSize",s,x,n),l=N("includeBatchInIndex",s,x,n),{result:c,indexes:d}=r.maxPoolWithArgmax(N("x",s,x,n),[o[1],o[2]],[a[1],a[2]],i,l);return[c,d]}case"AvgPool3D":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("kernelSize",s,x,n);return[r.avgPool3d(N("x",s,x,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],i)]}case"MaxPool3D":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("kernelSize",s,x,n);return[r.maxPool3d(N("x",s,x,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],i)]}case"Dilation2D":{const a=N("strides",s,x,n),i=N("pad",s,x,n),o=N("dilations",s,x,n),l=a[1],c=a[2],d=o[1],h=o[2];return[r.dilation2d(N("x",s,x,n),N("filter",s,x,n),[l,c],i,[d,h],"NHWC")]}default:throw TypeError("Node type "+s.op+" is not implemented")}},q5=(s,x,n,r=pn)=>{switch(s.op){case"Fill":{const a=N("shape",s,x,n),i=N("dtype",s,x,n),o=N("value",s,x,n);return[r.fill(a,o,i)]}case"LinSpace":{const a=N("start",s,x,n),i=N("stop",s,x,n),o=N("num",s,x,n);return[r.linspace(a,i,o)]}case"Multinomial":{const a=N("logits",s,x,n),i=N("numSamples",s,x,n),o=N("seed",s,x,n);return[r.multinomial(a,i,o)]}case"OneHot":{const a=N("indices",s,x,n),i=N("depth",s,x,n),o=N("onValue",s,x,n),l=N("offValue",s,x,n),c=N("dtype",s,x,n);return[r.oneHot(a,i,o,l,c)]}case"Ones":return[r.ones(N("shape",s,x,n),N("dtype",s,x,n))];case"OnesLike":return[r.onesLike(N("x",s,x,n))];case"RandomStandardNormal":return[r.randomStandardNormal(N("shape",s,x,n),N("dtype",s,x,n),N("seed",s,x,n))];case"RandomUniform":return[r.randomUniform(N("shape",s,x,n),N("minval",s,x,n),N("maxval",s,x,n),N("dtype",s,x,n))];case"Range":{const a=N("start",s,x,n),i=N("stop",s,x,n),o=N("step",s,x,n);return[r.range(a,i,o,N("dtype",s,x,n))]}case"TruncatedNormal":{const a=N("shape",s,x,n),i=N("mean",s,x,n),o=N("stdDev",s,x,n),l=N("seed",s,x,n);return[r.truncatedNormal(a,i,o,N("dtype",s,x,n),l)]}case"Zeros":return[r.zeros(N("shape",s,x,n),N("dtype",s,x,n))];case"ZerosLike":return[r.zerosLike(N("x",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}};function gg(s,x,n){const r=N("boxes",s,x,n),a=N("scores",s,x,n),i=N("maxOutputSize",s,x,n),o=N("iouThreshold",s,x,n),l=N("scoreThreshold",s,x,n),c=N("softNmsSigma",s,x,n);return{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}}const X5=async(s,x,n,r,a=pn)=>{switch(s.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:c,scoreThreshold:d,softNmsSigma:h}=gg(s,x,n),p=await a.image.nonMaxSuppressionWithScoreAsync(i,o,l,c,d,h);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:c,scoreThreshold:d}=gg(s,x,n),h=N("padToMaxOutputSize",s,x,n),p=await a.image.nonMaxSuppressionPaddedAsync(i,o,l,c,d,h);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:l,iouThreshold:c,scoreThreshold:d}=gg(s,x,n);return[await a.image.nonMaxSuppressionAsync(i,o,l,c,d)]}case"Where":{const i=a.cast(N("condition",s,x,n),"bool"),o=[await a.whereAsync(i)];return i.dispose(),o}case"ListDiff":return a.setdiff1dAsync(N("x",s,x,n),N("y",s,x,n));default:throw TypeError("Node type "+s.op+" is not implemented")}},K5=(s,x,n,r=pn)=>{switch(s.op){case"LowerBound":{const a=N("sortedSequence",s,x,n),i=N("values",s,x,n);return[r.lowerBound(a,i)]}case"TopKV2":{const a=N("x",s,x,n),i=N("k",s,x,n),o=N("sorted",s,x,n),l=r.topk(a,i,o);return[l.values,l.indices]}case"UpperBound":{const a=N("sortedSequence",s,x,n),i=N("values",s,x,n);return[r.upperBound(a,i)]}case"Unique":{const a=N("x",s,x,n),i=r.unique(a);return[i.values,i.indices]}case"UniqueV2":{const a=N("x",s,x,n),i=N("axis",s,x,n),o=r.unique(a,i);return[o.values,o.indices]}default:throw TypeError("Node type "+s.op+" is not implemented")}},$5=(s,x,n,r=pn)=>{switch(s.op){case"Const":return x[s.name];case"PlaceholderWithDefault":const a=N("default",s,x,n);return[Pn(s.name,x,n)||a];case"Placeholder":return[Pn(s.name,x,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=N("x",s,x,n);return[Br(h)]}case"IdentityN":return N("x",s,x,n).map(h=>Br(h));case"Snapshot":const i=N("x",s,x,n);return[Br(i)];case"Shape":return[r.tensor1d(N("x",s,x,n).shape,"int32")];case"ShapeN":return N("x",s,x,n).map(h=>r.tensor1d(h.shape));case"Size":return[r.scalar(N("x",s,x,n).size,"int32")];case"Rank":return[r.scalar(N("x",s,x,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=N("x",s,x,n),l=N("data",s,x,n),c=N("message",s,x,n),d=N("summarize",s,x,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let h=0;h<l.length;h++)console.log(Array.prototype.slice.call(l[h].dataSync()).slice(0,d));return[o];default:throw TypeError("Node type "+s.op+" is not implemented")}};class Z5{constructor(x,n){this.keyDType=x,this.valueDType=n,this.handle=Pt(0),this.tensorMap=new Map,ur(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(x=>x.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Pt(this.size(),"int32")}async import(x,n){this.checkKeyAndValueTensor(x,n);const r=await x.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),vt(()=>{const a=la(n),i=r.length,o=a.length;G(i===o,()=>"The number of elements doesn't match, keys has "+i+" elements, the values has "+o+" elements.");for(let l=0;l<i;l++){const c=r[l],d=a[l];ur(d),this.tensorMap.set(c,d)}return this.handle})}async find(x,n){this.checkKeyAndValueTensor(x,n);const r=await x.data();return vt(()=>{const a=[];for(let i=0;i<r.length;i++){const o=r[i],l=this.findWithDefault(o,n);a.push(l)}return Dr(a)})}findWithDefault(x,n){const r=this.tensorMap.get(x);return r??n}checkKeyAndValueTensor(x,n){if(x.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+x.dtype);if(n.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+n.dtype)}}const J5=async(s,x,n,r)=>{switch(s.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(s.name);if(a!=null)return[a];{const i=N("keyDType",s,x,n),o=N("valueDType",s,x,n),l=new Z5(i,o);return r.addHashTable(s.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=N("tableHandle",s,x,n,r),i=N("keys",s,x,n),o=N("values",s,x,n);return[await r.getHashTableById(a.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=N("tableHandle",s,x,n,r),i=N("keys",s,x,n),o=N("defaultValue",s,x,n);return[await r.getHashTableById(a.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=N("tableHandle",s,x,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError("Node type "+s.op+" is not implemented")}},Q5=(s,x,n,r=pn)=>{switch(s.op){case"ResizeBilinear":{const a=N("images",s,x,n),i=N("size",s,x,n),o=N("alignCorners",s,x,n),l=N("halfPixelCenters",s,x,n);return[r.image.resizeBilinear(a,[i[0],i[1]],o,l)]}case"ResizeNearestNeighbor":{const a=N("images",s,x,n),i=N("size",s,x,n),o=N("alignCorners",s,x,n),l=N("halfPixelCenters",s,x,n);return[r.image.resizeNearestNeighbor(a,[i[0],i[1]],o,l)]}case"CropAndResize":{const a=N("image",s,x,n),i=N("boxes",s,x,n),o=N("boxInd",s,x,n),l=N("cropSize",s,x,n),c=N("method",s,x,n),d=N("extrapolationValue",s,x,n);return[r.image.cropAndResize(a,i,o,l,c,d)]}case"ImageProjectiveTransformV3":{const a=N("images",s,x,n),i=N("transforms",s,x,n),o=N("outputShape",s,x,n),l=N("fillValue",s,x,n),c=N("interpolation",s,x,n),d=N("fillMode",s,x,n);return[r.image.transform(a,i,c.toLowerCase(),d.toLowerCase(),l,o)]}default:throw TypeError("Node type "+s.op+" is not implemented")}},j5=(s,x,n,r=pn)=>{switch(s.op){case"Equal":return[r.equal(N("a",s,x,n),N("b",s,x,n))];case"NotEqual":return[r.notEqual(N("a",s,x,n),N("b",s,x,n))];case"Greater":return[r.greater(N("a",s,x,n),N("b",s,x,n))];case"GreaterEqual":return[r.greaterEqual(N("a",s,x,n),N("b",s,x,n))];case"Less":return[r.less(N("a",s,x,n),N("b",s,x,n))];case"LessEqual":return[r.lessEqual(N("a",s,x,n),N("b",s,x,n))];case"LogicalAnd":return[r.logicalAnd(N("a",s,x,n),N("b",s,x,n))];case"LogicalNot":return[r.logicalNot(N("a",s,x,n))];case"LogicalOr":return[r.logicalOr(N("a",s,x,n),N("b",s,x,n))];case"Select":case"SelectV2":return[r.where(N("condition",s,x,n),N("a",s,x,n),N("b",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},e6=(s,x,n,r=pn)=>{switch(s.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(N("a",s,x,n),N("b",s,x,n),N("transposeA",s,x,n),N("transposeB",s,x,n))];case"Einsum":return[r.einsum(N("equation",s,x,n),...N("tensors",s,x,n))];case"Transpose":return[r.transpose(N("x",s,x,n),N("perm",s,x,n))];case"_FusedMatMul":const[a,i]=N("fusedOps",s,x,n),o=a==="biasadd",l=i==="prelu",c=N("numArgs",s,x,n),d=N("leakyreluAlpha",s,x,n);if(o){if(l&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,p]=N("args",s,x,n);return[r.fused.matMul({a:N("a",s,x,n),b:N("b",s,x,n),transposeA:N("transposeA",s,x,n),transposeB:N("transposeB",s,x,n),bias:h,activation:i,preluActivationWeights:p,leakyreluAlpha:d})];default:throw TypeError("Node type "+s.op+" is not implemented")}},t6=(s,x,n,r=pn)=>{switch(s.op){case"EuclideanNorm":return[r.euclideanNorm(N("x",s,x,n),N("axis",s,x,n),N("keepDims",s,x,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(N("x",s,x,n),N("mean",s,x,n),N("variance",s,x,n),N("offset",s,x,n),N("scale",s,x,n),N("epsilon",s,x,n))];case"FusedBatchNormV3":return[r.batchNorm(N("x",s,x,n),N("mean",s,x,n),N("variance",s,x,n),N("offset",s,x,n),N("scale",s,x,n),N("epsilon",s,x,n))];case"LRN":return[r.localResponseNormalization(N("x",s,x,n),N("radius",s,x,n),N("bias",s,x,n),N("alpha",s,x,n),N("beta",s,x,n))];case"Softmax":return[r.softmax(N("x",s,x,n))];case"LogSoftmax":return[r.logSoftmax(N("x",s,x,n))];case"SparseToDense":return[r.sparseToDense(N("sparseIndices",s,x,n),N("outputShape",s,x,n),N("sparseValues",s,x,n),N("defaultValue",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},x6=(s,x,n,r=pn)=>{switch(s.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:i}=r.raggedGather(N("paramsNestedSplits",s,x,n),N("paramsDenseValues",s,x,n),N("indices",s,x,n),N("outputRaggedRank",s,x,n));return a.concat(i)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:i}=r.raggedRange(N("starts",s,x,n),N("limits",s,x,n),N("splits",s,x,n));return[a,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(N("shape",s,x,n),N("values",s,x,n),N("defaultValue",s,x,n),N("rowPartitionTensors",s,x,n),N("rowPartitionTypes",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},n6=(s,x,n,r=pn)=>{switch(s.op){case"Max":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.max(N("x",s,x,n),l,c)]}case"Mean":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.mean(N("x",s,x,n),l,c)]}case"Min":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.min(N("x",s,x,n),l,c)]}case"Sum":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.sum(N("x",s,x,n),l,c)]}case"All":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.all(N("x",s,x,n),l,c)]}case"Any":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.any(N("x",s,x,n),l,c)]}case"ArgMax":{const l=N("axis",s,x,n);return[r.argMax(N("x",s,x,n),l)]}case"ArgMin":{const l=N("axis",s,x,n);return[r.argMin(N("x",s,x,n),l)]}case"Prod":{const l=N("axis",s,x,n),c=N("keepDims",s,x,n);return[r.prod(N("x",s,x,n),l,c)]}case"Cumprod":{const l=N("axis",s,x,n),c=N("exclusive",s,x,n),d=N("reverse",s,x,n);return[r.cumprod(N("x",s,x,n),l,c,d)]}case"Cumsum":{const l=N("axis",s,x,n),c=N("exclusive",s,x,n),d=N("reverse",s,x,n);return[r.cumsum(N("x",s,x,n),l,c,d)]}case"Bincount":const a=N("x",s,x,n),i=N("weights",s,x,n),o=N("size",s,x,n);return[r.bincount(a,i,o)];case"DenseBincount":{const l=N("x",s,x,n),c=N("weights",s,x,n),d=N("size",s,x,n),h=N("binaryOutput",s,x,n);return[r.denseBincount(l,c,d,h)]}default:throw TypeError("Node type "+s.op+" is not implemented")}},r6=(s,x,n,r=pn)=>{switch(s.op){case"ConcatV2":case"Concat":{const a=N("n",s,x,n),i=N("axis",s,x,n);let o=N("tensors",s,x,n);return o=o.slice(0,a),[r.concat(o,i)]}case"Gather":{const a=N("x",s,x,n),i=N("indices",s,x,n);return[r.gather(a,r.cast(i,"int32"),0)]}case"GatherV2":{const a=N("axis",s,x,n),i=N("batchDims",s,x,n),o=N("x",s,x,n),l=N("indices",s,x,n);return[r.gather(o,r.cast(l,"int32"),a,i)]}case"Reverse":{const a=N("dims",s,x,n),i=[];for(let l=0;l<a.length;l++)a[l]&&i.push(l);const o=N("x",s,x,n);return[r.reverse(o,i)]}case"ReverseV2":{const a=N("axis",s,x,n),i=N("x",s,x,n);return[r.reverse(i,a)]}case"Slice":{const a=N("begin",s,x,n),i=N("size",s,x,n);return[r.slice(N("x",s,x,n),a,i)]}case"StridedSlice":{const a=N("begin",s,x,n),i=N("end",s,x,n),o=N("strides",s,x,n),l=N("beginMask",s,x,n),c=N("endMask",s,x,n),d=N("ellipsisMask",s,x,n),h=N("newAxisMask",s,x,n),p=N("shrinkAxisMask",s,x,n),m=N("x",s,x,n);return[r.stridedSlice(m,a,i,o,l,c,d,h,p)]}case"Pack":return vt(()=>{const a=N("axis",s,x,n),i=N("tensors",s,x,n),o=i[0].shape,l=r.squeeze(i[0]).shape,c=i.map(d=>{const h=T0(d.shape,o);if(!h&&!T0(r.squeeze(d).shape,l))throw new Error("the input tensors shape does not match");return h?d:r.reshape(d,o)});return[r.stack(c,a)]});case"Unpack":{const a=N("axis",s,x,n),i=N("tensor",s,x,n);return r.unstack(i,a)}case"Tile":{const a=N("reps",s,x,n);return[r.tile(N("x",s,x,n),a)]}case"Split":case"SplitV":{const a=N("axis",s,x,n),i=N("numOrSizeSplits",s,x,n),o=N("x",s,x,n);return r.split(o,i,a)}case"ScatterNd":{const a=N("indices",s,x,n),i=N("values",s,x,n),o=N("shape",s,x,n);return[r.scatterND(a,i,o)]}case"GatherNd":{const a=N("x",s,x,n),i=N("indices",s,x,n);return[r.gatherND(a,i)]}case"SparseToDense":{const a=N("sparseIndices",s,x,n),i=N("outputShape",s,x,n),o=N("sparseValues",s,x,n),l=N("defaultValue",s,x,n);return[r.sparseToDense(a,o,i,o.dtype===l.dtype?l:r.cast(l,o.dtype))]}default:throw TypeError("Node type "+s.op+" is not implemented")}},s6=(s,x,n,r=pn)=>{switch(s.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:i,emptyRowIndicator:o,reverseIndexMap:l}=r.sparse.sparseFillEmptyRows(N("indices",s,x,n),N("values",s,x,n),N("denseShape",s,x,n),N("defaultValue",s,x,n));return[a,i,o,l]}case"SparseReshape":{const{outputIndices:a,outputShape:i}=r.sparse.sparseReshape(N("inputIndices",s,x,n),N("inputShape",s,x,n),N("newShape",s,x,n));return[a,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(N("data",s,x,n),N("indices",s,x,n),N("segmentIds",s,x,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(N("data",s,x,n),N("indices",s,x,n),N("segmentIds",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},a6=(s,x,n,r=pn)=>{switch(s.op){case"FFT":return[r.fft(N("x",s,x,n))];case"IFFT":return[r.ifft(N("x",s,x,n))];case"RFFT":return[r.rfft(N("x",s,x,n))];case"IRFFT":return[r.irfft(N("x",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},i6=(s,x,n,r=pn)=>{switch(s.op){case"StringNGrams":{const{nGrams:a,nGramsSplits:i}=r.string.stringNGrams(N("data",s,x,n),N("dataSplits",s,x,n),N("separator",s,x,n),N("nGramWidths",s,x,n),N("leftPad",s,x,n),N("rightPad",s,x,n),N("padWidth",s,x,n),N("preserveShortSequences",s,x,n));return[a,i]}case"StringSplit":{const{indices:a,values:i,shape:o}=r.string.stringSplit(N("input",s,x,n),N("delimiter",s,x,n),N("skipEmpty",s,x,n));return[a,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(N("input",s,x,n),N("numBuckets",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}},o6=(s,x,n,r=pn)=>{switch(s.op){case"Cast":return[r.cast(N("x",s,x,n),N("dtype",s,x,n))];case"ExpandDims":{const a=N("axis",s,x,n);return[r.expandDims(N("x",s,x,n),a)]}case"Squeeze":{const a=N("axis",s,x,n);return[r.squeeze(N("x",s,x,n),a)]}case"Reshape":return[r.reshape(N("x",s,x,n),N("shape",s,x,n))];case"MirrorPad":return[r.mirrorPad(N("x",s,x,n),N("padding",s,x,n),N("mode",s,x,n))];case"PadV2":case"Pad":return[r.pad(N("x",s,x,n),N("padding",s,x,n),N("constantValue",s,x,n))];case"SpaceToBatchND":{const a=N("blockShape",s,x,n),i=N("paddings",s,x,n);return[r.spaceToBatchND(N("x",s,x,n),a,i)]}case"BatchToSpaceND":{const a=N("blockShape",s,x,n),i=N("crops",s,x,n);return[r.batchToSpaceND(N("x",s,x,n),a,i)]}case"DepthToSpace":{const a=N("blockSize",s,x,n),i=N("dataFormat",s,x,n).toUpperCase();return[r.depthToSpace(N("x",s,x,n),a,i)]}case"BroadcastTo":return[r.broadcastTo(N("x",s,x,n),N("shape",s,x,n))];case"BroadcastArgs":return[r.broadcastArgs(N("s0",s,x,n),N("s1",s,x,n))];default:throw TypeError("Node type "+s.op+" is not implemented")}};function Rw(s,x,n,r,a=vt){const i=((o,l,c)=>{switch(o.category){case"arithmetic":return a(()=>F5(o,l,c));case"basic_math":return a(()=>U5(o,l,c));case"control":return H5(o,l,c);case"convolution":return a(()=>Y5(o,l,c));case"creation":return a(()=>q5(o,l,c));case"dynamic":return X5(o,l,c);case"evaluation":return a(()=>K5(o,l,c));case"image":return a(()=>Q5(o,l,c));case"graph":return a(()=>$5(o,l,c));case"logical":return a(()=>j5(o,l,c));case"matrices":return a(()=>e6(o,l,c));case"normalization":return a(()=>t6(o,l,c));case"ragged":return a(()=>x6(o,l,c));case"reduction":return a(()=>n6(o,l,c));case"slice_join":return a(()=>r6(o,l,c));case"sparse":return a(()=>s6(o,l,c));case"spectral":return a(()=>a6(o,l,c));case"string":return a(()=>i6(o,l,c));case"transformation":return a(()=>o6(o,l,c));case"hash_table":return J5(o,l,c,r);case"custom":const d=Aw(o.op);if(d&&d.customExecutor)return d.customExecutor(new O5(o,l,c));throw TypeError("Custom op "+o.op+" is not registered.");default:throw TypeError("Unknown op '"+o.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(s,x,n);return Bt(i)?i.then(o=>[].concat(o)):[].concat(i)}class Pw{constructor(x={},n={},r={},a={}){this.weightMap=x,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(x,n){return{id:x,frameName:n,iterationId:0}}set currentContext(x){this.contexts!==x&&(this.contexts=x,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const x=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);x.push(this.contextIdforContexts(r))}x.push(""),this._currentContextIds=x}contextIdforContexts(x){return x?x.map(n=>n.id===0&&n.iterationId===0?"":n.frameName+"-"+n.iterationId).join("/"):""}enterFrame(x){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,x)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const x=Object.assign({},this.contexts[this.contexts.length-1]);x.iterationId+=1,x.id=this.lastId,this.contexts.splice(-1,1,x),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(x){return this.weightMap[x]}addTensorArray(x){this.tensorArrayMap[x.id]=x}getTensorArray(x){return this.tensorArrayMap[x]}addTensorList(x){this.tensorListMap[x.id]=x}getTensorList(x){return this.tensorListMap[x]}dispose(x){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(x);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(x)}}function Lw(s,x,n,r){const a=new Set,i=[];let o=null,l=null;const c=new Set,d=Object.keys(s).map(m=>r2(m)[0]);let h=[];r!=null&&(h=r.map(m=>r2(m.name)[0]));const p=[...x];for(;p.length>0;){const m=p.pop();if((Dw(m)||h6(m)||p6(m))&&o==null&&(o=m,l=o.children.map(g=>g.name).filter(g=>a.has(g))),a.add(m.name),n[m.name]==null&&d.indexOf(m.name)===-1&&h.indexOf(m.name)===-1){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(g=>{c.has(g.name)||(c.add(g.name),p.push(g))})}}return{inputs:s,outputs:x,usedNodes:a,missingInputs:i,dynamicNode:o,syncInputs:l}}function l6(s,x,n){const{usedNodes:r,inputs:a}=n,i=[],o=Object.keys(a).map(h=>r2(h)[0]).map(h=>s.nodes[h]),l=s.initNodes;o.forEach(h=>{r.has(h.name)&&i.push(h)}),s.weights.forEach(h=>{r.has(h.name)&&i.push(h)}),l?.forEach(h=>{r.has(h.name)&&i.push(h)});const c=new Set,d=[];for(;i.length>0;){const h=i.pop();c.add(h.name),x[h.name]||d.push(h),h.children.forEach(p=>{!c.has(p.name)&&r.has(p.name)&&p.inputs.every(m=>c.has(m.name))&&i.push(p)})}return d}const c6=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],u6=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],d6=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Dw(s){return c6.indexOf(s.op)>=0}function h6(s){return u6.indexOf(s.op)>=0}function p6(s){return d6.indexOf(s.op)>=0}class sd{constructor(x,n){this.graph=x,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=x.outputs,this._inputs=x.inputs,this._initNodes=x.initNodes,this._signature=x.signature,this._functions=x.functions,x.functions!=null&&Object.keys(x.functions).forEach(r=>{this._functionExecutorMap[r]=new sd(x.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(x){const n=Object.keys(x).map(r=>x[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=x}set resourceManager(x){this._resourceManager=x}get inputs(){return this._inputs.map(x=>({name:x.name,shape:x.attrParams.shape?x.attrParams.shape.value:void 0,dtype:x.attrParams.dtype?x.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(x=>({name:x.name,shape:x.attrParams.shape?x.attrParams.shape.value:void 0,dtype:x.attrParams.dtype?x.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(x=>x.signatureKey||x.name)}get outputNodes(){return this._outputs.map(x=>{const n=x.signatureKey||x.name;return x.defaultOutput?n+":"+x.defaultOutput:n})}get functions(){return Object.keys(this._functions).reduce((x,n)=>(x[n]=this._functions[n].signature,x),{})}getCompilationKey(x,n){const r=x.map(i=>i.name).sort(),a=n.map(i=>i.name).sort();return r.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(x,n){const r=Lw(x,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error("This execution contains the node '"+i.name+"', which has the dynamic op '"+i.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+o+"]");if(a.length>0){const l=n.map(d=>d.name),c=Object.keys(x);throw new Error("Cannot compute the outputs ["+l+"] from the provided inputs ["+c+"]. Missing the following inputs: ["+a+"]")}return l6(this.graph,this.weightMap,r)}cloneAndKeepTensor(x){if(x==null)return null;const n=x.clone();return ur(n),n}cloneTensorList(x){return x?x.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(x){return Object.fromEntries(Object.entries(x).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(x,n){this.disposeIntermediateTensors(),x=this.mapInputs(x);const r=Object.keys(x).sort();this.checkInputs(x),this.checkInputShapeAndType(x),n=this.mapOutputs(n),this.checkOutputs(n);const a=r.map(p=>this.graph.nodes[r2(p)[0]]),i=n.map(p=>r2(p)[0]);let o=i.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(a,o);let c=this.compiledMap.get(l);c==null&&(c=this.compile(x,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Ce().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const d={},h={};return vt(()=>{const p=new Pw(this.weightMap,d,h,this.functionExecutorMap),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(x).forEach(b=>{const[v,w]=r2(b),_=[];_[w]=x[b],m[v]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(_))});const g=this.getFrozenTensorIds(m),y={};for(let b=0;b<c.length;b++){const v=c[b];if(!m[v.name]){const w=Rw(v,m,p,this._resourceManager);if(Bt(w))throw new Error("The execution of the op '"+v.op+"' returned a promise. Please use model.executeAsync() instead.");m[v.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(w)),this.checkTensorForDisposal(v.name,v,m,p,g,i,y)}}return this.parent==null&&p.dispose(g),n.map(b=>Pn(b,m,p))})}getFrozenTensorIds(x){const n=[].concat.apply([],Object.keys(x).map(r=>x[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(x,n,r,a,i,o,l){n.category==="control"||o.indexOf(x)!==-1||(r[x].forEach(c=>{c!=null&&(l[c.id]=(l[c.id]||0)+n.children.length)}),n.inputs.forEach(c=>{if(c.category!=="control"){const d=f5(c.name,r,a);d?.forEach(h=>{if(h&&!h.kept&&!i.has(h.id)){const p=l[h.id];p===1?(h.dispose(),delete l[h.id]):p!=null&&l[h.id]--}})}}))}async executeAsync(x,n){return this._executeAsync(x,n)}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(x=>{for(const n of x)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(x,n,r=!1,a={},i={}){this.disposeIntermediateTensors(),r||(x=this.mapInputs(x),this.checkInputs(x),this.checkInputShapeAndType(x),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=Ce().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const o=new Pw(this.weightMap,a,i,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const l=await this.executeWithControlFlow(x,o,n,r),c=n.map(m=>Pn(m,l,o)),d=c.map(m=>m.id),h=Object.keys(x).map(m=>x[m].id),p=new Set([...d,...h,...this.weightIds]);return Object.values(l).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!p.has(g.id)&&g.dispose()})}),this.parent==null&&o.dispose(p),c}async executeFunctionAsync(x,n,r){const a=x.reduce((i,o,l)=>(i[this.inputs[l].name]=o,i),{});return this._executeAsync(a,this.outputNodes,!0,n,r)}async executeWithControlFlow(x,n,r,a){const i=Object.keys(x),o=i.map(T=>this.graph.nodes[r2(T)[0]]),l=r.map(T=>r2(T)[0]);let c=l.map(T=>this.graph.nodes[T]);c.length===0&&(c=this._outputs);const{usedNodes:d,missingInputs:h,dynamicNode:p,syncInputs:m}=Lw(x,c,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:n.currentContext})),y=Object.assign({},this.weightMap);Object.keys(x).forEach(T=>{const[A,E]=r2(T),M=[];M[E]=x[T],y[A]=M});const b={},v=this.getFrozenTensorIds(y),w={};for(;g.length>0;){const T=this.processStack(o,g,n,y,w,v,l,b,d);await Promise.all(T)}p==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(T=>!Dw(T)&&!Pn(T.name,y,n)).map(T=>T.name);if(_.length>0){let T="";throw p!=null&&(T="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+m+"]"),new Error("Cannot compute the outputs ["+_+"] from the provided inputs ["+i+"]. Consider providing the following inputs: ["+h+"]. "+T)}return y}processStack(x,n,r,a,i,o,l,c,d){const h=[];for(;n.length>0;){const p=n.pop();r.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&N("isConstant",p.node,a,r)&&([m]=Ur(p.node.name,r)),a[p.node.name]==null){const g=Rw(p.node,a,r,this._resourceManager);m||([m]=Ur(p.node.name,r));const y=r.currentContext;Bt(g)?h.push(g.then(b=>(a[m]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(b)),r.currentContext=y,this.checkTensorForDisposal(m,p.node,a,r,o,l,c),this.processChildNodes(p.node,n,r,a,i,d),b))):(a[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,p.node,a,r,o,l,c),this.processChildNodes(p.node,n,r,a,i,d))}else this.processChildNodes(p.node,n,r,a,i,d)}return h}processChildNodes(x,n,r,a,i,o){x.children.forEach(l=>{const[c]=Ur(l.name,r);i[c]||!o.has(l.name)||(l.op==="Merge"?l.inputNames.some(d=>!!Pn(d,a,r))&&(i[c]=!0,n.push({contexts:r.currentContext,node:l})):l.inputNames.every(d=>!!Pn(d,a,r))&&(i[c]=!0,n.push({contexts:r.currentContext,node:l})))})}dispose(){Object.keys(this.weightMap).forEach(x=>this.weightMap[x].forEach(n=>n.dispose()))}checkInputShapeAndType(x){Object.keys(x).forEach(n=>{const r=x[n],[a]=r2(n),i=this.graph.nodes[a];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,l=o.length===r.shape.length&&r.shape.every((c,d)=>o[d]===-1||o[d]===c);G(l,()=>"The shape of dict['"+i.name+"'] provided in model.execute(dict) must be ["+o+"], but was ["+r.shape+"]")}i.attrParams.dtype&&i.attrParams.dtype.value&&G(r.dtype===i.attrParams.dtype.value,()=>"The dtype of dict['"+i.name+"'] provided in model.execute(dict) must be "+i.attrParams.dtype.value+", but was "+r.dtype)})}mapInputs(x){var n,r;const a={};for(const i in x){const o=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[i];o!=null?a[o.name]=x[i]:a[i]=x[i]}return a}checkInputs(x){const n=Object.keys(x).filter(r=>{const[a]=r2(r);return this.graph.nodes[a]==null});if(n.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+n+"] that are not part of graph")}mapOutputs(x){return x.map(n=>{var r,a;const i=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[n];return i!=null?i.name:n},{})}checkOutputs(x){x.forEach(n=>{const[r]=r2(n);if(!this.graph.nodes[r])throw new Error("The output '"+n+"' is not found in the graph")})}}class f6{constructor(x={},n={}){this.hashTableNameToHandle=x,this.hashTableMap=n}addHashTable(x,n){this.hashTableNameToHandle[x]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(x){return this.hashTableNameToHandle[x]}getHashTableById(x){return this.hashTableMap[x]}dispose(){for(const x in this.hashTableMap)this.hashTableMap[x].clearAndClose(),delete this.hashTableMap[x];for(const x in this.hashTableNameToHandle)this.hashTableNameToHandle[x].dispose(),delete this.hashTableNameToHandle[x]}}const m6="?tfjs-format=file",g6="model.json";class y6{constructor(x,n={},r=Dv){this.modelUrl=x,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new f6}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const x=this.modelUrl;if(x.load!=null)this.handler=x;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(x,this.loadOptions);else{const n=this.io.getLoadHandlers(x,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(x,this.loadOptions));else if(n.length>1)throw new Error("Found more than one ("+n.length+") load handlers for URL '"+[x]+"'");this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const x=this.handler.load();return Bt(x)?x.then(n=>this.loadSync(n)):this.loadSync(x)}loadSync(x){this.artifacts=x;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=n.versions.producer+"."+n.versions.minConsumer;const a=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new sd(Ew.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,x.modelInitializer!=null&&x.modelInitializer.node!=null){const i=Ew.Instance.transformGraph(x.modelInitializer);this.initializer=new sd(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=x.initializerSignature}return!0}async save(x,n){if(typeof x=="string"){const r=this.io.getSaveHandlers(x);if(r.length===0)throw new Error("Cannot find any save handlers for URL '"+x+"'");if(r.length>1)throw new Error("Found more than one ("+r.length+") save handlers for URL '"+x+"'");x=r[0]}if(x.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return x.save(this.artifacts)}addStructuredOutputNames(x){if(this.structuredOutputKeys){const n=x instanceof _n?[x]:x,r={};return n.forEach((a,i)=>r[this.structuredOutputKeys[i]]=a),r}return x}predict(x,n){const r=this.execute(x,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(x,n){const r=await this.executeAsync(x,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(x){var n;if(!(x instanceof _n)&&!Array.isArray(x)){const i=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(i!=null)for(const o in i){const l=i[o];l.resourceId!=null&&(x[o]=this.resourceIdToCapturedInput[l.resourceId])}return x}x=Array.isArray(x)?x:[x];const r=Object.keys(this.resourceIdToCapturedInput).length;if(x.length+r!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-r)+" non-resource placeholders, while there are "+x.length+" input tensors provided.");let a=0;return this.inputNodes.reduce((i,o)=>{var l,c,d;const h=(d=(c=(l=this.signature)===null||l===void 0?void 0:l.inputs)===null||c===void 0?void 0:c[o])===null||d===void 0?void 0:d.resourceId;return h!=null?i[o]=this.resourceIdToCapturedInput[h]:i[o]=x[a++],i},{})}normalizeOutputs(x){return x=x||this.outputNodes,Array.isArray(x)?x:[x]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(x){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,r=Object.keys(n);for(let a=0;a<r.length;a++){const i=r[a],o=n[i];this.resourceIdToCapturedInput[o.resourceId]=x[a]}}}execute(x,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),x=this.normalizeInputs(x),n=this.normalizeOutputs(n);const r=this.executor.execute(x,n);return r.length>1?r:r[0]}async executeAsync(x,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),x=this.normalizeInputs(x),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(x,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(x){return Object.keys(x).reduce((n,r)=>(n[r]=[x[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Yn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function ad(s,x={},n=Dv){if(s==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");x==null&&(x={}),x.fromTFHub&&typeof s=="string"&&(s=b6(s));const r=new y6(s,x,n);return await r.load(),r}function b6(s){return s.endsWith("/")||(s=s+"/"),""+s+g6+m6}const ma={},id={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function v6(s,x){ma[s]=x}function $2(s,x){if(!(s in ma)||x!=null){const r=_6(s,x);if(r!==null)ma[s]=r;else return console.log("Could not get context for WebGL version",s),null}const n=ma[s];return n==null||n.isContextLost()?(delete ma[s],$2(s)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),ma[s])}function w6(s){if(typeof OffscreenCanvas<"u"&&s===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function _6(s,x){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=x??w6(s);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete ma[s]},!1),Ce().getBool("SOFTWARE_WEBGL_ENABLED")&&(id.failIfMajorPerformanceCaveat=!1),s===1?n.getContext("webgl",id)||n.getContext("experimental-webgl",id):n.getContext("webgl2",id)}var sl;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(sl||(sl={}));var p2;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(p2||(p2={}));var fn;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(fn||(fn={}));function al(s,x){return[x,s]}function S6(s,x){return s*x}function od(s){const x=be(s),n=Math.ceil(x/4);return ex(n)}function _i(s,x){return[Math.max(1,Math.ceil(x/2)),Math.max(1,Math.ceil(s/2))]}function T6(s,x){const[n,r]=_i(s,x);return n*r*4}function yg(s,x){const n=s;let r,a,i,o,l,c,d,h,p,m;return Ce().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,i=n.RGBA16F,o=n.RGBA32F,l=n.RED,d=4,h=1,p=n.HALF_FLOAT,m=n.FLOAT,c=n.RGBA8):(r=s.RGBA,a=s.RGBA,i=s.RGBA,o=n.RGBA,l=s.RGBA,d=4,h=4,p=x!=null?x.HALF_FLOAT_OES:null,m=s.FLOAT,c=s.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:d,defaultNumChannels:h,textureTypeHalfFloat:p,textureTypeFloat:m}}function P0(s,x){const n=x();return Ce().getBool("DEBUG")&&A6(s),n}function A6(s){const x=s.getError();if(x!==s.NO_ERROR)throw new Error("WebGL Error: "+I6(s,x))}const E6=596e-10,C6=65504;function M6(s){return!!(Ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||E6<Math.abs(s)&&Math.abs(s)<C6)}function I6(s,x){switch(x){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+x}}function ld(s,x){return zr(s,()=>s.getExtension(x),'Extension "'+x+'" not supported on this browser.')}function k6(s,x){const n=zr(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(P0(s,()=>s.shaderSource(n,x)),P0(s,()=>s.compileShader(n)),s.getShaderParameter(n,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function N6(s,x){const n=zr(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(P0(s,()=>s.shaderSource(n,x)),P0(s,()=>s.compileShader(n)),Ce().get("ENGINE_COMPILE_ONLY"))return n;if(s.getShaderParameter(n,s.COMPILE_STATUS)===!1)throw Ow(x,s.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const R6=/ERROR: [0-9]+:([0-9]+):/g;function Ow(s,x){const n=R6.exec(x);if(n==null){console.log("Couldn't parse line number in error: "+x),console.log(s);return}const r=+n[1],a=s.split(`
`),i=a.length.toString().length+2,o=a.map((p,m)=>yt((m+1).toString(),i)+p);let l=0;for(let p=0;p<o.length;p++)l=Math.max(o[p].length,l);const c=o.slice(0,r-1),d=o.slice(r-1,r),h=o.slice(r);console.log(c.join(`
`)),console.log(x.split(`
`)[0]),console.log("%c "+yt(d[0],l),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function P6(s){return zr(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function L6(s,x){if(P0(s,()=>s.linkProgram(x)),!Ce().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(x,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(x)),new Error("Failed to link vertex and fragment shaders.")}function bg(s,x){if(P0(s,()=>s.validateProgram(x)),s.getProgramParameter(x,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(x)),new Error("Shader program validation failed.")}function D6(s,x){const n=zr(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return P0(s,()=>s.bindBuffer(s.ARRAY_BUFFER,n)),P0(s,()=>s.bufferData(s.ARRAY_BUFFER,x,s.STATIC_DRAW)),n}function O6(s,x){const n=zr(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return P0(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,n)),P0(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,x,s.STATIC_DRAW)),n}function F6(s){return zr(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function U6(s,x){const n=Ce().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||x<=0){const r="["+s+"x"+x+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(s>n||x>n){const r="["+s+"x"+x+"]",a="["+n+"x"+n+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function B6(s){return zr(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Fw(s,x,n,r,a,i,o){const l=s.getAttribLocation(x,n);return l===-1?!1:(P0(s,()=>s.bindBuffer(s.ARRAY_BUFFER,r)),P0(s,()=>s.vertexAttribPointer(l,a,s.FLOAT,!1,i,o)),P0(s,()=>s.enableVertexAttribArray(l)),!0)}function z6(s,x,n){Y6(s,n),P0(s,()=>s.activeTexture(s.TEXTURE0+n)),P0(s,()=>s.bindTexture(s.TEXTURE_2D,x))}function W6(s,x,n){return zr(s,()=>s.getUniformLocation(x,n),'uniform "'+n+'" not present in program.')}function G6(s,x,n){return s.getUniformLocation(x,n)}function V6(s,x,n,r){P0(s,()=>z6(s,x,r)),P0(s,()=>s.uniform1i(n,r))}function vg(s,x,n){P0(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,n)),P0(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,x,0))}function Uw(s,x){P0(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,x)),P0(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function cd(s){const x=s.checkFramebufferStatus(s.FRAMEBUFFER);if(x!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+H6(s,x))}function H6(s,x){switch(x){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+x}}function zr(s,x,n){const r=P0(s,()=>x());if(r==null)throw new Error(n);return r}function Y6(s,x){const n=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=x+s.TEXTURE0;if(r<s.TEXTURE0||r>n){const a="[gl.TEXTURE0, gl.TEXTURE"+n+"]";throw new Error("textureUnit must be in "+a+".")}}function Si(s,x=2){return be(s.slice(0,s.length-x))}function Ti(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function ud(s){let x=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(x=[Si(s),...Ti(s)]),x}function q6(s,x=!1){let n=Ce().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ce().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ce().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),x&&(n=n*2,r=r*2,s=s.map((l,c)=>c>=s.length-2?V0(s[c]):s[c]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=Je(s).newShape);let a=be(s),i=null;s.length<=1&&a<=n?i=[1,a]:s.length===2&&s[0]<=n&&s[1]<=n?i=s:s.length===3&&s[0]*s[1]<=n&&s[2]<=n?i=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=n&&s[1]*s[2]<=n?i=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=n&&s[3]<=n?i=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=n&&s[1]*s[2]*s[3]<=n&&(i=[s[0],s[1]*s[2]*s[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(x?2:1)&&Math.min(...i)>0;if(i==null||o)if(x){const l=Si(s);let c=2,d=2;s.length&&([c,d]=Ti(s)),a=l*(c/2)*(d/2),i=ex(a).map(h=>h*2)}else i=ex(a);return i}function dd(s){return s%2===0}function hd(s,x){if(s=s.slice(-2),x=x.slice(-2),T0(s,x)||!s.length||!x.length||s[0]===0||s[1]===0||x[0]===0||x[1]===0)return!0;if(s.length!==x.length){const n=s.slice(-1)[0],r=x.slice(-1)[0];if(n===r||dd(n)&&dd(r)&&(s[0]===1||x[0]===1))return!0}return s[1]===x[1]&&dd(s[0])&&dd(x[0])}let wg,_g;function X6(s){if(wg==null){const x=$2(s);wg=x.getParameter(x.MAX_TEXTURE_SIZE)}return wg}function K6(s){if(_g==null){const x=$2(s);_g=x.getParameter(x.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,_g)}function $6(s){if(s===0)return 0;let x;const n=$2(s);return L2(n,"EXT_disjoint_timer_query_webgl2")&&s===2?x=2:L2(n,"EXT_disjoint_timer_query")?x=1:x=0,x}function L2(s,x){return s.getExtension(x)!=null}function Bw(s){try{if($2(s)!=null)return!0}catch(x){return console.log("Error when getting WebGL context: ",x),!1}return!1}function Z6(s){if(s===0)return!1;const x=$2(s);if(s===1){if(!L2(x,"OES_texture_float"))return!1}else if(!L2(x,"EXT_color_buffer_float"))return!1;return Sg(x)}function J6(s){if(s===0)return!1;const x=$2(s);if(s===1){if(!L2(x,"OES_texture_float")||!L2(x,"WEBGL_color_buffer_float"))return!1}else{if(L2(x,"EXT_color_buffer_float"))return Sg(x);const n="EXT_color_buffer_half_float";if(L2(x,n)){const r=x.getExtension(n);return Q6(x,r)}return!1}return Sg(x)}function Sg(s){const x=yg(s),n=s.createTexture();s.bindTexture(s.TEXTURE_2D,n);const r=1,a=1;s.texImage2D(s.TEXTURE_2D,0,x.internalFormatFloat,r,a,0,x.textureFormatFloat,x.textureTypeFloat,null);const i=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,i),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,n,0);const o=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(n),s.deleteFramebuffer(i),o}function Q6(s,x){const n=yg(s,x),r=s.createTexture();s.bindTexture(s.TEXTURE_2D,r);const a=1,i=1;s.texImage2D(s.TEXTURE_2D,0,n.internalFormatHalfFloat,a,i,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,o),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,r,0);const l=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(r),s.deleteFramebuffer(o),l}function j6(s){return s!==2?!1:$2(s).fenceSync!=null}function il(s,x){Array.isArray(s)||(s=[s]),s.forEach(n=>{n!=null&&G(n.dtype!=="complex64",()=>x+" does not support complex64 tensors in the WebGL backend.")})}const H0=Ce();H0.registerFlag("HAS_WEBGL",()=>H0.getNumber("WEBGL_VERSION")>0),H0.registerFlag("WEBGL_VERSION",()=>Bw(2)?2:Bw(1)?1:0),H0.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),H0.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>H0.get("WEBGL_VERSION")===2),H0.registerFlag("WEBGL_CPU_FORWARD",()=>!0),H0.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),H0.registerFlag("WEBGL_PACK",()=>H0.getBool("HAS_WEBGL")),H0.registerFlag("WEBGL_PACK_NORMALIZATION",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_CLIP",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_PACK_REDUCE",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_LAZILY_UNPACK",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_CONV_IM2COL",()=>H0.getBool("WEBGL_PACK")),H0.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>X6(H0.getNumber("WEBGL_VERSION"))),H0.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>K6(H0.getNumber("WEBGL_VERSION"))),H0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=H0.getNumber("WEBGL_VERSION");return s===0?0:$6(s)}),H0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>H0.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!cb()),H0.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Z6(H0.getNumber("WEBGL_VERSION"))),H0.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>H0.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:H0.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),H0.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>J6(H0.getNumber("WEBGL_VERSION"))),H0.registerFlag("WEBGL_FENCE_API_ENABLED",()=>j6(H0.getNumber("WEBGL_VERSION"))),H0.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>H0.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),H0.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(s<0&&s!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+s+".")}),H0.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>cb()?1:-1,s=>{if(s<0&&s!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+s+".")}),H0.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),H0.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),H0.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),H0.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),H0.registerFlag("WEBGL_EXP_CONV",()=>!1),H0.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>H0.getBool("IS_TEST")),H0.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),H0.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),H0.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),H0.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ln(){let s,x,n,r,a,i,o,l,c,d;return Ce().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",x="in",n="out",r="in",a="texture",i="outputColor",o="out vec4 outputColor;",l=Ce().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",x="attribute",n="varying",r="varying",a="texture2D",i="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:x,varyingVs:n,varyingFs:r,texture2D:a,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:c,defineRound:d}}function ga(s,x,n="index"){const r=U0(x);return r.map((a,i)=>{const o="int "+s[i]+" = "+n+" / "+a,l=i===r.length-1?"int "+s[i+1]+" = "+n+" - "+s[i]+" * "+a:"index -= "+s[i]+" * "+a;return o+"; "+l+";"}).join("")}function pd(s,x,n="index"){const r=U0(x);return r.map((a,i)=>{const o="int "+s[i]+" = "+n+" / outShapeStrides["+i+"]",l=i===r.length-1?"int "+s[i+1]+" = "+n+" - "+s[i]+" * outShapeStrides["+i+"]":"index -= "+s[i]+" * outShapeStrides["+i+"]";return o+"; "+l+";"}).join("")}function eP(s,x){const n=s.length,r=s.map(i=>x+"["+i+"]"),a=new Array(n-1);a[n-2]=r[n-1];for(let i=n-3;i>=0;--i)a[i]="("+a[i+1]+" * "+r[i+1]+")";return a}function tP(s,x,n="index"){const r=s.map((i,o)=>o),a=eP(r,x);return a.map((i,o)=>{const l="int "+s[o]+" = "+n+" / "+a[o],c=o===a.length-1?"int "+s[o+1]+" = "+n+" - "+s[o]+" * "+a[o]:"index -= "+s[o]+" * "+a[o];return l+"; "+c+";"}).join("")}function Tg(s){const x=U0(s).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+x[0]+" + coords.y * "+x[1]+` + coords.z;
  }
`}function Ag(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const zw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:Ww}=e5;function xP(s,x,n){const r=[];if(s.forEach(m=>{const g=be(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push("uniform float "+m.name+(g>1?"["+g+"]":"")+";"):(r.push("uniform sampler2D "+m.name+";"),r.push("uniform int offset"+m.name+";")),n.enableShapeUniforms){const{uniformShape:y}=Eg(n.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(y.length){case 1:r.push("uniform int "+m.name+"Shape;");break;case 2:r.push("uniform ivec2 "+m.name+"Shape;");break;case 3:r.push("uniform ivec3 "+m.name+"Shape;");break;case 4:r.push("uniform ivec4 "+m.name+"Shape;");break}r.push("uniform ivec2 "+m.name+"TexShape;")}}),n.enableShapeUniforms){switch(x.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(m=>{r.push("uniform "+m.type+" "+m.name+(m.arrayIndex?"["+m.arrayIndex+"]":"")+";")});const a=r.join(`
`),i=s.map(m=>nP(m,x,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=x.texShape,l=Ln(),c=aP(l);let d,h,p=lP(l);return x.isPacked?(d=rP(x.logicalShape,o,n.enableShapeUniforms),h=oP(l)):(d=sP(x.logicalShape,o,n.enableShapeUniforms),h=iP(l)),n.packedInputs&&(p+=hP),[p,c,h,a,d,i,n.userCode].join(`
`)}function Ai(s,x=!1){const n=s.shapeInfo.logicalShape;switch(n.length){case 0:return AP(s,x);case 1:return CP(s,x);case 2:return IP(s,x);case 3:return NP(s,x);case 4:return PP(s,x);case 5:return LP(s);case 6:return DP(s);default:throw new Error(n.length+"-D input sampling is not yet supported")}}function Gw(s,x){switch(s.shapeInfo.logicalShape.length){case 0:return TP(s);case 1:return EP(s,x);case 2:return MP(s,x);case 3:return kP(s,x);default:return RP(s,x)}}function nP(s,x,n=!1,r){let a="";n?a+=Gw(s,r):a+=Ai(s,r);const i=s.shapeInfo.logicalShape,o=x.logicalShape;return i.length<=o.length&&(n?a+=OP(s,x):a+=FP(s,x)),a}function rP(s,x,n){switch(s.length){case 0:return Vw();case 1:return pP(s,x,n);case 2:return _P(s,x,n);case 3:return mP(s,x,n);default:return yP(s,x,n)}}function sP(s,x,n){switch(s.length){case 0:return Vw();case 1:return fP(s,x,n);case 2:return SP(s,x,n);case 3:return gP(s,x,n);case 4:return bP(s,x,n);case 5:return vP(s,x);case 6:return wP(s,x);default:throw new Error(s.length+"-D output sampling is not yet supported")}}function aP(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+s.texture2D+`(textureSampler, uv).r;
    }
  `}function iP(s){return`
    void setOutput(float val) {
      `+s.output+` = vec4(val, 0, 0, 0);
    }
  `}function oP(s){return`
    void setOutput(vec4 val) {
      `+s.output+` = val;
    }
  `}function lP(s){return s.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+s.varyingFs+` vec2 resultUV;
    `+s.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+s.defineSpecialNaN+`
    `+s.defineSpecialInf+`
    `+s.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+cP+`
    `+uP+`
    `+dP+`
  `}const cP=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uP=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dP=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hP=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Vw(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pP(s,x,n){const r=[Math.ceil(x[0]/2),Math.ceil(x[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+r[1]+`.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+r[0]+`.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+r[0]+", "+r[1]+`));
      return 2 * (resTexRC.x * `+r[1]+` + resTexRC.y);
    }
  `}function fP(s,x,n){return x[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+x[1]+`.0);
      }
    `:x[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+x[0]+`.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+x[0]+", "+x[1]+`));
      return resTexRC.x * `+x[1]+` + resTexRC.y;
    }
  `}function mP(s,x,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(x[0]/2),Math.ceil(x[1]/2)],a=Math.ceil(s[2]/2),i=a*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+r[0]+", "+r[1]+`));
      int index = resTexRC.x * `+r[1]+` + resTexRC.y;

      int b = index / `+i+`;
      index -= b * `+i+`;

      int r = 2 * (index / `+a+`);
      int c = imod(index, `+a+`) * 2;

      return ivec3(b, r, c);
    }
  `}function gP(s,x,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+pd(["r","c","d"],s)+`
    return ivec3(r, c, d);
  }
`;const r=ga(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+x[0]+", "+x[1]+`));
      int index = resTexRC.x * `+x[1]+` + resTexRC.y;
      `+r+`
      return ivec3(r, c, d);
    }
  `}function yP(s,x,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(x[0]/2),Math.ceil(x[1]/2)],a=Math.ceil(s[s.length-1]/2),i=a*Math.ceil(s[s.length-2]/2);let o=i,l="",c="b, r, c";for(let d=2;d<s.length-1;d++)o*=s[s.length-d-1],l=`
      int b`+d+" = index / "+o+`;
      index -= b`+d+" * "+o+`;
    `+l,c="b"+d+", "+c;return`
    ivec`+s.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+r[0]+", "+r[1]+`));
      int index = resTexRC.x * `+r[1]+` + resTexRC.y;

      `+l+`

      int b = index / `+i+`;
      index -= b * `+i+`;

      int r = 2 * (index / `+a+`);
      int c = imod(index, `+a+`) * 2;

      return ivec`+s.length+"("+c+`);
    }
  `}function bP(s,x,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+pd(["r","c","d","d2"],s)+`
      return ivec4(r, c, d, d2);
    }
  `;const r=ga(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+x[0]+", "+x[1]+`));
      int index = resTexRC.x * `+x[1]+` + resTexRC.y;
      `+r+`
      return ivec4(r, c, d, d2);
    }
  `}function vP(s,x){const n=ga(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+x[0]+`,
                             `+x[1]+`));

      int index = resTexRC.x * `+x[1]+` + resTexRC.y;

      `+n+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function wP(s,x){const n=ga(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+x[0]+", "+x[1]+`));
      int index = resTexRC.x * `+x[1]+` + resTexRC.y;

      `+n+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function _P(s,x,n){const r=[Math.ceil(x[0]/2),Math.ceil(x[1]/2)];if(T0(s,x))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+r[0]+", "+r[1]+`));
      }
    `;const a=Math.ceil(s[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+r[0]+", "+r[1]+`));

      int index = resTexRC.x * `+r[1]+` + resTexRC.y;
      int r = 2 * (index / `+a+`);
      int c = imod(index, `+a+`) * 2;

      return ivec2(r, c);
    }
  `}function SP(s,x,n){return T0(s,x)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+x[0]+", "+x[1]+`));
      }
    `:s[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+x[0]+", "+x[1]+`));
        int index = resTexRC.x * `+x[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+x[0]+", "+x[1]+`));
        int index = resTexRC.x * `+x[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+x[0]+", "+x[1]+`));
      int index = resTexRC.x * `+x[1]+` + resTexRC.y;
      int r = index / `+s[1]+`;
      int c = index - r * `+s[1]+`;
      return ivec2(r, c);
    }
  `}function ya(s){return"offset"+s}function TP(s){const x=s.name,n="get"+x.charAt(0).toUpperCase()+x.slice(1),r=Ln();return`
    vec4 `+n+`() {
      return `+r.texture2D+"("+x+`, halfCR);
    }
  `}function AP(s,x){const n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(s.shapeInfo.isUniform)return"float "+r+"() {return "+n+";}";const[a,i]=s.shapeInfo.texShape;if(a===1&&i===1)return`
      float `+r+`() {
        return sampleTexture(`+n+`, halfCR);
      }
    `;const o=ya(n);if(x)return`
    float `+r+`() {
      vec2 uv = uvFromFlat(`+n+"TexShape[0], "+n+"TexShape[1], "+o+`);
      return sampleTexture(`+n+`, uv);
    }
  `;const[l,c]=s.shapeInfo.texShape;return`
    float `+r+`() {
      vec2 uv = uvFromFlat(`+l+", "+c+", "+o+`);
      return sampleTexture(`+n+`, uv);
    }
  `}function EP(s,x){const n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=s.shapeInfo.texShape,i=Ln();if(x)return`
    vec4 `+r+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+n+"TexShape[0]) / 2.0), ceil(float("+n+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+i.texture2D+"("+n+`, uv);
    }
  `;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 `+r+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+o[0]+", "+o[1]+`, index);
      return `+i.texture2D+"("+n+`, uv);
    }
  `}function CP(s,x){const n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(s.shapeInfo.isUniform)return`
      float `+r+`(int index) {
        `+Ei(s)+`
      }
    `;const a=s.shapeInfo.texShape,i=a[0],o=a[1];if(o===1&&i===1)return`
      float `+r+`(int index) {
        return sampleTexture(`+n+`, halfCR);
      }
    `;const l=ya(n);return o===1?x?`
      float `+r+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+l+") + 0.5) / float("+n+`TexShape[0]));
        return sampleTexture(`+n+`, uv);
      }
    `:`
      float `+r+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+l+") + 0.5) / "+i+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `:i===1?x?`
      float `+r+`(int index) {
        vec2 uv = vec2((float(index + `+l+") + 0.5) / float("+n+`TexShape[1]), 0.5);
        return sampleTexture(`+n+`, uv);
      }
    `:`
      float `+r+`(int index) {
        vec2 uv = vec2((float(index + `+l+") + 0.5) / "+o+`.0, 0.5);
        return sampleTexture(`+n+`, uv);
      }
    `:x?`
    float `+r+`(int index) {
      vec2 uv = uvFromFlat(`+n+"TexShape[0], "+n+"TexShape[1], index + "+l+`);
      return sampleTexture(`+n+`, uv);
    }
  `:`
    float `+r+`(int index) {
      vec2 uv = uvFromFlat(`+i+", "+o+", index + "+l+`);
      return sampleTexture(`+n+`, uv);
    }
  `}function MP(s,x){const n=s.shapeInfo.logicalShape,r=s.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=s.shapeInfo.texShape,o=i[0],l=i[1],c=Ln();if(i!=null&&T0(n,i))return x?`
      vec4 `+a+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+r+"TexShape[1], "+r+`TexShape[0]);

        return `+c.texture2D+"("+r+`, uv);
      }
    `:`
      vec4 `+a+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+l+".0, "+o+`.0);

        return `+c.texture2D+"("+r+`, uv);
      }
    `;if(x)return`
    vec4 `+a+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+r+"TexShape[0]) / 2.0), ceil(float("+r+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+r+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+c.texture2D+"("+r+`, uv);
    }
  `;const d=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],h=Math.ceil(n[1]/2);return`
    vec4 `+a+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+h+", "+d[0]+", "+d[1]+`, row, col);
      return `+c.texture2D+"("+r+`, uv);
    }
  `}function IP(s,x){const n=s.shapeInfo.logicalShape,r=s.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=s.shapeInfo.texShape;if(i!=null&&T0(n,i)){if(x)return`
      float `+a+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+r+"TexShape[1], "+r+`TexShape[0]);
        return sampleTexture(`+r+`, uv);
      }
    `;const m=i[0],g=i[1];return`
    float `+a+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+g+".0, "+m+`.0);
      return sampleTexture(`+r+`, uv);
    }
  `}const{newShape:o,keptDims:l}=Je(n),c=o;if(c.length<n.length){const m=Ci(s,c),g=["row","col"];return`
      `+Ai(m,x)+`
      float `+a+`(int row, int col) {
        return `+a+"("+Mi(g,l)+`);
      }
    `}if(s.shapeInfo.isUniform)return`
      float `+a+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+n[1]+`, 1)));
        `+Ei(s)+`
      }
    `;const d=i[0],h=i[1],p=ya(r);return h===1?x?`
      float `+a+`(int row, int col) {
        float index = dot(vec3(row, col, `+p+"), vec3("+r+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+r+`TexShape[0]));
        return sampleTexture(`+r+`, uv);
      }
    `:`
    float `+a+`(int row, int col) {
      float index = dot(vec3(row, col, `+p+"), vec3("+n[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+d+`.0);
      return sampleTexture(`+r+`, uv);
    }
  `:d===1?x?`
      float `+a+`(int row, int col) {
        float index = dot(vec3(row, col, `+p+"), vec3("+r+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+r+`TexShape[1]), 0.5);
        return sampleTexture(`+r+`, uv);
      }
    `:`
    float `+a+`(int row, int col) {
      float index = dot(vec3(row, col, `+p+"), vec3("+n[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+h+`.0, 0.5);
      return sampleTexture(`+r+`, uv);
    }
  `:x?`
      float `+a+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+r+"Shape[1] + col + "+p+`;
        vec2 uv = uvFromFlat(`+r+"TexShape[0], "+r+`TexShape[1], index);
        return sampleTexture(`+r+`, uv);
      }
    `:`
  float `+a+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+n[1]+" + col + "+p+`;
    vec2 uv = uvFromFlat(`+d+", "+h+`, index);
    return sampleTexture(`+r+`, uv);
  }
`}function kP(s,x){const n=s.shapeInfo.logicalShape,r=s.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=s.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){const m=n.slice(1),g=[1,2],y=Ci(s,m),b=["b","row","col"];return`
        `+Gw(y,x)+`
        vec4 `+a+`(int b, int row, int col) {
          return `+a+"("+Mi(b,g)+`);
        }
      `}const l=Ln();if(x)return`
    vec4 `+a+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+r+"TexShape[0]) / 2.0), ceil(float("+r+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+r+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+r+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+l.texture2D+"("+r+`, uv);
    }
  `;const c=o[0],d=o[1],h=Math.ceil(n[2]/2),p=h*Math.ceil(n[1]/2);return`
    vec4 `+a+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+c+", "+d+", "+p+", "+h+`, b, row, col);
      return `+l.texture2D+"("+r+`, uv);
    }
  `}function NP(s,x){const n=s.shapeInfo.logicalShape,r=s.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],o=n[2],{newShape:l,keptDims:c}=Je(n),d=l;if(d.length<n.length){const b=Ci(s,d),v=["row","col","depth"];return`
        `+Ai(b,x)+`
        float `+a+`(int row, int col, int depth) {
          return `+a+"("+Mi(v,c)+`);
        }
      `}if(s.shapeInfo.isUniform)return`
      float `+a+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+i+", "+o+`, 1)));
        `+Ei(s)+`
      }
    `;const h=s.shapeInfo.texShape,p=h[0],m=h[1],g=s.shapeInfo.flatOffset;if(m===i&&g==null)return x?`
      float `+a+`(int row, int col, int depth) {
        int stride1 = `+r+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+r+"TexShape[1], "+r+`TexShape[0]);
        return sampleTexture(`+r+`, uv);
      }
    `:`
        float `+a+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+o+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+m+".0, "+p+`.0);
          return sampleTexture(`+r+`, uv);
        }
      `;if(m===o&&g==null)return x?`
      float `+a+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+r+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+r+"TexShape[1], "+r+`TexShape[0]);
        return sampleTexture(`+r+`, uv);
      }
    `:`
    float `+a+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+n[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+m+".0, "+p+`.0);
      return sampleTexture(`+r+`, uv);
    }
  `;const y=ya(r);return x?`
    float `+a+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+r+"Shape[1] * "+r+`Shape[2];
      int stride1 = `+r+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+y+`;
      vec2 uv = uvFromFlat(`+r+"TexShape[0], "+r+`TexShape[1], index);
      return sampleTexture(`+r+`, uv);
    }
    `:`
      float `+a+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+i+" + col * "+o+" + depth + "+y+`;
        vec2 uv = uvFromFlat(`+p+", "+m+`, index);
        return sampleTexture(`+r+`, uv);
      }
  `}function RP(s,x){const n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=Ln();if(x)return`
    vec4 `+r+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+n+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+n+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+n+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+n+"TexShape[0]) / 2.0), ceil(float("+n+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+a.texture2D+"("+n+`, uv);
    }
  `;const i=s.shapeInfo.logicalShape,o=i.length,l=s.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],d=c[0],h=c[1],p=Math.ceil(i[o-1]/2);let m=p*Math.ceil(i[o-2]/2),g="int b, int row, int col",y="b * "+m+" + (row / 2) * "+p+" + (col / 2)";for(let b=2;b<o-1;b++)g="int b"+b+", "+g,m*=i[o-b-1],y="b"+b+" * "+m+" + "+y;return`
    vec4 `+r+"("+g+`) {
      int index = `+y+`;
      int texR = index / `+h+`;
      int texC = index - texR * `+h+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+h+", "+d+`);
      return `+a.texture2D+"("+n+`, uv);
    }
  `}function PP(s,x){const n=s.shapeInfo.logicalShape,r=s.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],o=n[2]*i,l=n[1]*o,{newShape:c,keptDims:d}=Je(n);if(c.length<n.length){const _=Ci(s,c),T=["row","col","depth","depth2"];return`
      `+Ai(_,x)+`
      float `+a+`(int row, int col, int depth, int depth2) {
        return `+a+"("+Mi(T,d)+`);
      }
    `}if(s.shapeInfo.isUniform)return`
      float `+a+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+l+", "+o+", "+i+`, 1)));
        `+Ei(s)+`
      }
    `;const h=s.shapeInfo.flatOffset,p=s.shapeInfo.texShape,m=p[0],g=p[1],y="int stride2 = "+r+"Shape[3];",b="int stride1 = "+r+"Shape[2] * stride2;",v="int stride0 = "+r+"Shape[1] * stride1;";if(g===l&&h==null)return x?`
      float `+a+`(int row, int col, int depth, int depth2) {
        `+y+`
        `+b+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+r+"TexShape[1], "+r+`TexShape[0]);
        return sampleTexture(`+r+`, uv);
      }
    `:`
      float `+a+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+o+", "+i+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+r+`, uv);
      }
    `;if(g===i&&h==null)return x?`
      float `+a+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+r+"Shape[1] * "+r+"Shape[2], "+r+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+r+"TexShape[1], "+r+`TexShape[0]);
        return sampleTexture(`+r+`, uv);
      }
    `:`
      float `+a+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+n[1]*n[2]+", "+n[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+r+`, uv);
      }
    `;const w=ya(r);return x?`
    float `+a+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+y+`
      `+b+`
      `+v+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+r+"TexShape[0], "+r+"TexShape[1], index + "+w+`);
      return sampleTexture(`+r+`, uv);
    }
  `:`
    float `+a+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+l+" + col * "+o+` +
          depth * `+i+` + depth2;
      vec2 uv = uvFromFlat(`+m+", "+g+", index + "+w+`);
      return sampleTexture(`+r+`, uv);
    }
  `}function LP(s){const x=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=x[4],i=x[3]*a,o=x[2]*i,l=x[1]*o,{newShape:c,keptDims:d}=Je(x);if(c.length<x.length){const b=Ci(s,c),v=["row","col","depth","depth2","depth3"];return`
      `+Ai(b)+`
      float `+r+`(int row, int col, int depth, int depth2, int depth3) {
        return `+r+"("+Mi(v,d)+`);
      }
    `}if(s.shapeInfo.isUniform)return`
      float `+r+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+l+", "+o+", "+i+", "+a+`)) +
          depth3;
        `+Ei(s)+`
      }
    `;const h=s.shapeInfo.flatOffset,p=s.shapeInfo.texShape,m=p[0],g=p[1];if(g===l&&h==null)return`
      float `+r+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+o+", "+i+", "+a+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;if(g===a&&h==null)return`
      float `+r+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+x[1]*x[2]*x[3]+`,
               `+x[2]*x[3]+", "+x[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;const y=ya(n);return`
    float `+r+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+l+" + col * "+o+" + depth * "+i+` +
          depth2 * `+a+" + depth3 + "+y+`;
      vec2 uv = uvFromFlat(`+m+", "+g+`, index);
      return sampleTexture(`+n+`, uv);
    }
  `}function DP(s){const x=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:i}=Je(x);if(a.length<x.length){const v=Ci(s,a),w=["row","col","depth","depth2","depth3","depth4"];return`
      `+Ai(v)+`
      float `+r+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+r+"("+Mi(w,i)+`);
      }
    `}const o=x[5],l=x[4]*o,c=x[3]*l,d=x[2]*c,h=x[1]*d;if(s.shapeInfo.isUniform)return`
      float `+r+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+h+", "+d+", "+c+", "+l+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+o+`, 1)));
        `+Ei(s)+`
      }
    `;const p=s.shapeInfo.flatOffset,m=s.shapeInfo.texShape,g=m[0],y=m[1];if(y===h&&p==null)return`
      float `+r+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+d+", "+c+", "+l+", "+o+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+y+".0, "+g+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;if(y===o&&p==null)return`
      float `+r+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+x[1]*x[2]*x[3]*x[4]+`,
               `+x[2]*x[3]*x[4]+`,
               `+x[3]*x[4]+`,
               `+x[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+y+".0, "+g+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;const b=ya(n);return`
    float `+r+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+h+" + col * "+d+" + depth * "+c+` +
          depth2 * `+l+" + depth3 * "+o+" + depth4 + "+b+`;
      vec2 uv = uvFromFlat(`+g+", "+y+`, index);
      return sampleTexture(`+n+`, uv);
    }
  `}function Ei(s){const x=s.name,n=be(s.shapeInfo.logicalShape);return n<2?"return "+x+";":`
    for (int i = 0; i < `+n+`; i++) {
      if (i == index) {
        return `+x+`[i];
      }
    }
  `}function OP(s,x){const n=s.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",i=s.shapeInfo.logicalShape.length,o=x.logicalShape.length,l=Ww(s.shapeInfo.logicalShape,x.logicalShape),c=ux(o),d=o-i;let h;const p=["x","y","z","w","u","v"];i===0?h="":o<2&&l.length>=1?h="coords = 0;":h=l.map(v=>"coords."+p[v+d]+" = 0;").join(`
`);let m="";o<2&&i>0?m="coords":m=s.shapeInfo.logicalShape.map((v,w)=>"coords."+p[w+d]).join(", ");let g="return outputValue;";const y=be(s.shapeInfo.logicalShape)===1,b=be(x.logicalShape)===1;if(i===1&&!y&&!b)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!b)o===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(l.length){const v=i-2,w=i-1;l.indexOf(v)>-1&&l.indexOf(w)>-1?g="return vec4(outputValue.x);":l.indexOf(v)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(w)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+a+`() {
      `+c+` coords = getOutputCoords();
      `+h+`
      vec4 outputValue = get`+r+"("+m+`);
      `+g+`
    }
  `}function FP(s,x){const n=s.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",i=x.texShape,o=s.shapeInfo.texShape,l=s.shapeInfo.logicalShape.length,c=x.logicalShape.length;if(!s.shapeInfo.isUniform&&l===c&&s.shapeInfo.flatOffset==null&&T0(o,i))return`
      float `+a+`() {
        return sampleTexture(`+n+`, resultUV);
      }
    `;const d=ux(c),h=Ww(s.shapeInfo.logicalShape,x.logicalShape),p=c-l;let m;const g=["x","y","z","w","u","v"];l===0?m="":c<2&&h.length>=1?m="coords = 0;":m=h.map(b=>"coords."+g[b+p]+" = 0;").join(`
`);let y="";return c<2&&l>0?y="coords":y=s.shapeInfo.logicalShape.map((b,v)=>"coords."+g[v+p]).join(", "),`
    float `+a+`() {
      `+d+` coords = getOutputCoords();
      `+m+`
      return get`+r+"("+y+`);
    }
  `}function ux(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error("GPU for rank "+s+" is not yet supported")}function Eg(s,x,n){const{newShape:r,keptDims:a}=Je(x),i=x.length,o=s&&i===3&&x[0]===1,l=o?x.slice(1):r,c=!s&&i>1&&!T0(x,n)&&r.length<i||o;return{useSqueezeShape:c,uniformShape:c?l:x,keptDims:a}}function Ci(s,x){const n=JSON.parse(JSON.stringify(s));return n.shapeInfo.logicalShape=x,n}function Mi(s,x){return x.map(n=>s[n]).join(", ")}function UP(s,x,n,r){const a=n.map((h,p)=>{const m={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(m.flatOffset=h.texData.slice.flatOffset),{name:x.variableNames[p],shapeInfo:m}}),i=a.map(h=>h.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=xP(a,o,x),c=N6(s.gl,l),d=s.createProgram(c);return Ce().get("ENGINE_COMPILE_ONLY")?{program:x,fragmentShader:c,source:l,webGLProgram:d,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:x,fragmentShader:c,source:l,webGLProgram:d,inShapeInfos:i,outShapeInfo:o},Hw(s,x,d))}function Hw(s,x,n){const r={},a={},i={},o=[];let l,c,d,h=null,p=null;p=s.getUniformLocation(n,"NAN",!1),Ce().getNumber("WEBGL_VERSION")===1&&(h=s.getUniformLocation(n,"INFINITY",!1));const m=!1;for(let g=0;g<x.variableNames.length;g++){const y=x.variableNames[g];r[y]=s.getUniformLocation(n,y,m),r["offset"+y]=s.getUniformLocation(n,"offset"+y,m),x.enableShapeUniforms&&(a[y+"Shape"]=s.getUniformLocation(n,y+"Shape",m),i[y+"TexShape"]=s.getUniformLocation(n,y+"TexShape",m))}return x.enableShapeUniforms&&(l=s.getUniformLocation(n,"outShape",m),d=s.getUniformLocation(n,"outShapeStrides",m),c=s.getUniformLocation(n,"outTexShape",m)),x.customUniforms&&x.customUniforms.forEach((g,y)=>{o[y]=s.getUniformLocation(n,g.name,m)}),{uniformLocations:r,customUniformLocations:o,infLoc:h,nanLoc:p,inShapesLocations:a,inTexShapesLocations:i,outShapeLocation:l,outShapeStridesLocation:d,outTexShapeLocation:c}}function Yw(s,x){if(s.length!==x.length)throw Error("Binary was compiled with "+s.length+" inputs, but was executed with "+x.length+" inputs");s.forEach((n,r)=>{const a=n.logicalShape,i=x[r],o=i.shape;if(!T0(a,o))throw Error("Binary was compiled with different shapes than the current args. Shapes "+a+" and "+o+" must match");if(n.isUniform&&i.isUniform)return;const l=n.texShape,c=i.isUniform?null:i.texData.texShape;if(!T0(l,c))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+l+" and "+c+" must match")})}function BP(s,x,n,r,a){x.program.enableShapeUniforms||(Yw(x.inShapeInfos,n),Yw([x.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?s.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):s.setOutputMatrixTexture(i.texture,o[0],o[1]),s.setProgram(x.webGLProgram),Ce().getNumber("WEBGL_VERSION")===1&&x.infLoc!==null&&s.gl.uniform1f(x.infLoc,1/0),x.nanLoc!==null&&s.gl.uniform1f(x.nanLoc,NaN),n.forEach((c,d)=>{const h=x.program.variableNames[d],p=x.uniformLocations[h],m=x.uniformLocations["offset"+h],g=x.inShapesLocations[h+"Shape"],y=x.inTexShapesLocations[h+"TexShape"];if(g){const{uniformShape:b}=Eg(x.program.packedInputs,c.shape,c.texData.texShape);switch(b.length){case 1:s.gl.uniform1iv(g,new Int32Array(b));break;case 2:s.gl.uniform2iv(g,new Int32Array(b));break;case 3:s.gl.uniform3iv(g,new Int32Array(b));break;case 4:s.gl.uniform4iv(g,new Int32Array(b));break}}if(y&&s.gl.uniform2i(y,c.texData.texShape[0],c.texData.texShape[1]),p!=null){if(c.isUniform){if(be(c.shape)<2)s.gl.uniform1f(p,c.uniformValues[0]);else{let b=c.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),s.gl.uniform1fv(p,b)}return}c.texData.slice!=null&&m!=null&&s.gl.uniform1i(m,c.texData.slice.flatOffset),s.setInputMatrixTexture(c.texData.texture.texture,p,d)}});const l=x.outShapeLocation;if(l)switch(r.shape.length){case 1:s.gl.uniform1iv(l,new Int32Array(r.shape));break;case 2:s.gl.uniform2iv(l,new Int32Array(r.shape));break;case 3:s.gl.uniform3iv(l,new Int32Array(r.shape));break;case 4:s.gl.uniform4iv(l,new Int32Array(r.shape));break}if(x.outShapeStridesLocation){const c=U0(r.shape);switch(r.shape.length){case 2:s.gl.uniform1iv(x.outShapeStridesLocation,new Int32Array(c));break;case 3:s.gl.uniform2iv(x.outShapeStridesLocation,new Int32Array(c));break;case 4:s.gl.uniform3iv(x.outShapeStridesLocation,new Int32Array(c));break}}x.outTexShapeLocation&&s.gl.uniform2i(x.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),x.program.customUniforms&&a&&x.program.customUniforms.forEach((c,d)=>{const h=x.customUniformLocations[d],p=a[d];if(c.type==="float")s.gl.uniform1fv(h,p);else if(c.type==="vec2")s.gl.uniform2fv(h,p);else if(c.type==="vec3")s.gl.uniform3fv(h,p);else if(c.type==="vec4")s.gl.uniform4fv(h,p);else if(c.type==="int")s.gl.uniform1iv(h,p);else if(c.type==="ivec2")s.gl.uniform2iv(h,p);else if(c.type==="ivec3")s.gl.uniform3iv(h,p);else if(c.type==="ivec4")s.gl.uniform4iv(h,p);else throw Error("uniform type "+c.type+" is not supported yet.")}),s.executeProgram()}function zP(s,x,n){let r="";x.concat(n).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:d,uniformShape:h,keptDims:p}=Eg(s.packedInputs,o.shape,c);let m="",g="",y="";if(h.length===1&&s.packedInputs){const E=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];m=(E[0]>1)+"_"+(E[1]>1)}else if(h.length===2&&!s.packedInputs)g=(h[0]>1)+"_"+(h[1]>1);else if(h.length>2&&!s.packedInputs){const E=U0(h);y=(E[0]===c[1])+"_"+(E[E.length-1]===c[1])}const b=o.shape.length,v=h.length===2&&T0(o.shape,c),w=be(o.shape)===1,_=yi(o.shape,n.shape),T=!s.packedInputs&&b===n.shape.length&&T0(c,n.texData.texShape),A=s.packedInputs||h.length>2?"":(c[0]>1)+"_"+(c[1]>1);r+=b+"_"+T+"_"+(d?p:"")+"_"+h.length+"_"+w+"_"+_+"_"+v+"_"+m+"_"+g+"_"+y+"_"+A+"_"+l}else{const c=o.isUniform?"uniform":o.texData.texShape;r+=o.shape+"_"+c+"_"+l}});const a=s.userCode;let i=s.constructor.name;return i+="_"+r+"_"+a+(""+Ce().getNumber("WEBGL_VERSION")),i}function Dn(s){return Ce().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}class WP{constructor(x){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=sl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ln();this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?pd(["r","c","d"],x):ga(["r","c","d"],x))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+n.output+` = result;
      }
    `}}class GP{constructor(x){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=sl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ln();this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?pd(["r","c","d"],x):ga(["r","c","d"],x))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+n.output+` = result;
      }
    `}}class VP{constructor(x){this.variableNames=["A"],this.outTexUsage=p2.DOWNLOAD;const n=Ln();this.outputShape=x,this.userCode=`
      `+zw+`

      void main() {
        float x = getAAtOutCoords();
        `+n.output+` = encode_float(x);
      }
    `}}class HP{constructor(x){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=p2.DOWNLOAD;const n=Ln();this.outputShape=x,this.userCode=`
      `+zw+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+n.output+` = encode_float(x);
      }
    `}}const YP={R:0,G:1,B:2,A:3};class qw{constructor(x,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=Ln();this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)");let o="";for(let l=0;l<r.length;l++){const c=r[l];o+=`
          if(offset == `+l+`) {
            result = values[`+YP[c]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?Ag():Tg(x))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+r.length+`);

        flatIndex = idiv(flatIndex, `+r.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+a.texture2D+`(A, uv);
          `+o+`
        }
        `+a.output+" = vec4("+i+`, 0., 0., 0.);
      }
    `}}class qP{constructor(x,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ln();this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length);let a="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const c=o*2+l;a+=`
          localCoords = coords;
          if(localCoords[2] + `+l+" < "+(this.enableShapeUniforms?"outShape[2]":""+x[2])+`) {
          localCoords[2] += `+l+`;
          if (localCoords[1] + `+o+" < "+(this.enableShapeUniforms?"outShape[1]":""+x[1])+`) {
            localCoords[1] += `+o+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+r.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+c+`] = values[0];
            } else if (offset == 1) {
              result[`+c+`] = values[1];
            } else if (offset == 2) {
              result[`+c+`] = values[2];
            } else {
              result[`+c+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?Ag():Tg(x))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+a+`

          `+r.output+" = "+i+`;
        }
    `}}function XP(s){const x=Ln(),n=x.version+`
    precision highp float;
    `+x.attribute+` vec3 clipSpacePos;
    `+x.attribute+` vec2 uv;
    `+x.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return k6(s,n)}function KP(s){const x=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return D6(s,x)}function $P(s){const x=new Uint16Array([0,1,2,2,1,3]);return O6(s,x)}function ol(s,x,n,r,a,i){U6(x,n);const o=F6(s),l=s.TEXTURE_2D;return P0(s,()=>s.bindTexture(l,o)),P0(s,()=>s.texParameteri(l,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),P0(s,()=>s.texParameteri(l,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),P0(s,()=>s.texParameteri(l,s.TEXTURE_MIN_FILTER,s.NEAREST)),P0(s,()=>s.texParameteri(l,s.TEXTURE_MAG_FILTER,s.NEAREST)),Ce().getNumber("WEBGL_VERSION")===1?P0(s,()=>s.texImage2D(l,0,r,x,n,0,a,i,null)):P0(s,()=>s.texStorage2D(l,1,r,x,n)),P0(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:o,texShape:[n,x]}}function Xw(s){return s.internalFormatFloat}function ZP(s,x,n,r){const[a,i]=al(x,n);return ol(s,a,i,Xw(r),r.textureFormatFloat,s.FLOAT)}function Kw(s){return s.internalFormatHalfFloat}function JP(s,x,n,r){const[a,i]=al(x,n);return ol(s,a,i,Kw(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function $w(s){return s.downloadTextureFormat}function QP(s,x,n,r){const[a,i]=al(x,n);return ol(s,a,i,$w(r),s.RGBA,s.UNSIGNED_BYTE)}function Zw(s){return s.internalFormatPackedFloat}function jP(s,x,n,r){const[a,i]=_i(x,n);return ol(s,a,i,Zw(r),s.RGBA,s.FLOAT)}function Jw(s){return s.internalFormatPackedHalfFloat}function e7(s,x,n,r){const[a,i]=_i(x,n);return ol(s,a,i,Jw(r),s.RGBA,r.textureTypeHalfFloat)}function t7(s,x,n){return P0(s,()=>s.bindBuffer(s.ARRAY_BUFFER,n)),Fw(s,x,"clipSpacePos",n,3,20,0)&&Fw(s,x,"uv",n,2,20,12)}function x7(s,x,n,r,a,i){P0(s,()=>s.bindTexture(s.TEXTURE_2D,x));let o,l,c;a instanceof Uint8Array?(o=new Uint8Array(n*r*4),l=s.UNSIGNED_BYTE,c=s.RGBA):(o=new Float32Array(n*r*4),l=s.FLOAT,c=i.internalFormatPackedFloat),o.set(a),Ce().getNumber("WEBGL_VERSION")===2?P0(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,n,r,s.RGBA,l,o)):P0(s,()=>s.texImage2D(s.TEXTURE_2D,0,c,n,r,0,s.RGBA,l,o)),P0(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function n7(s,x,n){P0(s,()=>s.bindTexture(s.TEXTURE_2D,x)),n.data instanceof Uint8Array?Ce().getNumber("WEBGL_VERSION")===2?P0(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,n.width,n.height,s.RGBA,s.UNSIGNED_BYTE,n.data)):P0(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,n.width,n.height,0,s.RGBA,s.UNSIGNED_BYTE,n.data)):Ce().getNumber("WEBGL_VERSION")===2?P0(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,n)):P0(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,n)),P0(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function r7(s,x,n,r){const a=s.createBuffer();P0(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,a));const i=4*4*x*n;return P0(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,i,s.STREAM_READ)),P0(s,()=>s.readPixels(0,0,n,x,s.RGBA,s.FLOAT,0)),P0(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),a}function s7(s,x,n){const r=s,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,x),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function a7(s,x,n,r){const[a,i]=al(x,n),o=4,l=new Uint8Array(S6(x*n,o));return P0(s,()=>s.readPixels(0,0,a,i,r.downloadTextureFormat,s.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function i7(s,x,n,r,a,i,o,l){const c=s,d=new Float32Array(T6(i,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,x),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,d),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),d}function o7(s,x,n){const r=new Float32Array(x*n*4);return P0(s,()=>s.readPixels(0,0,n,x,s.RGBA,s.FLOAT,r)),r}class Cg{constructor(x){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=Ce().getNumber("WEBGL_VERSION");if(x!=null?(this.gl=x,v6(n,x)):this.gl=$2(n),x=this.gl,Ce().getNumber("WEBGL_VERSION")===2){const i=x;this.createVertexArray=()=>P0(i,()=>i.createVertexArray()),this.bindVertexArray=o=>P0(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>P0(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>P0(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(x!=null){const i=x.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>P0(x,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>P0(x,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>P0(x,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>P0(x,()=>x.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ce().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=ld(this.gl,i),L2(this.gl,o))this.textureHalfFloatExtension=ld(this.gl,o);else if(Ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),L2(this.gl,a))this.colorBufferHalfFloatExtension=ld(this.gl,a);else if(Ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",L2(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(L2(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=KP(this.gl),this.indexBuffer=$P(this.gl),this.framebuffer=B6(this.gl),this.textureConfig=yg(this.gl,this.textureHalfFloatExtension)}get debug(){return Ce().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const x=this.gl;P0(x,()=>x.finish()),P0(x,()=>x.bindFramebuffer(x.FRAMEBUFFER,null)),P0(x,()=>x.deleteFramebuffer(this.framebuffer)),P0(x,()=>x.bindBuffer(x.ARRAY_BUFFER,null)),P0(x,()=>x.bindBuffer(x.ELEMENT_ARRAY_BUFFER,null)),P0(x,()=>x.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(x,n){return this.throwIfDisposed(),ZP(this.gl,x,n,this.textureConfig)}createFloat16MatrixTexture(x,n){return this.throwIfDisposed(),JP(this.gl,x,n,this.textureConfig)}createUnsignedBytesMatrixTexture(x,n){return this.throwIfDisposed(),QP(this.gl,x,n,this.textureConfig)}uploadPixelDataToTexture(x,n){this.throwIfDisposed(),n7(this.gl,x,n)}uploadDenseMatrixToTexture(x,n,r,a){this.throwIfDisposed(),x7(this.gl,x,n,r,a,this.textureConfig)}createFloat16PackedMatrixTexture(x,n){return this.throwIfDisposed(),e7(this.gl,x,n,this.textureConfig)}createPackedMatrixTexture(x,n){return this.throwIfDisposed(),jP(this.gl,x,n,this.textureConfig)}deleteMatrixTexture(x){this.throwIfDisposed(),this.outputTexture===x&&(Uw(this.gl,this.framebuffer),this.outputTexture=null),P0(this.gl,()=>this.gl.deleteTexture(x))}downloadByteEncodedFloatMatrixFromOutputTexture(x,n,r){return this.downloadMatrixDriver(x,()=>a7(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(x,n,r,a,i,o){return i7(this.gl,x,n,r,a,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(x,n){return s7(this.gl,x,n)}createBufferFromTexture(x,n,r){this.bindTextureToFrameBuffer(x);const a=r7(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const x=this.createFence(this.gl);return this.pollFence(x)}createFence(x){let n,r;if(Ce().getBool("WEBGL_FENCE_API_ENABLED")){const a=x,i=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);x.flush(),r=()=>{const o=a.clientWaitSync(i,0,0);return o===a.ALREADY_SIGNALED||o===a.CONDITION_SATISFIED},n=i}else Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(x,n,r){return this.downloadMatrixDriver(x,()=>o7(this.gl,n,r))}createProgram(x){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=XP(n));const r=P6(n);P0(n,()=>n.attachShader(r,this.vertexShader)),P0(n,()=>n.attachShader(r,x)),L6(n,r);let a;return a=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(a.vao),P0(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(t7(n,a,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&bg(n,a),this.setProgram(a),a}deleteProgram(x){this.throwIfDisposed(),x===this.program&&(this.program=null),x!=null&&(P0(this.gl,()=>this.gl.deleteProgram(x)),this.deleteVertexArray(x.vao))}setProgram(x){this.throwIfDisposed(),this.program=x,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&bg(this.gl,this.program)),P0(this.gl,()=>this.gl.useProgram(x))}getUniformLocation(x,n,r=!0){return this.throwIfDisposed(),r?W6(this.gl,x,n):G6(this.gl,x,n)}getAttributeLocation(x,n){return this.throwIfDisposed(),P0(this.gl,()=>this.gl.getAttribLocation(x,n))}getUniformLocationNoThrow(x,n){return this.throwIfDisposed(),this.gl.getUniformLocation(x,n)}setInputMatrixTexture(x,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),V6(this.gl,x,n,r)}setOutputMatrixTexture(x,n,r){this.setOutputMatrixTextureDriver(x,r,n)}setOutputPackedMatrixTexture(x,n,r){this.throwIfDisposed();const[a,i]=_i(n,r);this.setOutputMatrixTextureDriver(x,a,i)}setOutputMatrixWriteRegion(x,n,r,a){this.setOutputMatrixWriteRegionDriver(r,x,a,n)}setOutputPackedMatrixWriteRegion(x,n,r,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&bg(this.gl,this.program),cd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const x=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}P0(x,()=>x.drawElements(x.TRIANGLES,6,x.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),P0(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ld(this.gl,Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,a=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(a.TIME_ELAPSED_EXT,i),i}const x=this.getQueryTimerExtensionWebGL1(),n=x.createQueryEXT();return x.beginQueryEXT(x.TIME_ELAPSED_EXT,n),n}endQuery(){if(Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const x=this.getQueryTimerExtensionWebGL1();x.endQueryEXT(x.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(x){return await Wt(()=>this.disposed||this.isQueryAvailable(x,Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(x,Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(x,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(x,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(x,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(x,n){if(n===0)return!0;if(n===2){const r=this.gl,a=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(x,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),a=r.getQueryObjectEXT(x,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(x){return new Promise(n=>{this.addItemToPoll(()=>x.isFencePassed(),()=>n())})}pollItems(){const x=l7(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=x;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(x+1)}addItemToPoll(x,n){if(this.itemsToPoll.push({isDoneFn:x,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ce().platform&&(r=Ce().platform.setTimeoutCustom.bind(Ce().platform)),Wt(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(x){this.throwIfDisposed(),vg(this.gl,x,this.framebuffer),this.debug&&cd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(vg(this.gl,this.outputTexture,this.framebuffer),this.debug&&cd(this.gl)):Uw(this.gl,this.framebuffer)}downloadMatrixDriver(x,n){this.bindTextureToFrameBuffer(x);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(x,n,r){this.throwIfDisposed();const a=this.gl;vg(a,x,this.framebuffer),this.debug&&cd(a),this.outputTexture=x,P0(a,()=>a.viewport(0,0,n,r)),P0(a,()=>a.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(x,n,r,a){this.throwIfDisposed(),P0(this.gl,()=>this.gl.scissor(x,n,r,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function l7(s){let x=0;for(;x<s.length&&s[x]();++x);return x-1}function G0(s,x){Array.isArray(s)||(s=[s]),s.forEach(n=>{n!=null&&G(n.dtype!=="complex64",()=>x+" does not support complex64 tensors in the CPU backend.")})}function Qw(s){const x=new Float32Array(s.length);for(let n=0;n<s.length;++n)x[n]=Math.abs(s[n]);return x}const c7=s=>{const{x}=s.inputs,n=s.backend;G0(x,"abs");let r=new Float32Array(be(x.shape));const a=n.data.get(x.dataId).values;return r=Qw(a),n.makeOutput(r,x.shape,x.dtype)},u7={kernelName:Po,backendName:"cpu",kernelFunc:c7};function Wx(s){return(x,n,r,a,i)=>{const o=Ot(x,n),l=o.length,c=U0(o),d=be(o),h=Ke(i,d),p=x.length,m=n.length,g=U0(x),y=U0(n),b=yi(x,o),v=yi(n,o);if(b.length+v.length===0)for(let w=0;w<h.length;++w)h[w]=s(r[w%r.length],a[w%a.length]);else for(let w=0;w<h.length;++w){const _=bt(w,l,c),T=_.slice(-p);b.forEach(I=>T[I]=0);const A=J0(T,p,g),E=_.slice(-m);v.forEach(I=>E[I]=0);const M=J0(E,m,y);h[w]=s(r[A],a[M])}return[h,o]}}function s2(s){const{inputs:x,backend:n}=s,{real:r,imag:a}=x,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.makeTensorInfo(r.shape,"complex64"),c=n.data.get(l.dataId);return c.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(a.shape,"float32",o)},l}const d7={kernelName:cp,backendName:"cpu",kernelFunc:s2};function fd(s,x,n="float32"){if(n==="complex64"){const a=fd(s,x,"float32"),i=fd(s,x,"float32");return s2({inputs:{real:a,imag:i},backend:s})}const r=Ae(be(x),n);return s.makeTensorInfo(x,n,r)}function pr(s){const{inputs:x,backend:n}=s,{x:r}=x;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const h7={kernelName:Xc,backendName:"cpu",kernelFunc:pr};function ba(s){const{inputs:x,backend:n}=s,{input:r}=x,a=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}const p7={kernelName:cf,backendName:"cpu",kernelFunc:ba};function jw(s,x,n,r){if(r==="int32"){const a=Int32Array.from(s);return[x,"int32",a]}if(r==="bool"){const a=Js([0],n),[i,o]=Wx((l,c)=>l!==c?1:0)(x,[],s,a,"bool");return[o,"bool",i]}throw new Error("Error in Cast: failed to cast "+n+" to "+r)}function ms(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{dtype:i}=r;if(i==="complex64"){if(a.dtype==="complex64")return pr({inputs:{x:a},backend:n});const h=fd(n,a.shape,a.dtype),p=ms({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),m=s2({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),m}if(a.dtype==="complex64"){const h=ba({inputs:{input:a},backend:n}),p=ms({inputs:{x:h},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(h),p}if(!Nt(a.dtype,i)){const h=pr({inputs:{x:a},backend:n});return{dataId:h.dataId,shape:h.shape,dtype:i}}const o=n.data.get(a.dataId).values,[l,c,d]=jw(o,a.shape,a.dtype,i);return n.makeTensorInfo(l,c,d)}const f7={kernelName:Rc,backendName:"cpu",kernelFunc:ms};function an(s,x,n,r){return n==null?({inputs:a,backend:i})=>{const{a:o,b:l}=a,c=i;G0([o,l],s);const d=c.data.get(o.dataId).values,h=c.data.get(l.dataId).values,p=o.dtype==="string"?pa(d):d,m=o.dtype==="string"?pa(h):h,g=r||o.dtype,[y,b]=x(o.shape,l.shape,p,m,g);return c.makeTensorInfo(b,g,y)}:({inputs:a,backend:i})=>{const{a:o,b:l}=a,c=i;if(o.dtype==="complex64"||l.dtype==="complex64"){const d=ms({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),h=c.data.get(d.dataId),p=h.complexTensorInfos.real,m=h.complexTensorInfos.imag,g=c.data.get(p.dataId).values,y=c.data.get(m.dataId).values,b=ms({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),v=c.data.get(b.dataId),w=v.complexTensorInfos.real,_=v.complexTensorInfos.imag,T=c.data.get(w.dataId).values,A=c.data.get(_.dataId).values,[E,M,I]=n(o.shape,l.shape,g,y,T,A),C=c.makeTensorInfo(I,"float32",E),k=c.makeTensorInfo(I,"float32",M),O=s2({inputs:{real:C,imag:k},backend:c});return c.disposeIntermediateTensorInfo(d),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(C),c.disposeIntermediateTensorInfo(k),O}else{const d=c.data.get(o.dataId).values,h=c.data.get(l.dataId).values,p=r||o.dtype,[m,g]=x(o.shape,l.shape,d,h,p);return c.makeTensorInfo(g,p,m)}}}function Mg(s){return(x,n,r,a,i,o)=>{const l=Ot(x,n),c=be(l),d=l.length,h=U0(l),p=Ke("float32",c),m=Ke("float32",c),g=yi(x,l),y=yi(n,l),b=Fr(r,a),v=Fr(i,o),w=x.length,_=U0(x),T=n.length,A=U0(n);if(g.length+y.length===0)for(let E=0;E<p.length;E++){const M=E%b.length,I=E%v.length,C=s(b[M*2],b[M*2+1],v[I*2],v[I*2+1]);p[E]=C.real,m[E]=C.imag}else for(let E=0;E<p.length;E++){const M=bt(E,d,h),I=M.slice(-w);g.forEach(ee=>I[ee]=0);const C=J0(I,w,_),k=M.slice(-T);y.forEach(ee=>k[ee]=0);const O=J0(k,T,A),z=s(b[C*2],b[C*2+1],v[O*2],v[O*2+1]);p[E]=z.real,m[E]=z.imag}return[p,m,l]}}const e_=Wx((s,x)=>s+x),m7=Mg((s,x,n,r)=>({real:s+n,imag:x+r})),Ii=an(Do,e_,m7),g7={kernelName:Do,backendName:"cpu",kernelFunc:Ii};function Ig(s,x,n,r,a){const i=be(r),o=Ae(a,n);for(let l=0;l<s.length;l++){const c=s[l];if(c<0)throw new Error("Input x must be non-negative!");c>=a||(i>0?o[c]+=x[l]:o[c]+=1)}return o}function t_(s,x,n,r=!1){const a=s.shape[0],i=s.shape[1],o=At([a,n],x.dtype);for(let l=0;l<a;l++)for(let c=0;c<i;c++){const d=s.get(l,c);if(d<0)throw new Error("Input x must be non-negative!");d>=n||(r?o.set(1,l,d):x.size>0?o.set(o.get(l,d)+x.get(l,c),l,d):o.set(o.get(l,d)+1,l,d))}return o}function gs(s){return(x,n,r)=>{const a=Ke(n,x.length);for(let i=0;i<x.length;++i)a[i]=s(x[i],r);return a}}function nx(s,x,n){return({inputs:r,attrs:a,backend:i})=>{const{x:o}=r;if(G0(o,s),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const l=i,c=l.data.get(o.dataId).values,d=be(o.shape),h=n||o.dtype,p=a0(h,d);for(let m=0;m<d;++m)p[m]=x(c[m],a);return l.makeTensorInfo(o.shape,h,p)}}function ki(s,x,n){return({inputs:r,attrs:a,backend:i})=>{const{x:o}=r;if(G0(o,s),o.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");const l=i,c=l.data.get(o.dataId).values,d=n||o.dtype,h=x(c,d,a);return l.makeTensorInfo(o.shape,d,h)}}const x_=gs(s=>Math.ceil(s)),y7=ki(Pc,x_),b7={kernelName:Pc,backendName:"cpu",kernelFunc:y7};function n_(s,x,n,r){const a=a0(n,be(x));if(r&&n!=="string"){let i=0;s.forEach(o=>{const l=be(o.shape);a.set(o.vals,i),i+=l})}else{let i=0;s.forEach(o=>{const l=n==="string"?pa(o.vals):o.vals;let c=0;for(let d=0;d<o.shape[0];++d){const h=d*x[1]+i;for(let p=0;p<o.shape[1];++p)a[h+p]=l[c++]}i+=o.shape[1]})}return a}const r_=Wx((s,x)=>s===x?1:0),s_=an(zc,r_,null,"bool"),v7={kernelName:zc,backendName:"cpu",kernelFunc:s_},a_=gs(s=>Math.exp(s)),i_=ki(Wc,a_,"float32"),w7={kernelName:Wc,backendName:"cpu",kernelFunc:i_},o_=gs(s=>Math.expm1(s)),_7=ki(Gc,o_),S7={kernelName:Gc,backendName:"cpu",kernelFunc:_7},l_=gs(s=>Math.floor(s)),T7=ki(Vc,l_),A7={kernelName:Vc,backendName:"cpu",kernelFunc:T7};function c_(s,x,n,r,a,i,o,l,c){const d=At([r,i],n);for(let h=0;h<r;h++){const p=[];let m=0;for(let g=0;g<a;g++){const y=s[h*a+g];m+=y*o[g],p.push(y)}if(m<0||m>=c/i)throw new Error("Invalid indices: "+p+" does not index into "+l);for(let g=0;g<i;g++)d.values[h*i+g]=x.get(...x.indexToLoc(m*i+g))}return d}function u_(s,x,n){const r=At(n,s.dtype);for(let a=0;a<r.size;++a){const i=r.indexToLoc(a).slice(),o=i[0],l=i[2],c=x.locToIndex([o,l]);i[2]=x.values[c];const d=s.locToIndex(i);0<=d&&d<s.values.length&&(r.values[a]=s.values[d])}return r}const d_=Wx((s,x)=>s>x?1:0),E7=an(Yc,d_,null,"bool"),C7={kernelName:Yc,backendName:"cpu",kernelFunc:E7},h_=Wx((s,x)=>s>=x?1:0),M7=an(qc,h_,null,"bool"),I7={kernelName:qc,backendName:"cpu",kernelFunc:M7},p_=Wx((s,x)=>s<x?1:0),k7=an(Jc,p_,null,"bool"),N7={kernelName:Jc,backendName:"cpu",kernelFunc:k7},f_=Wx((s,x)=>s<=x?1:0),R7=an(Qc,f_,null,"bool"),P7={kernelName:Qc,backendName:"cpu",kernelFunc:R7};function m_(s,x,n){const r=(x-s)/(n-1),a=Ae(n,"float32");a[0]=s;for(let i=1;i<a.length;i++)a[i]=a[i-1]+r;return a}const g_=gs(s=>Math.log(s)),L7=ki(jc,g_),D7={kernelName:jc,backendName:"cpu",kernelFunc:L7};function y_(s,x,n,r){const a=Ke(r,be(n));for(let i=0;i<a.length;++i){const o=i*x;let l=s[o];for(let c=0;c<x;++c){const d=s[o+c];(Number.isNaN(d)||d>l)&&(l=d)}a[i]=l}return a}const b_=Wx((s,x)=>Math.max(s,x)),O7=an(ru,b_),F7={kernelName:ru,backendName:"cpu",kernelFunc:O7},v_=Wx((s,x)=>Math.min(s,x)),U7=an(su,v_),B7={kernelName:su,backendName:"cpu",kernelFunc:U7},kg=Wx((s,x)=>s*x),z7=Mg((s,x,n,r)=>({real:s*n-x*r,imag:s*r+x*n})),md=an(iu,kg,z7),W7={kernelName:iu,backendName:"cpu",kernelFunc:md};function w_(s,x,n){const r=as(-1,n);return kg([],x,r,s,n)}function G7(s){const{inputs:x,backend:n}=s,{x:r}=x;G0(r,"neg");const a=n.data.get(r.dataId).values,[i,o]=w_(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}const V7={kernelName:$p,backendName:"cpu",kernelFunc:G7},__=Wx((s,x)=>s!==x?1:0),H7=an(ou,__,null,"bool"),Y7={kernelName:ou,backendName:"cpu",kernelFunc:H7};function Ng(s,x,n,r,a){const i=x.length,o=be(x),l=U0(x),c=U0(a),d=Ke(n,be(a));for(let h=0;h<o;++h){const p=bt(h,i,l),m=new Array(p.length);for(let y=0;y<m.length;y++)m[y]=p[r[y]];const g=J0(m,i,c);d[g]=s[h]}return d}function $n(s){const{inputs:x,attrs:n,backend:r}=s,{x:a}=x,{perm:i}=n;G0(a,"transpose");const o=a.shape.length,l=new Array(o);for(let h=0;h<l.length;h++)l[h]=a.shape[i[h]];const c=r.data.get(a.dataId).values,d=Ng(c,a.shape,a.dtype,i,l);return{dataId:r.write(d,l,a.dtype),shape:l,dtype:a.dtype}}const q7={kernelName:Oo,backendName:"cpu",kernelFunc:$n};function S_(s,x,n,r){const[a,i]=dn(s,r),o=n2(x,"int32"),l=Ae(be(a),o),c=be(i);for(let d=0;d<l.length;++d){const h=d*c;let p=1;for(let m=0;m<c;++m)p*=n[h+m];l[d]=p}return{outVals:l,outShape:a,outDtype:o}}function X7(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;G0(a,"prod");const l=a.shape.length,c=_0(i,a.shape),d=Nx(c,l);let h=c,p=a;const m=[];d!=null&&(p=$n({inputs:{x:a},backend:n,attrs:{perm:d}}),m.push(p),h=Rx(h.length,l));const g=n.data.get(p.dataId).values,{outVals:y,outShape:b,outDtype:v}=S_(p.shape,p.dtype,g,h);let w=b;return o&&(w=$x(b,c)),m.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.makeTensorInfo(w,v,y)}const K7={kernelName:rf,backendName:"cpu",kernelFunc:X7};function $7(s,x,n){s.forEach((r,a)=>{if(r<0||r>=n){const i=bt(a,x.length,U0(x)).join(",");throw new Error("indices["+i+"] = "+r+" is not in [0, "+n+")")}})}function Z7(s,x){for(let n=0;n<s.length;++n){const r=s[n],a=n===s.length-1?x:s[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function J7(s,x,n,r){const a=[];let i=0;const o=x.length-1+n.length,l=new Array(o).fill(null).map(()=>[0]);Z7(n,r);let c=1;for(let d=0;d<x.length-1;++d){c*=x[d];const h=x[d+1];for(let p=1;p<c+1;++p)l[d].push(p*h)}for(let d=0;d<s.length;++d){let h=s[d],p=s[d]+1;for(let m=0;m<n.length;++m){const g=n[m],y=m+x.length-1;if(y>=0){const b=l[y],v=b[b.length-1]-g[h];for(let w=h;w<p;++w)l[y].push(g[w+1]+v)}h=g[h],p=g[p]}p!==h&&(a.push([h,p]),i+=p-h)}return{outSplits:l,valueSlices:a,numValues:i}}function Q7(s){const x=[];for(let n=0;n<s.length;++n){const r=s[n].length,a=a0("int32",r);x.push(a),s[n].forEach((i,o)=>a[o]=i)}return x}function T_(s,x){const n=s.slice(0,x);for(;n.length<x;)n.push(1);for(let r=x;r<s.length;r++)n[x-1]*=s[r];return n}function j7(s,x,n,r,a,i){const o=T_(x,2)[1],l=T_(i,2)[1];let c=0;for(const d of n)for(let h=d[0];h<d[1];++h){for(let p=0;p<r;++p)a[c*l+p]=s[h*o+p];++c}}function eL(s,x,n,r,a){const i=x.slice();i[0]=a;const o=a0(n,be(i)),l=s.length,c=l===0?0:l/x[0];return j7(s,x,r,c,o,i),[o,i]}function A_(s,x,n,r,a,i,o,l){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(x[0].length===0)throw new Error("Split tensors must not be scalars");const c=x[0][0]-1;if($7(i,o,c),r.length===0)throw new Error("params.rank must be nonzero");const d=r[0],{outSplits:h,valueSlices:p,numValues:m}=J7(i,o,s,d),g=Q7(h),y=eL(n,r,a,p,m);return[g,y[0],y[1]]}const E_=2147483647;function C_(s,x,n,r,a,i,o){if(x.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=x.length===0,c=a.length===0,d=o.length===0,h=[];l||h.push(x[0]),c||h.push(a[0]),d||h.push(o[0]);for(let v=1;v<h.length;++v)if(h[v]!==h[v-1])throw new Error("starts, limits, and deltas must have the same shape");const p=h.length===0?1:h[0],m=a0("int32",p+1);m[0]=0;for(let v=0;v<p;++v){const w=l?s[0]:s[v],_=c?r[0]:r[v],T=d?i[0]:i[v];if(T===0)throw new Error("Requires delta != 0");let A;if(T>0&&_<w||T<0&&_>w)A=0;else if(A=Math.ceil(Math.abs((_-w)/T)),A>E_)throw new Error("Requires ((limit - start) / delta) <= "+E_);m[v+1]=m[v]+A}const g=m[p],y=a0(n,g);let b=0;for(let v=0;v<p;++v){const w=m[v+1]-m[v];let _=l?s[0]:s[v];const T=d?i[0]:i[v];for(let A=0;A<w;++A)y[b++]=_,_+=T}return[m,y]}var D2=K2;class gd{constructor(x,n,r,a,i,o,l,c,d,h){this.shape=x,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=Xv(h),this.raggedRank=Kv(this.rowPartitionTypes)}getRowPartitionTypeByDimension(x){return this.rowPartitionTypes[0]===D2.FIRST_DIM_SIZE?this.rowPartitionTypes[x+1]:this.rowPartitionTypes[x]}getRowPartitionTensor(x){return this.rowPartitionTypes[0]===D2.FIRST_DIM_SIZE?this.rowPartitionValues[x+1]:this.rowPartitionValues[x]}getMaxWidth(x){const n=this.getRowPartitionTensor(x-1);switch(this.getRowPartitionTypeByDimension(x-1)){case D2.VALUE_ROWIDS:return gd.getMaxWidthValueRowID(n);case D2.ROW_SPLITS:return gd.getMaxWidthRowSplit(n);default:throw new Error("Cannot handle partition type "+D2[this.getRowPartitionTypeByDimension(x-1)])}}static getMaxWidthRowSplit(x){const n=x.length;if(n===0||n===1)return 0;let r=0;for(let a=0;a<n-1;++a){const i=x[a+1]-x[a];i>r&&(r=i)}return r}static getMaxWidthValueRowID(x){const n=x.length;if(n===0)return 0;let r=0,a=x[0],i=0;for(let o=1;o<n;++o){const l=x[o];l!==a&&(a=l,i=Math.max(o-r,i),r=o)}return Math.max(n-r,i)}tensorShapeFromTensor(x,n,r=!0){if(n.length===0){if(x[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return I_(x,r)}calculateOutputSize(x){const n=this.valuesShape,r=this.defaultValueShape;$v(r,n);const a=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=qv(this.raggedRank,a,n);i[0]<0&&(i[0]=x);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(x,n,r){const a=Math.min(x,r),i=[];let o=0;for(let l=0;l<a;++l,o+=n)i.push(o);for(let l=a;l<x;++l)i.push(-1);return G(i.length===x,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(x,n,r,a){const i=x.length,o=[];for(let l=0;l<i-1;++l){const c=x[l+1]-x[l];let d=Math.min(a,c),h=n[l];h===-1&&(d=0);for(let p=0;p<d;++p)o.push(h),h+=r;for(let p=0;p<c-d;++p)o.push(-1)}if(i>0&&o.length!==x[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(x,n,r,a){const i=x.length,o=[];if(i===0)return[];let l=0,c=x[0];if(c>=n.length)throw new Error("Got currentValueRowId="+c+", which is not less than "+n.length);let d=n[c];o.push(d);for(let h=1;h<i;++h){const p=x[h];if(p===c)d>=0&&(++l,l<a?d+=r:d=-1);else{if(l=0,c=p,p>=n.length)throw new Error("Got nextValueRowId="+p+" which is not less than "+n.length);d=n[p]}o.push(d)}if(o.length!==x.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(x,n,r,a){const i=this.getRowPartitionTensor(x),o=this.getRowPartitionTypeByDimension(x);switch(o){case D2.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,r,a);case D2.ROW_SPLITS:if(i.length-1>n.length)throw new Error("Row partition size is greater than output size: "+(i.length-1)+" > "+n.length);return this.calculateOutputIndexRowSplit(i,n,r,a);default:throw new Error("Unsupported partition type: "+D2[o])}}getFirstDimensionSize(){const x=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case D2.FIRST_DIM_SIZE:return x[0];case D2.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case D2.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+D2[n])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const x=this.getFirstDimensionSize(),n=this.calculateOutputSize(x),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let o=r.length-2;o>=0;--o)r[o]=r[o+1]*n[o+1];const a=I_(n,!1),i=a0(this.valuesDType,be(a));if(r[0]*n[0]>0){let o=this.calculateFirstParentOutputIndex(x,r[0],n[0]);for(let l=1;l<=this.raggedRank;++l)o=this.calculateOutputIndex(l-1,o,r[l],n[l]);this.setOutput(this.raggedRank,o,i,a)}return[a,i]}setOutput(x,n,r,a){if(r.length===0)return;const i=this.values,o=r;let l=a.slice();l=l.slice(x+1);const c=be(l),d=n.length;let h=this.defaultValue;if(h.length!==c&&h.length!==1){const y=this.defaultValueShape;vt(()=>{const b=Be(h,y);h=Yo(b,l).dataSync()})}let p=0,m=0,g=0;for(let y=0;y<=d;++y){let b=y<d?n[y]:-1;if(b===g){++g;continue}if(m<g){const v=i.subarray(p*c),w=o.subarray(m*c),_=(g-m)*c;M_(w,v,_)}if(y>=d){const v=r.length;b=Math.floor(v/c)}if(b>g)if(this.defaultValue.length===1)o.subarray(g*c,b*c).fill(this.defaultValue[0]),g=b;else for(;b>g;){const v=o.slice(g*c);M_(v,h,c),++g}b<0?(p=y+1,m=g):(p=y,m=g,g=m+1)}}}function M_(s,x,n){for(let r=0;r<n;r++)s[r]=x[r]}function I_(s,x){const n=[];for(let r of s){if(r<0){if(!x)throw new Error("Dimension "+r+" must be >= 0");if(r<-1)throw new Error("Dimension "+r+" must be >= -1");r=-1}n.push(r)}return n}function k_(s,x,n,r,a,i,o,l,c,d){return new gd(s,x,n,r,a,i,o,l,c,d).compute()}function N_(s,x,n,r){const a=s===x,i=s<x&&n<0,o=x<s&&n>1;if(a||i||o)return Ae(0,r);const l=Math.abs(Math.ceil((x-s)/n)),c=Ae(l,r);x<s&&n===1&&(n=-1),c[0]=s;for(let d=1;d<c.length;d++)c[d]=c[d-1]+n;return c}const R_=gs(s=>1/Math.sqrt(s)),tL=ki(pu,R_),xL={kernelName:pu,backendName:"cpu",kernelFunc:tL};function Ni(s,x,n,r,a,i,o,l,c,d){const h=[r/a,a],p=s.values,m=x.values;if(r===0)return At(n,x.dtype);const g=At(h,x.dtype);typeof c=="string"||typeof c=="number"?g.values.fill(c):typeof c=="boolean"&&g.values.fill(+c);for(let y=0;y<i;y++){const b=[];let v=0;for(let w=0;w<o;w++){const _=p[y*o+w];b.push(_),v+=_*l[w]}if(v<0||v>=r/a)throw new Error("Invalid indices: "+b+" does not index into "+n);for(let w=0;w<a;w++)d?g.values[v*a+w]+=m[y*a+w]:g.values[v*a+w]=x.rank===0?m[0]:m[y*a+w]}return g}const nL=gs(s=>1/(1+Math.exp(-s))),P_=nx(bu,s=>1/(1+Math.exp(-s))),rL={kernelName:bu,backendName:"cpu",kernelFunc:P_};function L_(s,x,n,r,a){const i=Rm(r,x,n),o=be(n),l=U0(r);if(i){const p=Pm(x,l);return a==="string"?s.slice(p,p+o):s.subarray(p,p+o)}const c=a==="string"?pa(s):s,d=At(r,a,c),h=At(n,a);for(let p=0;p<h.size;++p){const m=h.indexToLoc(p),g=m.map((y,b)=>y+x[b]);h.set(d.get(...g),...m)}return a==="string"?gw(h.values):h.values}function va(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{begin:i,size:o}=r;G0(a,"slice");const[l,c]=Lm(a,i,o);km(a,l,c);const d=n.data.get(a.dataId).values,h=L_(d,l,c,a.shape,a.dtype);return n.makeTensorInfo(c,a.dtype,h)}const sL={kernelName:yf,backendName:"cpu",kernelFunc:va};function D_(s,x,n,r,a,i,o){const l=x[0],c=i[0],d=new Array(c),h=new Array(l),p=x[1];if(c===0){if(l!==0)throw new Error(rw(l));const v=a0(n,0),w=a0(a,0);return[v,[0,p],w,d,h]}let m=!0,g=0;const y=new Array(c).fill(0);for(let v=0;v<l;++v){const w=s[v*p];if(w<0)throw new Error(sw(v,w));if(w>=c)throw new Error(aw(v,w,c));++y[w],m=m&&w>=g,g=w}let b=!0;for(let v=0;v<c;++v){const w=y[v]===0;d[v]=w,b=b&&!w,y[v]=Math.max(y[v],1),v>0&&(y[v]+=y[v-1])}if(b&&m){const v=s,w=r;for(let _=0;_<l;++_)h[_]=_;return[v,[l,p],w,d,h]}else{const v=y[c-1],w=a0(n,v*p),_=a0(a,v),T=new Array(c).fill(0);for(let A=0;A<l;++A){const E=s[A*p],M=T[E],I=(E===0?0:y[E-1])+M;T[E]++;for(let C=0;C<p;++C)w[I*p+C]=s[A*p+C];_[I]=r[A],h[A]=I}for(let A=0;A<c;++A)if(T[A]===0){const E=A===0?0:y[A-1];w[E*p+0]=A;for(let M=1;M<p;++M)w[E*p+M]=0;_[E]=o}return[w,[v,p],_,d,h]}}function O_(s,x,n,r,a){const i=be(r),o=x[0],l=a.length,c=[];let d=1,h=-1;for(let b=0;b<l;++b){const v=a[b];if(v===-1){if(h!==-1)throw new Error(iw(h,b));h=b,c.push(1)}else{if(v<0)throw new Error(ow(b,v));d*=v,c.push(v)}}if(h!==-1){if(d<=0)throw new Error(lw());const b=Math.trunc(i/d);if(d*b!==i)throw new Error(cw(r,c));c[h]=b}if(be(c)!==i)throw new Error(uw(r,c));const p=r.length,m=[];if(p>0){m[p-1]=1;for(let b=p-2;b>=0;--b)m[b]=m[b+1]*r[b+1]}const g=[];if(l>0){g[l-1]=1;for(let b=l-2;b>=0;--b)g[b]=g[b+1]*c[b+1]}const y=a0(n,o*l);for(let b=0;b<o;++b){let v=0;for(let w=0;w<p;++w)v+=s[b*p+w]*m[w];for(let w=0;w<l;++w)y[b*l+w]=Math.trunc(v/g[w]),v%=g[w]}return[y,[o,l],c]}function Rg(s,x,n,r,a,i=!1,o=0){const l=r.length,c=[x[0],s.length/x[0]],d=c[1],h=l>0?a[l-1]+1:0;if(h<0)throw new Error(ng());const p=x.slice();p[0]=h;const m=p.reduce((_,T)=>_*T,1),g=a0(n,m);if(l===0)return h>0&&g.fill(o),[g,p];if(h<=0)throw new Error(ng());let y=0,b=1,v=0,w=a[y];for(;;){let _=0;if(b<l){if(_=a[b],w===_){++b;continue}if(w>=_)throw new Error(dw())}if(w<0||w>=h)throw new Error(hw(w,h));w>v&&g.fill(o,v*d,w*d);for(let T=y;T<b;++T){const A=r[T];if(A<0||A>=c[0])throw new Error(pw(T,r[T],c[0]));for(let E=0;E<d;E++)g[w*d+E]+=s[A*d+E]}if(i)for(let T=0;T<d;T++)g[w*d+T]/=b-y;if(y=b,++b,v=w+1,w=_,b>l)break}return v<h&&g.fill(o,v*d,h*d),[g,p]}const aL=gs(s=>Math.sqrt(s)),iL=nx(wu,s=>Math.sqrt(s)),oL={kernelName:wu,backendName:"cpu",kernelFunc:iL},F_=Wx((s,x)=>{const n=s-x;return n*n}),lL=an(_u,F_),cL={kernelName:_u,backendName:"cpu",kernelFunc:lL};function U_(s,x,n,r){const a=At(s,x.dtype);for(let i=0;i<a.size;i++){const o=a.indexToLoc(i),l=new Array(o.length);for(let c=0;c<l.length;c++)l[c]=o[c]*n[c]+r[c];a.set(x.get(...l),...o)}return a}class uL{constructor(x,n,r,a,i,o){this.separator=is(x),this.nGramWidths=n,this.leftPad=is(r),this.rightPad=is(a),this.padWidth=i,this.preserveShort=o}getPadWidth(x){return Math.min(this.padWidth<0?x-1:this.padWidth,x-1)}getNumNGrams(x,n){const r=this.getPadWidth(n);return Math.max(0,x+2*r-n+1)}createNGrams(x,n,r,a,i,o){for(let l=0;l<i;++l){const c=this.getPadWidth(o),d=Math.max(0,c-l),h=Math.max(0,c-(i-(l+1))),p=o-(d+h),m=n+(d>0?0:l-c);let g=0;g+=d*this.leftPad.length;for(let w=0;w<p;++w)g+=x[m+w].length;g+=h*this.rightPad.length,g+=(d+h+p-1)*this.separator.length,r[a+l]=new Uint8Array(g);const y=r[a+l];let b=0;const v=w=>w.forEach(_=>y[b++]=_);for(let w=0;w<d;++w)v(this.leftPad),v(this.separator);for(let w=0;w<p-1;++w)v(x[m+w]),v(this.separator);if(p>0){v(x[m+p-1]);for(let w=0;w<h;++w)v(this.separator),v(this.rightPad)}else{for(let w=0;w<h-1;++w)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(x,n){const r=x.length,a=n.length;if(a>0){let c=n[0];if(c!==0)throw new Error("First split value must be 0, got "+c);for(let d=1;d<a;++d){let h=n[d]>=c;if(h=h&&n[d]<=r,!h)throw new Error("Invalid split value "+n[d]+", must be in ["+c+", "+r+"]");c=n[d]}if(c!==r)throw new Error("Last split value must be data size. Expected "+r+", got "+c)}const i=a-1,o=a0("int32",a);if(r===0||a===0){const c=new Array(r);for(let d=0;d<=i;++d)o[d]=0;return[c,o]}o[0]=0;for(let c=1;c<=i;++c){const d=n[c]-n[c-1];let h=0;this.nGramWidths.forEach(p=>{h+=this.getNumNGrams(d,p)}),this.preserveShort&&d>0&&h===0&&(h=1),o[c]=o[c-1]+h}const l=new Array(o[i]);for(let c=0;c<i;++c){const d=n[c];let h=o[c];if(this.nGramWidths.forEach(p=>{const m=n[c+1]-n[c],g=this.getNumNGrams(m,p);this.createNGrams(x,d,l,h,g,p),h+=g}),this.preserveShort&&h===o[c]){const p=n[c+1]-n[c];if(p===0)continue;const m=p+2*this.padWidth,g=1;this.createNGrams(x,d,l,h,g,m)}}return[l,o]}}function B_(s,x,n,r,a,i,o,l){return new uL(n,r,a,i,o,l).compute(s,x)}function dL(s,x,n,r){if(!s.length)return;if(x.length===0){for(let i=0;i<s.length;++i)r.push(s.subarray(i,i+1));return}if(x.length===1){const i=x[0];let o=s.indexOf(i);for(;o!==-1;){const l=s.subarray(0,o);(!n||l.length!==0)&&r.push(l),s=s.subarray(o+1),o=s.indexOf(i)}(!n||s.length!==0)&&r.push(s);return}let a=0;for(let i=0;i<s.length+1;i++)if(i===s.length||x.indexOf(s[i])!==-1){const o=s.subarray(a,i);(!n||o.length!==0)&&r.push(o),a=i+1}}function z_(s,x,n){const r=s.length,a=[];let i=0,o=0;const l=new Array(r);for(let m=0;m<r;++m){const g=a.length;dL(s[m],x,n,a);const y=a.length-g;l[m]=y,i+=y,o=Math.max(o,y)}const c=a0("int32",i*2),d=new Array(i),h=[r,o];let p=0;for(let m=0;m<r;++m)for(let g=0;g<l[m];++g)c[p*2]=m,c[p*2+1]=g,d[p]=a[p],++p;return[c,d,h]}function W_(s,x){const n=a0("int32",s.length);for(let r=0;r<s.length;++r)n[r]=YC(s[r]).modulo(x).getLowBitsUnsigned();return n}const G_=Wx((s,x)=>s-x),hL=Mg((s,x,n,r)=>({real:s-n,imag:x-r})),Pg=an(Su,G_,hL),pL={kernelName:Su,backendName:"cpu",kernelFunc:Pg};function V_(s,x){const n=new Array(s.rank);for(let a=0;a<n.length;a++)n[a]=s.shape[a]*x[a];const r=At(n,s.dtype);for(let a=0;a<r.values.length;++a){const i=r.indexToLoc(a),o=new Array(s.rank);for(let c=0;c<o.length;c++)o[c]=i[c]%s.shape[c];const l=s.locToIndex(o);r.values[a]=s.values[l]}return r}const ll=(s,x)=>{const n=x.value-s.value;return n===0?s.index-x.index:n};function H_(s,x,n=0,r=s.length-1){for(;r>n;){if(r-n>600){const l=r-n+1,c=x-n+1,d=Math.log(l),h=.5*Math.exp(2*d/3),p=.5*Math.sqrt(d*h*(l-h)/l)*Math.sign(c-l/2),m=Math.max(n,Math.floor(x-c*h/l+p)),g=Math.min(r,Math.floor(x+(l-c)*h/l+p));H_(s,x,m,g)}const a=s[x];let i=n,o=r;for(Z0(s,n,x),ll(s[r],a)>0&&Z0(s,n,r);i<o;){for(Z0(s,i,o),i++,o--;ll(s[i],a)<0;)i=i+1;for(;ll(s[o],a)>0;)o=o-1}ll(s[n],a)===0?Z0(s,n,o):(o=o+1,Z0(s,o,r)),o<=x&&(n=o+1),x<=o&&(r=o-1)}}function Y_(s,x,n,r,a){const i=x[x.length-1],[o,l]=[s.length/i,i],c=Ke(n,o*r),d=Ke("int32",o*r);for(let p=0;p<o;p++){const m=p*l,g=s.subarray(m,m+l);let y=new Array(g.length);g.forEach((_,T)=>y[T]={value:_,index:T}),r<y.length&&(H_(y,r),y=y.slice(0,r)),a&&y.sort(ll);const b=p*r,v=c.subarray(b,b+r),w=d.subarray(b,b+r);for(let _=0;_<r;_++)v[_]=y[_].value,w[_]=y[_].index}const h=x.slice();return h[h.length-1]=r,[At(h,n,c),At(h,"int32",d)]}function q_(s,x,n,r){const a=_0(x,n)[0],i=[1,n[0],1];for(let y=0;y<a;y++)i[0]*=n[y];i[1]=n[a];for(let y=a+1;y<n.length;y++)i[2]*=n[y];const o={},l=new Int32Array(n[a]),c=new rn(i,r,s),d=[],h=i[0]===1&&i[2]===1;for(let y=0;y<n[a];y++){let b;if(h)b=s[y].toString();else{const v=[];for(let w=0;w<i[0];w++)for(let _=0;_<i[2];_++)v.push(c.get(w,y,_));b=v.join(",")}if(o[b]!==void 0)l[y]=o[b];else{const v=Object.keys(o).length;o[b]=v,l[y]=v,d.push(y)}}const p=i.slice();p[1]=Object.keys(o).length;const m=new rn(p,r);d.forEach((y,b)=>{for(let v=0;v<i[0];v++)for(let w=0;w<i[2];w++)m.set(c.get(v,y,w),v,b,w)});const g=n.slice();return g[a]=p[1],{outputValues:m.values,outputShape:g,indices:l}}var fL=Object.freeze({__proto__:null,simpleAbsImpl:Qw,addImpl:e_,bincountImpl:Ig,bincountReduceImpl:t_,castImpl:jw,ceilImpl:x_,concatImpl:n_,equalImpl:r_,expImpl:a_,expm1Impl:o_,floorImpl:l_,gatherNdImpl:c_,gatherV2Impl:u_,greaterImpl:d_,greaterEqualImpl:h_,lessImpl:p_,lessEqualImpl:f_,linSpaceImpl:m_,logImpl:g_,maxImpl:y_,maximumImpl:b_,minimumImpl:v_,multiplyImpl:kg,negImpl:w_,notEqualImpl:__,prodImpl:S_,raggedGatherImpl:A_,raggedRangeImpl:C_,raggedTensorToTensorImpl:k_,rangeImpl:N_,rsqrtImpl:R_,scatterImpl:Ni,sigmoidImpl:nL,sliceImpl:L_,sparseFillEmptyRowsImpl:D_,sparseReshapeImpl:O_,sparseSegmentReductionImpl:Rg,sqrtImpl:aL,squaredDifferenceImpl:F_,stridedSliceImpl:U_,stringNGramsImpl:B_,stringSplitImpl:z_,stringToHashBucketFastImpl:W_,subImpl:G_,tileImpl:V_,topKImpl:Y_,transposeImpl:Ng,uniqueImpl:q_});const{addImpl:mL,bincountImpl:X_,bincountReduceImpl:gL,castImpl:yL,ceilImpl:bL,concatImpl:vL,equalImpl:wL,expImpl:_L,expm1Impl:SL,floorImpl:TL,gatherNdImpl:AL,gatherV2Impl:EL,greaterImpl:CL,greaterEqualImpl:ML,lessImpl:IL,lessEqualImpl:kL,linSpaceImpl:NL,logImpl:RL,maxImpl:PL,maximumImpl:LL,minimumImpl:DL,multiplyImpl:OL,negImpl:FL,notEqualImpl:UL,prodImpl:BL,raggedGatherImpl:zL,raggedRangeImpl:WL,raggedTensorToTensorImpl:GL,rangeImpl:VL,rsqrtImpl:HL,scatterImpl:YL,sigmoidImpl:qL,simpleAbsImpl:K_,sliceImpl:XL,sparseFillEmptyRowsImpl:KL,sparseReshapeImpl:$L,sparseSegmentReductionImpl:$_,sqrtImpl:ZL,stridedSliceImpl:JL,stringNGramsImpl:QL,stringSplitImpl:jL,stringToHashBucketFastImpl:eD,subImpl:tD,tileImpl:xD,topKImpl:nD,transposeImpl:Lg,uniqueImpl:rD}=fL;function Z_(s,x){return["x","y","z","w","u","v"].slice(0,x).map(n=>s+"."+n)}function On(s,x){return x===1?[s]:Z_(s,x)}function sD(s,x){if(s===1)return"rc";let n="";for(let r=0;r<s;r++)n+=x[r],r<s-1&&(n+=",");return n}class aD{constructor(x){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=x,this.rank=x.length,this.enableShapeUniforms=Dn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=On("rc",this.rank),r=ux(this.rank),a=this.getOutOfBoundsCondition(n),i=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          `+r+` rc = getOutputCoords();

          if(`+a+`) {
            setOutput(vec4(0));
          } else {
            `+i+`

            setOutput(vec4(`+o+`));
          }
        }
      `}}getSourceCoordsArr(x){const n=[];for(let r=0;r<=1;r++)for(let a=0;a<=1;a++){let i=(r===0?"r":"rp1")+", "+(a===0?"c":"cp1");for(let o=2;o<this.rank;o++)i=x[x.length-1-o]+","+i;n.push(i)}return n}getOutOfBoundsCondition(x){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let n="";for(let r=this.rank-2;r<this.rank;r++)n+=x[r]+" >= "+(this.enableShapeUniforms?"outShape["+r+"]":this.outputShape[r]),r<this.rank-1&&(n+="||");return n}getSetup(x){if(this.rank===1)return"";const n=x.slice(-2),r=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+n[0]+`;
      int c = `+n[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+r+`;
      bool rEdge = rp1 >= `+a+`;
    `}getOutput(x){const n=this.getSourceCoordsArr(x);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+n[0]+`),
            cEdge ? 0. : getA(`+n[1]+`),
            rEdge ? 0. : getA(`+n[2]+`),
            rEdge || cEdge ? 0. : getA(`+n[3]+")"}}class J_{constructor(x,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length);let r="";for(let a=0;a<4;a++){let i="thisRC = rc;";a%2===1&&(i+="thisRC.z += 1;"),a>1&&(i+="thisRC.y += 1;"),r+=`
        `+i+`
        `+(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+a+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(a>0?"}":"")+`
      `}this.userCode=`
      `+iD(n,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?Ag():Tg(x))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":x[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":x[2])+`;

        `+r+`

        setOutput(result);
      }
    `}}function iD(s,x){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(x?tP(["r","c","d"],"inputShape"):ga(["r","c","d"],s))+`
      return ivec3(r, c, d);
    }
  `}class oD{constructor(x){this.gpgpu=x,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(x,n,r){const a=j_(n,r),i=eS(x,a,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=Q_(x,a,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[i].shift();return this.usedTextures[i].push(c),c}let l;return a===fn.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(x[0],x[1]):a===fn.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(x[0],x[1]):a===fn.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(x[0],x[1]):a===fn.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(x[0],x[1]):a===fn.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(x[0],x[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(x,n,r,a){if(this.freeTextures==null)return;const i=j_(r,a),o=eS(n,i,a);o in this.freeTextures||(this.freeTextures[o]=[]);const l=Q_(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,a),c=Ce().get("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(x.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(x),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const d=this.usedTextures[o],h=d.indexOf(x);if(h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");d.splice(h,1),this.log()}log(){if(!this.logEnabled)return;const x=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+x+")");const n=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*n)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const x in this.freeTextures)this.freeTextures[x].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const x in this.usedTextures)this.usedTextures[x].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lD(s,x){const n=s;if(x===n.R32F)return 4;if(x===n.R16F)return 2;if(x===n.RGBA32F||x===s.RGBA)return 16;if(x===n.RGBA16F)return 8;if(x===n.RGBA8)return 4;throw new Error("Unknown internal format "+x)}function Q_(s,x,n,r,a){const i=cD(x,r);let o;if(a){const[c,d]=_i(s[0],s[1]);o=c*d}else{const[c,d]=al(s[0],s[1]);o=c*d}const l=lD(n,i);return o*l}function cD(s,x){switch(s){case fn.PACKED_2X2_FLOAT32:return Zw(x);case fn.PACKED_2X2_FLOAT16:return Jw(x);case fn.UNPACKED_FLOAT32:return Xw(x);case fn.UNPACKED_FLOAT16:return Kw(x);case fn.PACKED_4X1_UNSIGNED_BYTE:return $w(x);default:throw new Error("Unknown physical texture type "+s)}}function uD(s){return Ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?fn.PACKED_2X2_FLOAT32:fn.UNPACKED_FLOAT32:s?fn.PACKED_2X2_FLOAT16:fn.UNPACKED_FLOAT16}function j_(s,x){if(s===p2.UPLOAD)return fn.PACKED_2X2_FLOAT32;if(s===p2.RENDER||s==null)return uD(x);if(s===p2.DOWNLOAD||s===p2.PIXELS)return fn.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+s)}function eS(s,x,n){return s[0]+"_"+s[1]+"_"+x+"_"+n}class fr{constructor(x,n){this.variableNames=["A"],this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+n+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const O2="if (isnan(x)) return x;",dD="return x;",tS="return abs(x);",hD="return (x >= 0.0) ? x : (exp(x) - 1.0);",pD=O2+`
  return (x < 0.0) ? 0.0 : x;
`,fD=O2+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ys="return x;",mD="return 1.0 / (1.0 + exp(-1.0 * x));",gD="return x;",yD=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bD=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vD=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wD="return 1.0 / (1.0 + exp(-1.0 * x));";class bs{constructor(x,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+n+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class _D{constructor(x){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length);const n=x.length,r=On("rc",n),a=ux(n),i=sD(n,r),o=r.slice(-2),l=n<=1?"rc":"vec2("+o.join(",")+")";this.userCode=`
      void main() {
        `+a+` rc = getOutputCoords();
        vec4 packedInput = getA(`+i+`);

        setOutput(getChannel(packedInput, `+l+`));
      }
    `}}const SD=gm,TD=1e-7,AD=1e-4,Dg={};function ED(s){return s in Dg||(Dg[s]={}),Dg[s]}const CD=Ce().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),MD=600;function ID(){return Ce().global.screen==null?1024:Ce().global.screen.height*Ce().global.screen.width*window.devicePixelRatio*MD/1024/1024}class yd extends W0{constructor(x){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ce().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(x!=null){if(x instanceof Cg)n=x;else{const r=$2(Ce().getNumber("WEBGL_VERSION"),x);n=new Cg(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=$2(Ce().getNumber("WEBGL_VERSION"));n=new Cg(r),this.binaryCache=ED(Ce().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new oD(this.gpgpu),this.numMBBeforeWarning=ID(),this.texData=new t0(this,cr())}nextDataId(){return yd.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(x,n,r,a,i,o){const l=this.makeTensorInfo(n,r),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:x,texShape:[a,i]},c.texShape=[a,i];const d=ud(n),h=new qw(d,!1,o),p=this.runWebGLProgram(h,[l],r,[[a,i]]);return p.shape=n,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(x,n,r){if((Ce().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ce().getBool("DEBUG"))&&this.checkNumericalProblems(x),r==="complex64"&&x!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:r,values:x,usage:p2.UPLOAD,refCount:1}),a}refCount(x){return this.texData.has(x)?this.texData.get(x).refCount:0}incRef(x){const n=this.texData.get(x);n.refCount++}decRef(x){if(this.texData.has(x)){const n=this.texData.get(x);n.refCount--}}move(x,n,r,a,i){if(Ce().getBool("DEBUG")&&this.checkNumericalProblems(n),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(x,{shape:r,dtype:a,values:n,usage:p2.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(x){this.disposeData(x.dataId)}readSync(x){const n=this.texData.get(x),{values:r,dtype:a,complexTensorInfos:i,slice:o,shape:l,isPacked:c}=n;if(o!=null){let m;c?m=new bs(l,ys):m=new fr(l,ys);const g=this.runWebGLProgram(m,[{dataId:x,shape:l,dtype:a}],a),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(x);if(a==="string")return r;const d=this.activeTimers!=null;let h;d&&(h=c2());let p;if(a==="complex64"){const m=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId);p=Fr(m,g)}else p=this.getValuesFromTexture(x);return d&&(this.downloadWaitMs+=c2()-h),this.convertAndCacheOnCPU(x,p)}async read(x){if(this.pendingRead.has(x)){const y=this.pendingRead.get(x);return new Promise(b=>y.push(b))}const n=this.texData.get(x),{values:r,shape:a,slice:i,dtype:o,complexTensorInfos:l,isPacked:c}=n;if(i!=null){let y;c?y=new bs(a,ys):y=new fr(a,ys);const b=this.runWebGLProgram(y,[{dataId:x,shape:a,dtype:o}],o),v=this.read(b.dataId);return this.disposeIntermediateTensorInfo(b),v}if(r!=null)return this.convertAndCacheOnCPU(x);if(Ce().getBool("DEBUG")&&!Ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ce().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,h;if(o!=="complex64"&&Ce().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(x);const y=this.texData.get(h.dataId);d=this.gpgpu.createBufferFromTexture(y.texture.texture,...od(a))}this.pendingRead.set(x,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(o==="complex64"){const y=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),b=y[0],v=y[1];p=Fr(b,v)}else if(d==null)p=this.getValuesFromTexture(x);else{const y=be(a);p=this.gpgpu.downloadFloat32MatrixFromBuffer(d,y)}if(h!=null&&this.disposeIntermediateTensorInfo(h),d!=null){const y=this.gpgpu.gl;P0(y,()=>y.deleteBuffer(d))}const m=this.convertAndCacheOnCPU(x,p),g=this.pendingRead.get(x);return this.pendingRead.delete(x),g.forEach(y=>y(m)),this.pendingDisposal.has(x)&&(this.pendingDisposal.delete(x),this.disposeData(x)&&cr().removeDataId(x,this),this.pendingDeletes--),m}readToGPU(x,n={}){const r=this.texData.get(x),{values:a,shape:i,slice:o,dtype:l,isPacked:c,texture:d}=r;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let g;c?g=new bs(i,ys):g=new fr(i,ys);const y=this.runWebGLProgram(g,[{dataId:x,shape:i,dtype:l}],l),b=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),b}if(d==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(x,n.customTexShape),p=cr().makeTensorFromTensorInfo(h),m=this.texData.get(h.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(x){const n=this.readSync(x.dataId);if(x.dtype==="string")try{const r=n.map(a=>os(a));return At(x.shape,x.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return At(x.shape,x.dtype,n)}checkNumericalProblems(x){if(x!=null)for(let n=0;n<x.length;n++){const r=x[n];if(!M6(r))throw Ce().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+r+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+r+" cannot be represented on this device.")}}getValuesFromTexture(x){const{shape:n,dtype:r,isPacked:a}=this.texData.get(x),i=be(n);if(Ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(x),g=this.texData.get(m.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...od(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),y}const o=Ce().getBool("WEBGL_PACK")&&a===!0,l=o?ud(n):n,c=o?new HP(l):new VP(l),d=this.runWebGLProgram(c,[{shape:l,dtype:r,dataId:x}],"float32"),h=this.texData.get(d.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(d),p}timerAvailable(){return Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(x){const n=this.activeTimers,r=[];let a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,x();const i=Qs(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Qs(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=n,a&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);l.kernelMs=ft(c),l.getExtraProfileInfo=()=>c.map((d,h)=>({name:o[h],ms:d})).map(d=>d.name+": "+d.ms).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:c2(),endMs:null}}endTimer(x){return Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),x):(x.endMs=c2(),x)}async getQueryTime(x){if(Ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(x);const n=x;return n.endMs-n.startMs}disposeData(x,n=!1){if(this.pendingDisposal.has(x))return!1;if(!this.texData.has(x))return!0;if(n?this.texData.get(x).refCount=0:this.texData.get(x).refCount--,!n&&this.texData.get(x).refCount>0)return!1;if(this.pendingRead.has(x))return this.pendingDisposal.add(x),this.pendingDeletes++,!1;this.releaseGPUData(x);const{complexTensorInfos:r}=this.texData.get(x);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(x),!0}releaseGPUData(x){const{texture:n,dtype:r,texShape:a,usage:i,isPacked:o,slice:l}=this.texData.get(x),c=l&&l.origDataId||x,d=this.dataRefCount.get(c);d>1?this.dataRefCount.set(c,d-1):(this.dataRefCount.delete(c),n!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(n,a,i,o)));const h=this.texData.get(x);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(x){return this.uploadToGPU(x),this.texData.get(x).texture.texture}getDataInfo(x){return this.texData.get(x)}shouldExecuteOnCPU(x,n=CD){return Ce().getBool("WEBGL_CPU_FORWARD")&&x.every(r=>this.texData.get(r.dataId).texture==null&&be(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(x){E2("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=x.dataSync();return SD(x.shape,n)}packedUnaryOp(x,n,r){const a=new bs(x.shape,n),i=this.compileAndRun(a,[x],r);return cr().makeTensorFromTensorInfo(i)}abs(x){if(this.shouldExecuteOnCPU([x])&&x.dtype!=="complex64"){const a=K_(this.texData.get(x.dataId).values);return this.makeOutput(x.shape,x.dtype,a)}if(Ce().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,tS,x.dtype);const n=new fr(x.shape,tS),r=this.compileAndRun(n,[x]);return cr().makeTensorFromTensorInfo(r)}makeTensorInfo(x,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&tx(r[0])){const i=r.map(o=>is(o));a=this.write(i,x,n)}else a=this.write(r,x,n);return this.texData.get(a).usage=null,{dataId:a,shape:x,dtype:n}}makeOutput(x,n,r){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(x,n,r),this)}unpackTensor(x){const n=new _D(x.shape);return this.runWebGLProgram(n,[x],x.dtype)}packTensor(x){const n=new aD(x.shape),r=!0;return this.runWebGLProgram(n,[x],x.dtype,null,r)}packedReshape(x,n){const r=[Si(x.shape),...Ti(x.shape)],a={dtype:x.dtype,shape:r,dataId:x.dataId},i=[Si(n),...Ti(n)],o=new J_(i,r),l=!0,c=[r],d=this.runWebGLProgram(o,[a],x.dtype,c,l);return{dataId:d.dataId,shape:n,dtype:d.dtype}}decode(x,n){const r=this.texData.get(x),{isPacked:a,shape:i,dtype:o}=r;if(n!=null){const m=be(i),g=n[0]*n[1]*4;G(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=ud(i);let c;a?c=new GP(l):c=new WP(l);const d=!0,h=[n??od(l)],p=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:x}],o,h,d,n);return{dtype:o,shape:i,dataId:p.dataId}}runWebGLProgram(x,n,r,a,i=!1,o){const l=this.makeTensorInfo(x.outputShape,r),c=this.texData.get(l.dataId);if(x.packedOutput&&(c.isPacked=!0),x.outPackingScheme===sl.DENSE){const w=o??od(x.outputShape);c.texShape=w.map(_=>_*2)}if(x.outTexUsage!=null&&(c.usage=x.outTexUsage),be(l.shape)===0)return c.values=Ke(l.dtype,0),l;const d=[],h=n.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(w.dataId);if(_.texture==null){if(!x.packedInputs&&be(w.shape)<=Ce().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:_.values};x.packedInputs&&(_.isPacked=!0,_.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!_.isPacked!=!!x.packedInputs)w=_.isPacked?this.unpackTensor(w):this.packTensor(w),d.push(w),_=this.texData.get(w.dataId);else if(_.isPacked&&!hd(_.shape,w.shape)){const T=w,A=w.shape;w.shape=_.shape,w=this.packedReshape(w,A),d.push(w),_=this.texData.get(w.dataId),T.shape=A}return{shape:w.shape,texData:_,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=zP(x,h,p),g=this.getAndSaveBinary(m,()=>UP(this.gpgpu,x,h,p)),y=this.activeTimers!=null;let b;y&&(b=this.startTimer()),Ce().get("ENGINE_COMPILE_ONLY")||BP(this.gpgpu,g,h,p,a),d.forEach(w=>this.disposeIntermediateTensorInfo(w)),y&&(b=this.endTimer(b),this.activeTimers.push({name:x.constructor.name,query:this.getQueryTime(b)}));const v=Ce().get("WEBGL_FLUSH_THRESHOLD");if(v>0){const w=c2();w-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!Ce().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const w=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),w}return l}compileAndRun(x,n,r,a,i=!1){return r=r||n[0].dtype,this.runWebGLProgram(x,n,r,a,i)}getAndSaveBinary(x,n){return x in this.binaryCache||(this.binaryCache[x]=n()),this.binaryCache[x]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ce().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(x=>{this.gpgpu.deleteProgram(this.binaryCache[x].webGLProgram),delete this.binaryCache[x]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=vt(()=>{if(!Ce().get("WEBGL_RENDER_FLOAT32_ENABLED")){const x=Ce().getBool("DEBUG");Ce().set("DEBUG",!1);const n=this.abs(Pt(1e-8)).dataSync()[0];if(Ce().set("DEBUG",x),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?TD:AD}uploadToGPU(x){const n=this.texData.get(x),{shape:r,dtype:a,values:i,texture:o,usage:l,isPacked:c}=n;if(o!=null)return;const d=this.activeTimers!=null;let h;d&&(h=c2());let p=n.texShape;if(p==null&&(p=q6(r,c),n.texShape=p),i!=null){const m=ud(r);let g,y=p[1],b=p[0];const v=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!v)&&([y,b]=_i(p[0],p[1])),c?g=new qP(m,v):g=new qw(m,v);const w=v?[b,y]:p,_=this.makeTensorInfo(w,a),T=this.texData.get(_.dataId);v?T.usage=p2.PIXELS:T.usage=p2.UPLOAD,T.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),y,b,i);const A=[[b,y]],E=!0,M=this.runWebGLProgram(g,[_],a,A,E),I=this.texData.get(M.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,Ce().get("ENGINE_COMPILE_ONLY")?this.disposeData(M.dataId):(n.texture=I.texture,n.values=null,this.texData.delete(M.dataId)),this.disposeIntermediateTensorInfo(_),d&&(this.uploadWaitMs+=c2()-h)}else{const m=this.acquireTexture(p,l,a,c);n.texture=m}}convertAndCacheOnCPU(x,n){const r=this.texData.get(x),{dtype:a}=r;return n!=null&&(r.values=kD(n,a)),r.values}acquireTexture(x,n,r,a){if(this.numBytesInGPU+=this.computeBytes(x,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+i+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(x,n,a)}computeBytes(x,n){return x[0]*x[1]*it(n)}checkCompileCompletion(){for(const[,x]of Object.entries(this.binaryCache))this.checkCompletion_(x)}async checkCompileCompletionAsync(){const x=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))x.push(this.checkCompletionAsync_(n));return Promise.all(x)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(a=>{try{this.checkCompletion_(n),a(!0)}catch(i){throw i}});x.push(r)}return Promise.all(x)}}async checkCompletionAsync_(x){return this.gpgpu.gl.getProgramParameter(x.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(x):(await Z9(),this.checkCompletionAsync_(x))}checkCompletion_(x){if(this.gpgpu.gl.getProgramParameter(x.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(x.webGLProgram)),this.gpgpu.gl.getShaderParameter(x.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Ow(x.source,this.gpgpu.gl.getShaderInfoLog(x.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,x]of Object.entries(this.binaryCache)){const{uniformLocations:n,customUniformLocations:r,infLoc:a,nanLoc:i,inShapesLocations:o,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:d,outTexShapeLocation:h}=Hw(this.gpgpu,x.program,x.webGLProgram);x.uniformLocations=n,x.customUniformLocations=r,x.infLoc=a,x.nanLoc=i,x.inShapesLocations=o,x.inTexShapesLocations=l,x.outShapeLocation=c,x.outShapeStridesLocation=d,x.outTexShapeLocation=h}}createTensorFromGPUData(x,n,r){x.channels=x.channels||"RGBA";const{texture:a,height:i,width:o,channels:l}=x,c=cr().backend;if(!c.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=c.writeTexture(a,n,r,i,o,l);return cr().makeTensorFromDataId(d,n,r,c)}}yd.nextDataId=0;function kD(s,x){if(x==="float32"||x==="complex64")return s;if(x==="int32"||x==="bool"){const n=x==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let r=0;r<n.length;++r)n[r]=Math.round(s[r]);return n}else throw new Error("Unknown dtype "+x)}ub()&&kb("webgl",()=>new yd,2);const Og=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Ri{constructor(x,n,r){this.variableNames=["A","B"],this.outputShape=Ot(n,r),this.enableShapeUniforms=Dn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+x+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const cl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ul{constructor(x,n,r,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ot(n,r);const i=this.outputShape.length;this.enableShapeUniforms=Dn(i);let o="";if(a)if(i===0||be(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          `+ux(i)+` coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=On("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (`+l[i-2]+" + 1) >= outShape["+i+` - 2];
            bool nextColOutOfBounds =
              (`+l[i-1]+" + 1) >= outShape["+i+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (`+l[i-2]+" + 1) >= "+this.outputShape[i-2]+`;
            bool nextColOutOfBounds =
              (`+l[i-1]+" + 1) >= "+this.outputShape[i-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+x+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+o+`

        setOutput(result);
      }
    `}}function a2(s){const{inputs:x,backend:n}=s,{x:r}=x;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const ND={kernelName:Xc,backendName:"webgl",kernelFunc:a2};function vs(s){const{inputs:x,backend:n}=s,{real:r,imag:a}=x,i=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(i.dataId),l=a2({inputs:{x:r},backend:n}),c=a2({inputs:{x:a},backend:n});return o.complexTensorInfos={real:l,imag:c},i}const RD={kernelName:cp,backendName:"webgl",kernelFunc:vs},xS="return (a < 0.) ? b * a : a;",nS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function PD(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{alpha:i}=r,o=n.makeTensorInfo([],"float32",as(i,"float32")),l=Ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ul(nS,a.shape,o.shape):new Ri(xS,a.shape,o.shape),c=n.runWebGLProgram(l,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),c}const LD={kernelName:Up,backendName:"webgl",kernelFunc:PD},rS="return (a < 0.) ? b * a : a;",sS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function DD(s){const{inputs:x,backend:n}=s,{x:r,alpha:a}=x,i=Ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ul(sS,r.shape,a.shape):new Ri(rS,r.shape,a.shape);return n.runWebGLProgram(i,[r,a],"float32")}const OD={kernelName:nf,backendName:"webgl",kernelFunc:DD},Pi="if (isnan(x)) return x;";function Yt({opSnippet:s,packedOpSnippet:x,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:i})=>{const{x:o}=a,l=i,c=r||o.dtype;if(l.shouldExecuteOnCPU([o])&&n!=null){const p=l.texData.get(o.dataId),m=n(p.values,c);return l.makeTensorInfo(o.shape,c,m)}const d=Ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&x!=null;let h;return d?h=new bs(o.shape,x):h=new fr(o.shape,s),l.runWebGLProgram(h,[o],c)}}function mn({opSnippet:s,packedOpSnippet:x,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:i}){return({inputs:o,backend:l})=>{const{a:c,b:d}=o,h=l;if(r&&c.dtype==="complex64"){const y=h.texData.get(c.dataId),b=h.texData.get(d.dataId),[v,w]=[[y.complexTensorInfos.real,b.complexTensorInfos.real],[y.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(T=>{const[A,E]=T,M={dataId:A.dataId,dtype:A.dtype,shape:c.shape},I={dataId:E.dataId,dtype:E.dtype,shape:d.shape},C=new Ri(s,c.shape,d.shape);return h.runWebGLProgram(C,[M,I],n2(A.dtype,E.dtype))}),_=vs({inputs:{real:v,imag:w},backend:h});return h.disposeIntermediateTensorInfo(v),h.disposeIntermediateTensorInfo(w),_}const p=i||n2(c.dtype,d.dtype);if((c.dtype==="string"||d.dtype==="string"||h.shouldExecuteOnCPU([c,d]))&&a!=null){const y=h.texData.get(c.dataId).values,b=h.texData.get(d.dataId).values,v=c.dtype==="string"?pa(y):y,w=c.dtype==="string"?pa(b):b,[_,T]=a(c.shape,d.shape,v,w,p),A=h.makeTensorInfo(T,p),E=h.texData.get(A.dataId);return E.values=_,A}const m=Ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&x!=null;let g;return m?g=new ul(x,c.shape,d.shape,n):g=new Ri(s,c.shape,d.shape),h.runWebGLProgram(g,[c,d],p)}}function dl(s,x=!1){if(s==="linear")return x?gD:dD;if(s==="relu")return x?bD:pD;if(s==="elu")return x?yD:hD;if(s==="relu6")return x?vD:fD;if(s==="prelu")return x?sS:rS;if(s==="leakyrelu")return x?nS:xS;if(s==="sigmoid")return x?wD:mD;throw new Error("Activation "+s+" has not been implemented for the WebGL backend.")}class aS{constructor(x,n,r,a=!1,i=!1,o=!1,l=null,c=!1,d=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Dn(this.outputShape.length);const h=a?x[1]:x[2],p=Math.ceil(h/2),m=a?"i * 2, rc.y":"rc.y, i * 2",g=i?"rc.z, i * 2":"i * 2, rc.z",y=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",w="";l&&(c?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+l+`
        }`:d?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+l+`
        }`:v=`vec4 activation(vec4 x) {
          `+l+`
        }`,w="result = activation(result);");const _=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),d&&this.variableNames.push("leakyreluAlpha");let T="rc.x",A="rc.x";x[0]<n[0]?T="imod(rc.x, "+x[0]+")":n[0]<x[0]&&(A="imod(rc.x, "+n[0]+")"),this.userCode=`
      `+v+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+p+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+T+`;
        int batchB = `+A+`;
        for (int i = 0; i < `+p+`; i++) {
          vec4 a = getMatrixA(batchA, `+m+`);
          vec4 b = getMatrixB(batchB, `+g+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+y[0]+" * "+b[0]+`);
          result += (`+y[1]+" * "+b[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+_+`

        `+w+`

        setOutput(result);
      }
    `}}const iS={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class oS{constructor(x,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ot(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+x+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const lS="return a * b;";function Fg(s){const{inputs:x,backend:n}=s,{a:r,b:a}=x,i=n2(r.dtype,a.dtype);if(r.dtype==="complex64"){const l=n.texData.get(r.dataId),c=n.texData.get(a.dataId),d=new oS(iS.REAL,r.shape,a.shape),h=new oS(iS.IMAG,r.shape,a.shape),p=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:a.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:a.shape}],m=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(h,p,"float32"),y=vs({inputs:{real:m,imag:g},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([r,a])){const l=n.texData.get(r.dataId),c=n.texData.get(a.dataId),[d,h]=OL(r.shape,a.shape,l.values,c.values,i),p=n.makeTensorInfo(h,i),m=n.texData.get(p.dataId);return m.values=d,p}let o;return Ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ul(lS,r.shape,a.shape):o=new Ri(lS,r.shape,a.shape),n.runWebGLProgram(o,[r,a],i)}const FD={kernelName:iu,backendName:"webgl",kernelFunc:Fg};function UD(s,x,n){const r=[Si(s.shape),...Ti(s.shape)],a={dtype:s.dtype,shape:r,dataId:s.dataId},i=[Si(x),...Ti(x)],o=new J_(i,r),l=!0,c=[r],d=n.runWebGLProgram(o,[a],s.dtype,c,l);return{dataId:d.dataId,shape:x,dtype:d.dtype}}function C0(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{shape:i}=r,o=n,l=be(a.shape),c=It(i,l),d=be(c);G(l===d,()=>"The new shape ("+c+") has "+d+" elements and the old shape ("+a.shape+") has "+l+" elements. The new shape and old shape must have the same number of elements.");const h=o.texData.get(a.dataId);return h.isPacked&&!hd(a.shape,c)&&!(h.texture!==null&&hd(h.shape,c))?UD(a,c,o):(o.incRef(a.dataId),{dataId:a.dataId,shape:c,dtype:a.dtype})}const BD={kernelName:uf,backendName:"webgl",kernelFunc:C0};class cS{constructor(x,n){this.variableNames=["x"];const{windowSize:r,batchSize:a,inSize:i,outSize:o}=x;this.outputShape=[a,o];const l=Math.floor(r/4)*4,c=r%4;let d="sumValue += dot(values, ones);";if(n!=null){const p=1/n;d="sumValue += dot(values * "+(Lt(p)?p.toPrecision(2):p)+", ones);"}let h="";i%r>0&&(h=`
        if (inIdx < 0 || inIdx >= `+i+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+h+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+r+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+l+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+d+`
        }

        int inIdx = inOffset + `+l+`;
        if (`+(c===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+d+`
        } else if (`+(c===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+d+`
        } else if (`+(c===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+d+`
        }
        setOutput(sumValue);
      }
    `}}class zD{constructor(x,n){this.variableNames=["x"];const{windowSize:r,batchSize:a,inSize:i,outSize:o}=x;this.outputShape=[a,o];let l="0.0",c="";n==="prod"?l="1.0":n==="min"?(l="1.0 / 1e-20",c="min"):n==="max"&&(l="-1.0 / 1e-20",c="max");let d=n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";n==="sum"?d="sumValue":n==="prod"?d="prodValue":n==="all"?d="allValue":n==="any"&&(d="anyValue");const h=Math.floor(r/4)*4,p=r%4;let m=`
      if (`+(n==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(n==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+c+`(values, minMaxValue);
        if (`+(n==="min")+" || "+(n==="max")+`) {
          minMaxValue = `+c+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";i%r>0&&(y=`
        if (inIdx < 0 || inIdx >= `+i+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+l+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+y+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+r+`;

        vec4 minMaxValue = vec4(`+l+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+h+`; i += 4) {
          int inIdx = inOffset + i;
          `+g+" values = "+g+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+m+`
        }

        int inIdx = inOffset + `+h+`;
        if (`+(p===1)+`) {
          `+g+" values = "+g+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+m+`
        } else if (`+(p===2)+`) {
          `+g+" values = "+g+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+m+`
        } else if (`+(p===3)+`) {
          `+g+" values = "+g+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+m+`
        }
        setOutput(`+d+`);
      }
    `}}function WD(s){const x=[];for(;x.length===0||x[x.length-1].outSize!==1;){const n=x.length?x[x.length-1].outSize:s[1],r=xd(n);x.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return x}function wa(s,x,n,r){const a=WD(s.shape);let i=s;for(let o=0;o<a.length;o++){const{inSize:l,windowSize:c,outSize:d}=a[o];let h,p;n==="mean"?h=o===0?new cS({windowSize:c,inSize:l,batchSize:s.shape[0],outSize:d},l):new cS({windowSize:c,inSize:l,batchSize:s.shape[0],outSize:d}):h=new zD({windowSize:c,inSize:l,batchSize:s.shape[0],outSize:d},n),p=i,i=r.runWebGLProgram(h,[i],x),p.dataId!==s.dataId&&r.disposeIntermediateTensorInfo(p)}return i}class GD{constructor(x,n){this.variableNames=["A"];const r=new Array(x.length);for(let o=0;o<r.length;o++)r[o]=x[n[o]];this.outputShape=r,this.rank=r.length;const a=ux(this.rank),i=VD(n);this.userCode=`
    void main() {
      `+a+` resRC = getOutputCoords();
      setOutput(getA(`+i+`));
    }
    `}}function VD(s){const x=s.length;if(x>6)throw Error("Transpose for rank "+x+" is not yet supported");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(x);for(let a=0;a<s.length;a++)r[s[a]]=n[a];return r.join()}class HD{constructor(x,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(x.length);for(let h=0;h<r.length;h++)r[h]=x[n[h]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const a=ux(this.rank),i=Z_("rc",this.rank),o=new Array(this.rank);for(let h=0;h<n.length;h++)o[n[h]]=i[h];const l="vec2("+o.slice(-2).join()+")",c="++"+i[this.rank-1]+" < "+r[this.rank-1],d="getChannel(getA("+o.join()+"), "+l+")";this.userCode=`
    void main() {
      `+a+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+d+`;
      if(`+c+`) {
        result[1] = `+d+`;
      }
      --`+i[this.rank-1]+`;
      if(++`+i[this.rank-2]+" < "+r[this.rank-2]+`) {
        result[2] = `+d+`;
        if(`+c+`) {
          result[3] = `+d+`;
        }
      }
      setOutput(result);
    }
    `}}function bd(s,x,n){const r=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HD(s.shape,x):new GD(s.shape,x);return n.runWebGLProgram(r,[s],s.dtype)}function YD(s,x,n,r){const a=x,i=s.shape.length,o=_0(a,s.shape);let l=o;const c=Nx(l,i),d=c!=null;let h=s;d&&(h=bd(s,c,r),l=Rx(l.length,i)),hn("sum",l,i);const[p,m]=dn(h.shape,l);let g=p;n&&(g=$x(p,o));const y=be(m),b=be(s.shape)/y,v=C0({inputs:{x:h},attrs:{shape:[b,y]},backend:r}),w=Zf(s.dtype),_=wa(v,w,"sum",r),T=C0({inputs:{x:_},attrs:{shape:g},backend:r});return r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(_),d&&r.disposeIntermediateTensorInfo(h),T}function vd(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;return YD(a,i,o,n)}const qD={kernelName:bf,backendName:"webgl",kernelFunc:vd};function Fn(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{perm:i}=r,o=n,l=a.shape.length,c=new Array(l);for(let h=0;h<c.length;h++)c[h]=a.shape[i[h]];let d;if(o.shouldExecuteOnCPU([a])){const h=o.texData.get(a.dataId).values,p=Lg(h,a.shape,a.dtype,i,c);d=o.makeTensorInfo(c,a.dtype);const m=o.texData.get(d.dataId);m.values=p}else d=bd(a,i,o);return d}const XD={kernelName:Oo,backendName:"webgl",kernelFunc:Fn},uS=1e3;function wd({a:s,b:x,transposeA:n,transposeB:r,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:c=null}){const d=s.shape.length,h=x.shape.length,p=n?s.shape[d-2]:s.shape[d-1],m=r?x.shape[h-1]:x.shape[h-2],g=n?s.shape[d-1]:s.shape[d-2],y=r?x.shape[h-2]:x.shape[h-1],b=s.shape.slice(0,-2),v=x.shape.slice(0,-2),w=be(b),_=be(v),T=Ot(s.shape.slice(0,-2),x.shape.slice(0,-2)).concat([g,y]);G(p===m,()=>"Error in matMul: inner shapes ("+p+") and ("+m+") of Tensors with shapes "+s.shape+" and "+x.shape+" and transposeA="+n+" and transposeB="+r+" must match.");const A=n?[w,p,g]:[w,g,p],E=r?[_,y,m]:[_,m,y],M=C0({inputs:{x:s},backend:a,attrs:{shape:A}}),I=C0({inputs:{x},backend:a,attrs:{shape:E}}),C=[M,I],k=Math.max(w,_),O=n?M.shape[1]:M.shape[2],z=i!=null,ee=o!=null,re=c==="leakyrelu",Y=c!=null?dl(c,!0):null,Q=z||ee||re||Y!=null;let te;if((g===1||y===1)&&O>uS&&Q===!1){let xe=M,ae=I;n&&(xe=Fn({inputs:{x:M},backend:a,attrs:{perm:[0,2,1]}}),C.push(xe)),r&&(ae=Fn({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),C.push(ae));const le=y!==1,de=y===1;let ue=xe;le&&(ue=C0({inputs:{x:xe},backend:a,attrs:{shape:[k,O,1]}}),C.push(ue));const ge=y===1?2:1;let pe=ae;de&&(pe=C0({inputs:{x:ae},backend:a,attrs:{shape:[k,1,O]}}),C.push(pe));const Le=Fg({inputs:{a:ue,b:pe},backend:a});te=vd({inputs:{x:Le},backend:a,attrs:{axis:ge,keepDims:!0}}),C.push(Le)}else{const xe=n2(s.dtype,x.dtype),ae=new aS(A,E,[k,g,y],n,r,z,Y,ee,re),le=[M,I];if(i!=null&&le.push(i),ee&&le.push(o),re){const de=a.makeTensorInfo([],"float32",as(l,"float32"));le.push(de),C.push(de)}te=a.runWebGLProgram(ae,le,xe)}const se=C0({inputs:{x:te},backend:a,attrs:{shape:T}});C.push(te);for(const xe of C)a.disposeIntermediateTensorInfo(xe);return se}function KD(s){const{inputs:x,backend:n,attrs:r}=s,{a,b:i,bias:o,preluActivationWeights:l}=x,{transposeA:c,transposeB:d,activation:h,leakyreluAlpha:p}=r;return wd({a,b:i,transposeA:c,transposeB:d,backend:n,bias:o,preluActivationWeights:l,leakyreluAlpha:p,activation:h})}const $D={kernelName:Mu,backendName:"webgl",kernelFunc:KD},dS="return abs(x);";function ZD(s){const{inputs:x,backend:n}=s,{x:r}=x;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=n.texData.get(r.dataId),o=K_(i.values);return n.makeTensorInfo(r.shape,r.dtype,o)}let a;return Ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new bs(r.shape,dS):a=new fr(r.shape,dS),n.runWebGLProgram(a,[r],r.dtype)}const JD={kernelName:Po,backendName:"webgl",kernelFunc:ZD},QD=O2+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,jD=Yt({opSnippet:QD}),eO={kernelName:Lo,backendName:"webgl",kernelFunc:jD},tO=O2+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,xO=Yt({opSnippet:tO}),nO={kernelName:Ec,backendName:"webgl",kernelFunc:xO},hS="return a + b;",rO=mn({opSnippet:hS,packedOpSnippet:hS,supportsComplex:!0,cpuKernelImpl:mL}),sO={kernelName:Do,backendName:"webgl",kernelFunc:rO};class aO{constructor(x,n){this.outputShape=[],this.outputShape=x,this.variableNames=n.map((i,o)=>"T"+o);const r=[];this.variableNames.forEach(i=>{r.push("float v"+i+" = get"+i+"AtOutCoords();")});const a=this.variableNames.map(i=>"v"+i).join(" + ");this.userCode=`
      void main() {
        `+r.join(`
        `)+`

        float result = `+a+`;
        setOutput(result);
      }
    `}}class iO{constructor(x,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=x,this.variableNames=n.map((i,o)=>"T"+o);const r=[];this.variableNames.forEach(i=>{r.push("vec4 v"+i+" = get"+i+"AtOutCoords();")});const a=this.variableNames.map(i=>"v"+i).join(" + ");this.userCode=`
      void main() {
        `+r.join(`
        `)+`

        vec4 result = `+a+`;
        setOutput(result);
      }
    `}}function _d(s){const{inputs:x,backend:n}=s,r=x;if(r.length===1)return a2({inputs:{x:r[0]},backend:n});if(r.length>Ce().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=_d({inputs:r.slice(0,l),backend:n}),d=_d({inputs:r.slice(l),backend:n});return _d({inputs:[c,d],backend:n})}const a=r.map(l=>l.dtype).reduce((l,c)=>n2(l,c)),i=r.map(l=>l.shape),o=Ce().getBool("WEBGL_PACK")?new iO(r[0].shape,i):new aO(r[0].shape,i);return n.runWebGLProgram(o,r,a)}const oO={kernelName:jh,backendName:"webgl",kernelFunc:_d};function lO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r,l=a.shape.length,c=_0(i,a.shape);let d=c;const h=Nx(d,l);let p=a;h!=null&&(p=Fn({inputs:{x:a},backend:n,attrs:{perm:h}}),d=Rx(d.length,l)),hn("all",d,l);const[m,g]=dn(p.shape,d),y=be(g),b=C0({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=wa(b,b.dtype,"all",n);let w;if(o){const _=$x(m,c);w=C0({inputs:{x:v},backend:n,attrs:{shape:_}})}else w=C0({inputs:{x:v},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),h!=null&&n.disposeIntermediateTensorInfo(p),w}const cO={kernelName:ep,backendName:"webgl",kernelFunc:lO};function uO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r,l=a.shape.length,c=_0(i,a.shape);let d=c;const h=Nx(d,l);let p=a;h!=null&&(p=Fn({inputs:{x:a},backend:n,attrs:{perm:h}}),d=Rx(d.length,l)),hn("any",d,l);const[m,g]=dn(p.shape,d),y=be(g),b=C0({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=wa(b,b.dtype,"any",n);let w;if(o){const _=$x(m,c);w=C0({inputs:{x:v},backend:n,attrs:{shape:_}})}else w=C0({inputs:{x:v},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),h!=null&&n.disposeIntermediateTensorInfo(p),w}const dO={kernelName:tp,backendName:"webgl",kernelFunc:uO};class hO{constructor(x,n,r){this.variableNames=["A"];const{windowSize:a,batchSize:i,outSize:o}=x;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const l=n==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+a+`;

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < `+a+`; i++) {
          int inIdx = `+c+`;
          float candidate = getA(batch, inIdx);
          if (candidate `+l+` bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class pO{constructor(x,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,G(x.length>2,()=>"Packed arg"+(r.charAt(0).toUpperCase()+r.slice(1))+" supports only inputs with rank above 2.");const i=x[x.length-1],o=Math.ceil(i/n);this.outputShape=x.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,d=ux(c),h=On("coords",c);let p,m;if(o===1){m=c+1;const C=ux(m);p=`
        `+C+" sourceLocR = "+C+"("+h.join()+`, 0);
        ++`+h[c-1]+`;
        `+C+" sourceLocG = "+C+"("+h.join()+`, 0);
        ++`+h[c-2]+`;
        `+C+" sourceLocA = "+C+"("+h.join()+`, 0);
        --`+h[c-1]+`;
        `+C+" sourceLocB = "+C+"("+h.join()+`, 0);
        --`+h[c-2]+";"}else m=c,p=`
        `+d+` sourceLocR = coords;
        ++`+h[c-1]+`;
        `+d+` sourceLocG = coords;
        ++`+h[c-2]+`;
        `+d+` sourceLocA = coords;
        --`+h[c-1]+`;
        `+d+` sourceLocB = coords;
        --`+h[c-2]+";";const g=["x","y","z","w","u","v"].slice(0,m),y="."+g[m-1],b=g.map(C=>"int "+C),v=On("sourceLocR",m-1).concat("inIdx.r"),w=On("sourceLocG",m-1).concat("inIdx.g"),_=On("sourceLocB",m-1).concat("inIdx.b"),T=On("sourceLocA",m-1).concat("inIdx.a"),A=r==="max"?"greaterThan":"lessThan",E=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(`+v.join()+`),
                             getBestIndicesAChannel(`+w.join()+`),
                             getBestIndicesAChannel(`+_.join()+`),
                             getBestIndicesAChannel(`+T.join()+")));",M=`vec4(
            getAChannel(`+v.join()+`),
            hasNextCol ? getAChannel(`+w.join()+`) : 0.,
            hasNextRow ? getAChannel(`+_.join()+`) : 0.,
            hasNextRow && hasNextCol ? getAChannel(`+T.join()+") : 0.)",I=a?"":`
      float getBestIndicesAChannel(`+b.join()+`) {
        return getChannel(getBestIndicesA(`+g.join()+`),
                                          vec2(`+g.slice(-2).join()+`));
      }`;this.userCode=`
      float getAChannel(`+b.join()+`) {
        return getChannel(getA(`+g.join()+`),
                               vec2(`+g.slice(-2).join()+`));
      }
      `+I+`
      void main() {
        `+d+` coords = getOutputCoords();
        bool hasNextCol = `+h[c-1]+" < "+(l[c-1]-1)+`;
        bool hasNextRow = `+h[c-2]+" < "+(l[c-2]-1)+`;
        `+p+`
        ivec4 srcIdx = ivec4(sourceLocR`+y+", sourceLocG"+y+`,
          sourceLocB`+y+", sourceLocA"+y+") * "+n+`;
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = `+M+`;

        for (int i = 0; i < `+n+`; i++) {
          inIdx = srcIdx;
          `+E+`
          vec4 candidate = `+M+`;
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(`+A+`(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function pS(s,x,n,r=null){let a=x.shape[0],i=x.shape[1];r!=null&&(a=r.shape[0],i=r.shape[1]);const o=xd(i),l={windowSize:o,inSize:i,batchSize:a,outSize:Math.ceil(i/o)},c=new hO(l,n,r==null),d=[x];r!=null&&d.push(r);const h=s.runWebGLProgram(c,d,"int32");if(h.shape[1]===1)return h;const p=pS(s,x,n,h);return s.disposeIntermediateTensorInfo(h),p}function fS(s,x,n,r=null){const a=r!=null?r.shape:x.shape,i=a[a.length-1],o=xd(i),l=new pO(a,o,n,r==null),c=r==null?[x]:[x,r],d=s.runWebGLProgram(l,c,"int32");if(d.shape.length===x.shape.length){const h=fS(s,x,n,d);return s.disposeIntermediateTensorInfo(d),h}return d}function mS(s,x,n,r){const a=[n];if(hn("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,x.shape.length),!Ce().getBool("WEBGL_PACK_REDUCE")||x.shape.length<=2){const i=[],o=s.texData.get(x.dataId),l=o!==null&&o.isPacked;let c=x;l&&(c=s.unpackTensor(x),i.push(c));const[d,h]=dn(c.shape,a),p=be(h),m=C0({inputs:{x:c},backend:s,attrs:{shape:[-1,p]}});i.push(m);const g=pS(s,m,r);i.push(g);const y=C0({inputs:{x:g},backend:s,attrs:{shape:d}});return i.forEach(b=>s.disposeIntermediateTensorInfo(b)),y}return fS(s,x,r)}function fO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i}=r;let o=_0(i,a.shape);const l=Nx(o,a.shape.length);let c=a;const d=[];l!=null&&(c=Fn({inputs:{x:a},backend:n,attrs:{perm:l}}),d.push(c),o=Rx(o.length,c.shape.length)),hn("argMax",[o[0]],c.shape.length);const h=mS(n,c,o[0],"max");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const mO={kernelName:xp,backendName:"webgl",kernelFunc:fO};function gO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i}=r;let o=_0(i,a.shape);const l=Nx(o,a.shape.length);let c=a;const d=[];l!=null&&(c=Fn({inputs:{x:a},backend:n,attrs:{perm:l}}),d.push(c),o=Rx(o.length,c.shape.length)),hn("argMin",[o[0]],c.shape.length);const h=mS(n,c,o[0],"min");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const yO={kernelName:np,backendName:"webgl",kernelFunc:gO},bO=O2+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,vO=Yt({opSnippet:bO}),wO={kernelName:Cc,backendName:"webgl",kernelFunc:vO},_O=O2+"return log(x + sqrt(x * x + 1.0));",SO=Yt({opSnippet:_O}),TO={kernelName:Mc,backendName:"webgl",kernelFunc:SO},AO=O2+`
  return atan(x);
`,EO=Yt({opSnippet:AO}),CO={kernelName:Ic,backendName:"webgl",kernelFunc:EO},MO=Og+`
  return atan(a, b);
`,IO=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cl+`
  return result;
`,kO=mn({opSnippet:MO,packedOpSnippet:IO}),NO={kernelName:Nc,backendName:"webgl",kernelFunc:kO},RO=O2+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,PO=Yt({opSnippet:RO}),LO={kernelName:kc,backendName:"webgl",kernelFunc:PO};class hl{constructor(x,n,r,a=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=x.filterWidth,l=x.strideHeight,c=x.strideWidth,d=x.dilationHeight,h=x.dilationWidth,p=x.effectiveFilterHeight,m=x.effectiveFilterWidth,g=x.padInfo.top,y=x.padInfo.left;this.outputShape=x.outShape;const b=n==="avg",v="((batch  * "+x.inHeight+" + xR) * "+x.inWidth+" + xC) * "+x.inChannels+" + d",w="(xR * "+x.inWidth+" + xC) * "+x.inChannels+" + d";let _="0.0";if(b||(_="-1.0 / 1e-20"),r){const C=">=";this.userCode=`
        const ivec2 strides = ivec2(`+l+", "+c+`);
        const ivec2 pads = ivec2(`+g+", "+y+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+p+`;
              wR += `+d+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+x.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+m+`;
                wC += `+h+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+x.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+C+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(a?i?v:w:"wR * "+m+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let A=n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";n==="avg"&&(A="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,M=o%4,I=`
      if (`+b+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+T+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+l+", "+c+`);
      const ivec2 pads = ivec2(`+g+", "+y+`);
      const float initializationValue = `+_+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+x.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+_+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+p+`;
            wR += `+d+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+x.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+E+`; wC += 4) {
            int xC = xCCorner + wC * `+h+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              getValue(batch, xR, xC + 2 * `+h+`, d),
              getValue(batch, xR, xC + 3 * `+h+`, d)
            );

            `+I+`
          }

          int xC = xCCorner + `+E+`;
          if (`+(M===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+I+`
          } else if (`+(M===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              initializationValue,
              initializationValue
            );

            `+I+`
          } else if (`+(M===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              getValue(batch, xR, xC + 2 * `+h+`, d),
              initializationValue
            );

            `+I+`
          }
        }
        setOutput(`+A+`);
      }
    `}}class Ug{constructor(x,n,r,a=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=x.filterWidth,l=x.strideDepth,c=x.strideHeight,d=x.strideWidth,h=x.dilationDepth,p=x.dilationHeight,m=x.dilationWidth,g=x.effectiveFilterDepth,y=x.effectiveFilterHeight,b=x.effectiveFilterWidth,v=x.padInfo.front,w=x.padInfo.top,_=x.padInfo.left;this.outputShape=x.outShape;const T=n==="avg";let A="0.0";if(T||(A="-1.0 / 1e-20"),r){const O=">=";this.userCode=`
        const ivec3 strides =
            ivec3(`+l+", "+c+", "+d+`);
        const ivec3 pads = ivec3(`+v+", "+w+", "+_+`);

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < `+g+`;
              wD += `+h+`) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= `+x.inDepth+`) {
              continue;
            }

            for (int wR = 0; wR < `+y+`;
                wR += `+p+`) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= `+x.inHeight+`) {
                continue;
              }

              for (int wC = 0; wC < `+b+`;
                  wC += `+m+`) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= `+x.inWidth+`) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value `+O+` currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = `+(a?i?"(((batch * "+x.inDepth+" + xD) * "+x.inHeight+" + xR) * "+x.inWidth+" + xC) * "+x.inChannels+" + ch":"((xD * "+x.inHeight+" + xR) * "+x.inWidth+" + xC) * "+x.inChannels+" + ch":"wD * "+y+" * "+b+` +
                      wR * `+b+" + wC")+`;
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let M=n+"("+n+"("+n+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";n==="avg"&&(M="avgValue / max(count, 1.0)");const I=Math.floor(o/4)*4,C=o%4,k=`
      if (`+T+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+E+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(`+l+", "+c+", "+d+`);
      const ivec3 pads = ivec3(`+v+", "+w+", "+_+`);
      const float initializationValue = `+A+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= `+x.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+A+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < `+g+`;
            wD += `+h+`) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= `+x.inDepth+`) {
            continue;
          }

          for (int wR = 0; wR < `+y+`;
            wR += `+p+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+x.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+I+`; wC += 4) {
              int xC = xCCorner + wC * `+m+`;

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+m+`, ch),
                getValue(batch, xD, xR, xC + 2 * `+m+`, ch),
                getValue(batch, xD, xR, xC + 3 * `+m+`, ch)
              );

              `+k+`
            }

            int xC = xCCorner + `+I+`;
            if (`+(C===1)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              `+k+`
            } else if (`+(C===2)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+m+`, ch),
                initializationValue,
                initializationValue
              );

              `+k+`
            } else if (`+(C===3)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+m+`, ch),
                getValue(batch, xD, xR, xC + 2 * `+m+`, ch),
                initializationValue
              );

              `+k+`
            }
          }
        }
        setOutput(`+M+`);
      }
    `}}function DO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x;il(a,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,d=1;G(Sn(o,d),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+d+"'");const h=k2(a.shape,i,o,d,l,c);if(h.filterWidth===1&&h.filterHeight===1&&T0(h.inShape,h.outShape))return a2({inputs:{x:a},backend:n});const p=new hl(h,"avg",!1);return n.runWebGLProgram(p,[a],"float32")}const OO={kernelName:rp,backendName:"webgl",kernelFunc:DO};function FO(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:d}=r,h=[1,1,1],p=Ir(a.shape,i,o,h,l,c,d),m=new Ug(p,"avg",!1);return n.runWebGLProgram(m,[a],"float32")}const UO={kernelName:sp,backendName:"webgl",kernelFunc:FO};class BO{constructor(x){this.variableNames=["dy"],this.outputShape=x.inShape;const n=x.filterHeight,r=x.filterWidth,a=x.strideHeight,i=x.strideWidth,o=x.dilationHeight,l=x.dilationWidth,c=x.effectiveFilterHeight,d=x.effectiveFilterWidth,h=c-1-x.padInfo.top,p=d-1-x.padInfo.left,m=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(`+h+", "+p+`);
      const float avgMultiplier = float(`+m+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+c+`;
            wR += `+o+`) {
          float dyR = float(dyRCorner + wR) / `+a+`.0;

          if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < `+d+`;
            wC+= `+l+`) {
            float dyC = float(dyCCorner + wC) / `+i+`.0;

            if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class zO{constructor(x){this.variableNames=["dy"],this.outputShape=x.inShape;const n=x.filterDepth,r=x.filterHeight,a=x.filterWidth,i=x.strideDepth,o=x.strideHeight,l=x.strideWidth,c=x.dilationDepth,d=x.dilationHeight,h=x.dilationWidth,p=x.effectiveFilterDepth,m=x.effectiveFilterHeight,g=x.effectiveFilterWidth,y=p-1-x.padInfo.front,b=m-1-x.padInfo.top,v=g-1-x.padInfo.left,w=1/(n*r*a);this.userCode=`
      const ivec3 pads = ivec3(`+y+", "+b+", "+v+`);
      const float avgMultiplier = float(`+w+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < `+p+`;
            wD += `+c+`) {
          float dyD = float(dyDCorner + wD) / `+i+`.0;

          if (dyD < 0.0 || dyD >= `+x.outDepth+`.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < `+m+`;
              wR += `+d+`) {
            float dyR = float(dyRCorner + wR) / `+o+`.0;

            if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < `+g+`;
                wC += `+h+`) {
              float dyC = float(dyCCorner + wC) / `+l+`.0;

              if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function WO(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,o=i,{filterSize:l,strides:c,pad:d,dimRoundingMode:h}=r,p=[1,1,1],m=Ir(o.shape,l,c,p,d,h),g=new zO(m);return n.runWebGLProgram(g,[a],o.dtype)}const GO={kernelName:ky,backendName:"webgl",kernelFunc:WO};function VO(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,o=i;il([a,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:d}=r,h=k2(o.shape,l,c,1,d),p=new BO(h);return n.runWebGLProgram(p,[a],o.dtype)}const HO={kernelName:Iy,backendName:"webgl",kernelFunc:VO};function YO(s){const{inputs:x,backend:n,attrs:r}=s,{a,b:i}=x,{transposeA:o,transposeB:l}=r;return wd({a,b:i,transposeA:o,transposeB:l,backend:n})}const qO={kernelName:ap,backendName:"webgl",kernelFunc:YO};class XO{constructor(x,n,r,a,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ot(x,n),Ot(x,r);let l="0.0";a!=null&&(Ot(x,a),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";i!=null&&(Ot(x,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=x,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = `+l+`;
        float scale = `+c+`;
        float inv = scale * inversesqrt(variance + float(`+o+`));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class KO{constructor(x,n,r,a,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ot(x,n),Ot(x,r);let l="vec4(0.0)";a!=null&&(Ot(x,a),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(Ot(x,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=x,this.userCode=`
      void main() {
        vec4 offset = `+l+`;
        vec4 scale = `+c+`;

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(`+o+`));

        setOutput((x - mean) * inv + offset);
      }
    `}}const $O=({inputs:s,backend:x,attrs:n})=>{const{x:r,mean:a,variance:i,offset:o,scale:l}=s;G(a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(l==null||a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=n;c==null&&(c=.001);const d=[r,a,i];let h=null;o!=null&&(h=o.shape,d.push(o));let p=null;l!=null&&(p=l.shape,d.push(l));const m=Ce().getBool("WEBGL_PACK_NORMALIZATION")?new KO(r.shape,a.shape,i.shape,h,p,c):new XO(r.shape,a.shape,i.shape,h,p,c);return x.runWebGLProgram(m,d,d[0].dtype)},ZO={kernelName:Pp,backendName:"webgl",kernelFunc:$O};class JO{constructor(x){this.variableNames=["source"],this.outputShape=x,this.rank=x.length;const n=ux(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=QO(this.rank);let a;const i=x.map((o,l)=>"sourceLoc."+Bg[l]+" = start["+l+"] + coords."+Bg[l]+";");a=`
        `+n+` sourceLoc;
        `+n+` coords = getOutputCoords();
        `+i.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+a+`
        setOutput(getSource(`+r+`));
      }
    `}}const Bg=["x","y","z","w","u","v"];function QO(s){if(s===1)return"sourceLoc";if(s<=6)return Bg.slice(0,s).map(x=>"sourceLoc."+x).join(",");throw Error("Slicing for rank "+s+" is not yet supported")}class jO{constructor(x){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=x,this.rank=x.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=ux(this.rank),r=On("coords",this.rank),a=On("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":"vec2("+a.slice(-2).join()+")",o="getChannel(getSource("+a.join()+"), "+i+")",l=`
      result.x = `+o+`;
      if (++`+r[this.rank-1]+" < "+x[this.rank-1]+`) {
        ++`+a[this.rank-1]+`;
        result.y = `+o+`;
        --`+a[this.rank-1]+`;
      }
    `,c=this.rank===1?"":`
      --`+r[this.rank-1]+`;
      if (++`+r[this.rank-2]+" < "+x[this.rank-2]+`) {
        ++`+a[this.rank-2]+`;
        result.z = `+o+`;
        if (++`+r[this.rank-1]+" < "+x[this.rank-1]+`) {
          ++`+a[this.rank-1]+`;
          result.w = `+o+`;
        }
      }
    `,d=this.rank<=4?`sourceLoc = coords +
            `+n+"("+x.map((h,p)=>"start["+p+"]").join()+");":x.map((h,p)=>a[p]+" = "+r[p]+" + start["+p+"];").join(`
`);this.userCode=`
      void main() {
        `+n+` coords = getOutputCoords();
        `+n+` sourceLoc;
        `+d+`
        vec4 result = vec4(0.);
        `+l+`
        `+c+`
        setOutput(result);
      }
    `}}function eF(s,x,n,r){const a=r.texData.get(s.dataId),i=r.makeTensorInfo(n,s.dtype),o=r.texData.get(i.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=s.dtype;let l=Pm(x,U0(s.shape));a.slice&&(l+=a.slice.flatOffset),o.slice={flatOffset:l,origDataId:a.slice&&a.slice.origDataId||s.dataId};const c=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,c+1),i}function Li(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{begin:i,size:o}=r,[l,c]=Lm(a,i,o);if(km(a,l,c),be(c)===0)return n.makeTensorInfo(c,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){const p=n.texData.get(a.dataId),m=XL(p.values,l,c,a.shape,a.dtype);return n.makeTensorInfo(c,a.dtype,m)}const{isPacked:d}=n.texData.get(a.dataId),h=Rm(a.shape,l,c);if(d||!h){const p=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jO(c):new JO(c),m=[l];return n.runWebGLProgram(p,[a],a.dtype,m)}return n.uploadToGPU(a.dataId),eF(a,l,c,n)}const tF={kernelName:yf,backendName:"webgl",kernelFunc:Li},xF=s=>{const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockShape:i,crops:o}=r;G(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((_,T)=>_*T),c=tl(a.shape,i,l),d=xl(c.length,i.length),h=nl(a.shape,i,l),p=Bm(o,i.length),m=zm(h,o,i.length),g=[],y=C0({inputs:{x:a},backend:n,attrs:{shape:c}}),b=Fn({inputs:{x:y},backend:n,attrs:{perm:d}}),v=C0({inputs:{x:b},backend:n,attrs:{shape:h}}),w=Li({inputs:{x:v},backend:n,attrs:{begin:p,size:m}});return g.push(y),g.push(b),g.push(v),g.forEach(_=>n.disposeIntermediateTensorInfo(_)),w},nF={kernelName:ip,backendName:"webgl",kernelFunc:xF};function rF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,weights:i}=x,{size:o}=r,l=n.readSync(a.dataId),c=n.readSync(i.dataId),d=X_(l,c,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,d)}const sF={kernelName:op,backendName:"webgl",kernelFunc:rF};function aF(s){const{inputs:x,backend:n}=s,{s0:r,s1:a}=x,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=Ot(Array.from(i),Array.from(o));return n.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const iF={kernelName:lp,backendName:"webgl",kernelFunc:aF},oF="return float(a != b);",gS=mn({opSnippet:oF,cpuKernelImpl:UL,dtype:"bool"}),lF={kernelName:ou,backendName:"webgl",kernelFunc:gS};function pl(s){const{inputs:x,backend:n}=s,{input:r}=x,a=n.texData.get(r.dataId);return a2({inputs:{x:a.complexTensorInfos.real},backend:n})}const cF={kernelName:cf,backendName:"webgl",kernelFunc:pl},uF="return float(int(x));";function dF(s,x){const n=new fr(s.shape,uF),r=x.runWebGLProgram(n,[s],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function zg(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{dtype:i}=r;if(i==="complex64"){if(a.dtype==="complex64")return a2({inputs:{x:a},backend:n});const o=X2(a.shape),l=zg({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),c=vs({inputs:{real:l,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(l),c}if(a.dtype==="complex64"){const o=pl({inputs:{input:a},backend:n}),l=zg({inputs:{x:o},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(o),l}if(!Nt(a.dtype,i)){const o=a2({inputs:{x:a},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(n.shouldExecuteOnCPU([a])){const o=n.texData.get(a.dataId).values,[l,c,d]=yL(o,a.shape,a.dtype,i);return n.makeTensorInfo(l,c,d)}if(i==="int32")return dF(a,n);if(i==="bool"){const o=n.makeTensorInfo([],"bool",Ke("bool",1)),l=gS({inputs:{a,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error("Error in Cast: failed to cast "+a.dtype+" to "+i)}const hF={kernelName:Rc,backendName:"webgl",kernelFunc:zg},yS="return ceil(x);",pF=Yt({opSnippet:yS,packedOpSnippet:yS,cpuKernelImpl:bL}),fF={kernelName:Pc,backendName:"webgl",kernelFunc:pF};class mF{constructor(x){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=x,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class gF{constructor(x){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=x,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function yF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{clipValueMin:i,clipValueMax:o}=r;let l;Ce().getBool("WEBGL_PACK_CLIP")?l=new gF(a.shape):l=new mF(a.shape);const c=[[i],[o]];return n.runWebGLProgram(l,[a],a.dtype,c)}const bF={kernelName:Lc,backendName:"webgl",kernelFunc:yF};class vF{constructor(x){this.variableNames=["real","imag"],this.outputShape=x,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function bS(s,x){return{dataId:x.dataId,dtype:x.dtype,shape:s.shape}}function wF(s){const{inputs:x,backend:n}=s,{x:r}=x,a=n.texData.get(r.dataId),i=new vF(r.shape),o=[bS(r,a.complexTensorInfos.real),bS(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}const _F={kernelName:up,backendName:"webgl",kernelFunc:wF};class SF{constructor(x){this.outputShape=[],this.outputShape=hr(x,1),this.variableNames=x.map((o,l)=>"T"+l);const n=new Array(x.length-1);n[0]=x[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+x[o][1];const r=["if (yC < "+n[0]+") setOutput(getT0(yR, yC));"];for(let o=1;o<n.length;o++){const l=n[o-1];r.push("else if (yC < "+n[o]+") setOutput(getT"+o+"(yR, yC-"+l+"));")}const a=n.length,i=n[n.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+r.join(`
        `)+`
      }
    `}}class TF{constructor(x,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hr(x,n);const r=this.outputShape,a=r.length,i=ux(a),o=On("coords",a),l=["x","y","z","w","u","v"].slice(0,a);this.variableNames=x.map((b,v)=>"T"+v);const c=new Array(x.length-1);c[0]=x[0][n];for(let b=1;b<c.length;b++)c[b]=c[b-1]+x[b][n];const d=l[n],h=l.slice(-2),p=l.join();let m="if ("+d+" < "+c[0]+`) {
        return getChannel(
            getT0(`+p+"), vec2("+h.join()+`));
        }`;for(let b=1;b<c.length;b++){const v=c[b-1];m+=`
        if (`+d+" < "+c[b]+"  && "+d+" >= "+c[b-1]+`) {
          return getChannel(
            getT`+b+"("+Sd(l,d,v)+`),
            vec2(`+Sd(h,d,v)+`));
        }`}const g=c.length,y=c[c.length-1];m+=`
        return getChannel(
          getT`+g+"("+Sd(l,d,y)+`),
          vec2(`+Sd(h,d,y)+"));",this.userCode=`
      float getValue(`+l.map(b=>"int "+b)+`) {
        `+m+`
      }

      void main() {
        `+i+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+o+`), 0., 0., 0.);

        `+o[a-1]+" = "+o[a-1]+` + 1;
        if (`+o[a-1]+" < "+r[a-1]+`) {
          result.g = getValue(`+o+`);
        }

        `+o[a-2]+" = "+o[a-2]+` + 1;
        if (`+o[a-2]+" < "+r[a-2]+`) {
          result.a = getValue(`+o+`);
        }

        `+o[a-1]+" = "+o[a-1]+` - 1;
        if (`+o[a-2]+" < "+r[a-2]+` &&
            `+o[a-1]+" < "+r[a-1]+`) {
          result.b = getValue(`+o+`);
        }
        setOutput(result);
      }
    `}}function Sd(s,x,n){const r=s.indexOf(x);return s.map((a,i)=>i===r?a+" - "+n:a).join()}function Td(s){const{inputs:x,backend:n}=s,{input:r}=x,a=n.texData.get(r.dataId);return a2({inputs:{x:a.complexTensorInfos.imag},backend:n})}const AF={kernelName:Fp,backendName:"webgl",kernelFunc:Td};function fl(s,x,n){const r=s[0].dtype;if(r==="complex64"){const g=s.map(_=>pl({inputs:{input:_},backend:n})),y=s.map(_=>Td({inputs:{input:_},backend:n})),b=fl(g,x,n),v=fl(y,x,n),w=vs({inputs:{real:b,imag:v},backend:n});return g.forEach(_=>n.disposeIntermediateTensorInfo(_)),y.forEach(_=>n.disposeIntermediateTensorInfo(_)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),w}let a=n.shouldExecuteOnCPU(s);if(r==="string"&&(a=!0),a){const g=s.map(A=>{const E=be(A.shape.slice(x));return C0({inputs:{x:A},backend:n,attrs:{shape:[-1,E]}})}),y=g.map(A=>({vals:n.readSync(A.dataId),shape:A.shape})),b=hr(g.map(A=>A.shape),1),v=g[0].shape[0]===1,w=vL(y,b,r,v),_=hr(s.map(A=>A.shape),x),T=n.makeTensorInfo(_,r,w);return g.forEach(A=>n.disposeIntermediateTensorInfo(A)),T}const i=s.filter(g=>be(g.shape)>0),o=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const g=o?new fr(s[0].shape,ys):new bs(s[0].shape,ys);return n.runWebGLProgram(g,s,r)}const l=Ce().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const g=[];for(let b=0;b<i.length;b+=l){const v=i.slice(b,b+l);g.push(fl(v,x,n))}const y=fl(g,x,n);for(const b of g)n.disposeIntermediateTensorInfo(b);return y}if(o){const g=new TF(i.map(y=>y.shape),x);return n.runWebGLProgram(g,i,r)}const{tensors2D:c,outShape:d}=EF(i,x,n),h=new SF(c.map(g=>g.shape)),p=n.runWebGLProgram(h,c,r);c.forEach(g=>n.disposeIntermediateTensorInfo(g));const m=C0({inputs:{x:p},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(p),m}function EF(s,x,n){const r=hr(s.map(a=>a.shape),x);return{tensors2D:s.map(a=>C0({inputs:{x:a},attrs:{shape:[-1,be(a.shape.slice(x))]},backend:n})),outShape:r}}function vS(s){const{inputs:x,backend:n,attrs:r}=s,{axis:a}=r,i=_0(a,x[0].shape)[0],o=x.map(d=>d.shape);Om(o,i);const l=hr(x.map(d=>d.shape),i);if(be(l)===0)return n.makeTensorInfo(l,x[0].dtype,[]);const c=x.filter(d=>be(d.shape)>0);return c.length===1?a2({inputs:{x:c[0]},backend:n}):fl(c,i,n)}const CF={kernelName:dp,backendName:"webgl",kernelFunc:vS};class wS{constructor(x,n=!1,r=null,a=!1,i=!1){this.variableNames=["x","W"],this.outputShape=x.outShape;const o=x.padInfo.top,l=x.padInfo.left,c=x.strideHeight,d=x.strideWidth,h=x.dilationHeight,p=x.dilationWidth,m=x.filterHeight,g=x.filterWidth,y=Math.floor(x.inChannels/4)*4,b=x.inChannels%4,v=x.dataFormat==="channelsLast",w=v?1:2,_=v?2:3,T=v?3:1;let A="",E="";r&&(a?A=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+r+`
        }`:i?A=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+r+`
        }`:A=`
          float activation(float x) {
            `+r+`
          }
        `,E="result = activation(result);");const M=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+A+`

      const ivec2 strides = ivec2(`+c+", "+d+`);
      const ivec2 pads = ivec2(`+o+", "+l+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+T+`];

        ivec2 xRCCorner =
            ivec2(coords[`+w+"], coords["+_+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+m+`; wR++) {
          int xR = xRCorner + wR * `+h+`;

          if (xR < 0 || xR >= `+x.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+g+`; wC++) {
            int xC = xCCorner + wC * `+p+`;

            if (xC < 0 || xC >= `+x.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+y+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+v+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(b===1)+`) {

              if (`+v+`) {
                dotProd +=
                    getX(batch, xR, xC, `+y+`) *
                    getW(wR, wC, `+y+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+y+`, xR, xC) *
                    getW(wR, wC, `+y+`, d2);
              }

            } else if (`+(b===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+y+`, d2),
                getW(wR, wC, `+y+` + 1, d2)
              );

              if (`+v+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+y+`),
                  getX(batch, xR, xC, `+y+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+y+`, xR, xC),
                  getX(batch, `+y+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(b===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+y+`, d2),
                getW(wR, wC, `+y+` + 1, d2),
                getW(wR, wC, `+y+` + 2, d2)
              );

              if (`+v+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+y+`),
                  getX(batch, xR, xC, `+y+` + 1),
                  getX(batch, xR, xC, `+y+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+y+`, xR, xC),
                  getX(batch, `+y+` + 1, xR, xC),
                  getX(batch, `+y+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+M+`
        `+E+`
        setOutput(result);
      }
    `}}class MF{constructor(x){this.variableNames=["x","W"],this.outputShape=x.outShape;const n=x.padInfo.front,r=x.padInfo.top,a=x.padInfo.left,i=x.strideDepth,o=x.strideHeight,l=x.strideWidth,c=x.dilationDepth,d=x.dilationHeight,h=x.dilationWidth,p=x.filterDepth,m=x.filterHeight,g=x.filterWidth,y=Math.floor(x.inChannels/4)*4,b=x.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(`+i+", "+o+", "+l+`);
      const ivec3 pads = ivec3(`+n+", "+r+", "+a+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < `+p+`; wF++) {
          int xF = xFCorner + wF * `+c+`;

          if (xF < 0 || xF >= `+x.inDepth+`) {
            continue;
          }

          for (int wR = 0; wR < `+m+`; wR++) {
            int xR = xRCorner + wR * `+d+`;

            if (xR < 0 || xR >= `+x.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+g+`; wC++) {
              int xC = xCCorner + wC * `+h+`;

              if (xC < 0 || xC >= `+x.inWidth+`) {
                continue;
              }

              for (int d1 = 0; d1 < `+y+`; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (`+(b===1)+`) {
                dotProd +=
                  getX(batch, xF, xR, xC, `+y+`) *
                  getW(wF, wR, wC, `+y+`, d2);
              } else if (`+(b===2)+`) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, `+y+`),
                  getX(batch, xF, xR, xC, `+y+` + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, `+y+`, d2),
                  getW(wF, wR, wC, `+y+` + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (`+(b===3)+`) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, `+y+`),
                  getX(batch, xF, xR, xC, `+y+` + 1),
                  getX(batch, xF, xR, xC, `+y+` + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, `+y+`, d2),
                  getW(wF, wR, wC, `+y+` + 1, d2),
                  getW(wF, wR, wC, `+y+` + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _S{constructor(x,n=!1,r=null,a=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=Dn(this.outputShape.length);const o=x.padInfo.left,l=x.strideWidth,c=x.dilationWidth,d=x.filterHeight,h=x.filterWidth,p=h;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<h;v++)m+=`
           vec4 xTexelC`+v*2+`;
           int xTexelC`+v*2+`Ready;
           vec4 xTexelC`+(v*2+1)+`;
           int xTexelC`+(v*2+1)+`Ready;
           vec4 xC`+v+";";m+=`
     for (int r = 0; r < `+d+`; r++) {
      for (int d1 = 0; d1 < `+x.inChannels+`; d1 += 2) {
       `;for(let v=0;v<h;v++)m+=`
           xTexelC`+v*2+` = vec4(0.0);
           xTexelC`+v*2+`Ready = 0;
           xTexelC`+(v*2+1)+` = vec4(0.0);
           xTexelC`+(v*2+1)+`Ready = 0;
           xC`+v+" = vec4(0.0);";m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(p+1)/2;v++){const w=v*2;if(m+=`
           xC = xCCorner + `+w*c+`;
           `,l===1){if(w<h&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+w+`Ready == 0) {
                   xTexelC`+w+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+w+`.zw = vec2(0.0);
                   }
                   xTexelC`+w+`Ready = 1;
                 }
               `,c===1&&w>0?m+=`
                 xC`+w+" = vec4(xTexelC"+(w-2)+".zw, xTexelC"+w+`.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+w+" = vec4(previous.zw, xTexelC"+w+`.xy);
                   } else {
                     xC`+w+" = vec4(0.0, 0.0, xTexelC"+w+`.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+w+`Ready == 0) {
                   xTexelC`+w+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+w+`.zw = vec2(0.0);
                   }
                   xTexelC`+w+`Ready = 1;
                 }

                 xC`+w+" = xTexelC"+w+`;
                 `,w+1<h)){const _=o%2===0?V0(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + `+_+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(w+1)+`Ready == 0) {
                     xTexelC`+(w+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(w+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(w+1)+`Ready = 1;
                   }
                   `,c>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(w+1)+" = vec4(previous.zw, xTexelC"+(w+1)+`.xy);
                     } else {
                      xC`+(w+1)+" = vec4(0.0, 0.0, xTexelC"+(w+1)+`.xy);
                     }
                     `:m+=`
                     xC`+(w+1)+" = vec4(xTexelC"+w+".zw, xTexelC"+(w+1)+`.xy);
                     `):_===1?m+=`
                     xC`+(w+1)+" = xTexelC"+w+`;
                     `:m+=`
                     xCOffset = xC + `+_+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(w+1)+`Ready == 0) {
                       xTexelC`+(w+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(w+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(w+1)+`Ready = 1;
                     }

                     xC`+(w+1)+" = xTexelC"+(w+1)+`;
                     `}}else w<h&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+w+`Ready == 0) {
                   xTexelC`+w+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+w+`.zw = vec2(0.0);
                   }
                   xTexelC`+w+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(w+1)+`Ready == 0) {
                   xTexelC`+(w+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(w+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(w+1)+`Ready = 1;
                 }

                 xC`+w+" = vec4(xTexelC"+w+".zw, xTexelC"+(w+1)+`.zw);
               `,w+1<h&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(w+1)+" = vec4(xTexelC"+(w+1)+`.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+w+`Ready == 0) {
                   xTexelC`+w+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+w+`.zw = vec2(0.0);
                   }
                   xTexelC`+w+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(w+1)+`Ready == 0) {
                   xTexelC`+(w+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(w+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(w+1)+`Ready = 1;
                 }

                 xC`+w+` = vec4(
                   xTexelC`+w+".xy, xTexelC"+(w+1)+`.xy);
               `,w+1<h&&(m+=`
                   xC`+(w+1)+" = vec4(xTexelC"+w+".zw, xTexelC"+(w+1)+`.zw);
                 `)));w<h&&(m+=`
             wTexel = getW(r, `+w+`, d1, d2);
             dotProd += xC`+w+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+x.inChannels+`) {
               dotProd += xC`+w+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<h&&(m+=`
               wTexel = getW(r, `+(w+1)+`, d1, d2);
               dotProd += xC`+(w+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+x.inChannels+`) {
                 dotProd += xC`+(w+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let g="",y="";r&&(a?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+r+`
         }`:i?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+r+`
         }`:g=`vec4 activation(vec4 x) {
           `+r+`
         }`,y="result = activation(result);");const b=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+g+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+m+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+b+`
         `+y+`
         setOutput(result);
       }
     `}}class IF{constructor(x,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=x,this.enableShapeUniforms=Dn(this.outputShape.length);const{dataFormat:r}=n,a=Ln(),i=r==="channelsLast",o=i?1:2,l=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+x[2]+" && pos < "+x[1]+") {";let d="";for(let h=0;h<=1;h++)for(let p=0;p<=1;p++)d+=`
          blockIndex = rc.z + `+p+`;
          pos = rc.y + `+h+`;

          `+c+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+o+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+l+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+i+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(h*2+p)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(h*2+p)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+d+`

        `+a.output+` = result;
      }
    `}}function Ad(s,x){const n=s.length;return n>=3?x?[...s.slice(0,-3),s[n-3]*s[n-2],s[n-1]]:[...s.slice(0,-3),s[n-3],s[n-2]*s[n-1]]:!x&&n===1&&s[0]>1?[s[0],1]:null}function SS({x:s,filter:x,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const c=s.shape,d=r.texData.get(s.dataId),h=n.inChannels,p=c[0]*c[1]*c[2],m=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,b=!1;let v;const w=[];if(i!=null){const _=Ad(i.shape,g);_!=null&&(i=C0({inputs:{x:i},backend:r,attrs:{shape:_}}),w.push(i))}if(a!=null){const _=Ad(a.shape,g);_!=null&&(a=C0({inputs:{x:a},backend:r,attrs:{shape:_}}),w.push(a))}if(!((p===1||m===1)&&h>uS)&&d.isPacked&&g&&d.texture!=null&&c[2]%2!==0&&T0(d.shape.slice(-3),c.slice(-3))){const _=c[0]*c[1]*(c[2]+1),T={dataId:s.dataId,shape:[1,_,n.inChannels],dtype:s.dtype},A=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,G(hd(d.shape,T.shape),()=>"packed reshape "+d.shape+" to "+T.shape+" isn't free");const E=C0({inputs:{x},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});w.push(E);const M=wd({a:T,b:E,backend:r,transposeA:y,transposeB:b,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),I=r.texData.get(M.dataId);G(I.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=A,I.shape=n.outShape,v=a2({inputs:{x:M},backend:r}),v.shape=n.outShape,w.push(M)}else{const _=n.outHeight*n.outWidth,T=C0({inputs:{x:s},backend:r,attrs:{shape:g?[n.batchSize,_,n.inChannels]:[n.batchSize,n.inChannels,_]}}),A=C0({inputs:{x},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),E=wd({a:g?T:A,b:g?A:T,transposeA:!g,transposeB:b,backend:r,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o});v=C0({inputs:{x:E},backend:r,attrs:{shape:n.outShape}}),w.push(T),w.push(A),w.push(E)}for(const _ of w)r.disposeIntermediateTensorInfo(_);return v}function TS({x:s,filter:x,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:c,filterHeight:d,inChannels:h,outWidth:p,outHeight:m,dataFormat:g}=n,y=g==="channelsLast",b=c*d*h,v=m*p,w=[n.batchSize,b,v],_=!0,T=!1,A=[];if(i!=null){const xe=Ad(i.shape,y);xe!=null&&(i=C0({inputs:{x:i},backend:r,attrs:{shape:xe}}),A.push(i))}if(a!=null){const xe=Ad(a.shape,y);xe!=null&&(a=C0({inputs:{x:a},backend:r,attrs:{shape:xe}}),A.push(a))}const E=C0({inputs:{x},backend:r,attrs:{shape:[1,b,be(x.shape)/b]}});A.push(E);const M=new IF(w,n),I=[s.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],C=r.runWebGLProgram(M,[s],"float32",I),k=C0({inputs:{x:C},backend:r,attrs:{shape:w}});A.push(C),A.push(k);const O=a!=null,z=i!=null,ee=l==="leakyrelu",re=l?dl(l,!0):null,Y=new aS(y?k.shape:E.shape,y?E.shape:k.shape,y?[n.batchSize,v,n.outChannels]:[n.batchSize,n.outChannels,v],_,T,O,re,z,ee),Q=y?[k,E]:[E,k];if(a&&Q.push(a),z&&Q.push(i),ee){const xe=r.makeTensorInfo([],"float32",as(o,"float32"));Q.push(xe),A.push(xe)}const te=r.runWebGLProgram(Y,Q,"float32"),se=C0({inputs:{x:te},backend:r,attrs:{shape:n.outShape}});A.push(te);for(const xe of A)r.disposeIntermediateTensorInfo(xe);return se}function kF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h}=r,p=kr(c),m=sn(a.shape,i.shape,o,d,l,h,!1,p);let g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=SS({x:a,filter:i,convInfo:m,backend:n});else if(m.strideWidth<=2&&p==="channelsLast"&&Ce().getBool("WEBGL_EXP_CONV")){const b=new _S(m),v=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=n.runWebGLProgram(b,[a,i],"float32",v)}else if(Ce().getBool("WEBGL_CONV_IM2COL"))g=TS({x:a,filter:i,convInfo:m,backend:n});else{const b=new wS(m);g=n.runWebGLProgram(b,[a,i],"float32")}const y=C0({inputs:{x:g},backend:n,attrs:{shape:m.outShape}});return n.disposeIntermediateTensorInfo(g),y}const NF={kernelName:hp,backendName:"webgl",kernelFunc:kF};class RF{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape;const n=x.strideHeight,r=x.strideWidth,a=x.padInfo.top,i=x.padInfo.left,o=x.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < `+x.batchSize+`; b++) {
          for (int yR = 0; yR < `+x.outHeight+`; yR++) {
            int xR = wR + yR * `+n+" - "+a+`;

            if (xR < 0 || xR >= `+x.inHeight+`) {
              continue;
            }

            for (int yC = 0; yC < `+x.outWidth+`; yC++) {
              int xC = wC + yC * `+r+" - "+i+`;

              if (xC < 0 || xC >= `+x.inWidth+`) {
                continue;
              }

              if (`+o+`) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class PF{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const n=x.filterHeight,r=x.filterWidth,a=x.strideHeight,i=x.strideWidth,o=x.dataFormat==="channelsLast",l=n-1-x.padInfo.top,c=r-1-x.padInfo.left,d=o?1:2,h=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+l+", "+c+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+p+`];

        ivec2 dyCorner = ivec2(coords[`+d+"], coords["+h+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+n+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+a+`.0;

          if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+n+` - 1 - wR;

          for (int wC = 0; wC < `+r+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+i+`.0;

            if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+r+` - 1 - wC;

            for (int d2 = 0; d2 < `+x.outChannels+`; d2++) {

              if (`+o+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class LF{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape;const n=x.strideDepth,r=x.strideHeight,a=x.strideWidth,i=x.padInfo.front,o=x.padInfo.top,l=x.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < `+x.batchSize+`; b++) {
          for (int yF = 0; yF < `+x.outDepth+`; yF++) {
            int xF = wF + yF * `+n+" - "+i+`;

            if (xF < 0 || xF >= `+x.inDepth+`) {
              continue;
            }

            for (int yR = 0; yR < `+x.outHeight+`; yR++) {
              int xR = wR + yR * `+r+" - "+o+`;

              if (xR < 0 || xR >= `+x.inHeight+`) {
                continue;
              }

              for (int yC = 0; yC < `+x.outWidth+`; yC++) {
                int xC = wC + yC * `+a+" - "+l+`;

                if (xC < 0 || xC >= `+x.inWidth+`) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class DF{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const n=x.filterDepth,r=x.filterHeight,a=x.filterWidth,i=x.strideDepth,o=x.strideHeight,l=x.strideWidth,c=n-1-x.padInfo.front,d=r-1-x.padInfo.top,h=a-1-x.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(`+c+", "+d+", "+h+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < `+n+`; wF++) {
          float dyF = float(dyFCorner + wF) / `+i+`.0;

          if (dyF < 0.0 || dyF >= `+x.outDepth+`.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = `+n+` - 1 - wF;

          for (int wR = 0; wR < `+r+`; wR++) {
            float dyR = float(dyRCorner + wR) / `+o+`.0;

            if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = `+r+` - 1 - wR;

            for (int wC = 0; wC < `+a+`; wC++) {
              float dyC = float(dyCCorner + wC) / `+l+`.0;

              if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = `+a+` - 1 - wC;

              for (int d2 = 0; d2 < `+x.outChannels+`; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function OF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,pad:l,dataFormat:c,dimRoundingMode:d,filterShape:h}=r,p=kr(c),m=sn(a.shape,h,o,1,l,d,!1,p),g=new RF(m);return n.runWebGLProgram(g,[a,i],"float32")}const FF={kernelName:pp,backendName:"webgl",kernelFunc:OF};function UF(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{inputShape:o,strides:l,pad:c,dataFormat:d,dimRoundingMode:h}=r,p=kr(d),m=sn(o,i.shape,l,1,c,h,!1,p),g=new PF(m);return n.runWebGLProgram(g,[a,i],"float32")}const BF={kernelName:fp,backendName:"webgl",kernelFunc:UF};function zF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dilations:c}=r,d=ps(a.shape,i.shape,o,c,l),h=new MF(d);return n.runWebGLProgram(h,[a,i],"float32")}const WF={kernelName:mp,backendName:"webgl",kernelFunc:zF};function GF(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,pad:l,filterShape:c}=r,d=ps(a.shape,c,o,1,l),h=new LF(d);return n.runWebGLProgram(h,[a,i],"float32")}const VF={kernelName:Ny,backendName:"webgl",kernelFunc:GF};function HF(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{pad:o,strides:l,inputShape:c}=r,d=ps(c,i.shape,l,1,o),h=new DF(d);return n.runWebGLProgram(h,[a,i],"float32")}const YF={kernelName:gp,backendName:"webgl",kernelFunc:HF},qF=Pi+`
  return cos(x);
`,XF=Yt({opSnippet:qF}),KF={kernelName:Dc,backendName:"webgl",kernelFunc:XF},$F=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,ZF=Yt({opSnippet:$F}),JF={kernelName:Oc,backendName:"webgl",kernelFunc:ZF};class QF{constructor(x,n,r,a,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,c,d]=x,[h]=n,[p,m]=r;this.outputShape=[h,p,m,d];const g=a==="bilinear"?1:0,[y,b]=[l-1+".0",c-1+".0"],[v,w,_]=p>1?[""+(l-1)/(p-1),"(y2-y1) * height_ratio","y1*"+y+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+y],[T,A,E]=m>1?[""+(c-1)/(m-1),"(x2-x1) * width_ratio","x1*"+b+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+b];this.userCode=`
      const float height_ratio = float(`+v+`);
      const float width_ratio = float(`+T+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+o+`) {
          return;
        }

        float height_scale = `+w+`;
        float width_scale = `+A+`;

        float in_y = `+_+`;
        if( in_y < 0.0 || in_y > `+y+` ) {
          setOutput(float(`+i+`));
          return;
        }
        float in_x = `+E+`;
        if( in_x < 0.0 || in_x > `+b+` ) {
          setOutput(float(`+i+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+g+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const jF=s=>{const{inputs:x,backend:n,attrs:r}=s,{image:a,boxes:i,boxInd:o}=x,{cropSize:l,method:c,extrapolationValue:d}=r,h=new QF(a.shape,i.shape,l,c,d);return n.runWebGLProgram(h,[a,i,o],"float32")},eU={kernelName:vp,backendName:"webgl",kernelFunc:jF};var ml;(function(s){s.Prod="*",s.Sum="+"})(ml||(ml={}));class AS{constructor(x,n,r,a){this.op=x,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===ml.Prod?"1.0":"0.0",l=r?o:"getX("+ES(i,"coords",this.op)+")",c=this.outputShape[this.outputShape.length-1];let d="",h="";r?(d=a?"end != "+(c-1):"end != 0",h=a?"end + 1":"end - 1"):(d=a?"end + pow2 < "+c:"end >= pow2",h=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        `+ux(i)+` coords = getOutputCoords();
        int end = `+CS(i,"coords",this.op)+`;
        float val = `+l+`;
        int pow2 = int(pow(2.0, index));
        if (`+d+`) {
          int idx = `+h+`;
          `+CS(i,"coords",this.op)+` = idx;
          val `+this.op+"= getX("+ES(i,"coords",this.op)+`);
        }
        setOutput(val);
      }
    `}}function ES(s,x,n){if(s===1)return""+x;if(s===2)return x+".x, "+x+".y";if(s===3)return x+".x, "+x+".y, "+x+".z";if(s===4)return x+".x, "+x+".y, "+x+".z, "+x+".w";throw new Error("Cumulative "+n+" for rank "+s+" is not yet supported")}function CS(s,x,n){if(s===1)return""+x;if(s===2)return x+".y";if(s===3)return x+".z";if(s===4)return x+".w";throw new Error("Cumulative "+n+" for rank "+s+" is not yet supported")}function MS(s,x,n,r,a,i){const o=x.shape.length,l=Nx([r],o);let c=x;l!=null&&(c=Fn({inputs:{x},backend:n,attrs:{perm:l}}));const d=Rx(1,o)[0];if(d!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis="+(x.shape.length-1)+" but got axis="+r);const h=c.shape[d];let p=a2({inputs:{x:c},backend:n});for(let m=0;m<=Math.ceil(Math.log2(h))-1;m++){const g=new AS(s,c.shape,!1,i),y=[[m]],b=p;p=n.runWebGLProgram(g,[p],p.dtype,y),n.disposeIntermediateTensorInfo(b)}if(a){const m=new AS(s,c.shape,a,i),g=p;p=n.runWebGLProgram(m,[p],p.dtype),n.disposeIntermediateTensorInfo(g)}if(l!=null){const m=Xo(l),g=Fn({inputs:{x:p},backend:n,attrs:{perm:m}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),g}return p}function tU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,exclusive:o,reverse:l}=r;return MS(ml.Prod,a,n,i,o,l)}const xU={kernelName:yp,backendName:"webgl",kernelFunc:tU};function nU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,exclusive:o,reverse:l}=r;return MS(ml.Sum,a,n,i,o,l)}const rU={kernelName:bp,backendName:"webgl",kernelFunc:nU};function sU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,weights:i}=x,{size:o,binaryOutput:l}=r;if(a.shape.length===1){const c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=X_(c,d,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,h)}else if(a.shape.length===2){const c=n.bufferSync(a),d=n.bufferSync(i),h=gL(c,d,o,l);return n.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+a.shape.length+".")}const aU={kernelName:wp,backendName:"webgl",kernelFunc:sU};class iU{constructor(x,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=x,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+n+`;
      int offset_h = imod(h, `+n+`);
      int in_w = w / `+n+`;
      int offset_w = imod(w, `+n+`);
      int offset_d = (offset_h * `+n+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function oU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockSize:i,dataFormat:o}=r,l=a.shape[0],c=o==="NHWC"?a.shape[1]:a.shape[2],d=o==="NHWC"?a.shape[2]:a.shape[3],h=o==="NHWC"?a.shape[3]:a.shape[1],p=c*i,m=d*i,g=h/(i*i),y=o==="NHWC"?[l,p,m,g]:[l,g,p,m],b=new iU(y,i,o);return n.runWebGLProgram(b,[a],a.dtype)}const lU={kernelName:_p,backendName:"webgl",kernelFunc:oU};class IS{constructor(x,n=!1,r=null,a=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=Dn(this.outputShape.length);const o=x.filterHeight,l=x.filterWidth,c=x.outChannels/x.inChannels;let d="",h="";r&&(a?d=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+r+`
        }`:i?d=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+r+`
        }`:d=`
          float activation(float x) {
            `+r+`
          }
        `,h="result = activation(result);");const p=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+d+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+c+`;
        int q = d2 - d1 * `+c+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+o+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+l+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+p+`
        `+h+`
        setOutput(result);
      }
    `}}class kS{constructor(x,n=!1,r=null,a=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=Dn(this.outputShape.length);const o=x.outChannels/x.inChannels,l=x.padInfo.left,c=x.strideWidth,d=x.dilationWidth,h=x.filterHeight,p=x.filterWidth,m=p;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<p;w++)g+=`
          vec4 xTexelC`+w*2+`;
          int xTexelC`+w*2+`Ready;
          vec4 xTexelC`+(w*2+1)+`;
          int xTexelC`+(w*2+1)+`Ready;
          vec4 xC`+w+";";g+=`
    for (int r = 0; r < `+h+`; r++) {
      `;for(let w=0;w<p;w++)g+=`
          xTexelC`+w*2+` = vec4(0.0);
          xTexelC`+w*2+`Ready = 0;
          xTexelC`+(w*2+1)+` = vec4(0.0);
          xTexelC`+(w*2+1)+`Ready = 0;
          xC`+w+" = vec4(0.0);";g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(m+1)/2;w++){const _=w*2;if(g+=`
          xC = xCCorner + `+_*d+`;
          `,c===1){if(_<p&&(l%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+_+`Ready == 0) {
                  xTexelC`+_+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+_+`.zw = vec2(0.0);
                  }
                  xTexelC`+_+`Ready = 1;
                }
              `,d===1&&_>0?g+=`
                xC`+_+" = vec4(xTexelC"+(_-2)+".zw, xTexelC"+_+`.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+_+" = vec4(previous.zw, xTexelC"+_+`.xy);
                  } else {
                    xC`+_+" = vec4(0.0, 0.0, xTexelC"+_+`.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+_+`Ready == 0) {
                  xTexelC`+_+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+_+`.zw = vec2(0.0);
                  }
                  xTexelC`+_+`Ready = 1;
                }

                xC`+_+" = xTexelC"+_+`;
                `,_+1<p)){const T=l%2===0?V0(d):d;d%2===0&&l%2===1||d%2!==0&&l%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + `+T+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(_+1)+`Ready == 0) {
                    xTexelC`+(_+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(_+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(_+1)+`Ready = 1;
                  }
                  `,d>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(_+1)+" = vec4(previous.zw, xTexelC"+(_+1)+`.xy);
                    } else {
                     xC`+(_+1)+" = vec4(0.0, 0.0, xTexelC"+(_+1)+`.xy);
                    }
                    `:g+=`
                    xC`+(_+1)+" = vec4(xTexelC"+_+".zw, xTexelC"+(_+1)+`.xy);
                    `):T===1?g+=`
                    xC`+(_+1)+" = xTexelC"+_+`;
                    `:g+=`
                    xCOffset = xC + `+T+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(_+1)+`Ready == 0) {
                      xTexelC`+(_+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(_+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(_+1)+`Ready = 1;
                    }

                    xC`+(_+1)+" = xTexelC"+(_+1)+`;
                    `}}else _<p&&(l%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+_+`Ready == 0) {
                  xTexelC`+_+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+_+`.zw = vec2(0.0);
                  }
                  xTexelC`+_+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(_+1)+`Ready == 0) {
                  xTexelC`+(_+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(_+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(_+1)+`Ready = 1;
                }

                xC`+_+" = vec4(xTexelC"+_+".zw, xTexelC"+(_+1)+`.zw);
              `,_+1<p&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(_+1)+" = vec4(xTexelC"+(_+1)+`.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+_+`Ready == 0) {
                  xTexelC`+_+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+_+`.zw = vec2(0.0);
                  }
                  xTexelC`+_+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(_+1)+`Ready == 0) {
                  xTexelC`+(_+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(_+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(_+1)+`Ready = 1;
                }

                xC`+_+` = vec4(
                  xTexelC`+_+".xy, xTexelC"+(_+1)+`.xy);
              `,_+1<p&&(g+=`
                  xC`+(_+1)+" = vec4(xTexelC"+_+".zw, xTexelC"+(_+1)+`.zw);
                `)));_<p&&(g+=`
            wTexel = getW(r, `+_+`, d1, q);
            dotProd += xC`+_+` * vec4(wTexel.xz, wTexel.xz);
          `,_+1<p&&(g+=`
              wTexel = getW(r, `+(_+1)+`, d1, q);
              dotProd += xC`+(_+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",b="";r&&(a?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+r+`
        }`:i?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+r+`
        }`:y=`vec4 activation(vec4 x) {
          `+r+`
        }`,b="result = activation(result);");const v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+y+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+o+`;
        int q = d2 - d1 * `+o+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+g+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+v+`
        `+b+`
        setOutput(result);
      }
    `}}function cU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dilations:c,dimRoundingMode:d}=r;let h=c;h==null&&(h=[1,1]),G(Sn(o,h),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+h+"'");const p=sn(a.shape,i.shape,o,h,l,d,!0);let m;Ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new kS(p):m=new IS(p);const g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(m,[a,i],"float32",g)}const uU={kernelName:Sp,backendName:"webgl",kernelFunc:cU};class dU{constructor(x){this.variableNames=["x","dy"],this.outputShape=x.filterShape;const n=x.strideHeight,r=x.strideWidth,a=x.padInfo.top,i=x.padInfo.left,o=x.outChannels/x.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * `+o+` + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < `+x.batchSize+`; b++) {
          for (int yR = 0; yR < `+x.outHeight+`; yR++) {
            int xR = wR + yR * `+n+" - "+a+`;

            if (xR < 0 || xR >= `+x.inHeight+`) {
              continue;
            }

            for (int yC = 0; yC < `+x.outWidth+`; yC++) {
              int xC = wC + yC * `+r+" - "+i+`;

              if (xC < 0 || xC >= `+x.inWidth+`) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class hU{constructor(x){this.variableNames=["dy","W"],this.outputShape=x.inShape;const n=x.filterHeight,r=x.filterWidth,a=x.strideHeight,i=x.strideWidth,o=n-1-x.padInfo.top,l=r-1-x.padInfo.left,c=x.outChannels/x.inChannels;this.userCode=`
      const ivec2 pads = ivec2(`+o+", "+l+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < `+n+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+a+`.0;

          if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+n+` - 1 - wR;

          for (int wC = 0; wC < `+r+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+i+`.0;

            if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+r+` - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < `+c+`; dm++) {
              int d2 = d1 * `+c+` + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function pU(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,dilations:l,pad:c,dimRoundingMode:d,filterShape:h}=r,p=sn(a.shape,h,o,l,c,d,!0),m=new dU(p);return n.runWebGLProgram(m,[a,i],"float32")}const fU={kernelName:Tp,backendName:"webgl",kernelFunc:pU};function mU(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{strides:o,dilations:l,pad:c,dimRoundingMode:d,inputShape:h}=r,p=sn(h,i.shape,o,l,c,d,!0),m=new hU(p);return n.runWebGLProgram(m,[a,i],"float32")}const gU={kernelName:Ap,backendName:"webgl",kernelFunc:mU};class yU{constructor(x){this.variableNames=["X"],this.outputShape=[x,x],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function bU(s){const{inputs:x,backend:n}=s,{x:r}=x,a=[...r.shape,...r.shape],i=be(r.shape),o=C0({inputs:{x:r},backend:n,attrs:{shape:[i]}}),l=new yU(i),c=n.runWebGLProgram(l,[o],o.dtype),d=C0({inputs:{x:c},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),d}const vU={kernelName:Ep,backendName:"webgl",kernelFunc:bU};class wU{constructor(x){this.variableNames=["x","W"],this.outputShape=x.outShape;const{inHeight:n,inWidth:r,padInfo:a,strideHeight:i,strideWidth:o,filterHeight:l,filterWidth:c,dilationHeight:d,dilationWidth:h}=x,{top:p,left:m}=a;this.userCode=`
      const ivec2 strides = ivec2(`+i+", "+o+`);
      const ivec2 pads = ivec2(`+p+", "+m+`);
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < `+l+`; h++) {
          int hIn = hBeg + h * `+d+`;

          if (hIn >= 0 && hIn < `+n+`) {
            for (int w = 0; w < `+c+`; w++) {
              int wIn = wBeg + w * `+h+`;

              if (wIn >= 0 && wIn < `+r+`) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function _U(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dilations:c}=r,d=Wo(a.shape,i.shape,o,l,"NHWC",c);let h;const p=new wU(d);h=n.runWebGLProgram(p,[a,i],"float32");const m=C0({inputs:{x:h},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(h),m}const SU={kernelName:Cp,backendName:"webgl",kernelFunc:_U};function TU(s){const{inputs:x,backend:n,attrs:r}=s,{equation:a}=r,i=x,{allDims:o,summedDims:l,idDims:c}=Jm(a,i.length);jm(o.length,c,i);const{path:d,steps:h}=eg(l,c),p=h.length;let m=null,g=o.length;const y=[];for(let b=0;b<p;++b){for(const v of h[b]){const{permutationIndices:w,expandDims:_}=Qm(g,c[v]);let T;tg(w)?T=i[v]:(T=Fn({inputs:{x:i[v]},backend:n,attrs:{perm:w}}),y.push(T));const A=T.shape.slice();for(let E=0;E<_.length;++E)A.splice(_[E],0,1);T0(T.shape,A)||(T=C0({inputs:{x:T},backend:n,attrs:{shape:A}}),y.push(T)),m===null?m=T:(m=Fg({inputs:{a:T,b:m},backend:n}),y.push(m))}b<p-1&&(d[b]>=0&&(m=vd({inputs:{x:m},backend:n,attrs:{axis:d[b]-(o.length-g),keepDims:!1}}),y.push(m)),g--)}for(const b of y)b!==m&&n.disposeIntermediateTensorInfo(b);return m}const AU={kernelName:Mp,backendName:"webgl",kernelFunc:TU},EU="return (x >= 0.0) ? x : (exp(x) - 1.0);",CU=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,MU=Yt({opSnippet:EU,packedOpSnippet:CU}),IU={kernelName:Uc,backendName:"webgl",kernelFunc:MU},kU="return (b >= 1.0) ? a : a * (b + 1.0);",NU=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,RU=s=>{const{inputs:x,backend:n}=s,{dy:r,y:a}=x,i=Ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ul(NU,r.shape,a.shape):new Ri(kU,r.shape,a.shape);return n.runWebGLProgram(i,[r,a],r.dtype)},PU={kernelName:Ly,backendName:"webgl",kernelFunc:RU},LU=`
  return vec4(equal(a, b));
`,DU="return float(a == b);",OU=mn({opSnippet:DU,packedOpSnippet:LU,dtype:"bool",cpuKernelImpl:wL}),FU={kernelName:zc,backendName:"webgl",kernelFunc:OU},UU=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = `+Vm+`;
  float a1 = `+Hm+`;
  float a2 = `+Ym+`;
  float a3 = `+qm+`;
  float a4 = `+Xm+`;
  float a5 = `+Km+`;

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,BU=Yt({opSnippet:UU}),zU={kernelName:Bc,backendName:"webgl",kernelFunc:BU},WU=Pi+`
  return exp(x);
`,GU=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,NS=Yt({opSnippet:WU,packedOpSnippet:GU,cpuKernelImpl:_L,dtype:"float32"}),VU={kernelName:Wc,backendName:"webgl",kernelFunc:NS};function Wg(s){const{inputs:x,attrs:n,backend:r}=s,{dim:a}=n,{input:i}=x,o=i.shape.length,l=i.shape.slice();let c=a;return a<0&&(G(-(o+1)<=a,()=>"Axis must be in the interval ["+-(o+1)+", "+o+"]"),c=o+a+1),l.splice(c,0,1),C0({inputs:{x:i},backend:r,attrs:{shape:l}})}const HU={kernelName:Ip,backendName:"webgl",kernelFunc:Wg},RS="return exp(x) - 1.0;",YU=Yt({opSnippet:RS,packedOpSnippet:RS,cpuKernelImpl:SL}),qU={kernelName:Gc,backendName:"webgl",kernelFunc:YU};class PS{constructor(x,n,r){this.variableNames=["real","imag"];const a=n[1];this.outputShape=n;const i=r?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,o=r?a+".0":"1.0";let l;if(x==="real")l="return real * expR - imag * expI;";else if(x==="imag")l="return real * expI + imag * expR;";else throw new Error('FFT component must be either "real" or "imag", got '+x+".");this.userCode=`
      const float exponentMultiplier = `+i+`;

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        `+l+`
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(`+a+`);
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < `+a+`; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / `+o+`;
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function LS(s,x,n){const r=n.texData.get(s.dataId),a=be(s.shape),i=s.shape[s.shape.length-1],o=a/i,l=C0({inputs:{x:s},backend:n,attrs:{shape:[o,i]}}),c=l.shape,d=new PS("real",c,x),h=new PS("imag",c,x),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],m=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(h,p,"float32"),y=vs({inputs:{real:m,imag:g},backend:n});n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g);const b=C0({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(y),b}function XU(s){const{inputs:x,backend:n}=s,{input:r}=x;return LS(r,!1,n)}const KU={kernelName:kp,backendName:"webgl",kernelFunc:XU};class $U{constructor(x,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=x,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function gl(s){const{backend:x,attrs:n}=s,{shape:r,value:a}=n;let{dtype:i}=n;if(i=i||Gt(a),i==="string"){const o=a0(i,be(r));return o.fill(a),x.makeTensorInfo(r,i,o)}else{const o=new $U(r,a),l=[[a]];return x.runWebGLProgram(o,[],i,l)}}const ZU={kernelName:Np,backendName:"webgl",kernelFunc:gl};class JU{constructor(x){this.variableNames=["Image"],this.outputShape=[];const n=x[2];this.outputShape=x,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = `+n+` - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < `+n+`) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const QU={kernelName:Rp,backendName:"webgl",kernelFunc:({inputs:s,backend:x})=>{const{image:n}=s,r=x,a=new JU(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},DS="return floor(x);",jU=Yt({opSnippet:DS,packedOpSnippet:DS,cpuKernelImpl:TL}),eB={kernelName:Vc,backendName:"webgl",kernelFunc:jU},tB=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,xB=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,nB=mn({opSnippet:tB,packedOpSnippet:xB,dtype:"int32"}),rB={kernelName:Hc,backendName:"webgl",kernelFunc:nB};class sB{constructor(x){this.variableNames=["A"];const n=Ln(),[r,a]=x;this.outputShape=x,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+a+".0, "+r+`.0);

        vec4 values = `+n.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class aB{constructor(x){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Ln(),[r,a]=x;this.outputShape=x,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+a+".0, "+r+`.0);
            vec4 values = `+n.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+n.output+` = result;
      }
    `}}const iB={kernelName:Uf,backendName:"webgl",kernelFunc:oB};let Di,Gg=Ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function oB(s){const{inputs:x,backend:n,attrs:r}=s;let{pixels:a}=x;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[c,d]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],h=[d,c],p=[d,c,i];if(l||o){const b=Ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Di==null||b!==Gg)&&(Gg=b,Di=document.createElement("canvas").getContext("2d",{willReadFrequently:Gg})),Di.canvas.width=c,Di.canvas.height=d,Di.drawImage(a,0,0,c,d),a=Di.canvas}const m=n.makeTensorInfo(h,"int32");n.texData.get(m.dataId).usage=p2.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(m.dataId),a);const g=Ce().getBool("WEBGL_PACK")?new aB(p):new sB(p),y=n.runWebGLProgram(g,[m],"int32");return n.disposeData(m.dataId),y}function lB(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i,bias:o,preluActivationWeights:l}=x,{strides:c,pad:d,dataFormat:h,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:y}=r,b=kr(h),v=sn(a.shape,i.shape,c,p,d,m,!1,b);let w;const _=[],T=o!=null,A=l!=null,E=g==="leakyrelu",M=()=>{const C=[a,i],k=(O,z)=>{if(z==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const ee=C0({inputs:{x:O},backend:n,attrs:{shape:[O.shape[0],1,1]}});return _.push(ee),ee}return O};if(T&&C.push(k(o,h)),A&&C.push(k(l,h)),E){const O=n.makeTensorInfo([],"float32",as(y,"float32"));C.push(O),_.push(O)}return C};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))w=SS({x:a,filter:i,convInfo:v,backend:n,bias:o,activation:g,preluActivationWeights:l,leakyreluAlpha:y});else if(v.strideWidth<=2&&b==="channelsLast"&&Ce().getBool("WEBGL_EXP_CONV")){const C=g?dl(g,!0):null,k=new _S(v,T,C,A,E),O=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],z=M();w=n.runWebGLProgram(k,z,"float32",O)}else if(Ce().getBool("WEBGL_CONV_IM2COL"))w=TS({x:a,filter:i,convInfo:v,backend:n,bias:o,activation:g,preluActivationWeights:l,leakyreluAlpha:y});else{const C=g?dl(g,!1):null,k=new wS(v,T,C,A,E),O=M();w=n.runWebGLProgram(k,O,"float32")}const I=C0({inputs:{x:w},backend:n,attrs:{shape:v.outShape}});return _.push(w),_.forEach(C=>n.disposeIntermediateTensorInfo(C)),I}const cB={kernelName:Iu,backendName:"webgl",kernelFunc:lB};function uB(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i,bias:o,preluActivationWeights:l}=x,{strides:c,pad:d,dilations:h,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=r,y=[];let b=h;b==null&&(b=[1,1]),G(Sn(c,b),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+b+"'");const v=sn(a.shape,i.shape,c,b,d,p,!0),w=Ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,_=m?dl(m,w):null,T=[a,i],A=o!=null,E=l!=null,M=m==="leakyrelu";if(A&&T.push(o),E&&T.push(l),M){const O=n.makeTensorInfo([],"float32",as(g,"float32"));T.push(O),y.push(O)}let I;w?I=new kS(v,A,_,E,M):I=new IS(v,A,_,E,M);const C=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],k=n.runWebGLProgram(I,T,"float32",C);return y.forEach(O=>n.disposeIntermediateTensorInfo(O)),k}const dB={kernelName:ku,backendName:"webgl",kernelFunc:uB};class hB{constructor(x,n,r,a){this.sliceDim=x,this.strides=n,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=r;const i=ux(r.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], `+l+`));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= `+this.paramsShape[l]+`;
          flattenIndex += index * `+this.strides[l]+";";this.userCode=`
         void main() {
          `+i+` coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          `+o+`

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function pB(s){const{inputs:x,backend:n}=s,{params:r,indices:a}=x,i=a.shape,o=i[i.length-1],l=be(r.shape),[c,d,h,p]=Mm(r,a),m=C0({inputs:{x:a},backend:n,attrs:{shape:[d,o]}}),g=C0({inputs:{x:r},backend:n,attrs:{shape:[be(r.shape)/h,h]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const w=n.readSync(a.dataId),_=n.bufferSync(r),T=AL(w,_,r.dtype,d,o,h,p,r.shape,l);return n.makeTensorInfo(c,r.dtype,T.values)}const y=new hB(o,p,[d,h],r.shape),b=n.runWebGLProgram(y,[g,m],g.dtype),v=C0({inputs:{x:b},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),v}const fB={kernelName:Dp,backendName:"webgl",kernelFunc:pB};class mB{constructor(x,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=ux(this.rank),a=gB(x);this.userCode=`
      void main() {
        `+r+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+x[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+a+`));
      }
    `}}function gB(s,x){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<s.length;a++)a===2?r.push("index"):r.push(""+n[a]);return r.join()}function OS(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,indices:i}=x,{axis:o,batchDims:l}=r,c=_0(o,a.shape)[0];if(Ce().get("DEBUG")){const _=n.readSync(i.dataId),T=a.shape[c];for(let A=0;A<_.length;++A){const E=_[A];G(E<=T-1&&E>=0,()=>"GatherV2: the index value "+E+" is not in [0, "+(T-1)+"]")}}const d=rg(a,i,c,l),h=be(i.shape),p=[],m=C0({inputs:{x:a},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=C0({inputs:{x:i},backend:n,attrs:{shape:[d.batchSize,h/d.batchSize]}});p.push(m),p.push(g);const y=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([a,i])||a.dtype==="string"){const _=n.bufferSync(g),T=n.bufferSync(m),A=EL(T,_,y);return p.forEach(E=>n.disposeIntermediateTensorInfo(E)),n.makeTensorInfo(d.outputShape,A.dtype,A.values)}const b=new mB(m.shape,y),v=n.runWebGLProgram(b,[m,g],m.dtype);p.push(v);const w=C0({inputs:{x:v},backend:n,attrs:{shape:d.outputShape}});return p.forEach(_=>n.disposeIntermediateTensorInfo(_)),w}const yB={kernelName:Lp,backendName:"webgl",kernelFunc:OS},bB="return float(a > b);",vB=`
  return vec4(greaterThan(a, b));
`,wB=mn({opSnippet:bB,packedOpSnippet:vB,cpuKernelImpl:CL,dtype:"bool"}),_B={kernelName:Yc,backendName:"webgl",kernelFunc:wB},SB="return float(a >= b);",TB=`
  return vec4(greaterThanEqual(a, b));
`,AB=mn({opSnippet:SB,packedOpSnippet:TB,dtype:"bool",cpuKernelImpl:ML}),EB={kernelName:qc,backendName:"webgl",kernelFunc:AB};function CB(s){const{inputs:x,backend:n}=s,{input:r}=x;return LS(r,!0,n)}const MB={kernelName:Op,backendName:"webgl",kernelFunc:CB},IB="return float(!isnan(x) && !isinf(x));",kB=Yt({opSnippet:IB,dtype:"bool"}),NB={kernelName:Kc,backendName:"webgl",kernelFunc:kB},RB="return float(isinf(x));",PB=Yt({opSnippet:RB,dtype:"bool"}),LB={kernelName:$c,backendName:"webgl",kernelFunc:PB},DB="return float(isnan(x));",OB=Yt({opSnippet:DB,dtype:"bool"}),FB={kernelName:Zc,backendName:"webgl",kernelFunc:OB},UB="return float(a < b);",BB=`
  return vec4(lessThan(a, b));
`,zB=mn({opSnippet:UB,packedOpSnippet:BB,cpuKernelImpl:IL,dtype:"bool"}),WB={kernelName:Jc,backendName:"webgl",kernelFunc:zB},GB="return float(a <= b);",VB=`
  return vec4(lessThanEqual(a, b));
`,HB=mn({opSnippet:GB,packedOpSnippet:VB,cpuKernelImpl:kL,dtype:"bool"}),YB={kernelName:Qc,backendName:"webgl",kernelFunc:HB};function qB(s){const{backend:x,attrs:n}=s,{start:r,stop:a,num:i}=n,o=NL(r,a,i);return x.makeTensorInfo([o.length],"float32",o)}const XB={kernelName:Bp,backendName:"webgl",kernelFunc:qB},KB=Pi+`
  return x < 0.0 ? 0./0. : log(x);
`,$B=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ZB=Yt({opSnippet:KB,packedOpSnippet:$B,cpuKernelImpl:RL}),JB={kernelName:jc,backendName:"webgl",kernelFunc:ZB},QB=Pi+`
  return log(1.0 + x);
`,jB=Yt({opSnippet:QB}),ez={kernelName:eu,backendName:"webgl",kernelFunc:jB},tz="return float(a >= 1.0 && b >= 1.0);",xz=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,nz=mn({opSnippet:tz,packedOpSnippet:xz,dtype:"bool"}),rz={kernelName:tu,backendName:"webgl",kernelFunc:nz},sz="return float(!(x >= 1.0));",az=Yt({opSnippet:sz}),iz={kernelName:xu,backendName:"webgl",kernelFunc:az},oz="return float(a >= 1.0 || b >= 1.0);",lz=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,cz=mn({opSnippet:oz,packedOpSnippet:lz,dtype:"bool"}),uz={kernelName:nu,backendName:"webgl",kernelFunc:cz};class dz{constructor(x,n,r,a,i){this.variableNames=["x"],this.outputShape=[];const o=n,l=x[3]-1;this.outputShape=x;let c;const d="float("+r+") + float("+a+") * sum";i===.5?c="inversesqrt("+d+")":i===1?c="1.0/("+d+")":c="exp(log("+d+") * float(-"+i+"));",this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -`+o+"; j <= "+o+`; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  `+l+`) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * `+c+`;
        setOutput(val);
      }
    `}}class hz{constructor(x,n,r,a,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,l=x[3]-1;this.outputShape=x;let c;const d="float("+r+") + float("+a+") * sum";i===.5?c="inversesqrt("+d+")":i===1?c="1.0/("+d+")":c="exp(log("+d+") * float(-"+i+"));",this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < `+this.outputShape[3]+`;
        bool hasNextRow = c < `+this.outputShape[2]+`;

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - `+o+`;
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - `+o+"; j <= "+o+`; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(`+l+`));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * `+c+`;
        setOutput(result);
      }
    `}}const pz=s=>{const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{depthRadius:i,bias:o,alpha:l,beta:c}=r,d=Ce().getBool("WEBGL_PACK_NORMALIZATION")?new hz(a.shape,i,o,l,c):new dz(a.shape,i,o,l,c);return n.runWebGLProgram(d,[a],a.dtype)},fz={kernelName:zp,backendName:"webgl",kernelFunc:pz};class mz{constructor(x,n,r,a,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=x,this.depth=x[3],this.depthRadius=n,this.bias=r,this.alpha=a,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < `+this.depth+`; ++d) {
          int depthBegin = int(max(0.0, float(d - `+n+`)));
          int depthEnd = int(min(float(`+this.depth+`),
              float(d + `+n+` + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = `+this.depth+`;

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(`+a+") * norm + float("+r+`);

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(`+a+`)
                * float(`+i+`)
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * `+i+`);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const gz=s=>{const{inputs:x,backend:n,attrs:r}=s,{x:a,y:i,dy:o}=x,{depthRadius:l,bias:c,alpha:d,beta:h}=r,p=new mz(a.shape,l,c,d,h);return n.runWebGLProgram(p,[a,i,o],a.dtype)},yz={kernelName:Dy,backendName:"webgl",kernelFunc:gz};function bz(s,x,n,r){const a=be(x),i=be(s.shape)/a,o=C0({inputs:{x:s},attrs:{shape:[i,a]},backend:r}),l=wa(o,s.dtype,"max",r),c=C0({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),c}function FS(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{reductionIndices:i,keepDims:o}=r,l=a.shape.length,c=_0(i,a.shape);let d=c;const h=Nx(d,l),p=h!=null,m=n.shouldExecuteOnCPU([a]);let g=a;if(p){if(m){const _=n.texData.get(g.dataId).values,T=new Array(l);for(let M=0;M<T.length;M++)T[M]=a.shape[h[M]];const A=Lg(_,a.shape,a.dtype,h,T);g=n.makeTensorInfo(T,a.dtype);const E=n.texData.get(g.dataId);E.values=A}else g=bd(a,h,n);d=Rx(d.length,l)}hn("max",d,l);const[y,b]=dn(g.shape,d);let v=y;o&&(v=$x(y,c));let w;if(m){const _=n.texData.get(g.dataId).values,T=PL(_,be(b),v,a.dtype);w=n.makeTensorInfo(v,a.dtype);const A=n.texData.get(w.dataId);A.values=T}else w=bz(g,b,v,n);return p&&n.disposeIntermediateTensorInfo(g),w}const vz={kernelName:Wp,backendName:"webgl",kernelFunc:FS},wz=Og+`
  return max(a, b);
`,_z=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cl+`
  return result;
`,Sz=mn({opSnippet:wz,packedOpSnippet:_z,cpuKernelImpl:LL}),Tz={kernelName:ru,backendName:"webgl",kernelFunc:Sz};function Az(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x;il(a,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,d=1;G(Sn(o,d),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+d+"'");const h=k2(a.shape,i,o,d,l,c);if(h.filterWidth===1&&h.filterHeight===1&&T0(h.inShape,h.outShape))return a2({inputs:{x:a},backend:n});const p=new hl(h,"max",!1);return n.runWebGLProgram(p,[a],a.dtype)}const Ez={kernelName:Gp,backendName:"webgl",kernelFunc:Az};function Cz(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{filterSize:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:d}=r,h=[1,1,1],p=Ir(a.shape,i,o,h,l,d,c),m=new Ug(p,"max",!1);return n.runWebGLProgram(m,[a],a.dtype)}const Mz={kernelName:Vp,backendName:"webgl",kernelFunc:Cz};class Iz{constructor(x){this.variableNames=["dy","maxPos"],this.outputShape=x.inShape;const n=x.strideHeight,r=x.strideWidth,a=x.dilationHeight,i=x.effectiveFilterHeight,o=x.effectiveFilterWidth,l=i-1-x.padInfo.top,c=o-1-x.padInfo.left,d=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(`+l+", "+c+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+i+`;
          wR += `+a+`) {
          float dyR = float(dyRCorner + wR) / `+n+`.0;

          if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < `+o+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+r+`.0;

            if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = `+d+` - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * `+o+` + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class kz{constructor(x){this.variableNames=["dy","maxPos"],this.outputShape=x.inShape;const n=x.strideDepth,r=x.strideHeight,a=x.strideWidth,i=x.dilationDepth,o=x.dilationHeight,l=x.dilationWidth,c=x.effectiveFilterDepth,d=x.effectiveFilterHeight,h=x.effectiveFilterWidth,p=c-1-x.padInfo.front,m=d-1-x.padInfo.top,g=h-1-x.padInfo.left,y=c*d*h-1;this.userCode=`
      const ivec3 pads = ivec3(`+p+", "+m+", "+g+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < `+c+`;
           wD += `+i+`) {
          float dyD = float(dyDCorner + wD) / `+n+`.0;

          if (dyD < 0.0 || dyD >= `+x.outDepth+`.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < `+d+`;
              wR += `+o+`) {
            float dyR = float(dyRCorner + wR) / `+r+`.0;

            if (dyR < 0.0 || dyR >= `+x.outHeight+`.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < `+h+`;
                wC += `+l+`) {
              float dyC = float(dyCCorner + wC) / `+a+`.0;

              if (dyC < 0.0 || dyC >= `+x.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = `+y+` -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * `+d+" * "+h+` +
                  wR * `+h+` + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Nz(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,o=i,{filterSize:l,strides:c,pad:d,dimRoundingMode:h}=r,p=[1,1,1],m=Ir(o.shape,l,c,p,d,h),g=new Ug(m,"max",!0),y=n.runWebGLProgram(g,[o],o.dtype),b=new kz(m),v=n.runWebGLProgram(b,[a,y],o.dtype);return n.disposeIntermediateTensorInfo(y),v}const Rz={kernelName:Fy,backendName:"webgl",kernelFunc:Nz};function Pz(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i,output:o}=x,l=i;il([i,o],"maxPoolGrad");const{filterSize:c,strides:d,pad:h,dimRoundingMode:p}=r,m=k2(l.shape,c,d,1,h,p),g=!0,y=new hl(m,"max",g),b=n.runWebGLProgram(y,[l],l.dtype),v=new Iz(m),w=n.runWebGLProgram(v,[a,b],l.dtype);return n.disposeIntermediateTensorInfo(b),w}const Lz={kernelName:Oy,backendName:"webgl",kernelFunc:Pz};function Dz(s,x,n,r){let a=new hl(n,"max",!1);const i=r.runWebGLProgram(a,[s],"float32");a=new hl(n,"max",!0,!0,x);const o=r.runWebGLProgram(a,[s],"float32");return[i,o]}const Oz={kernelName:Hp,backendName:"webgl",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{x:r}=s,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=x,c=n;G(r.shape.length===4,()=>"Error in maxPool: input must be rank 4 but got rank "+r.shape.length+".");const d=[1,1];G(Sn(i,d),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+i+" and dilations '"+d+"'");const h=k2(r.shape,a,i,d,o),[p,m]=Dz(r,l,h,c);return[p,m]}};function Fz(s,x,n,r){const a=be(x),i=be(s.shape)/a,o=C0({inputs:{x:s},attrs:{shape:[i,a]},backend:r}),l=wa(o,"float32","mean",r),c=C0({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),c}const Uz={kernelName:Yp,backendName:"webgl",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{x:r}=s,{keepDims:a,axis:i}=x,o=n,l=r.shape.length,c=_0(i,r.shape);let d=c;const h=Nx(d,l),p=h!=null,m=o.shouldExecuteOnCPU([r]),g=[];let y=r;if(p){if(m){const T=o.texData.get(y.dataId).values,A=new Array(l);for(let I=0;I<A.length;I++)A[I]=r.shape[h[I]];const E=Lg(T,r.shape,r.dtype,h,A);y=o.makeTensorInfo(A,r.dtype);const M=o.texData.get(y.dataId);M.values=E}else y=bd(r,h,o);g.push(y),d=Rx(d.length,l)}hn("sum",d,l);const[b,v]=dn(y.shape,d);let w=b;a&&(w=$x(b,c));const _=Fz(y,v,w,o);for(const T of g)o.disposeIntermediateTensorInfo(T);return _}};function Bz(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r,l=a.shape.length,c=_0(i,a.shape);let d=c;const h=Nx(d,l);let p=a;h!=null&&(p=Fn({inputs:{x:a},backend:n,attrs:{perm:h}}),d=Rx(d.length,a.shape.length)),hn("min",d,l);const[m,g]=dn(p.shape,d),y=be(g),b=C0({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=wa(b,b.dtype,"min",n);let w;if(o){const _=$x(m,c);w=C0({inputs:{x:v},backend:n,attrs:{shape:_}})}else w=C0({inputs:{x:v},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),h!=null&&n.disposeIntermediateTensorInfo(p),w}const zz={kernelName:qp,backendName:"webgl",kernelFunc:Bz},Wz=Og+`
  return min(a, b);
`,Gz=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cl+`
  return result;
`,Vz=mn({opSnippet:Wz,packedOpSnippet:Gz,cpuKernelImpl:DL}),Hz={kernelName:su,backendName:"webgl",kernelFunc:Vz};class Yz{constructor(x,n,r){this.variableNames=["x"],this.outputShape=n.map((h,p)=>h[0]+x[p]+h[1]);const a=x.length,i=ux(a),o=n.map(h=>h[0]).join(","),l=n.map((h,p)=>h[0]+x[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),d=r==="reflect"?0:1;if(a===1){this.userCode=`
        int start = `+o+`;
        int end = `+l+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - `+d+`;
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + `+d+`;
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      `+i+" start = "+i+"("+o+`);
      `+i+" end = "+i+"("+l+`);

      void main() {
        `+i+` outC = getOutputCoords();
        for (int i = 0; i < `+a+`; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - `+d+`;
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + `+d+`;
          }
        }
        `+i+` coords = outC - start;
        setOutput(getX(`+c+`));
      }
    `}}class qz{constructor(x,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,b)=>y[0]+x[b]+y[1]);const a=x.length,i=ux(a),o=n.map(y=>y[0]).join(","),l=n.map((y,b)=>y[0]+x[b]).join(","),c=On("rc",a),d=On("source",a),h=c[a-1]+" < "+this.outputShape[a-1],p=a===1?"source":"vec2("+d.slice(-2).join()+")",m=r==="reflect"?0:1;let g="";if(a===1){const y=`
        `+i+` source = rc;
        if (source < start) {
          source = start * 2 - source - `+m+`;
        } else if (source >= end) {
          source = (end - 1) * 2 - source + `+m+`;
        }
        source -= start;
      `;g=`
        `+i+` rc = outputLoc;
        `+y+`
        result[0] = getChannel(getX(`+d.join()+"), "+p+`);
        `+c[a-1]+` += 1;
        if(`+h+`) {
          `+y+`
          result[1] = getChannel(getX(`+d.join()+"), "+p+`);
        }
      `}else{const y=`
        `+i+` source = rc;
        `+i+" lt = "+i+`(lessThan(source, start));
        `+i+" gte = "+i+`(greaterThanEqual(source, end));
        `+i+` orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - `+m+`) +
                gte * ((end - 1) * 2 - source + `+m+`);
        source -= start;
      `;g=`
        `+i+` rc = outputLoc;
        `+y+`
        result[0] = getChannel(getX(`+d.join()+"), "+p+`);
        `+c[a-1]+` += 1;
        if(`+h+`) {
          `+y+`
          result[1] = getChannel(getX(`+d.join()+"), "+p+`);
        }
        rc = outputLoc;
        `+c[a-2]+` += 1;
        if(`+c[a-2]+" < "+this.outputShape[a-2]+`) {
          `+y+`
          result[2] = getChannel(getX(`+d.join()+"), "+p+`);
          `+c[a-1]+` += 1;
          if(`+h+`) {
            `+y+`
            result[3] = getChannel(getX(`+d.join()+"), "+p+`);
          }
        }
      `}this.userCode=`
      const `+i+" start = "+i+"("+o+`);
      const `+i+" end = "+i+"("+l+`);

      void main() {
        `+i+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+g+`
        setOutput(result);
      }
    `}}const Xz=({inputs:s,backend:x,attrs:n})=>{const{x:r}=s,{paddings:a,mode:i}=n,o=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qz(r.shape,a,i):new Yz(r.shape,a,i);return x.runWebGLProgram(o,[r],r.dtype)},Kz={kernelName:Xp,backendName:"webgl",kernelFunc:Xz},$z=`if (b == 0.0) return NAN;
  return mod(a, b);`,Zz=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+cl+`
  return result;
`,Jz=mn({opSnippet:$z,packedOpSnippet:Zz}),Qz={kernelName:au,backendName:"webgl",kernelFunc:Jz};class jz{constructor(x,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[x,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < `+(n-1)+`; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(`+(n-1)+`));
      }
    `}}const eW=`
if (a == b) {
  return 1.0;
};
return a / b;`,tW=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,US=mn({opSnippet:eW,packedOpSnippet:tW,checkOutOfBounds:!0}),xW={kernelName:Fc,backendName:"webgl",kernelFunc:US},BS="return a - b;",zS=mn({opSnippet:BS,packedOpSnippet:BS,supportsComplex:!0,cpuKernelImpl:tD}),nW={kernelName:Su,backendName:"webgl",kernelFunc:zS};function WS(s){const{inputs:x,backend:n,attrs:r}=s,{logits:a}=x,{dim:i}=r,o=_0([i],a.shape),l=FS({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),c=$x(l.shape,o),d=C0({inputs:{x:l},backend:n,attrs:{shape:c}}),h=zS({inputs:{a,b:d},backend:n}),p=NS({inputs:{x:h},backend:n}),m=vd({inputs:{x:p},backend:n,attrs:{axis:o,keepDims:!1}}),g=C0({inputs:{x:m},backend:n,attrs:{shape:c}}),y=US({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}const rW={kernelName:_f,backendName:"webgl",kernelFunc:WS};function sW(s){const{inputs:x,backend:n,attrs:r}=s,{logits:a}=x,{numSamples:i,seed:o,normalized:l}=r,c=l?a:WS({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),d=c.shape[0],h=c.shape[1],p=new jz(d,h,i),m=[[o]],g=n.runWebGLProgram(p,[c],"int32",m);return l||n.disposeIntermediateTensorInfo(c),g}const aW={kernelName:Kp,backendName:"webgl",kernelFunc:sW},iW=O2+`
  return -x;
`,oW=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function lW(s){const{inputs:x,backend:n}=s,{x:r}=x;if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId),[o,l]=FL(i.values,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,o)}let a;return Ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new bs(r.shape,oW):a=new fr(r.shape,iW),n.runWebGLProgram(a,[r],r.dtype)}const cW={kernelName:$p,backendName:"webgl",kernelFunc:lW},uW=vm;function dW(s){E2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=r,d=n.readSync(a.dataId),h=n.readSync(i.dataId),{selectedIndices:p}=uW(d,h,o,l,c);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const hW={kernelName:Zp,backendName:"webgl",kernelFunc:dW},pW=wm;function fW(s){E2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:d}=r,h=n.readSync(a.dataId),p=n.readSync(i.dataId),{selectedIndices:m,validOutputs:g}=pW(h,p,o,l,c,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const mW={kernelName:Jp,backendName:"webgl",kernelFunc:fW},gW=_m;function yW(s){E2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=r,h=n.readSync(a.dataId),p=n.readSync(i.dataId),m=o,g=l,y=c,b=d,{selectedIndices:v,selectedScores:w}=gW(h,p,m,g,y,b);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const bW={kernelName:Qp,backendName:"webgl",kernelFunc:yW};class vW{constructor(x,n,r,a){this.variableNames=["indices"],this.outputShape=[x,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(`+a+"), float("+r+`),
                      float(index == coords.y)));
      }
    `}}const wW=s=>{const{inputs:x,backend:n,attrs:r}=s,{indices:a}=x,{dtype:i,depth:o,onValue:l,offValue:c}=r,d=be(a.shape),h=new vW(d,o,l,c),p=C0({inputs:{x:a},backend:n,attrs:{shape:[d]}}),m=n.runWebGLProgram(h,[p],i);n.disposeIntermediateTensorInfo(p);const g=[...a.shape,o],y=C0({inputs:{x:m},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(m),y},_W={kernelName:ef,backendName:"webgl",kernelFunc:wW};function Ed(s){const{inputs:x,backend:n}=s,{x:r}=x;if(r.dtype==="complex64"){const a=pl({inputs:{input:r},backend:n}),i=Ed({inputs:{x:a},backend:n}),o=Td({inputs:{input:r},backend:n}),l=Ed({inputs:{x:o},backend:n}),c=vs({inputs:{real:i,imag:l},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}else return gl({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const SW={kernelName:Ff,backendName:"webgl",kernelFunc:Ed};function GS(s){const{inputs:x,backend:n}=s,{x:r}=x;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const a=pl({inputs:{input:r},backend:n}),i=GS({inputs:{x:a},backend:n}),o=Td({inputs:{input:r},backend:n}),l=Ed({inputs:{x:o},backend:n}),c=vs({inputs:{real:i,imag:l},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}else return gl({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const TW={kernelName:jp,backendName:"webgl",kernelFunc:GS};function AW(s){const{inputs:x,backend:n,attrs:r}=s,{axis:a}=r;if(x.length===1)return Wg({inputs:{input:x[0]},backend:n,attrs:{dim:a}});const i=x[0].shape,o=x[0].dtype;x.forEach(h=>{F0(i,h.shape,"All tensors passed to stack must have matching shapes"),G(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=x.map(h=>{const p=Wg({inputs:{input:h},backend:n,attrs:{dim:a}});return l.push(p),p}),d=vS({inputs:c,backend:n,attrs:{axis:a}});return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),d}const EW={kernelName:tf,backendName:"webgl",kernelFunc:AW};class CW{constructor(x,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((d,h)=>d[0]+x[h]+d[1]);const a=x.length,i=ux(a),o=n.map(d=>d[0]).join(","),l=n.map((d,h)=>d[0]+x[h]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = `+o+`;
        int end = `+l+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+i+" start = "+i+"("+o+`);
      `+i+" end = "+i+"("+l+`);

      void main() {
        `+i+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+i+` coords = outC - start;
          setOutput(getX(`+c+`));
        }
      }
    `}}class MW{constructor(x,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((b,v)=>b[0]+x[v]+b[1]);const a=x.length,i=ux(a),o=n.map(b=>b[0]).join(","),l=n.map((b,v)=>b[0]+x[v]).join(","),c=On("rc",a),d=On("source",a),h=c[a-1]+" < "+this.outputShape[a-1],p=a===1?"source":"vec2("+d.slice(-2).join()+")",m=[i+" rc = outputLoc;",c[a-1]+` += 1;
       if(`+h+`) {
      `,a===1?"":`}
       rc = outputLoc;
       `+c[a-2]+` += 1;
       if(`+c[a-2]+" < "+this.outputShape[a-2]+") {",a===1?"":"  "+c[a-1]+` += 1;
         if(`+h+") {"],g=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let b=0,v=a===1?2:4;b<v;b++)y+=`
        `+m[b]+`
        if (`+g+`) {
          result[`+b+`] = float(value);
        } else {
          `+i+` source = rc - start;
          result[`+b+"] = getChannel(getX("+d.join()+"), "+p+`);
        }
      `;y+=a===1?"} ":"}}",this.userCode=`
      const `+i+" start = "+i+"("+o+`);
      const `+i+" end = "+i+"("+l+`);

      void main() {
        `+i+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+y+`
        setOutput(result);
      }
    `}}const VS=s=>{const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{paddings:i,constantValue:o}=r;if(be(a.shape)===0){const d=i.map((h,p)=>h[0]+a.shape[p]+h[1]);return gl({backend:n,attrs:{shape:d,value:o,dtype:a.dtype}})}const l=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MW(a.shape,i,o):new CW(a.shape,i,o),c=[[o]];return n.runWebGLProgram(l,[a],a.dtype,c)},IW={kernelName:xf,backendName:"webgl",kernelFunc:VS},kW=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,NW=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+cl+`
  return result;
`,RW=mn({opSnippet:kW,packedOpSnippet:NW}),PW={kernelName:lu,backendName:"webgl",kernelFunc:RW};function LW(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r,l=a.shape.length,c=[],d=_0(i,a.shape);let h=d;const p=Nx(h,l);let m=a;p!=null&&(m=Fn({inputs:{x:a},backend:n,attrs:{perm:p}}),h=Rx(h.length,l),c.push(m)),hn("prod",h,l);let g;if(n.shouldExecuteOnCPU([m])){const y=n.texData.get(m.dataId).values,{outVals:b,outShape:v,outDtype:w}=BL(m.shape,m.dtype,y,h);g=n.makeTensorInfo(v,w,b)}else{const[y,b]=dn(m.shape,h),v=be(b),w=C0({inputs:{x:m},backend:n,attrs:{shape:[-1,v]}}),_=Zf(a.dtype),T=wa(w,_,"prod",n);g=C0({inputs:{x:T},backend:n,attrs:{shape:y}}),c.push(w),c.push(T)}if(o){c.push(g);const y=$x(g.shape,d);g=C0({inputs:{x:g},backend:n,attrs:{shape:y}})}return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const DW={kernelName:rf,backendName:"webgl",kernelFunc:LW};function OW(s){const{inputs:x,backend:n,attrs:r}=s,{paramsNestedSplits:a,paramsDenseValues:i,indices:o}=x,{outputRaggedRank:l}=r,c=a.map(w=>n.readSync(w.dataId)),d=a.map(w=>w.shape),h=n.readSync(i.dataId),p=n.readSync(o.dataId),[m,g,y]=zL(c,d,h,i.shape,i.dtype,p,o.shape,l),b=m.map(w=>n.makeTensorInfo([w.length],"int32",w)),v=n.makeTensorInfo(y,i.dtype,g);return b.concat([v])}const FW={kernelName:sf,backendName:"webgl",kernelFunc:OW};function UW(s){const{inputs:x,backend:n}=s,{starts:r,limits:a,deltas:i}=x,o=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId),[d,h]=WL(o,r.shape,r.dtype,l,a.shape,c,i.shape),p=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([h.length],r.dtype,h);return[p,m]}const BW={kernelName:af,backendName:"webgl",kernelFunc:UW};function zW(s){const{inputs:x,backend:n,attrs:r}=s,{shape:a,values:i,defaultValue:o,rowPartitionTensors:l}=x,{rowPartitionTypes:c}=r,d=n.readSync(a.dataId),h=n.readSync(i.dataId),p=n.readSync(o.dataId),m=l.map(v=>n.readSync(v.dataId)),g=l.map(v=>v.shape),[y,b]=GL(d,a.shape,h,i.shape,i.dtype,p,o.shape,m,g,c);return n.makeTensorInfo(y,i.dtype,b)}const WW={kernelName:of,backendName:"webgl",kernelFunc:zW},HS=s=>{const{backend:x,attrs:n}=s,{start:r,stop:a,step:i,dtype:o}=n,l=VL(r,a,i,o);return x.makeTensorInfo([l.length],o,l)},GW={kernelName:lf,backendName:"webgl",kernelFunc:HS},VW="return 1.0 / x;",HW=Yt({opSnippet:VW}),YW={kernelName:cu,backendName:"webgl",kernelFunc:HW},qW=O2+`
  return (x < 0.0) ? 0.0 : x;
`,XW=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KW=Yt({opSnippet:qW,packedOpSnippet:XW}),$W={kernelName:uu,backendName:"webgl",kernelFunc:KW},ZW=O2+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,JW=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QW=Yt({opSnippet:ZW,packedOpSnippet:JW}),jW={kernelName:du,backendName:"webgl",kernelFunc:QW};class eG{constructor(x,n,r,a,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,d]=x;this.outputShape=[o,n,r,d];const h=[a&&n>1?l-1:l,a&&r>1?c-1:c],p=[a&&n>1?n-1:n,a&&r>1?r-1:r];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+h[0]/p[0]+`,
          `+h[1]/p[1]+`);
      const vec2 inputShapeRC = vec2(`+l+".0, "+c+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+m+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class tG{constructor(x,n,r,a,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,d]=x;this.outputShape=[o,n,r,d];const h=[a&&n>1?l-1:l,a&&r>1?c-1:c],p=[a&&n>1?n-1:n,a&&r>1?r-1:r];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+h[0]/p[0]+`,
          `+h[1]/p[1]+`,
          `+h[1]/p[1]+`);
      const vec3 inputShapeRC = vec3(`+l+".0, "+c+`.0,
                                     `+c+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+m+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(d-1)+`;
        bool hasNextRow = coords.z < `+(r-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function xG(s){const{inputs:x,backend:n,attrs:r}=s,{images:a}=x,{alignCorners:i,halfPixelCenters:o,size:l}=r,[c,d]=l,h=Ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tG(a.shape,c,d,i,o):new eG(a.shape,c,d,i,o);return n.runWebGLProgram(h,[a],"float32")}const nG={kernelName:hf,backendName:"webgl",kernelFunc:xG};class rG{constructor(x,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,i]=n,[,o,l]=x,c=[r&&o>1?a-1:a,r&&l>1?i-1:i],d=[r&&o>1?o-1:o,r&&l>1?l-1:l],h=c[0]/d[0],p=c[1]/d[1],m=1/h,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(`+h+`);
        const float widthScale = float(`+p+`);

        const float invHeightScale = float(`+m+`);
        const float invWidthScale = float(`+g+`);

        const int winHeight = int(`+y+`);
        const int winWidth = int(`+b+`);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= `+o+`) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= `+l+`) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), `+(a-1)+`.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), `+(i-1)+`.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function sG(s){const{inputs:x,backend:n,attrs:r}=s,{images:a,dy:i}=x,{alignCorners:o}=r,l=new rG(i.shape,a.shape,o);return n.runWebGLProgram(l,[i],i.dtype)}const aG={kernelName:By,backendName:"webgl",kernelFunc:sG};class iG{constructor(x,n,r,a,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,d]=x;this.outputShape=[o,n,r,d];const h=[a&&n>1?l-1:l,a&&r>1?c-1:c],p=[a&&n>1?n-1:n,a&&r>1?r-1:r],m=a?"0.5":"0.0";let g;i?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+h[0]/p[0]+`,
          `+h[1]/p[1]+`);
      const vec2 inputShapeRC = vec2(`+l+".0, "+c+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+g+`;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + `+m+`)));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class oG{constructor(x,n,r,a,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,d]=x;this.outputShape=[o,n,r,d];const h=[a&&n>1?l-1:l,a&&r>1?c-1:c],p=[a&&n>1?n-1:n,a&&r>1?r-1:r],m=a?"0.5":"0.0";let g;i?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+h[0]/p[0]+`,
          `+h[1]/p[1]+`,
          `+h[1]/p[1]+`);
      const vec3 inputShapeRC = vec3(`+l+".0, "+c+`.0,
                                     `+c+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+g+`;

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + `+m+`)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(d-1)+`;
        bool hasNextRow = coords.z < `+(r-1)+`;

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function lG(s){const{inputs:x,backend:n,attrs:r}=s,{images:a}=x,{alignCorners:i,halfPixelCenters:o,size:l}=r,[c,d]=l,h=Ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new oG(a.shape,c,d,i,o):new iG(a.shape,c,d,i,o);return n.runWebGLProgram(h,[a],a.dtype)}const cG={kernelName:df,backendName:"webgl",kernelFunc:lG};class uG{constructor(x,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,i]=n,[,o,l]=x,c=[r&&o>1?a-1:a,r&&l>1?i-1:i],d=[r&&o>1?o-1:o,r&&l>1?l-1:l],h=c[0]/d[0],p=c[1]/d[1],m=1/h,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(`+h+`);
        const float widthScale = float(`+p+`);

        const float invHeightScale = float(`+m+`);
        const float invWidthScale = float(`+g+`);

        const int winHeight = int(`+y+`);
        const int winWidth = int(`+b+`);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= `+o+`) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= `+l+`) {
              continue;
            }

            float sourceFracRow =
              float(`+c[0]+`) *
                (float(dyR) / float(`+d[0]+`));

            float sourceFracCol =
                float(`+c[1]+`) *
                  (float(dyC) / float(`+d[1]+`));

            int sourceNearestRow = int(min(
                float(int(`+a+`) - 1),
                `+r+` ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(`+i+`) - 1),
                `+r+` ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function dG(s){const{inputs:x,backend:n,attrs:r}=s,{images:a,dy:i}=x,{alignCorners:o}=r,l=new uG(i.shape,a.shape,o);return n.runWebGLProgram(l,[i],i.dtype)}const hG={kernelName:Uy,backendName:"webgl",kernelFunc:dG};class pG{constructor(x,n){this.variableNames=["x"];const r=x.length;if(r>4)throw new Error("WebGL backend: Reverse of rank-"+r+" tensor is not yet supported");if(this.outputShape=x,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(`+x[0]+` - coord - 1));
        }
      `;return}const a=l=>n.indexOf(l)!==-1&&x[l]!==1?x[l]+" - coords["+l+"] - 1":"coords["+l+"]",i=x.map((l,c)=>a(c)).join(","),o=ux(r);this.userCode=`
      void main() {
        `+o+` coords = getOutputCoords();
        setOutput(getX(`+i+`));
      }
    `}}class fG{constructor(x,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=x.length;if(r>4)throw new Error("WebGL backend: Reverse of rank-"+r+" tensor is not yet supported");this.outputShape=x;const a=On("rc",r),i=a[r-1]+" + 1 < "+this.outputShape[r-1],o=a[r-2]+" + 1 < "+this.outputShape[r-2],l=ux(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(`+x[0]+` - rc - 1),
            `+x[0]+` - rc - 1);
          if(`+i+`){
              result.g = getChannel(getX(`+x[0]+` - (rc  + 1) - 1),
                `+x[0]+` - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          `+l+` rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = `+c(a.slice())+`;
          if(`+i+`){
            result.g = `+d(a.slice())+`;
          }
          if(`+o+`) {
            result.b = `+h(a.slice())+`;
            if(`+i+`) {
              result.a = `+p(a.slice())+`;
            }
          }
          setOutput(result);
        }
    `;function c(y){return m(y)}function d(y){return y[r-1]="("+y[r-1]+" + 1)",m(y)}function h(y){return y[r-2]="("+y[r-2]+" + 1)",m(y)}function p(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",m(y)}function m(y){const b=x.map((_,T)=>g(T,y)),v=b.join(","),w=b.slice(-2).join(",");return"getChannel(getX("+v+"), vec2("+w+"))"}function g(y,b){return n.indexOf(y)!==-1&&x[y]!==1?x[y]+" - "+b[y]+" - 1":""+b[y]}}}function mG(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{dims:i}=r,o=a.shape.length,l=_0(i,a.shape);if(o===0)return a2({inputs:{x:a},backend:n});const c=Ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fG(a.shape,l):new pG(a.shape,l);return n.runWebGLProgram(c,[a],a.dtype)}const gG={kernelName:pf,backendName:"webgl",kernelFunc:mG};class yG{constructor(x,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=x[1],a=x[2];this.outputShape=x;let i="";typeof n=="number"?i="float outputValue = "+n.toFixed(2)+";":i=`
        vec3 fill = vec3(`+n.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+i+`
          if(coordX >= 0 && coordX < `+a+" && coordY >= 0 && coordY < "+r+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const bG={kernelName:Bf,backendName:"webgl",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{image:r}=s,{radians:a,fillValue:i,center:o}=x,l=n,c=new yG(r.shape,i),[d,h]=Um(o,r.shape[1],r.shape[2]),p=[[d,h,Math.sin(a),Math.cos(a)]];return l.runWebGLProgram(c,[r],r.dtype,p)}},vG=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,wG=Yt({opSnippet:vG}),_G={kernelName:hu,backendName:"webgl",kernelFunc:wG},SG="return inversesqrt(x);",TG=Yt({opSnippet:SG,cpuKernelImpl:HL}),AG={kernelName:pu,backendName:"webgl",kernelFunc:TG};class YS{constructor(x,n,r,a,i,o,l=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=ux(i.length),d=ux(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const p="getIndices("+h+")";let m="";a===1?m="i":a===2&&(m="i, coords[1]");const g="getUpdates("+m+")",y=n>1?"strides[j]":"strides";this.userCode=`
        `+c+" strides = "+c+"("+i+`);

        void main() {
          `+d+` coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < `+x+`; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < `+n+`; j++) {
              int index = round(`+p+`);
              flattenedIndex += index * `+y+`;
            }
            if (flattenedIndex == coords[0]) {
              sum += `+g+`;
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}function EG(s){const{inputs:x,backend:n,attrs:r}=s,{indices:a,updates:i}=x,{shape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=el(i,a,o),m=[p/d,d];if(p===0)return n.makeTensorInfo(o,a.dtype);const g=C0({inputs:{x:a},backend:n,attrs:{shape:[c,l]}}),y=C0({inputs:{x:i},backend:n,attrs:{shape:[c,d]}}),b=n.makeTensorInfo([],"float32",new Float32Array([0])),v=new YS(c,l,g.shape.length,y.shape.length,h,m),w=n.runWebGLProgram(v,[y,g,b],y.dtype),_=C0({inputs:{x:w},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(b),_}const CG={kernelName:ff,backendName:"webgl",kernelFunc:EG};class MG{constructor(x,n,r,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[x,r];const i="while (left < right) {",o="for (int i = 0; i < "+Math.ceil(Math.log2(n+1))+"; ++i) { if (left >= right) break;",l=Ce().getNumber("WEBGL_VERSION")===2?i:o,c=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         `+l+`
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) `+c+` value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function IG(s){const{inputs:x,backend:n,attrs:r}=s,{sortedSequence:a,values:i}=x,{side:o}=r,l=new MG(a.shape[0],a.shape[1],i.shape[1],o),c=[[a.shape[1]]];return n.runWebGLProgram(l,[a,i],"int32",c)}const kG={kernelName:mf,backendName:"webgl",kernelFunc:IG};class NG{constructor(x,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let a,i;if(r>4)throw Error("Where for rank "+r+" is not yet supported");if(r===1)i="resRC",a="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],d=[];for(let h=0;h<n.length;h++)d.push(""+l[h]),h<x&&c.push(""+l[h]);a=c.join(),i=d.join()}const o=ux(r);this.userCode=`
      void main() {
        `+o+` resRC = getOutputCoords();
        float cVal = getC(`+a+`);
        if (cVal >= 1.0) {
          setOutput(getA(`+i+`));
        } else {
          setOutput(getB(`+i+`));
        }
      }
    `}}function RG(s){const{inputs:x,backend:n}=s,{condition:r,t:a,e:i}=x,o=new NG(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,i],n2(a.dtype,i.dtype))}const PG={kernelName:gf,backendName:"webgl",kernelFunc:RG},LG=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = `+Wm+`;
  float scale = `+Gm+`;
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,DG=Yt({opSnippet:LG}),OG={kernelName:fu,backendName:"webgl",kernelFunc:DG},FG=Pi+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,UG=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,BG=Yt({opSnippet:FG,packedOpSnippet:UG,cpuKernelImpl:qL}),zG={kernelName:bu,backendName:"webgl",kernelFunc:BG},WG=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,GG=Yt({opSnippet:WG}),VG={kernelName:yu,backendName:"webgl",kernelFunc:GG},HG=Pi+`
  return sin(x);
`,YG=Yt({opSnippet:HG}),qG={kernelName:mu,backendName:"webgl",kernelFunc:YG},XG=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,KG=Yt({opSnippet:XG}),$G={kernelName:gu,backendName:"webgl",kernelFunc:KG},ZG=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,JG=Yt({opSnippet:ZG}),QG={kernelName:vu,backendName:"webgl",kernelFunc:JG},jG=s=>{const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockShape:i,paddings:o}=r;G(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((w,_)=>w*_),c=[[0,0]];c.push(...o);for(let w=1+i.length;w<a.shape.length;++w)c.push([0,0]);const d=[],h=VS({inputs:{x:a},backend:n,attrs:{paddings:c,constantValue:0}}),p=tl(h.shape,i,l,!1),m=xl(p.length,i.length,!1),g=nl(h.shape,i,l,!1),y=C0({inputs:{x:h},backend:n,attrs:{shape:p}}),b=Fn({inputs:{x:y},backend:n,attrs:{perm:m}}),v=C0({inputs:{x:b},backend:n,attrs:{shape:g}});return d.push(h),d.push(y),d.push(b),d.forEach(w=>n.disposeIntermediateTensorInfo(w)),v},eV={kernelName:vf,backendName:"webgl",kernelFunc:jG};function tV(s){const{inputs:x,backend:n}=s,{indices:r,values:a,denseShape:i,defaultValue:o}=x;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         `+i.shape);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         `+r.shape);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         `+a.shape);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        `+o.shape);const l=n.readSync(r.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=n.readSync(o.dataId)[0],[p,m,g,y,b]=KL(l,r.shape,r.dtype,c,a.dtype,d,h);return[n.makeTensorInfo(m,r.dtype,p),n.makeTensorInfo([m[0]],a.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(v=>Number(v)))),n.makeTensorInfo([b.length],r.dtype,new Int32Array(b))]}const xV={kernelName:Sf,backendName:"webgl",kernelFunc:tV};function nV(s){const{inputs:x,backend:n}=s,{inputIndices:r,inputShape:a,newShape:i}=x;if(r.shape.length!==2)throw new Error("Input indices should be a matrix but received shape "+r.shape);if(a.shape.length!==1)throw new Error("Input shape should be a vector but received shape "+a.shape);if(i.shape.length!==1)throw new Error("Target shape should be a vector but received shape "+i.shape);const o=Array.from(n.readSync(a.dataId)),l=n.readSync(r.dataId),c=Array.from(n.readSync(i.dataId)),[d,h,p]=$L(l,r.shape,r.dtype,o,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const rV={kernelName:Tf,backendName:"webgl",kernelFunc:nV};function sV(s){const{inputs:x,backend:n}=s,{data:r,indices:a,segmentIds:i}=x;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              `+a.shape);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              `+i.shape);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId),[d,h]=$_(o,r.shape,r.dtype,l,c,!0);return n.makeTensorInfo(h,r.dtype,d)}const aV={kernelName:Af,backendName:"webgl",kernelFunc:sV};function iV(s){const{inputs:x,backend:n}=s,{data:r,indices:a,segmentIds:i}=x;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             `+a.shape);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             `+i.shape);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId),[d,h]=$_(o,r.shape,r.dtype,l,c);return n.makeTensorInfo(h,r.dtype,d)}const oV={kernelName:Ef,backendName:"webgl",kernelFunc:iV};function lV(s){const{inputs:x,backend:n,attrs:r}=s,{sparseIndices:a,sparseValues:i,defaultValue:o}=x,{outputShape:l}=r,{sliceRank:c,numUpdates:d,sliceSize:h,strides:p,outputSize:m}=el(i,a,l),g=!1;if(i.dtype==="string"){const w=n.bufferSync(a),_=n.bufferSync(i),T=os(n.readSync(o.dataId)[0]),A=YL(w,_,l,m,h,d,c,p,T,g);return n.makeTensorInfo(l,A.dtype,A.values)}const y=new YS(d,c,a.shape.length,i.shape.length,p,[m,1],g),b=n.runWebGLProgram(y,[i,a,o],i.dtype),v=C0({inputs:{x:b},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(b),v}const cV={kernelName:Cf,backendName:"webgl",kernelFunc:lV};function uV(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{numOrSizeSplits:i,axis:o}=r,l=_0(o,a.shape)[0],c=xg(a,i,l),d=a.shape.length,h=new Array(d).fill(0),p=a.shape.slice();return c.map(m=>{const g=[...p];g[l]=m;const y=Li({inputs:{x:a},backend:n,attrs:{begin:h,size:g}});return h[l]+=m,y})}const dV={kernelName:wf,backendName:"webgl",kernelFunc:uV},qS="return sqrt(x);",hV=Yt({opSnippet:qS,packedOpSnippet:qS,cpuKernelImpl:ZL}),pV={kernelName:wu,backendName:"webgl",kernelFunc:hV},fV="return x * x;",mV=Yt({opSnippet:fV}),gV={kernelName:zy,backendName:"webgl",kernelFunc:mV},XS="return (a - b) * (a - b);",yV=mn({opSnippet:XS,packedOpSnippet:XS}),bV={kernelName:_u,backendName:"webgl",kernelFunc:yV};function vV({inputs:s,attrs:x,backend:n}){const{x:r}=s,a=O2+(`
    return x > 0.0 ? 1.0 : float(`+x.alpha+`);
  `),i=new fr(r.shape,a);return n.runWebGLProgram(i,[r],r.dtype)}const wV={kernelName:Cu,backendName:"webgl",kernelFunc:vV};class _V{constructor(x,n,r){this.variableNames=["x"],this.outputShape=r;const a=r.length,i=ux(r.length),o=ux(r.length);let l="";if(a===1)l="coords * strides + begin";else{let c=0;l=r.map((d,h)=>(c++,r.length===1?"coords * strides["+h+"] + begin["+h+"]":"coords["+(c-1)+"] * strides["+h+"] + begin["+h+"]")).join(",")}this.userCode=`
      `+i+" begin = "+i+"("+x+`);
      `+i+" strides = "+i+"("+n+`);

      void main() {
        `+o+` coords = getOutputCoords();
        setOutput(getX(`+l+`));
      }
    `}}function SV(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{begin:i,end:o,strides:l,beginMask:c,endMask:d,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:m}=r,{finalShapeSparse:g,finalShape:y,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:_,end:T,strides:A}=Dm(a.shape,i,o,l,c,d,h,p,m);let E;if(b)E=C0({inputs:{x:a},backend:n,attrs:{shape:y}});else if(v||w){G(a.shape.length>=1,()=>"Input must have rank at least 1, got: "+a.shape.length);const I=Nm(_,T,A),C=Li({inputs:{x:a},backend:n,attrs:{begin:_,size:I}});E=C0({inputs:{x:C},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(C)}else if(n.shouldExecuteOnCPU([a])){const I=n.readSync(a.dataId),C=At(a.shape,a.dtype,I),k=JL(g,C,A,_);E=n.makeTensorInfo(y,a.dtype,k.values)}else{const I=new _V(_,A,g);E=n.runWebGLProgram(I,[a],a.dtype)}const M=C0({inputs:{x:E},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(E),M}const TV={kernelName:Mf,backendName:"webgl",kernelFunc:SV};function AV(s){const{inputs:x,backend:n,attrs:r}=s,{separator:a,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:d}=r,{data:h,dataSplits:p}=x,m=n.readSync(h.dataId),g=n.readSync(p.dataId),[y,b]=QL(m,g,a,i,o,l,c,d);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",b)]}const EV={kernelName:If,backendName:"webgl",kernelFunc:AV};function CV(s){const{inputs:x,backend:n,attrs:r}=s,{skipEmpty:a}=r,{input:i,delimiter:o}=x;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error("Input must be a vector, got shape: "+i.shape);if(o.shape.length!==0)throw new Error("Delimiter must be a scalar, got shape: "+o.shape);const l=n.readSync(i.dataId),c=n.readSync(o.dataId)[0],[d,h,p]=jL(l,c,a),m=h.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(p))]}const MV={kernelName:kf,backendName:"webgl",kernelFunc:CV};function IV(s){const{inputs:x,backend:n,attrs:r}=s,{numBuckets:a}=r,{input:i}=x;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(i.dataId),l=eD(o,a);return n.makeTensorInfo(i.shape,"int32",l)}const kV={kernelName:Nf,backendName:"webgl",kernelFunc:IV},NV="return tan(x);",RV=Yt({opSnippet:NV}),PV={kernelName:Tu,backendName:"webgl",kernelFunc:RV},LV=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,DV=Yt({opSnippet:LV}),OV={kernelName:Au,backendName:"webgl",kernelFunc:DV};class FV{constructor(x,n){this.variableNames=["A"];const r=new Array(x.length);for(let o=0;o<r.length;o++)r[o]=x[o]*n[o];this.outputShape=r,this.rank=r.length;const a=ux(this.rank),i=UV(x);this.userCode=`
      void main() {
        `+a+` resRC = getOutputCoords();
        setOutput(getA(`+i+`));
      }
    `}}function UV(s){const x=s.length;if(x>5)throw Error("Tile for rank "+x+" is not yet supported");if(x===1)return"imod(resRC, "+s[0]+")";const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<s.length;a++)r.push("imod("+n[a]+", "+s[a]+")");return r.join()}function KS(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{reps:i}=r;if(a.dtype==="string"||a.shape.length>5){const l=n.readSync(a.dataId),c=a.dtype==="string"?l.map(p=>os(p)):l,d=At(a.shape,a.dtype,c),h=xD(d,i);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new FV(a.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const BV={kernelName:Eu,backendName:"webgl",kernelFunc:KS};class zV{constructor(x){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=x,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class WV{constructor(x){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=x,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function _a(s,x){x!==null&&s.disposeIntermediateTensorInfo(x)}function $S(s){let x=1;for(;x<s;)x*=2;return x}function GV(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{k:i,sorted:o}=r,l=Ce().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=Ce().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=a.shape,h=d[d.length-1];if(n.shouldExecuteOnCPU([a])||h<l||i>c){const k=n.readSync(a.dataId),[O,z]=nD(k,d,a.dtype,i,o);return[n.makeTensorInfo(O.shape,O.dtype,O.values),n.makeTensorInfo(z.shape,z.dtype,z.values)]}if(i===0)return d[d.length-1]=0,[n.makeTensorInfo(d,a.dtype,[]),n.makeTensorInfo(d,"int32",[])];if(h===1)return[a,gl({attrs:{shape:d,dtype:"int32",value:0},backend:n})];const p=n.texData.get(a.dataId),m=p!==null&&p.isPacked,g=m?n.unpackTensor(a):a,y=be(d)/h,b=C0({inputs:{x:g},attrs:{shape:[y,h]},backend:n});m&&_a(n,g);const v=$S(i),w=$S(h);let _=null;const T=()=>_===null?[b,b]:[b,_],A=(k,O,z)=>{const ee=T(),re=new zV(z),Y=[[h],[_===null?1:0],[Number.NEGATIVE_INFINITY],[k],[O]],Q=_;_=n.runWebGLProgram(re,ee,"int32",Y),_a(n,Q)};for(let k=1;k<v;k*=2){const O=k*2;for(let z=k;z>=1;z/=2)A(O,z,[y,w])}for(let k=w;k>v;k/=2){const O=T(),z=new WV([y,k/2]),ee=[[h],[_===null?1:0],[v]],re=_;_=n.runWebGLProgram(z,O,"int32",ee),_a(n,re);const Y=v/2,Q=Y*2;for(let te=Y;te>=1;te/=2)A(Q,te,_.shape)}let E=_;_=Li({inputs:{x:_},backend:n,attrs:{begin:0,size:[y,i]}}),_a(n,E);let M=OS({inputs:{x:b,indices:_},backend:n,attrs:{axis:1,batchDims:1}});_a(n,b);const I=d.slice(0,-1);I.push(i),E=_,_=C0({inputs:{x:_},attrs:{shape:I},backend:n}),_a(n,E);const C=M;return M=C0({inputs:{x:M},attrs:{shape:I},backend:n}),_a(n,C),[M,_]}const VV={kernelName:Rf,backendName:"webgl",kernelFunc:GV};class HV{constructor(x,n,r,a,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=r==="nearest"?1:2;let c;switch(a){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+c+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+c+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+c+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+x+" && 0 <= coordX && coordX < "+n+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+i+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+i+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+n+`));
                float mapY = mapCoord(inY, float(`+x+`));

                if (`+l+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function YV(s){const{inputs:x,backend:n,attrs:r}=s,{image:a,transforms:i}=x,{interpolation:o,fillMode:l,fillValue:c,outputShape:d}=r,[h,p,m,g]=a.shape,[y,b]=d??[p,m],v=[h,y,b,g],w=new HV(p,m,o,l,c,v);return n.runWebGLProgram(w,[a,i],"float32")}const qV={kernelName:Pf,backendName:"webgl",kernelFunc:YV};function XV(s){const{inputs:x,attrs:n,backend:r}=s,{axis:a}=n,{x:i}=x;il(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:l,outputShape:c,indices:d}=rD(o,a,i.shape,i.dtype);return[r.makeTensorInfo(c,i.dtype,l),r.makeTensorInfo([d.length],"int32",d)]}const KV={kernelName:Lf,backendName:"webgl",kernelFunc:XV};function $V(s){const{inputs:x,backend:n,attrs:r}=s,{value:a}=x;let{axis:i}=r;i<0&&(i+=a.shape.length);const o=a,l=o.shape.length,c=a.shape[i],d=new Array(l-1);let h=0;for(let b=0;b<l;b++)b!==i&&(d[h++]=o.shape[b]);const p=[],m=new Array(l).fill(0),g=o.shape.slice();g[i]=1;const y=new Array(c);for(let b=0;b<y.length;b++){m[i]=b;const v=Li({inputs:{x:o},backend:n,attrs:{begin:m,size:g}}),w=C0({inputs:{x:v},backend:n,attrs:{shape:d}});y[b]=w,p.push(v)}return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const ZV={kernelName:Df,backendName:"webgl",kernelFunc:$V};class JV{constructor(x,n){this.variableNames=["x","segmentIds"];const r=x.windowSize,a=x.batchSize,i=x.inSize,o=x.numSegments,l=o*Math.ceil(i/r);this.outputShape=[a,l];const c="0.0",d="sumValue",h=Math.floor(r/4)*4,p=r%4,m=`
        sumValue += dot(values, segFilter);
    `;let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= `+i+`) {
          return initializationValue;
        }
      `);let y="";i%r>0&&(y=`
        if (inIdx < 0 || inIdx >= `+i+`) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = `+c+`;

      float getValue(int batch, int inIdx) {
        `+g+`
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        `+y+`
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          `+o+")) * float("+r+`));
        int currentSeg = int(mod(float(outIdx), float(`+o+`)));

        float sumValue = 0.0;

        for (int i = 0; i < `+h+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          `+m+`
        }

        int inIdx = inOffset + `+h+`;
        if (`+(p===1)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          `+m+`
        } else if (`+(p===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          `+m+`
        } else if (`+(p===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          `+m+`
        }
        setOutput(`+d+`);
      }
    `}}function QV(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,segmentIds:i}=x,{numSegments:o}=r,l=a.shape.length,c=[];let d=0;const h=Nx([d],l);let p=a;h!=null&&(p=Fn({inputs:{x:a},backend:n,attrs:{perm:h}}),c.push(p),d=Rx(1,l)[0]);const m=mw(p.shape,d,o),g=be([p.shape[d]]),y=C0({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}});c.push(y);const b=Zf(a.dtype),v=(A,E,M,I,C)=>{const k=A.shape[0],O=A.shape[1],z=fw(O,C),ee={windowSize:z,inSize:O,batchSize:k,numSegments:C},re=new JV(ee,E),Y=n.compileAndRun(re,[A,M],I);if(c.push(Y),Y.shape[1]===C)return Y;const Q=HS({backend:n,attrs:{start:0,stop:C,step:1,dtype:"float32"}}),te=KS({inputs:{x:Q},backend:n,attrs:{reps:[O/z]}});return c.push(Q),c.push(te),v(Y,E,te,I,C)},w=v(y,"unsortedSegmentSum",i,b,o),_=C0({inputs:{x:w},backend:n,attrs:{shape:m}});let T=_;if(h!=null){c.push(_);const A=Xo(h);T=Fn({inputs:{x:T},backend:n,attrs:{perm:A}})}return c.forEach(A=>n.disposeIntermediateTensorInfo(A)),T}const jV={kernelName:Of,backendName:"webgl",kernelFunc:QV},eH=[$D,JD,eO,nO,sO,oO,cO,dO,mO,yO,wO,TO,CO,NO,LO,OO,UO,GO,HO,qO,ZO,nF,sF,iF,hF,fF,bF,RD,_F,CF,NF,FF,BF,WF,VF,YF,KF,JF,eU,xU,rU,aU,lU,uU,fU,gU,vU,SU,AU,IU,PU,FU,zU,VU,HU,qU,KU,ZU,QU,eB,rB,iB,cB,dB,fB,yB,_B,EB,ND,MB,AF,NB,LB,FB,LD,WB,YB,XB,JB,ez,rz,iz,uz,fz,yz,vz,Tz,Ez,Mz,Rz,Lz,Oz,Uz,zz,Hz,Kz,Qz,aW,FD,cW,hW,mW,bW,lF,_W,TW,EW,IW,PW,OD,DW,FW,BW,WW,GW,cF,xW,YW,$W,jW,BD,nG,aG,cG,hG,gG,bG,_G,AG,CG,kG,PG,OG,zG,VG,qG,$G,tF,rW,QG,eV,xV,rV,aV,oV,cV,dV,pV,gV,bV,wV,TV,EV,MV,kV,nW,qD,PV,OV,BV,VV,qV,XD,KV,ZV,jV,SW];for(const s of eH)Vy(s);const tH=gm;class Cd extends W0{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new t0(this,cr())}nextDataId(){return Cd.nextDataId++}write(x,n,r){this.firstUse&&(this.firstUse=!1,Ce().get("IS_NODE")&&E2(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const a={id:this.nextDataId()};return this.data.set(a,{values:x,dtype:r,refCount:1}),a}makeTensorInfo(x,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&tx(r[0])){const i=r.map(o=>is(o));a=this.write(i,x,n)}else a=this.write(r,x,n);return{dataId:a,shape:x,dtype:n}}refCount(x){return this.data.has(x)?this.data.get(x).refCount:0}incRef(x){const n=this.data.get(x);n.refCount++}decRef(x){if(this.data.has(x)){const n=this.data.get(x);n.refCount--}}move(x,n,r,a,i){this.data.set(x,{values:n,dtype:a,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(x){return this.readSync(x)}readSync(x){const{dtype:n,complexTensorInfos:r}=this.data.get(x);if(n==="complex64"){const a=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return Fr(a,i)}return A2(this.data.get(x).values,n)}bufferSync(x){const n=this.readSync(x.dataId);if(x.dtype==="string")try{const r=n.map(a=>os(a));return At(x.shape,x.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return At(x.shape,x.dtype,n)}makeOutput(x,n,r){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,x),this)}disposeData(x,n=!1){if(this.data.has(x)){if(this.data.get(x).refCount--,!n&&this.data.get(x).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(x);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(x)}return!0}disposeIntermediateTensorInfo(x){this.disposeData(x.dataId)}async time(x){const n=c2();return x(),{kernelMs:c2()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(x){G0([x],"where");const n=this.readSync(x.dataId);return tH(x.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Cd.nextDataId=0,kb("cpu",()=>new Cd,1);const ZS=nx(Uc,s=>s>=0?s:Math.exp(s)-1),xH={kernelName:Uc,backendName:"cpu",kernelFunc:ZS};function JS(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{alpha:i}=r;G0([a],"leakyRelu");const o=be(a.shape),l=n.data.get(a.dataId).values,c=Ke("float32",o);for(let d=0;d<l.length;d++)c[d]=l[d]<0?i*l[d]:l[d];return n.makeTensorInfo(a.shape,"float32",c)}const nH={kernelName:Up,backendName:"cpu",kernelFunc:JS},rH=Wx((s,x)=>s<0?x*s:s);function QS(s){const{inputs:x,backend:n}=s,{x:r,alpha:a}=x;G0([r,a],"prelu");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[l,c]=rH(r.shape,a.shape,i,o,"float32");return n.makeTensorInfo(c,"float32",l)}const sH={kernelName:nf,backendName:"cpu",kernelFunc:QS},jS=nx(uu,s=>Math.max(0,s)),aH={kernelName:uu,backendName:"cpu",kernelFunc:jS},eT=nx(du,s=>Math.min(Math.max(0,s),6)),iH={kernelName:du,backendName:"cpu",kernelFunc:eT};function Md(s,x,n,r,a){if(n==="linear")return pr({inputs:{x},backend:s});if(n==="relu")return jS({inputs:{x},backend:s});if(n==="elu")return ZS({inputs:{x},backend:s});if(n==="relu6")return eT({inputs:{x},backend:s});if(n==="prelu")return QS({inputs:{x,alpha:r},backend:s});if(n==="leakyrelu")return JS({inputs:{x},backend:s,attrs:{alpha:a}});if(n==="sigmoid")return P_({inputs:{x},backend:s});throw new Error("Activation "+n+" has not been implemented for the CPU backend.")}function dx(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{shape:i}=r,o=be(a.shape),l=It(i,o),c=be(l);G(o===c,()=>"The new shape ("+l+") has "+c+" elements and the old shape ("+a.shape+") has "+o+" elements. The new shape and old shape must have the same number of elements."),n.incRef(a.dataId);const d=n.data.get(a.dataId);if(d.complexTensorInfos!=null){const h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag;h.shape=l,p.shape=l}return{dataId:a.dataId,shape:l,dtype:a.dtype}}const oH={kernelName:uf,backendName:"cpu",kernelFunc:dx};function tT(s){const{inputs:x,backend:n,attrs:r}=s,{a,b:i}=x,{transposeA:o,transposeB:l}=r;G0([a,i],"matMul");const c=a.shape.length,d=i.shape.length,h=o?a.shape[c-2]:a.shape[c-1],p=l?i.shape[d-1]:i.shape[d-2],m=o?a.shape[c-1]:a.shape[c-2],g=l?i.shape[d-2]:i.shape[d-1],y=a.shape.slice(0,-2),b=i.shape.slice(0,-2),v=be(y),w=be(b),_=Ot(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,g]);G(h===p,()=>"Error in matMul: inner shapes ("+h+") and ("+p+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+o+" and transposeB="+l+" must match.");const T=o?[v,h,m]:[v,m,h],A=l?[w,g,p]:[w,p,g],E=dx({inputs:{x:a},backend:n,attrs:{shape:T}}),M=dx({inputs:{x:i},backend:n,attrs:{shape:A}}),I=o?E.shape[1]:E.shape[2],C=o?E.shape[2]:E.shape[1],k=l?M.shape[1]:M.shape[2],O=Math.max(v,w),z=n.data.get(E.dataId).values,ee=n.data.get(M.dataId).values,re=U0(E.shape),Y=U0(M.shape),[Q,te,se]=o?[re[0],1,re[1]]:[re[0],re[1],1],[xe,ae,le]=l?[1,Y[1],Y[0]]:[Y[1],1,Y[0]],de=C*k,ue=At([O,C,k],E.dtype),ge=ue.values,pe=n.blockSize;for(let Le=0;Le<O;Le++){const we=Le%v,e0=Le%w;for(let Ze=0;Ze<C;Ze+=pe){const i0=Math.min(Ze+pe,C);for(let We=0;We<k;We+=pe){const v0=Math.min(We+pe,k);for(let Te=0;Te<I;Te+=pe){const Ie=Math.min(Te+pe,I);for(let Xe=Ze;Xe<i0;Xe++)for(let c0=We;c0<v0;c0++){let Ye=0;for(let I0=Te;I0<Ie;I0++){const m0=z[we*Q+Xe*te+I0*se],d0=ee[I0*xe+c0*ae+e0*le];Ye+=m0*d0}ge[Le*de+(Xe*k+c0)]+=Ye}}}}}return n.disposeIntermediateTensorInfo(E),n.disposeIntermediateTensorInfo(M),n.makeTensorInfo(_,ue.dtype,ue.values)}const lH={kernelName:ap,backendName:"cpu",kernelFunc:tT};function cH(s){const{inputs:x,backend:n,attrs:r}=s,{a,b:i,bias:o,preluActivationWeights:l}=x,{transposeA:c,transposeB:d,activation:h,leakyreluAlpha:p}=r;let m,g,y;const b=[];m=tT({inputs:{a,b:i},attrs:{transposeA:c,transposeB:d},backend:n}),o&&(g=Ii({inputs:{a:m,b:o},backend:n}),b.push(m),m=g),h&&(y=Md(n,m,h,l,p),b.push(m),m=y);for(const v of b)n.disposeIntermediateTensorInfo(v);return m}const uH={kernelName:Mu,backendName:"cpu",kernelFunc:cH},dH=nx(Lo,s=>Math.acos(s)),hH={kernelName:Lo,backendName:"cpu",kernelFunc:dH},pH=nx(Ec,s=>Math.acosh(s)),fH={kernelName:Ec,backendName:"cpu",kernelFunc:pH};function mH(s){const{inputs:x,backend:n}=s,r=x;G0(x,"addN");const a=r.map(l=>n.data.get(l.dataId).values),i=At(r[0].shape,r[0].dtype),o=i.values;for(let l=0;l<r.length;l++){const c=a[l];for(let d=0;d<o.length;d++)o[d]+=c[d]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}const gH={kernelName:jh,backendName:"cpu",kernelFunc:mH};function yH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;G0(a,"all");const l=_0(i,a.shape);let c=l;const d=Nx(c,a.shape.length);let h=a;d!=null&&(h=$n({inputs:{x:a},backend:n,attrs:{perm:d}}),c=Rx(c.length,a.shape.length)),hn("all",c,h.shape.length);const[p,m]=dn(h.shape,c),g=be(m),y=Ae(be(p),h.dtype),b=n.data.get(h.dataId).values;for(let w=0;w<y.length;++w){const _=w*g;let T=b[_];for(let A=0;A<g;++A){const E=b[_+A];T=T&&E}y[w]=T}d!=null&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,y);if(o){const w=$x(p,l),_=dx({inputs:{x:v},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(v),_}return v}const bH={kernelName:ep,backendName:"cpu",kernelFunc:yH};function vH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;G0(a,"any");const l=_0(i,a.shape);let c=l;const d=Nx(c,a.shape.length);let h=a;d!=null&&(h=$n({inputs:{x:a},backend:n,attrs:{perm:d}}),c=Rx(c.length,a.shape.length)),hn("any",c,h.shape.length);const[p,m]=dn(h.shape,c),g=be(m),y=Ae(be(p),h.dtype),b=n.data.get(h.dataId).values;for(let w=0;w<y.length;++w){const _=w*g;let T=b[_];for(let A=0;A<g;++A){const E=b[_+A];T=T||E}y[w]=T}d!=null&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,y);if(o){const w=$x(p,l),_=dx({inputs:{x:v},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(v),_}return v}const wH={kernelName:tp,backendName:"cpu",kernelFunc:vH};function _H(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i}=r;G0(a,"argMax");let o=_0(i,a.shape);const l=Nx(o,a.shape.length);let c=a;const d=[];l!=null&&(c=$n({inputs:{x:a},backend:n,attrs:{perm:l}}),d.push(c),o=Rx(o.length,c.shape.length)),o=[o[0]],hn("argMax",o,c.shape.length);const[h,p]=dn(c.shape,o),m=be(h),g=Ae(m,"int32"),y=be(p),b=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){const w=v*y;let _=b[w],T=0;for(let A=0;A<y;++A){const E=b[w+A];E>_&&(_=E,T=A)}g[v]=T}return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(h,"int32",g)}const SH={kernelName:xp,backendName:"cpu",kernelFunc:_H};function TH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i}=r;G0(a,"argMin");let o=_0(i,a.shape);const l=Nx(o,a.shape.length);let c=a;const d=[];l!=null&&(c=$n({inputs:{x:a},backend:n,attrs:{perm:l}}),d.push(c),o=Rx(o.length,c.shape.length)),o=[o[0]],hn("argMin",o,c.shape.length);const[h,p]=dn(c.shape,o),m=be(h),g=Ae(m,"int32"),y=be(p),b=n.data.get(c.dataId).values;for(let v=0;v<g.length;++v){const w=v*y;let _=b[w],T=0;for(let A=0;A<y;++A){const E=b[w+A];E<_&&(_=E,T=A)}g[v]=T}return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.makeTensorInfo(h,"int32",g)}const AH={kernelName:np,backendName:"cpu",kernelFunc:TH},EH=nx(Cc,s=>Math.asin(s)),CH={kernelName:Cc,backendName:"cpu",kernelFunc:EH},MH=nx(Mc,s=>Math.asinh(s)),IH={kernelName:Mc,backendName:"cpu",kernelFunc:MH},kH=nx(Ic,s=>Math.atan(s)),NH={kernelName:Ic,backendName:"cpu",kernelFunc:kH},RH=Wx((s,x)=>Math.atan2(s,x)),PH=an(Nc,RH),LH={kernelName:Nc,backendName:"cpu",kernelFunc:PH},DH=nx(kc,s=>Math.atanh(s)),OH={kernelName:kc,backendName:"cpu",kernelFunc:DH};function Vg(s,x,n,r,a,i){const o=a.strideHeight,l=a.strideWidth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,m=a.padInfo.top,g=a.padInfo.left,y=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=At(a.outShape,n),v=b.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3],_=a.outShape[2]*a.outShape[3],T=a.outShape[3];for(let A=0;A<a.batchSize;++A){const E=A*w,M=A*r[0];for(let I=0;I<a.inChannels;++I)for(let C=0;C<a.outHeight;++C){const k=C*o-m,O=Math.max(0,k),z=Math.min(a.inHeight,h+k),ee=E+C*_;for(let re=0;re<a.outWidth;++re){const Y=re*l-g,Q=Math.max(0,Y),te=Math.min(a.inWidth,p+Y);let se=y,xe=0,ae=0;for(let de=O;de<z;de+=c){const ue=M+de*r[1];for(let ge=Q;ge<te;ge+=d){const pe=ue+ge*r[2],Le=s[pe+I];i==="max"&&Le>se?se=Le:i==="avg"&&(xe+=Le,ae++)}if(isNaN(se))break}const le=ee+re*T+I;v[le]=i==="avg"?xe/ae:se}}}return b}function xT(s,x,n,r,a=!1,i=!1){const o=At(r.outShape,"int32"),l=r.strideHeight,c=r.strideWidth,d=r.dilationHeight,h=r.dilationWidth,p=r.effectiveFilterHeight,m=r.effectiveFilterWidth,g=r.padInfo.top,y=r.padInfo.left,b=At(x,n,s);for(let v=0;v<r.batchSize;++v)for(let w=0;w<r.inChannels;++w)for(let _=0;_<r.outHeight;++_){const T=_*l-g;let A=T;for(;A<0;)A+=d;const E=Math.min(r.inHeight,p+T);for(let M=0;M<r.outWidth;++M){const I=M*c-y;let C=I;for(;C<0;)C+=h;const k=Math.min(r.inWidth,m+I);let O=Number.NEGATIVE_INFINITY,z=-1;for(let ee=A;ee<E;ee+=d){const re=ee-T;for(let Y=C;Y<k;Y+=h){const Q=Y-I,te=b.get(v,ee,Y,w);te>O&&(O=te,a?z=i?((v*r.inHeight+ee)*r.inWidth+Y)*r.inChannels+w:(ee*r.inWidth+Y)*r.inChannels+w:z=re*m+Q)}}o.set(z,v,_,M,w)}}return o}function nT(s,x,n,r,a,i){const o=a.strideDepth,l=a.strideHeight,c=a.strideWidth,d=a.dilationDepth,h=a.dilationHeight,p=a.dilationWidth,m=a.effectiveFilterDepth,g=a.effectiveFilterHeight,y=a.effectiveFilterWidth,b=a.padInfo.front,v=a.padInfo.top,w=a.padInfo.left,_=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=At(a.outShape,n),A=T.values,E=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],M=a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[3]*a.outShape[4],C=a.outShape[4];for(let k=0;k<a.batchSize;++k){const O=k*E,z=k*r[0];for(let ee=0;ee<a.inChannels;++ee)for(let re=0;re<a.outDepth;++re){const Y=re*o-b;let Q=Y;for(;Q<0;)Q+=d;const te=Math.min(a.inDepth,m+Y),se=O+re*M;for(let xe=0;xe<a.outHeight;++xe){const ae=xe*l-v;let le=ae;for(;le<0;)le+=h;const de=Math.min(a.inHeight,g+ae),ue=se+xe*I;for(let ge=0;ge<a.outWidth;++ge){const pe=ge*c-w;let Le=pe;for(;Le<0;)Le+=p;const we=Math.min(a.inWidth,y+pe),e0=ue+ge*C;let Ze=_,i0=0,We=0;for(let Te=Q;Te<te;Te+=d){const Ie=z+Te*r[1];for(let Xe=le;Xe<de;Xe+=h){const c0=Ie+Xe*r[2];for(let Ye=Le;Ye<we;Ye+=p){const I0=c0+Ye*r[3],m0=s[I0+ee];if(i==="max"&&m0>Ze?Ze=m0:i==="avg"&&(i0+=m0,We++),isNaN(Ze))break}if(isNaN(Ze))break}if(isNaN(Ze))break}const v0=e0+ee;A[v0]=i==="avg"?i0/Math.max(We,1):Ze}}}}return T}function FH(s,x){const n=At(x.outShape,"int32"),r=x.strideDepth,a=x.strideHeight,i=x.strideWidth,o=x.dilationDepth,l=x.dilationHeight,c=x.dilationWidth,d=x.effectiveFilterDepth,h=x.effectiveFilterHeight,p=x.effectiveFilterWidth,m=x.padInfo.front,g=x.padInfo.top,y=x.padInfo.left;for(let b=0;b<x.batchSize;++b)for(let v=0;v<x.inChannels;++v)for(let w=0;w<x.outDepth;++w){const _=w*r-m;let T=_;for(;T<0;)T+=o;const A=Math.min(x.inDepth,d+_);for(let E=0;E<x.outHeight;++E){const M=E*a-g;let I=M;for(;I<0;)I+=l;const C=Math.min(x.inHeight,h+M);for(let k=0;k<x.outWidth;++k){const O=k*i-y;let z=O;for(;z<0;)z+=c;const ee=Math.min(x.inWidth,p+O);let re=Number.NEGATIVE_INFINITY,Y=-1;for(let Q=T;Q<A;Q+=o){const te=Q-_;for(let se=I;se<C;se+=l){const xe=se-M;for(let ae=z;ae<ee;ae+=c){const le=ae-O,de=s.get(b,Q,se,ae,v);de>=re&&(re=de,Y=te*h*p+xe*h+le)}}}n.set(Y,b,w,E,k,v)}}}return n}function UH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x;G0(a,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,d=1;G(Sn(o,d),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+d+"'");const h=k2(a.shape,i,o,d,l,c);let p;if(h.filterWidth===1&&h.filterHeight===1&&T0(h.inShape,h.outShape))p=pr({inputs:{x:a},backend:n});else{const m=n.data.get(a.dataId).values,g=U0(a.shape),y=Vg(m,a.shape,a.dtype,g,h,"avg");p=n.makeTensorInfo(h.outShape,a.dtype,y.values)}return p}const BH={kernelName:rp,backendName:"cpu",kernelFunc:UH};function zH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:d}=r;G0(a,"avgPool3d");const h=Ir(a.shape,i,o,1,l,c,d),p=n.data.get(a.dataId).values,m=nT(p,a.shape,a.dtype,U0(a.shape),h,"avg");return n.makeTensorInfo(m.shape,"float32",m.values)}const WH={kernelName:sp,backendName:"cpu",kernelFunc:zH};function GH(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=r;G0([a,i],"avgPool3DGrad");const h=Ir(i.shape,o,l,1,c,d),p=h.strideDepth,m=h.strideHeight,g=h.strideWidth,y=h.filterDepth,b=h.filterHeight,v=h.filterWidth,w=h.dilationDepth,_=h.dilationHeight,T=h.dilationWidth,A=h.effectiveFilterDepth,E=h.effectiveFilterHeight,M=h.effectiveFilterWidth,I=A-1-h.padInfo.front,C=M-1-h.padInfo.left,k=E-1-h.padInfo.top,O=At(i.shape,"float32"),z=1/(y*b*v),ee=n.bufferSync(a);for(let re=0;re<h.batchSize;++re)for(let Y=0;Y<h.inChannels;++Y)for(let Q=0;Q<h.inDepth;++Q)for(let te=0;te<h.inHeight;++te)for(let se=0;se<h.inWidth;++se){const xe=Q-I,ae=te-k,le=se-C;let de=0;for(let ue=0;ue<A;ue+=w){const ge=(xe+ue)/p;if(!(ge<0||ge>=h.outDepth||Math.floor(ge)!==ge))for(let pe=0;pe<E;pe+=_){const Le=(ae+pe)/m;if(!(Le<0||Le>=h.outHeight||Math.floor(Le)!==Le))for(let we=0;we<M;we+=T){const e0=(le+we)/g;e0<0||e0>=h.outWidth||Math.floor(e0)!==e0||(de+=ee.get(re,ge,Le,e0,Y))}}}O.set(de*z,re,Q,te,se,Y)}return n.makeTensorInfo(O.shape,O.dtype,O.values)}const VH={kernelName:ky,backendName:"cpu",kernelFunc:GH};function HH(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,o=i;G0([a,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:d}=r,h=k2(o.shape,l,c,1,d),p=h.strideHeight,m=h.strideWidth,g=h.filterHeight,y=h.filterWidth,b=h.dilationHeight,v=h.dilationWidth,w=h.effectiveFilterHeight,_=h.effectiveFilterWidth,T=_-1-h.padInfo.left,A=w-1-h.padInfo.top,E=At(o.shape,"float32"),M=1/(g*y),I=n.data.get(a.dataId).values,C=At(a.shape,"float32",I);for(let k=0;k<h.batchSize;++k)for(let O=0;O<h.inChannels;++O)for(let z=0;z<h.inHeight;++z)for(let ee=0;ee<h.inWidth;++ee){const re=z-A,Y=ee-T;let Q=0;for(let te=0;te<w;te+=b){const se=(re+te)/p;if(!(se<0||se>=h.outHeight||Math.floor(se)!==se))for(let xe=0;xe<_;xe+=v){const ae=(Y+xe)/m;ae<0||ae>=h.outWidth||Math.floor(ae)!==ae||(Q+=C.get(k,se,ae,O))}}E.set(Q*M,k,z,ee,O)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const YH={kernelName:Iy,backendName:"cpu",kernelFunc:HH};function qH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,scale:i,offset:o,mean:l,variance:c}=x;G(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),G(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),G(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),G0([a,l,c,i,o],"batchNorm");let{varianceEpsilon:d}=r;d==null&&(d=.001);const h=n.data.get(a.dataId).values,p=n.data.get(l.dataId).values,m=n.data.get(c.dataId).values,g=i?n.data.get(i.dataId).values:new Float32Array([1]),y=o?n.data.get(o.dataId).values:new Float32Array([0]),b=new Float32Array(h.length),v=y.length,w=g.length,_=m.length,T=p.length;let A=0,E=0,M=0,I=0;for(let C=0;C<h.length;++C)b[C]=y[A++]+(h[C]-p[E++])*g[M++]/Math.sqrt(m[I++]+d),A>=v&&(A=0),E>=T&&(E=0),M>=w&&(M=0),I>=_&&(I=0);return n.makeTensorInfo(a.shape,a.dtype,b)}const XH={kernelName:Pp,backendName:"cpu",kernelFunc:qH};function KH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockShape:i,crops:o}=r;G0([a],"batchToSpaceND");const l=i.reduce((w,_)=>w*_),c=tl(a.shape,i,l),d=xl(c.length,i.length),h=nl(a.shape,i,l),p=Bm(o,i.length),m=zm(h,o,i.length),g=dx({inputs:{x:a},backend:n,attrs:{shape:c}}),y=$n({inputs:{x:g},backend:n,attrs:{perm:d}}),b=dx({inputs:{x:y},backend:n,attrs:{shape:h}}),v=va({inputs:{x:b},backend:n,attrs:{begin:p,size:m}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),v}const $H={kernelName:ip,backendName:"cpu",kernelFunc:KH};function ZH(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,weights:i}=x,{size:o}=r,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,d=Ig(l,c,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,d)}const JH={kernelName:op,backendName:"cpu",kernelFunc:ZH};function QH(s){const{inputs:x,backend:n}=s,{s0:r,s1:a}=x,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=Ot(Array.from(i),Array.from(o));return n.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const jH={kernelName:lp,backendName:"cpu",kernelFunc:QH},eY=nx(Lc,(s,x)=>{const n=x;return s>n.clipValueMax?n.clipValueMax:s<n.clipValueMin?n.clipValueMin:s}),tY={kernelName:Lc,backendName:"cpu",kernelFunc:eY},xY=s=>{const{x}=s.inputs,n=s.backend,r=new Float32Array(be(x.shape)),a=n.data.get(x.dataId),i=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,l=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values;for(let d=0;d<l.length;d++){const h=l[d],p=c[d];r[d]=Math.hypot(h,p)}return n.makeOutput(r,x.shape,"float32")},nY={kernelName:up,backendName:"cpu",kernelFunc:xY};function Oi(s){const{inputs:x,backend:n}=s,{input:r}=x,a=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}const rY={kernelName:Fp,backendName:"cpu",kernelFunc:Oi};function Fi(s){const{inputs:x,backend:n,attrs:r}=s,{axis:a}=r,i=_0(a,x[0].shape)[0],o=x.map(b=>b.shape);Om(o,i);let l=hr(x.map(b=>b.shape),i);if(be(l)===0)return n.makeTensorInfo(l,x[0].dtype,[]);const c=x.filter(b=>be(b.shape)>0);if(c.length===1)return pr({inputs:{x:c[0]},backend:n});if(c[0].dtype==="complex64"){const b=c.map(A=>ba({inputs:{input:A},backend:n})),v=c.map(A=>Oi({inputs:{input:A},backend:n})),w=Fi({inputs:b,backend:n,attrs:{axis:i}}),_=Fi({inputs:v,backend:n,attrs:{axis:i}}),T=s2({inputs:{real:w,imag:_},backend:n});return b.forEach(A=>n.disposeIntermediateTensorInfo(A)),v.forEach(A=>n.disposeIntermediateTensorInfo(A)),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),T}const d=c.map(b=>{const v=be(b.shape.slice(i));return dx({inputs:{x:b},backend:n,attrs:{shape:[-1,v]}})}),h=d.map(b=>({vals:n.data.get(b.dataId).values,shape:b.shape}));l=hr(d.map(b=>b.shape),1);const p=d[0].shape[0]===1,m=n_(h,l,x[0].dtype,p),g=hr(c.map(b=>b.shape),i),y=n.makeTensorInfo(g,x[0].dtype,m);return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const sY={kernelName:dp,backendName:"cpu",kernelFunc:Fi};function rT(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h}=r;G0([a,i],"conv2d");const p=kr(c),m=sn(a.shape,i.shape,o,d,l,h,!1,p),g=m.filterHeight,y=m.filterWidth,b=m.dilationHeight,v=m.dilationWidth,w=m.padInfo.left,_=m.padInfo.top,T=m.dataFormat==="channelsLast",A=new rn(m.outShape,a.dtype),E=U0(a.shape),M=U0(i.shape),I=E[0],C=T?E[1]:E[2],k=T?E[2]:1,O=T?1:E[1],z=A.strides[0],ee=T?A.strides[1]:A.strides[2],re=T?A.strides[2]:1,Y=T?1:A.strides[1],Q=n.data.get(a.dataId).values,te=n.data.get(i.dataId).values,se=A.values;for(let xe=0;xe<m.batchSize;++xe){const ae=xe*I,le=xe*z;for(let de=0;de<m.outHeight;++de){const ue=le+de*ee,ge=de*m.strideHeight-_;for(let pe=0;pe<g;++pe){const Le=ge+pe*b;if(Le<0||Le>=m.inHeight)continue;const we=pe*M[0],e0=ae+Le*C;for(let Ze=0;Ze<m.outWidth;++Ze){const i0=ue+Ze*re,We=Ze*m.strideWidth-w;for(let v0=0;v0<y;++v0){const Te=We+v0*v;if(Te<0||Te>=m.inWidth)continue;const Ie=we+v0*M[1],Xe=e0+Te*k;let c0=Ie;for(let Ye=0;Ye<m.inChannels;++Ye){const I0=Q[Xe+Ye*O];for(let m0=0;m0<m.outChannels;++m0)se[i0+m0*Y]+=I0*te[c0+m0];c0+=m.outChannels}}}}}}return n.makeTensorInfo(A.shape,A.dtype,se)}const aY={kernelName:hp,backendName:"cpu",kernelFunc:rT};function iY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,pad:l,dataFormat:c,dimRoundingMode:d,filterShape:h}=r;G0([a,i],"conv2dBackpropFilter");const p=kr(c),m=sn(a.shape,h,o,1,l,d,!1,p),{strideHeight:g,strideWidth:y,filterHeight:b,filterWidth:v}=m,w=m.dataFormat==="channelsLast",_=new rn(m.filterShape,"float32"),T=m.padInfo.left,A=m.padInfo.top,E=n.data.get(a.dataId).values,M=n.data.get(i.dataId).values,I=new rn(a.shape,a.dtype,E),C=new rn(i.shape,i.dtype,M);for(let k=0;k<b;++k){const O=Math.max(0,Math.ceil((A-k)/g)),z=Math.min(m.outHeight,(m.inHeight+A-k)/g);for(let ee=0;ee<v;++ee){const re=Math.max(0,Math.ceil((T-ee)/y)),Y=Math.min(m.outWidth,(m.inWidth+T-ee)/y);for(let Q=0;Q<m.inChannels;++Q)for(let te=0;te<m.outChannels;++te){let se=0;for(let xe=0;xe<m.batchSize;++xe)for(let ae=O;ae<z;++ae){const le=k+ae*g-A;for(let de=re;de<Y;++de){const ue=ee+de*y-T;w?se+=I.get(xe,le,ue,Q)*C.get(xe,ae,de,te):se+=I.get(xe,Q,le,ue)*C.get(xe,te,ae,de)}}_.set(se,k,ee,Q,te)}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const oY={kernelName:pp,backendName:"cpu",kernelFunc:iY};function lY(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{inputShape:o,strides:l,pad:c,dataFormat:d,dimRoundingMode:h}=r;G0([a,i],"conv2dBackpropInput");const p=U0(i.shape),m=U0(a.shape);let g=kr(d);const y=sn(o,i.shape,l,1,c,h,!1,g),b=new rn(y.inShape,"float32"),v=b.values,w=n.data.get(a.dataId).values,_=n.data.get(i.dataId).values,[T,A,E]=p,{batchSize:M,filterHeight:I,filterWidth:C,inChannels:k,inHeight:O,inWidth:z,outChannels:ee,outHeight:re,outWidth:Y,strideHeight:Q,strideWidth:te}=y;g=y.dataFormat;const se=I-1-y.padInfo.top,xe=C-1-y.padInfo.left,ae=g==="channelsLast",le=b.strides[0],de=ae?b.strides[1]:b.strides[2],ue=ae?b.strides[2]:1,ge=ae?1:b.strides[1],pe=m[0],Le=ae?m[1]:m[2],we=ae?m[2]:1,e0=ae?1:m[1];for(let Ze=0;Ze<M;++Ze)for(let i0=0;i0<k;++i0)for(let We=0;We<O;++We){const v0=We-se,Te=Math.max(0,Math.ceil(v0/Q)),Ie=Math.min(re,(I+v0)/Q);for(let Xe=0;Xe<z;++Xe){const c0=Xe-xe,Ye=Math.max(0,Math.ceil(c0/te)),I0=Math.min(Y,(C+c0)/te);let m0=0;for(let rt=Te;rt<Ie;++rt){const ct=rt*Q-v0;for(let ie=Ye;ie<I0;++ie){const $=ie*te-c0,ke=pe*Ze+Le*rt+we*ie,Ge=T*(I-1-ct)+A*(C-1-$)+E*i0;for(let s0=0;s0<ee;++s0){const p0=w[ke+e0*s0],K0=_[Ge+s0];m0+=p0*K0}}}const d0=le*Ze+de*We+ue*Xe+ge*i0;v[d0]=m0}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const cY={kernelName:fp,backendName:"cpu",kernelFunc:lY};function uY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dilations:c}=r;G0([a,i],"conv3d");const d=ps(a.shape,i.shape,o,c,l),{filterDepth:h,filterHeight:p,filterWidth:m,dilationDepth:g,dilationHeight:y,dilationWidth:b,padInfo:v}=d,w=v.front,_=v.left,T=v.top,A=new rn(d.outShape,a.dtype),E=n.data.get(a.dataId).values,M=n.data.get(i.dataId).values,I=A.values,C=U0(a.shape),k=U0(i.shape);for(let O=0;O<d.batchSize;++O){const z=O*C[0],ee=O*A.strides[0];for(let re=0;re<d.outDepth;++re){const Y=ee+re*A.strides[1],Q=re*d.strideDepth-w;for(let te=0;te<h;++te){const se=Q+te*g;if(se<0||se>=d.inDepth)continue;const xe=te*k[0],ae=z+se*C[1];for(let le=0;le<d.outHeight;++le){const de=Y+le*A.strides[2],ue=le*d.strideHeight-T;for(let ge=0;ge<p;++ge){const pe=ue+ge*y;if(pe<0||pe>=d.inHeight)continue;const Le=xe+ge*k[1],we=ae+pe*C[2];for(let e0=0;e0<d.outWidth;++e0){const Ze=de+e0*d.outChannels,i0=e0*d.strideWidth-_;for(let We=0;We<m;++We){const v0=i0+We*b;if(v0<0||v0>=d.inWidth)continue;const Te=Le+We*k[2],Ie=we+v0*d.inChannels;let Xe=Te;for(let c0=0;c0<d.inChannels;++c0){const Ye=E[Ie+c0];for(let I0=0;I0<d.outChannels;++I0)I[Ze+I0]+=Ye*M[Xe+I0];Xe+=d.outChannels}}}}}}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}const dY={kernelName:mp,backendName:"cpu",kernelFunc:uY};function hY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,pad:l,filterShape:c}=r;G0([a,i],"conv3dBackpropFilterV2");const d=U0(a.shape),h=U0(i.shape),p=ps(a.shape,c,o,1,l),m=p.strideDepth,g=p.strideHeight,y=p.strideWidth,b=p.filterDepth,v=p.filterHeight,w=p.filterWidth,_=new rn(p.filterShape,"float32"),T=_.values,[A,E,M,I]=_.strides,C=n.data.get(i.dataId).values,[k,O,z,ee]=h,re=n.data.get(a.dataId).values,[Y,Q,te,se]=d,xe=p.padInfo.front,ae=p.padInfo.left,le=p.padInfo.top;for(let de=0;de<b;++de){const ue=Math.max(0,Math.ceil((xe-de)/m)),ge=Math.min(p.outDepth,(p.inDepth+xe-de)/m),pe=de*A;for(let Le=0;Le<v;++Le){const we=Math.max(0,Math.ceil((le-Le)/g)),e0=Math.min(p.outHeight,(p.inHeight+le-Le)/g),Ze=Le*E+pe;for(let i0=0;i0<w;++i0){const We=Math.max(0,Math.ceil((ae-i0)/y)),v0=Math.min(p.outWidth,(p.inWidth+ae-i0)/y),Te=i0*M+Ze;for(let Ie=0;Ie<p.inChannels;++Ie){const Xe=Ie*I+Te;for(let c0=0;c0<p.outChannels;++c0){let Ye=0;for(let I0=0;I0<p.batchSize;++I0){const m0=I0*Y,d0=I0*k;for(let rt=ue;rt<ge;++rt){const ct=(de+rt*m-xe)*Q+m0,ie=rt*O+d0;for(let $=we;$<e0;++$){const ke=(Le+$*g-le)*te+ct,Ge=$*z+ie;for(let s0=We;s0<v0;++s0){const p0=(i0+s0*y-ae)*se+ke,K0=s0*ee+Ge;Ye+=re[p0+Ie]*C[K0+c0]}}}}T[Xe+c0]=Ye}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const pY={kernelName:Ny,backendName:"cpu",kernelFunc:hY};function fY(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{pad:o,strides:l,inputShape:c}=r;G0([a],"conv3dBackpropInputV2");const d=U0(a.shape),h=U0(i.shape),p=ps(c,i.shape,l,1,o),m=new rn(p.inShape,"float32"),g=m.values,[y,b,v,w]=m.strides,_=n.data.get(a.dataId).values,[T,A,E,M]=d,I=n.data.get(i.dataId).values,[C,k,O,z]=h,{batchSize:ee,filterDepth:re,filterHeight:Y,filterWidth:Q,inChannels:te,inDepth:se,inHeight:xe,inWidth:ae,outChannels:le,outDepth:de,outHeight:ue,outWidth:ge,strideDepth:pe,strideHeight:Le,strideWidth:we}=p,e0=re-1-p.padInfo.front,Ze=Y-1-p.padInfo.top,i0=Q-1-p.padInfo.left;for(let We=0;We<ee;++We)for(let v0=0;v0<te;++v0)for(let Te=0;Te<se;++Te){const Ie=Te-e0,Xe=Math.max(0,Math.ceil(Ie/pe)),c0=Math.min(de,(re+Ie)/pe);for(let Ye=0;Ye<xe;++Ye){const I0=Ye-Ze,m0=Math.max(0,Math.ceil(I0/Le)),d0=Math.min(ue,(Y+I0)/Le);for(let rt=0;rt<ae;++rt){const ct=rt-i0,ie=Math.max(0,Math.ceil(ct/we)),$=Math.min(ge,(Q+ct)/we);let ke=0;for(let Ge=Xe;Ge<c0;++Ge){const s0=Ge*pe-Ie;for(let p0=m0;p0<d0;++p0){const K0=p0*Le-I0;for(let Re=ie;Re<$;++Re){const L0=Re*we-ct,u0=T*We+A*Ge+E*p0+M*Re,D0=C*(re-1-s0)+k*(Y-1-K0)+O*(Q-1-L0)+z*v0;for(let b0=0;b0<le;++b0){const et=_[u0+b0],Et=I[D0+b0];ke+=et*Et}}}}g[y*We+b*Te+v*Ye+w*rt+v0]=ke}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const mY={kernelName:gp,backendName:"cpu",kernelFunc:fY},gY=nx(Dc,s=>Math.cos(s)),yY={kernelName:Dc,backendName:"cpu",kernelFunc:gY},bY=nx(Oc,s=>Math.cosh(s)),vY={kernelName:Oc,backendName:"cpu",kernelFunc:bY};function wY(s){const{inputs:x,backend:n,attrs:r}=s,{image:a,boxes:i,boxInd:o}=x,{cropSize:l,method:c,extrapolationValue:d}=r,[h,p,m,g]=a.shape,y=i.shape[0],[b,v]=l,w=At([y,b,v,g],"float32"),_=n.data.get(i.dataId).values,T=n.data.get(o.dataId).values,A=n.data.get(a.dataId).values,E=U0(a.shape),M=U0(w.shape);for(let I=0;I<y;I++){const C=I*4,k=_[C],O=_[C+1],z=_[C+2],ee=_[C+3],re=T[I];if(re>=h)continue;const Y=b>1?(z-k)*(p-1)/(b-1):0,Q=v>1?(ee-O)*(m-1)/(v-1):0;for(let te=0;te<b;te++){const se=b>1?k*(p-1)+te*Y:.5*(k+z)*(p-1);if(se<0||se>p-1){for(let xe=0;xe<v;xe++)for(let ae=0;ae<g;ae++){const le=ae+xe*M[2]+te*M[1]+I*M[0];w.values[le]=d}continue}if(c==="bilinear"){const xe=Math.floor(se),ae=Math.ceil(se),le=se-xe;for(let de=0;de<v;de++){const ue=v>1?O*(m-1)+de*Q:.5*(O+ee)*(m-1);if(ue<0||ue>m-1){for(let we=0;we<g;we++){const e0=we+de*M[2]+te*M[1]+I*M[0];w.values[e0]=d}continue}const ge=Math.floor(ue),pe=Math.ceil(ue),Le=ue-ge;for(let we=0;we<g;we++){let e0=we+ge*E[2]+xe*E[1]+re*E[0];const Ze=A[e0];e0=we+pe*E[2]+xe*E[1]+re*E[0];const i0=A[e0];e0=we+ge*E[2]+ae*E[1]+re*E[0];const We=A[e0];e0=we+pe*E[2]+ae*E[1]+re*E[0];const v0=A[e0],Te=Ze+(i0-Ze)*Le,Ie=We+(v0-We)*Le;e0=we+de*M[2]+te*M[1]+I*M[0],w.values[e0]=Te+(Ie-Te)*le}}}else for(let xe=0;xe<v;++xe){const ae=v>1?O*(m-1)+xe*Q:.5*(O+ee)*(m-1);if(ae<0||ae>m-1){for(let ue=0;ue<g;ue++){const ge=ue+xe*M[2]+te*M[1]+I*M[0];w.values[ge]=d}continue}const le=Math.round(ae),de=Math.round(se);for(let ue=0;ue<g;ue++){const ge=ue+le*E[2]+de*E[1]+re*E[0],pe=ue+xe*M[2]+te*M[1]+I*M[0];w.values[pe]=A[ge]}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const _Y={kernelName:vp,backendName:"cpu",kernelFunc:wY};function SY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,exclusive:o,reverse:l}=r;G0(a,"cumprod");const c=Nx([i],a.shape.length);let d=a;c!=null&&(d=$n({inputs:{x:a},backend:n,attrs:{perm:c}}));const h=Rx(1,a.shape.length)[0];if(h!==d.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most axis="+(d.shape.length-1)+" but got axis="+h);const p=n2(d.dtype,"int32"),m=l2(be(d.shape),p),g=n.data.get(d.dataId).values,y=d.shape[d.shape.length-1],b=l?(w,_)=>w+y-_-1:(w,_)=>w+_;for(let w=0;w<g.length;w+=y)for(let _=0;_<y;_++){const T=b(w,_);if(_===0)m[T]=o?1:g[T];else{const A=b(w,_-1);m[T]=o?g[A]*m[A]:g[T]*m[A]}}const v=n.makeTensorInfo(d.shape,p,m);if(c!=null){const w=Xo(c),_=$n({inputs:{x:v},backend:n,attrs:{perm:w}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(d),_}return v}const TY={kernelName:yp,backendName:"cpu",kernelFunc:SY};function AY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,exclusive:o,reverse:l}=r;G0(a,"cumsum");const c=Nx([i],a.shape.length);let d=a;c!=null&&(d=$n({inputs:{x:a},backend:n,attrs:{perm:c}}));const h=Rx(1,a.shape.length)[0];if(h!==d.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(d.shape.length-1)+" but got axis="+h);const p=n2(d.dtype,"int32"),m=Ae(be(d.shape),p),g=n.data.get(d.dataId).values,y=d.shape[d.shape.length-1],b=l?(w,_)=>w+y-_-1:(w,_)=>w+_;for(let w=0;w<g.length;w+=y)for(let _=0;_<y;_++){const T=b(w,_);if(_===0)m[T]=o?0:g[T];else{const A=b(w,_-1);m[T]=o?g[A]+m[A]:g[T]+m[A]}}const v=n.makeTensorInfo(d.shape,p,m);if(c!=null){const w=Xo(c),_=$n({inputs:{x:v},backend:n,attrs:{perm:w}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(d),_}return v}const EY={kernelName:bp,backendName:"cpu",kernelFunc:AY};function CY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,weights:i}=x,{size:o,binaryOutput:l}=r;if(a.shape.length===1){const c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=Ig(c,d,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,h)}else if(a.shape.length===2){const c=n.bufferSync(a),d=n.bufferSync(i),h=t_(c,d,o,l);return n.makeTensorInfo(h.shape,i.dtype,h.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+a.shape.length+".")}const MY={kernelName:wp,backendName:"cpu",kernelFunc:CY};function IY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockSize:i,dataFormat:o}=r;G(o==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+o);const l=a.shape[0],c=a.shape[1],d=a.shape[2],h=a.shape[3],p=c*i,m=d*i,g=h/(i*i),y=n.data.get(a.dataId).values,b=new Float32Array(l*p*m*g);let v=0;for(let w=0;w<l;++w)for(let _=0;_<p;++_){const T=Math.floor(_/i),A=_%i;for(let E=0;E<m;++E){const M=Math.floor(E/i),I=E%i,C=(A*i+I)*g;for(let k=0;k<g;++k){const O=k+C+h*(M+d*(T+c*w));b[v++]=y[O]}}}return n.makeTensorInfo([l,p,m,g],a.dtype,b)}const kY={kernelName:_p,backendName:"cpu",kernelFunc:IY};function sT(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i}=x,{strides:o,pad:l,dilations:c,dimRoundingMode:d}=r;G0([a,i],"depthwiseConv2DNative");const h=U0(a.shape),p=U0(i.shape);let m=c;m==null&&(m=[1,1]),G(Sn(o,m),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+m+"'");const g=sn(a.shape,i.shape,o,m,l,d,!0),{filterHeight:y,filterWidth:b,dilationHeight:v,dilationWidth:w,padInfo:_}=g,T=_.left,A=_.top,E=g.outChannels/g.inChannels,M=new rn(g.outShape,a.dtype),I=n.data.get(a.dataId).values,C=n.data.get(i.dataId).values,k=M.values;for(let O=0;O<g.batchSize;++O){const z=O*h[0],ee=O*M.strides[0];for(let re=0;re<g.outHeight;++re){const Y=ee+re*M.strides[1],Q=re*g.strideHeight-A;for(let te=0;te<y;++te){const se=Q+te*v;if(se<0||se>=g.inHeight)continue;const xe=te*p[0],ae=z+se*h[1];for(let le=0;le<g.outWidth;++le){const de=Y+le*M.strides[2],ue=le*g.strideWidth-T;for(let ge=0;ge<b;++ge){const pe=ue+ge*w;if(pe<0||pe>=g.inWidth)continue;const Le=xe+ge*p[1],we=ae+pe*g.inChannels;let e0=de,Ze=Le;for(let i0=0;i0<g.inChannels;++i0){const We=I[we+i0];for(let v0=0;v0<E;++v0)k[e0+v0]+=We*C[Ze+v0];e0+=E,Ze+=E}}}}}}return n.makeTensorInfo(M.shape,M.dtype,M.values)}const NY={kernelName:Sp,backendName:"cpu",kernelFunc:sT};function RY(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,dy:i}=x,{strides:o,dilations:l,pad:c,dimRoundingMode:d,filterShape:h}=r;G0([a,i],"depthwiseConv2dNativeBackpropFilter");const p=sn(a.shape,h,o,l,c,d,!0),{strideHeight:m,strideWidth:g,filterHeight:y,filterWidth:b}=p,v=new rn(p.filterShape,"float32"),w=p.padInfo.left,_=p.padInfo.top,T=p.outChannels/p.inChannels,A=n.data.get(a.dataId).values,E=new rn(a.shape,a.dtype,A),M=n.data.get(i.dataId).values,I=new rn(i.shape,i.dtype,M);for(let C=0;C<y;++C){const k=Math.max(0,Math.ceil((_-C)/m)),O=Math.min(p.outHeight,(p.inHeight+_-C)/m);for(let z=0;z<b;++z){const ee=Math.max(0,Math.ceil((w-z)/g)),re=Math.min(p.outWidth,(p.inWidth+w-z)/g);for(let Y=0;Y<p.outChannels;++Y){const Q=Math.trunc(Y/T),te=Y%T;let se=0;for(let xe=0;xe<p.batchSize;++xe)for(let ae=k;ae<O;++ae){const le=C+ae*m-_;for(let de=ee;de<re;++de){const ue=z+de*g-w;se+=E.get(xe,le,ue,Q)*I.get(xe,ae,de,Y)}}v.set(se,C,z,Q,te)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const PY={kernelName:Tp,backendName:"cpu",kernelFunc:RY};function LY(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,filter:i}=x,{strides:o,dilations:l,pad:c,dimRoundingMode:d,inputShape:h}=r;G0([a,i],"depthwiseConv2DNativeBackpropInput");const p=U0(a.shape),m=U0(i.shape),g=sn(h,i.shape,o,l,c,d,!0),y=new rn(g.inShape,"float32"),b=y.values,[v,w,_]=y.strides,T=n.data.get(a.dataId).values,[A,E,M]=p,I=n.data.get(i.dataId).values,[C,k,O]=m,{batchSize:z,filterHeight:ee,filterWidth:re,inChannels:Y,inHeight:Q,inWidth:te,outChannels:se,outHeight:xe,outWidth:ae,strideHeight:le,strideWidth:de}=g,ue=ee-1-g.padInfo.top,ge=re-1-g.padInfo.left,pe=se/Y;for(let Le=0;Le<z;++Le)for(let we=0;we<Y;++we)for(let e0=0;e0<Q;++e0){const Ze=e0-ue,i0=Math.max(0,Math.ceil(Ze/le)),We=Math.min(xe,(ee+Ze)/le);for(let v0=0;v0<te;++v0){const Te=v0-ge,Ie=Math.max(0,Math.ceil(Te/de)),Xe=Math.min(ae,(re+Te)/de);let c0=0;for(let Ye=i0;Ye<We;++Ye){const I0=Ye*le-Ze;for(let m0=Ie;m0<Xe;++m0){const d0=m0*de-Te,rt=A*Le+E*Ye+M*m0,ct=C*(ee-1-I0)+k*(re-1-d0)+O*we;for(let ie=0;ie<pe;++ie){const $=we*pe+ie,ke=T[rt+$],Ge=I[ct+ie];c0+=ke*Ge}}}b[v*Le+w*e0+_*v0+we]=c0}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const DY={kernelName:Ap,backendName:"cpu",kernelFunc:LY};function OY(s){const{inputs:x,backend:n}=s,{x:r}=x,a=be(r.shape),i=n.data.get(r.dataId).values,o=At([a,a],r.dtype),l=o.values;for(let d=0;d<i.length;d++)l[d*a+d]=i[d];const c=[...r.shape,...r.shape];return n.makeTensorInfo(c,o.dtype,o.values)}const FY={kernelName:Ep,backendName:"cpu",kernelFunc:OY},UY={kernelName:Cp,backendName:"cpu",kernelFunc:({inputs:s,backend:x,attrs:n})=>{const{x:r,filter:a}=s,{strides:i,pad:o,dilations:l}=n,c=x,d=c.data.get(r.dataId).values,h=r.shape.length,p=c.data.get(a.dataId).values,m=a.shape.length,{batchSize:g,inHeight:y,inWidth:b,inChannels:v,outHeight:w,outWidth:_,padInfo:T,strideHeight:A,strideWidth:E,filterHeight:M,filterWidth:I,dilationHeight:C,dilationWidth:k,outShape:O}=Wo(r.shape,a.shape,i,o,"NHWC",l),z=be(O),ee=O.length,re=a0(r.dtype,z);for(let Y=0;Y<g;++Y)for(let Q=0;Q<w;++Q){const te=Q*A-T.top;for(let se=0;se<_;++se){const xe=se*E-T.left;for(let ae=0;ae<v;++ae){let le=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<M;++ue){const ge=te+ue*C;if(ge>=0&&ge<y)for(let pe=0;pe<I;++pe){const Le=xe+pe*k;if(Le>=0&&Le<b){const we=J0([Y,ge,Le,ae],h,U0(r.shape)),e0=J0([ue,pe,ae],m,U0(a.shape)),Ze=d[we]+p[e0];Ze>le&&(le=Ze)}}}const de=J0([Y,Q,se,ae],ee,U0(O));re[de]=le}}}return{dataId:c.write(Js(re,r.dtype),O,r.dtype),shape:O,dtype:r.dtype}}},BY={kernelName:Py,backendName:"cpu",kernelFunc:({inputs:s,backend:x,attrs:n})=>{const{x:r,filter:a,dy:i}=s,{strides:o,pad:l,dilations:c}=n,d=x,h=lx(r.shape,d.data.get(r.dataId).values),p=lx(a.shape,d.data.get(a.dataId).values),{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:v,outWidth:w,padInfo:_,strideHeight:T,strideWidth:A,filterHeight:E,filterWidth:M,dilationHeight:I,dilationWidth:C,outShape:k}=Wo(r.shape,a.shape,o,l,"NHWC",c);G(i.rank===k.length,()=>"Error in "+Py+", dy must have the same rank as output "+k.length+", but got "+i.rank);const O=lx(k,d.data.get(i.dataId).values),z=He(a.shape,a.dtype);for(let ee=0;ee<m;++ee)for(let re=0;re<v;++re){const Y=re*T-_.top;for(let Q=0;Q<w;++Q){const te=Q*A-_.left;for(let se=0;se<b;++se){let xe=Number.MIN_SAFE_INTEGER,ae=0,le=0;for(let de=0;de<E;++de){const ue=Y+de*I;if(ue>=0&&ue<g)for(let ge=0;ge<M;++ge){const pe=te+ge*C;if(pe>=0&&pe<y){const Le=h[ee][ue][pe][se]+p[de][ge][se];Le>xe&&(xe=Le,ae=de,le=ge)}}}z[ae][le][se]+=O[ee][re][Q][se]}}}return{dataId:d.write(Js(z,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},zY={kernelName:Ry,backendName:"cpu",kernelFunc:({inputs:s,backend:x,attrs:n})=>{const{x:r,filter:a,dy:i}=s,{strides:o,pad:l,dilations:c}=n,d=x,h=lx(r.shape,d.data.get(r.dataId).values),p=lx(a.shape,d.data.get(a.dataId).values),{batchSize:m,inHeight:g,inWidth:y,inChannels:b,outHeight:v,outWidth:w,padInfo:_,strideHeight:T,strideWidth:A,filterHeight:E,filterWidth:M,dilationHeight:I,dilationWidth:C,outShape:k}=Wo(r.shape,a.shape,o,l,"NHWC",c);G(i.rank===k.length,()=>"Error in "+Ry+", dy must have the same rank as output "+k.length+", but got "+i.rank);const O=lx(k,d.data.get(i.dataId).values),z=He(r.shape,r.dtype);for(let ee=0;ee<m;++ee)for(let re=0;re<v;++re){const Y=re*T-_.top;for(let Q=0;Q<w;++Q){const te=Q*A-_.left;for(let se=0;se<b;++se){let xe=Number.MIN_SAFE_INTEGER,ae=Y<0?0:Y,le=te<0?0:te;for(let de=0;de<E;++de){const ue=Y+de*I;if(ue>=0&&ue<g)for(let ge=0;ge<M;++ge){const pe=te+ge*C;if(pe>=0&&pe<y){const Le=h[ee][ue][pe][se]+p[de][ge][se];Le>xe&&(xe=Le,ae=ue,le=pe)}}}z[ee][ae][le][se]+=O[ee][re][Q][se]}}}return{dataId:d.write(Js(z,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function yl(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;G0(a,"sum");let l;a.dtype==="bool"?l=ms({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):l=pr({inputs:{x:a},backend:n});const c=l.shape.length,d=_0(i,l.shape),h=Nx(d,c);let p=d,m=l;h!=null&&(m=$n({inputs:{x:l},backend:n,attrs:{perm:h}}),p=Rx(p.length,c)),hn("sum",p,m.shape.length);const[g,y]=dn(m.shape,p),b=n2(m.dtype,"int32");let v=fd(n,g,b);const w=be(y),_=n.data.get(v.dataId).values,T=n.data.get(m.dataId).values;for(let A=0;A<_.length;++A){const E=A*w;let M=0;for(let I=0;I<w;++I)M+=T[E+I];_[A]=M}if(o){const A=$x(v.shape,d),E=v;v=dx({inputs:{x:v},backend:n,attrs:{shape:A}}),n.disposeIntermediateTensorInfo(E)}return n.disposeIntermediateTensorInfo(l),h!=null&&n.disposeIntermediateTensorInfo(m),v}const WY={kernelName:bf,backendName:"cpu",kernelFunc:yl};function GY(s){const{inputs:x,backend:n,attrs:r}=s,{equation:a}=r,i=x,{allDims:o,summedDims:l,idDims:c}=Jm(a,i.length);jm(o.length,c,i);const{path:d,steps:h}=eg(l,c),p=h.length;let m=null,g=o.length;const y=[];for(let b=0;b<p;++b){for(const v of h[b]){const{permutationIndices:w,expandDims:_}=Qm(g,c[v]);let T;tg(w)?T=i[v]:(T=$n({inputs:{x:i[v]},backend:n,attrs:{perm:w}}),y.push(T));const A=T.shape.slice();for(let E=0;E<_.length;++E)A.splice(_[E],0,1);T0(T.shape,A)||(T=dx({inputs:{x:T},backend:n,attrs:{shape:A}}),y.push(T)),m===null?m=T:(m=md({inputs:{a:T,b:m},backend:n}),y.push(m))}b<p-1&&(d[b]>=0&&(m=yl({inputs:{x:m},backend:n,attrs:{axis:d[b]-(o.length-g),keepDims:!1}}),y.push(m)),g--)}for(const b of y)b!==m&&n.disposeIntermediateTensorInfo(b);return m}const VY={kernelName:Mp,backendName:"cpu",kernelFunc:GY};function HY(s){const{inputs:x,backend:n}=s,{dy:r,y:a}=x;G0([r,a],"eluGrad");const i=new Float32Array(be(a.shape)),o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values;for(let c=0;c<o.length;++c){const d=o[c];d>=1?i[c]=l[c]:i[c]=l[c]*(d+1)}return n.makeTensorInfo(a.shape,"float32",i)}const YY={kernelName:Ly,backendName:"cpu",kernelFunc:HY},qY=Vm,XY=Hm,KY=Ym,$Y=qm,ZY=Xm,JY=Km,QY=nx(Bc,s=>{const x=Math.sign(s),n=Math.abs(s),r=1/(1+qY*n);return x*(1-((((JY*r+ZY)*r+$Y)*r+KY)*r+XY)*r*Math.exp(-n*n))}),jY={kernelName:Bc,backendName:"cpu",kernelFunc:QY};function Id(s){const{inputs:x,backend:n,attrs:r}=s,{input:a}=x,{dim:i}=r,o=a.shape.length,l=a.shape.slice();let c=i;return i<0&&(G(-(o+1)<=i,()=>"Axis must be in the interval ["+-(o+1)+", "+o+"]"),c=o+i+1),l.splice(c,0,1),dx({inputs:{x:a},backend:n,attrs:{shape:l}})}const eq={kernelName:Ip,backendName:"cpu",kernelFunc:Id},tq=Wx((s,x)=>s/x),Hg=an(Fc,tq),Yg={kernelName:Fc,backendName:"cpu",kernelFunc:Hg};function aT(s,x,n){const r=s.shape,a=r[0],i=r[1],o=n.data.get(s.dataId),l=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,d=[a,i],h=be(d),p=Ke("float32",h),m=Ke("float32",h);for(let v=0;v<a;v++){const w=va({inputs:{x:l},backend:n,attrs:{begin:[v,0],size:[1,i]}}),_=va({inputs:{x:c},backend:n,attrs:{begin:[v,0],size:[1,i]}}),T=s2({inputs:{real:w,imag:_},backend:n}),{real:A,imag:E}=xq(T,x,n),M=Fr(A,E);for(let I=0;I<i;I++){const C=$m(M,I);p[v*i+I]=C.real,m[v*i+I]=C.imag}n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(T)}const g=n.makeTensorInfo(d,"float32",p),y=n.makeTensorInfo(d,"float32",m),b=s2({inputs:{real:g,imag:y},backend:n});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}function xq(s,x,n){const r=be(s.shape),a=n.data.get(s.dataId),i=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(nq(r)){const l=qg(i,o,r,x,n),c=[s.shape[0],s.shape[1]];if(x){const d=n.makeTensorInfo(c,"float32",l.real),h=n.makeTensorInfo(c,"float32",l.imag),p=n.makeTensorInfo([],"float32",as(r,"float32")),m=pr({inputs:{x:p},backend:n}),g=Yg.kernelFunc({inputs:{a:d,b:p},backend:n}),y=Yg.kernelFunc({inputs:{a:h,b:m},backend:n}),b=n.data.get(g.dataId).values,v=n.data.get(y.dataId).values;return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),{real:b,imag:v}}return l}else{const l=Fr(i,o),c=rq(l,r,x);return Zv(c)}}function nq(s){return(s&s-1)===0}function qg(s,x,n,r,a){if(n===1)return{real:s,imag:x};const i=Fr(s,x),o=n/2,l=Jv(i),c=l.real,d=l.imag,h=[c.length],p=a.makeTensorInfo(h,"float32",c),m=a.makeTensorInfo(h,"float32",d),g=s2({inputs:{real:p,imag:m},backend:a}),y=Qv(i),b=y.real,v=y.imag,w=[b.length],_=a.makeTensorInfo(w,"float32",b),T=a.makeTensorInfo(w,"float32",v),A=s2({inputs:{real:_,imag:T},backend:a}),E=qg(c,d,o,r,a),M=E.real,I=E.imag,C=[M.length],k=a.makeTensorInfo(C,"float32",M),O=a.makeTensorInfo(C,"float32",I),z=s2({inputs:{real:k,imag:O},backend:a}),ee=qg(b,v,o,r,a),re=ee.real,Y=ee.imag,Q=[re.length],te=a.makeTensorInfo(Q,"float32",re),se=a.makeTensorInfo(Q,"float32",Y),xe=s2({inputs:{real:te,imag:se},backend:a}),ae=ew(n,r),le=[ae.real.length],de=a.makeTensorInfo(le,"float32",ae.real),ue=a.makeTensorInfo(le,"float32",ae.imag),ge=s2({inputs:{real:de,imag:ue},backend:a}),pe=md({inputs:{a:ge,b:xe},backend:a}),Le=Ii({inputs:{a:z,b:pe},backend:a}),we=Pg({inputs:{a:z,b:pe},backend:a}),e0=ba({inputs:{input:Le},backend:a}),Ze=ba({inputs:{input:we},backend:a}),i0=Oi({inputs:{input:Le},backend:a}),We=Oi({inputs:{input:we},backend:a}),v0=Fi({inputs:[e0,Ze],backend:a,attrs:{axis:0}}),Te=Fi({inputs:[i0,We],backend:a,attrs:{axis:0}}),Ie=a.data.get(v0.dataId).values,Xe=a.data.get(Te.dataId).values;return a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(k),a.disposeIntermediateTensorInfo(O),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(te),a.disposeIntermediateTensorInfo(se),a.disposeIntermediateTensorInfo(xe),a.disposeIntermediateTensorInfo(de),a.disposeIntermediateTensorInfo(ue),a.disposeIntermediateTensorInfo(ge),a.disposeIntermediateTensorInfo(pe),a.disposeIntermediateTensorInfo(Le),a.disposeIntermediateTensorInfo(we),a.disposeIntermediateTensorInfo(e0),a.disposeIntermediateTensorInfo(i0),a.disposeIntermediateTensorInfo(Ze),a.disposeIntermediateTensorInfo(We),a.disposeIntermediateTensorInfo(v0),a.disposeIntermediateTensorInfo(Te),{real:Ie,imag:Xe}}function rq(s,x,n){const r=new Float32Array(x*2);for(let a=0;a<x;a++){let i=0,o=0;for(let l=0;l<x;l++){const c=tw(a*l,x,n),d=$m(s,l);i+=d.real*c.real-d.imag*c.imag,o+=d.real*c.imag+d.imag*c.real}n&&(i/=x,o/=x),jv(r,i,o,a)}return r}function sq(s){const{inputs:x,backend:n}=s,{input:r}=x,a=be(r.shape),i=r.shape[r.shape.length-1],o=a/i,l=dx({inputs:{x:r},backend:n,attrs:{shape:[o,i]}}),c=aT(l,!1,n),d=dx({inputs:{x:c},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),d}const aq={kernelName:kp,backendName:"cpu",kernelFunc:sq};function Xg(s){const{backend:x,attrs:n}=s,{shape:r,value:a,dtype:i}=n,o=i||Gt(a),l=a0(o,be(r));return oq(l,a,o),x.makeTensorInfo(r,o,l)}const iq={kernelName:Np,backendName:"cpu",kernelFunc:Xg};function oq(s,x,n){s.fill(x)}const lq={kernelName:Rp,backendName:"cpu",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{image:r}=s,a=n,i=Ke(r.dtype,be(r.shape)),[o,l,c,d]=r.shape,h=a.data.get(r.dataId).values;for(let p=0;p<o;p++){const m=p*c*l*d;for(let g=0;g<l;g++){const y=g*(c*d);for(let b=0;b<c;b++){const v=b*d;for(let w=0;w<d;w++){const _=Math.round(c-b-1),T=m+y+v+w;let A=h[T];if(_>=0&&_<c){const E=_*d,M=m+y+E+w;A=h[M]}i[T]=A}}}}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},cq=Wx((s,x)=>Math.floor(s/x)),uq=an(Hc,cq,null,"int32"),dq={kernelName:Hc,backendName:"cpu",kernelFunc:uq};function hq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i,bias:o,preluActivationWeights:l}=x,{strides:c,pad:d,dataFormat:h,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:y}=r;let b=rT({inputs:{x:a,filter:i},backend:n,attrs:{strides:c,pad:d,dataFormat:h,dilations:p,dimRoundingMode:m}});if(o){const v=b;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const w=dx({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});b=Ii({inputs:{a:b,b:w},backend:n}),n.disposeIntermediateTensorInfo(w)}else b=Ii({inputs:{a:b,b:o},backend:n});n.disposeIntermediateTensorInfo(v)}if(g){const v=b;if(h==="NCHW"&&g==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const w=dx({inputs:{x:l},backend:n,attrs:{shape:[l.shape[0],1,1]}});b=Md(n,b,g,w,y),n.disposeIntermediateTensorInfo(w)}else b=Md(n,b,g,l,y);n.disposeIntermediateTensorInfo(v)}return b}const pq={kernelName:Iu,backendName:"cpu",kernelFunc:hq};function fq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,filter:i,bias:o,preluActivationWeights:l}=x,{strides:c,pad:d,dataFormat:h,dilations:p,dimRoundingMode:m,activation:g,leakyreluAlpha:y}=r;let b=sT({inputs:{x:a,filter:i},backend:n,attrs:{strides:c,pad:d,dataFormat:h,dilations:p,dimRoundingMode:m}});if(o){const v=b;b=Ii({inputs:{a:b,b:o},backend:n}),n.disposeIntermediateTensorInfo(v)}if(g){const v=b;b=Md(n,b,g,l,y),n.disposeIntermediateTensorInfo(v)}return b}const mq={kernelName:ku,backendName:"cpu",kernelFunc:fq};function gq(s){const{inputs:x,backend:n}=s,{params:r,indices:a}=x,i=be(r.shape),o=a.shape,l=o[o.length-1],[c,d,h,p]=Mm(r,a);if(d===0)return n.makeTensorInfo(c,r.dtype,[]);const m=n.data.get(a.dataId).values,g=n.bufferSync(r),y=c_(m,g,r.dtype,d,l,h,p,r.shape,i);return n.makeTensorInfo(c,r.dtype,y.values)}const yq={kernelName:Dp,backendName:"cpu",kernelFunc:gq};function bq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,indices:i}=x,{axis:o,batchDims:l}=r;G0([a,i],"gatherV2");const c=_0(o,a.shape)[0],d=n.data.get(i.dataId).values,h=a.shape[c];for(let A=0;A<d.length;++A){const E=d[A];G(E<=h-1&&E>=0,()=>"GatherV2: the index value "+E+" is not in [0, "+(h-1)+"]")}let p=l;l==null&&(p=0);const m=be(i.shape),g=rg(a,i,c,p),y=dx({inputs:{x:a},backend:n,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),b=dx({inputs:{x:i},backend:n,attrs:{shape:[g.batchSize,m/g.batchSize]}}),v=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],w=n.bufferSync(b),_=n.bufferSync(y),T=u_(_,w,v);return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.makeTensorInfo(g.outputShape,T.dtype,T.values)}const vq={kernelName:Lp,backendName:"cpu",kernelFunc:bq};function wq(s){const{inputs:x,backend:n}=s,{input:r}=x,a=be(r.shape),i=r.shape[r.shape.length-1],o=a/i,l=dx({inputs:{x:r},backend:n,attrs:{shape:[o,i]}}),c=aT(l,!0,n),d=dx({inputs:{x:c},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),d}const _q={kernelName:Op,backendName:"cpu",kernelFunc:wq},Sq=nx(Kc,s=>Number.isFinite(s)?1:0,"bool"),Tq={kernelName:Kc,backendName:"cpu",kernelFunc:Sq},Aq=nx($c,s=>Math.abs(s)===1/0?1:0,"bool"),Eq={kernelName:$c,backendName:"cpu",kernelFunc:Aq},Cq=nx(Zc,s=>Number.isNaN(s)?1:0,"bool"),Mq={kernelName:Zc,backendName:"cpu",kernelFunc:Cq};function Iq(s){const{backend:x,attrs:n}=s,{start:r,stop:a,num:i}=n,o=m_(r,a,i);return x.makeTensorInfo([o.length],"float32",o)}const kq={kernelName:Bp,backendName:"cpu",kernelFunc:Iq},Nq=nx(eu,s=>Math.log1p(s)),Rq={kernelName:eu,backendName:"cpu",kernelFunc:Nq},Pq=Wx((s,x)=>s&&x),Lq=an(tu,Pq,null,"bool"),Dq={kernelName:tu,backendName:"cpu",kernelFunc:Lq},Oq=nx(xu,s=>s?0:1,"bool"),Fq={kernelName:xu,backendName:"cpu",kernelFunc:Oq},Uq=Wx((s,x)=>s||x),Bq=an(nu,Uq,null,"bool"),zq={kernelName:nu,backendName:"cpu",kernelFunc:Bq};function Wq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{depthRadius:i,bias:o,alpha:l,beta:c}=r;G0(a,"LRN");const d=a.shape[3],h=d-1,p=n.data.get(a.dataId).values,m=be(a.shape),g=new Float32Array(m);function y(b){const v=b%d;let w=b-v+Math.max(0,v-i);const _=b-v+Math.min(v+i,h);let T=0;for(;w<=_;w++){const A=p[w];T+=A*A}return T}for(let b=0;b<m;b++){const v=y(b),w=p[b]*Math.pow(o+l*v,-c);g[b]=w}return n.makeTensorInfo(a.shape,a.dtype,g)}const Gq={kernelName:zp,backendName:"cpu",kernelFunc:Wq};function Vq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,y:i,dy:o}=x,{depthRadius:l,bias:c,alpha:d,beta:h}=r;G0(o,"LRNGrad");const p=be(o.shape),m=o.shape[3],g=n.data.get(o.dataId).values,y=n.data.get(a.dataId).values,b=n.data.get(i.dataId).values,v=new Float32Array(p),w=p;for(let _=0;_<w;_++){const T=_%m,A=_-T+Math.max(0,T-l),E=_-T+Math.min(m,T+l+1);let M=0;for(let I=A;I<E;I++)M+=Math.pow(y[I],2);M=d*M+c;for(let I=A;I<E;I++){let C=-2*d*h*y[I]*b[_]/M;_===I&&(C+=Math.pow(M,-h)),C*=g[_],v[I]+=C}}return n.makeTensorInfo(o.shape,a.dtype,v)}const Hq={kernelName:Dy,backendName:"cpu",kernelFunc:Vq};function iT(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{reductionIndices:i,keepDims:o}=r,l=n;let c=a.shape;const d=c.length,h=_0(i,c);let p=h;const m=Nx(p,d);let g=l.data.get(a.dataId).values;if(m!=null){const A=new Array(d);for(let E=0;E<A.length;E++)A[E]=c[m[E]];g=Ng(g,c,a.dtype,m,A),p=Rx(p.length,d),c=A}G0(a,"max"),hn("max",p,d);const[y,b]=dn(c,p),v=be(b),w=y_(g,v,y,a.dtype),_=l.write(w,y,a.dtype);let T=y;return o&&(T=$x(y,h)),{dataId:_,shape:T,dtype:a.dtype}}const Yq={kernelName:Wp,backendName:"cpu",kernelFunc:iT};function qq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x;G0(a,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,d=1;G(Sn(o,d),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+d+"'");const h=k2(a.shape,i,o,d,l,c);let p;if(h.filterWidth===1&&h.filterHeight===1&&T0(h.inShape,h.outShape))p=pr({inputs:{x:a},backend:n});else{const m=n.data.get(a.dataId).values,g=U0(a.shape),y=Vg(m,a.shape,a.dtype,g,h,"max");p=n.makeTensorInfo(h.outShape,a.dtype,y.values)}return p}const Xq={kernelName:Gp,backendName:"cpu",kernelFunc:qq};function Kq(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:d}=r;G0(a,"maxPool3d");const h=Ir(a.shape,i,o,1,l,c,d),p=n.data.get(a.dataId).values,m=nT(p,a.shape,a.dtype,U0(a.shape),h,"max");return n.makeTensorInfo(m.shape,"float32",m.values)}const $q={kernelName:Vp,backendName:"cpu",kernelFunc:Kq};function Zq(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i}=x,{filterSize:o,strides:l,pad:c,dimRoundingMode:d}=r;G0([a,i],"maxPool3DGrad");const h=Ir(i.shape,o,l,1,c,d),p=n.bufferSync(i),m=FH(p,h),g=h.strideDepth,y=h.strideHeight,b=h.strideWidth,v=h.dilationDepth,w=h.dilationHeight,_=h.dilationWidth,T=h.effectiveFilterDepth,A=h.effectiveFilterHeight,E=h.effectiveFilterWidth,M=T-1-h.padInfo.front,I=E-1-h.padInfo.left,C=A-1-h.padInfo.top,k=At(i.shape,"float32"),O=n.bufferSync(a);for(let z=0;z<h.batchSize;++z)for(let ee=0;ee<h.inChannels;++ee)for(let re=0;re<h.inDepth;++re)for(let Y=0;Y<h.inHeight;++Y)for(let Q=0;Q<h.inWidth;++Q){const te=re-M,se=Y-C,xe=Q-I;let ae=0;for(let le=0;le<T;le+=v){const de=(te+le)/g;if(!(de<0||de>=h.outDepth||Math.floor(de)!==de))for(let ue=0;ue<A;ue+=w){const ge=(se+ue)/y;if(!(ge<0||ge>=h.outHeight||Math.floor(ge)!==ge))for(let pe=0;pe<E;pe+=_){const Le=(xe+pe)/b;if(Le<0||Le>=h.outWidth||Math.floor(Le)!==Le)continue;const we=T*A*E-1-m.get(z,de,ge,Le,ee),e0=le*A*E+ue*E+pe,Ze=we===e0?1:0;Ze!==0&&(ae+=O.get(z,de,ge,Le,ee)*Ze)}}}k.set(ae,z,re,Y,Q,ee)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const Jq={kernelName:Fy,backendName:"cpu",kernelFunc:Zq};function Qq(s){const{inputs:x,backend:n,attrs:r}=s,{dy:a,input:i,output:o}=x,l=i;G0([i,o],"maxPoolGrad");const{filterSize:c,strides:d,pad:h,dimRoundingMode:p}=r,m=k2(l.shape,c,d,1,h,p),g=n.data.get(l.dataId).values,y=At(m.outShape,l.dtype,xT(g,l.shape,l.dtype,m).values),b=m.strideHeight,v=m.strideWidth,w=m.dilationHeight,_=m.dilationWidth,T=m.effectiveFilterHeight,A=m.effectiveFilterWidth,E=A-1-m.padInfo.left,M=T-1-m.padInfo.top,I=At(l.shape,"float32"),C=n.data.get(a.dataId).values,k=At(a.shape,"float32",C);for(let O=0;O<m.batchSize;++O)for(let z=0;z<m.inChannels;++z)for(let ee=0;ee<m.inHeight;++ee)for(let re=0;re<m.inWidth;++re){const Y=ee-M,Q=re-E;let te=0;for(let se=0;se<T;se+=w){const xe=(Y+se)/b;if(!(xe<0||xe>=m.outHeight||Math.floor(xe)!==xe))for(let ae=0;ae<A;ae+=_){const le=(Q+ae)/v;if(le<0||le>=m.outWidth||Math.floor(le)!==le)continue;const de=T*A-1-y.get(O,xe,le,z),ue=se*A+ae,ge=de===ue?1:0;ge!==0&&(te+=k.get(O,xe,le,z)*ge)}}I.set(te,O,ee,re,z)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const jq={kernelName:Oy,backendName:"cpu",kernelFunc:Qq};function eX(s,x,n,r,a){const i=U0(x),o=Vg(s,x,n,i,a,"max"),l=xT(s,x,n,a,!0,r);return[o.values,l.values]}const tX={kernelName:Hp,backendName:"cpu",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{x:r}=s,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=x,c=n;G0(r,"MaxPoolWithArgmax");const d=c.data.get(r.dataId).values,h=k2(r.shape,a,i,[1,1],o),[p,m]=eX(d,r.shape,r.dtype,l,h),g=c.write(p,h.outShape,r.dtype),y=c.write(m,h.outShape,r.dtype);return[{dataId:g,shape:h.outShape,dtype:r.dtype},{dataId:y,shape:h.outShape,dtype:"int32"}]}};function xX(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r,l=_0(i,a.shape),c=dn(a.shape,l)[1],d=be(c),h=[],p=n.makeTensorInfo([],"float32",new Float32Array([d]));h.push(p);const m=ms({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});h.push(m);const g=Hg({inputs:{a:m,b:p},backend:n});h.push(g);const y=yl({inputs:{x:g},backend:n,attrs:{axis:i,keepDims:o}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const nX={kernelName:Yp,backendName:"cpu",kernelFunc:xX};function rX(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{axis:i,keepDims:o}=r;G0(a,"min");const l=_0(i,a.shape);let c=l;const d=Nx(c,a.shape.length);let h=a;d!=null&&(h=$n({inputs:{x:a},backend:n,attrs:{perm:d}}),c=Rx(c.length,a.shape.length)),hn("min",c,h.shape.length);const[p,m]=dn(h.shape,c),g=be(m),y=Ae(be(p),h.dtype),b=n.data.get(h.dataId).values;for(let w=0;w<y.length;++w){const _=w*g;let T=b[_];for(let A=0;A<g;++A){const E=b[_+A];(Number.isNaN(E)||E<T)&&(T=E)}y[w]=T}d!=null&&n.disposeIntermediateTensorInfo(h);const v=n.makeTensorInfo(p,h.dtype,y);if(o){const w=$x(p,l),_=dx({inputs:{x:v},backend:n,attrs:{shape:w}});return n.disposeIntermediateTensorInfo(v),_}return v}const sX={kernelName:qp,backendName:"cpu",kernelFunc:rX};function aX(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{paddings:i,mode:o}=r;G0(a,"mirrorPad");const l=i.map((_,T)=>_[0]+a.shape[T]+_[1]),c=i.map(_=>_[0]),d=i.map((_,T)=>_[0]+a.shape[T]),h=o==="reflect"?0:1,p=n.data.get(a.dataId).values,m=a.shape.length,g=U0(a.shape),y=be(l),b=l.length,v=U0(l),w=Ke(a.dtype,y);for(let _=0;_<y;_++){let T=bt(_,b,v);for(let E=0;E<b;E++)T[E]<c[E]?T[E]=c[E]*2-T[E]-h:T[E]>=d[E]&&(T[E]=(d[E]-1)*2-T[E]+h);T=T.map((E,M)=>E-c[M]);const A=J0(T,m,g);w[_]=p[A]}return{dataId:n.write(w,l,a.dtype),shape:l,dtype:a.dtype}}const iX={kernelName:Xp,backendName:"cpu",kernelFunc:aX},oX=Wx((s,x)=>{const n=s%x;return s<0&&x<0||s>=0&&x>=0?n:(n+x)%x}),lX=an(au,oX),cX={kernelName:au,backendName:"cpu",kernelFunc:lX};function oT(s){const{inputs:x,backend:n,attrs:r}=s,{logits:a}=x,{dim:i}=r,o=a.shape.length;let l=i;if(l===-1&&(l=o-1),l!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+o+" and dim was "+l);const c=_0([l],a.shape),d=iT({inputs:{x:a},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),h=$x(d.shape,c),p=dx({inputs:{x:d},backend:n,attrs:{shape:h}}),m=Pg({inputs:{a,b:p},backend:n}),g=i_({inputs:{x:m},backend:n}),y=yl({inputs:{x:g},backend:n,attrs:{axis:c,keepDims:!1}}),b=dx({inputs:{x:y},backend:n,attrs:{shape:h}}),v=Hg({inputs:{a:g,b},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),v}const uX={kernelName:_f,backendName:"cpu",kernelFunc:oT};function dX(s){const{inputs:x,backend:n,attrs:r}=s,{logits:a}=x,{numSamples:i,seed:o,normalized:l}=r;G0(a,"multinomial");const c=l?a:oT({inputs:{logits:a},backend:n,attrs:{dim:-1}}),d=c.shape[0],h=c.shape[1],p=n.data.get(c.dataId).values,m=[d,i],g=Ae(be(m),"int32");for(let y=0;y<d;++y){const b=y*h,v=new Float32Array(h-1);v[0]=p[b];for(let T=1;T<v.length;++T)v[T]=v[T-1]+p[b+T];const w=$u.alea(o.toString()),_=y*i;for(let T=0;T<i;++T){const A=w();g[_+T]=v.length;for(let E=0;E<v.length;E++)if(A<v[E]){g[_+T]=E;break}}}return l||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(m,"int32",g)}const hX={kernelName:Kp,backendName:"cpu",kernelFunc:dX},pX=vm;function fX(s){const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=r;G0(a,"NonMaxSuppression");const d=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:p}=pX(d,h,o,l,c);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const mX={kernelName:Zp,backendName:"cpu",kernelFunc:fX},gX=wm;function yX(s){const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:d}=r;G0(a,"NonMaxSuppressionPadded");const h=n.data.get(a.dataId).values,p=n.data.get(i.dataId).values,{selectedIndices:m,validOutputs:g}=gX(h,p,o,l,c,d);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const bX={kernelName:Jp,backendName:"cpu",kernelFunc:yX},vX=_m;function wX(s){const{inputs:x,backend:n,attrs:r}=s,{boxes:a,scores:i}=x,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=r;G0(a,"NonMaxSuppressionWithScore");const h=n.data.get(a.dataId).values,p=n.data.get(i.dataId).values,m=o,g=l,y=c,b=d,{selectedIndices:v,selectedScores:w}=vX(h,p,m,g,y,b);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const _X={kernelName:Qp,backendName:"cpu",kernelFunc:wX};function SX(s){const{inputs:x,backend:n,attrs:r}=s,{indices:a}=x,{dtype:i,depth:o,onValue:l,offValue:c}=r;G0(a,"oneHot");const d=be(a.shape),h=new Float32Array(d*o);h.fill(c);const p=n.data.get(a.dataId).values;for(let m=0;m<d;++m)p[m]>=0&&p[m]<o&&(h[m*o+p[m]]=l);return n.makeTensorInfo([...a.shape,o],i,h)}const TX={kernelName:ef,backendName:"cpu",kernelFunc:SX};function kd(s){const{inputs:x,backend:n}=s,{x:r}=x;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const a=ba({inputs:{input:r},backend:n}),i=kd({inputs:{x:a},backend:n}),o=Oi({inputs:{input:r},backend:n}),l=kd({inputs:{x:o},backend:n}),c=s2({inputs:{real:i,imag:l},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}else return Xg({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const AX={kernelName:Ff,backendName:"cpu",kernelFunc:kd};function lT(s){const{inputs:x,backend:n}=s,{x:r}=x;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const a=ba({inputs:{input:r},backend:n}),i=lT({inputs:{x:a},backend:n}),o=Oi({inputs:{input:r},backend:n}),l=kd({inputs:{x:o},backend:n}),c=s2({inputs:{real:i,imag:l},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}else return Xg({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const EX={kernelName:jp,backendName:"cpu",kernelFunc:lT};function cT(s){const{inputs:x,backend:n,attrs:r}=s,{axis:a}=r;if(x.length===1)return Id({inputs:{input:x[0]},backend:n,attrs:{dim:a}});const i=x[0].shape,o=x[0].dtype;x.forEach(h=>{F0(i,h.shape,"All tensors passed to stack must have matching shapes"),G(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=x.map(h=>{const p=Id({inputs:{input:h},backend:n,attrs:{dim:a}});return l.push(p),p}),d=Fi({inputs:c,backend:n,attrs:{axis:a}});return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),d}const CX={kernelName:tf,backendName:"cpu",kernelFunc:cT};function MX(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{paddings:i,constantValue:o}=r;G0(a,"pad");const l=i.map((w,_)=>w[0]+a.shape[_]+w[1]),c=i.map(w=>w[0]),d=n.data.get(a.dataId).values,h=be(a.shape),p=a.shape.length,m=U0(a.shape),g=be(l),y=l.length,b=U0(l),v=Ke(a.dtype,g);o!==0&&v.fill(o);for(let w=0;w<h;w++){const _=bt(w,p,m).map((A,E)=>A+c[E]),T=J0(_,y,b);v[T]=d[w]}return{dataId:n.write(v,l,a.dtype),shape:l,dtype:a.dtype}}const uT={kernelName:xf,backendName:"cpu",kernelFunc:MX},IX=Wx((s,x)=>Math.pow(s,x)),kX=an(lu,IX),NX={kernelName:lu,backendName:"cpu",kernelFunc:kX};function RX(s){const{inputs:x,backend:n,attrs:r}=s,{paramsNestedSplits:a,paramsDenseValues:i,indices:o}=x,l=a.map(v=>n.data.get(v.dataId).values),c=a.map(v=>v.shape),d=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,[p,m,g]=A_(l,c,d,i.shape,i.dtype,h,o.shape),y=p.map(v=>n.makeTensorInfo([v.length],"int32",v)),b=n.makeTensorInfo(g,i.dtype,m);return y.concat([b])}const PX={kernelName:sf,backendName:"cpu",kernelFunc:RX};function LX(s){const{inputs:x,backend:n}=s,{starts:r,limits:a,deltas:i}=x,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h]=C_(o,r.shape,r.dtype,l,a.shape,c,i.shape),p=n.makeTensorInfo([d.length],"int32",d),m=n.makeTensorInfo([h.length],r.dtype,h);return[p,m]}const DX={kernelName:af,backendName:"cpu",kernelFunc:LX};function OX(s){const{inputs:x,backend:n,attrs:r}=s,{shape:a,values:i,defaultValue:o,rowPartitionTensors:l}=x,{rowPartitionTypes:c}=r,d=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,p=n.data.get(o.dataId).values,m=l.map(v=>n.data.get(v.dataId).values),g=l.map(v=>v.shape),[y,b]=k_(d,a.shape,h,i.shape,i.dtype,p,o.shape,m,g,c);return n.makeTensorInfo(y,i.dtype,b)}const FX={kernelName:of,backendName:"cpu",kernelFunc:OX};function UX(s){const{backend:x,attrs:n}=s,{start:r,stop:a,dtype:i,step:o}=n,l=N_(r,a,o,i);return x.makeTensorInfo([l.length],i,l)}const BX={kernelName:lf,backendName:"cpu",kernelFunc:UX},zX=nx(cu,s=>1/s),WX={kernelName:cu,backendName:"cpu",kernelFunc:zX};function GX(s){const{inputs:x,backend:n,attrs:r}=s,{images:a}=x,{alignCorners:i,halfPixelCenters:o,size:l}=r;G0(a,"resizeBilinear");const c=U0(a.shape),[d,h]=l,[p,m,g,y]=a.shape,b=n.data.get(a.dataId).values,v=new Float32Array(be([p,d,h,y])),w=[i&&d>1?m-1:m,i&&h>1?g-1:g],_=[i&&d>1?d-1:d,i&&h>1?h-1:h];let T=0;const A=w[0]/_[0],E=w[1]/_[1];for(let M=0;M<p;M++)for(let I=0;I<d;I++){let C;o?C=A*(I+.5)-.5:C=A*I;const k=Math.max(0,Math.floor(C)),O=C-k,z=Math.min(m-1,Math.ceil(C)),ee=M*c[0]+k*c[1],re=M*c[0]+z*c[1];for(let Y=0;Y<h;Y++){let Q;o?Q=E*(Y+.5)-.5:Q=E*Y;const te=Math.max(0,Math.floor(Q)),se=Q-te,xe=Math.min(g-1,Math.ceil(Q)),ae=ee+te*c[2],le=re+te*c[2],de=ee+xe*c[2],ue=re+xe*c[2];for(let ge=0;ge<y;ge++){const pe=b[ae+ge],Le=b[le+ge],we=b[de+ge],e0=b[ue+ge],Ze=pe+(we-pe)*se,i0=Le+(e0-Le)*se,We=Ze+(i0-Ze)*O;v[T++]=We}}}return n.makeTensorInfo([p,d,h,y],"float32",v)}const VX={kernelName:hf,backendName:"cpu",kernelFunc:GX};function HX(s){const{inputs:x,backend:n,attrs:r}=s,{images:a,dy:i}=x,{alignCorners:o}=r;G0([i,a],"resizeBilinearGrad");const l=U0(a.shape),[c,d,h,p]=a.shape,[,m,g]=i.shape,y=new Float32Array(c*d*h*p),b=[o&&m>1?d-1:d,o&&g>1?h-1:h],v=[o&&m>1?m-1:m,o&&g>1?g-1:g],w=b[0]/v[0],_=b[1]/v[1],T=n.data.get(i.dataId).values;let A=0;for(let E=0;E<c;E++){const M=E*l[0];for(let I=0;I<m;I++){const C=I*w,k=Math.floor(C),O=Math.min(Math.ceil(C),d-1),z=M+k*l[1],ee=M+O*l[1],re=C-k,Y=1-re;for(let Q=0;Q<g;Q++){const te=Q*_,se=Math.floor(te),xe=Math.min(Math.ceil(te),h-1),ae=te-se,le=1-ae,de=z+se*l[2],ue=z+xe*l[2],ge=ee+se*l[2],pe=ee+xe*l[2],Le=Y*le,we=Y*ae,e0=re*le,Ze=re*ae;for(let i0=0;i0<p;i0++){const We=T[A++];y[de+i0]+=We*Le,y[ue+i0]+=We*we,y[ge+i0]+=We*e0,y[pe+i0]+=We*Ze}}}}return n.makeTensorInfo([c,h,d,p],"float32",y)}const YX={kernelName:By,backendName:"cpu",kernelFunc:HX};function qX(s){const{inputs:x,backend:n,attrs:r}=s,{images:a}=x,{alignCorners:i,halfPixelCenters:o,size:l}=r;G0(a,"resizeNearestNeighbor");const c=U0(a.shape),[d,h]=l,[p,m,g,y]=a.shape,b=n.data.get(a.dataId).values,v=new Float32Array(p*d*h*y),w=[i&&d>1?m-1:m,i&&h>1?g-1:g],_=[i&&d>1?d-1:d,i&&h>1?h-1:h],T=w[0]/_[0],A=w[1]/_[1];let E=0;for(let M=0;M<p;M++){const I=M*c[0];for(let C=0;C<d;C++){const k=o?T*(C+.5):T*C;let O=Math.min(m-1,i?Math.round(k):Math.floor(k));o&&(O=Math.max(0,O));const z=I+O*c[1];for(let ee=0;ee<h;ee++){const re=o?A*(ee+.5):A*ee;let Y=Math.min(g-1,i?Math.round(re):Math.floor(re));o&&(Y=Math.max(0,Y));const Q=z+Y*c[2];for(let te=0;te<y;te++){const se=b[Q+te];v[E++]=se}}}}return n.makeTensorInfo([p,d,h,y],a.dtype,v)}const XX={kernelName:df,backendName:"cpu",kernelFunc:qX};function KX(s){const{inputs:x,backend:n,attrs:r}=s,{images:a,dy:i}=x,{alignCorners:o}=r;G0([i,a],"resizeNearestNeighborGrad");const l=U0(a.shape),c=U0(i.shape),[d,h,p,m]=a.shape,[,g,y]=i.shape,b=new Float32Array(d*h*p*m),v=n.data.get(i.dataId).values,w=[o&&g>1?h-1:h,o&&y>1?p-1:p],_=[o&&g>1?g-1:g,o&&y>1?y-1:y],T=w[0]/_[0],A=w[1]/_[1],E=1/T,M=1/A,I=Math.ceil(E)*2+2,C=Math.ceil(M)*2+2;for(let k=0;k<d;k++){const O=k*l[0];for(let z=0;z<h;z++){const ee=O+z*l[1],re=Math.floor(z*E),Y=Math.floor(re-I/2);for(let Q=0;Q<p;Q++){const te=ee+Q*l[2],se=Math.floor(Q*M),xe=Math.floor(se-C/2);for(let ae=0;ae<m;ae++){let le=0;for(let de=0;de<I;de++){const ue=de+Y;if(ue<0||ue>=g)continue;const ge=O+ue*c[1],pe=ue*T,Le=Math.min(h-1,o?Math.round(pe):Math.floor(pe));if(z===Le)for(let we=0;we<C;we++){const e0=we+xe;if(e0<0||e0>=y)continue;const Ze=ge+e0*c[2],i0=e0*A,We=Math.min(p-1,o?Math.round(i0):Math.floor(i0));Q===We&&(le+=v[Ze+ae])}}b[te+ae]=le}}}}return n.makeTensorInfo(a.shape,a.dtype,b)}const $X={kernelName:Uy,backendName:"cpu",kernelFunc:KX};function ZX(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{dims:i}=r;G0(a,"reverse");const o=a.shape.length,l=_0(i,a.shape);if(o===0)return pr({inputs:{x:a},backend:n});const c=new rn(a.shape,a.dtype),d=n.bufferSync(a);for(let h=0;h<c.size;h++){const p=c.indexToLoc(h),m=p.slice();l.forEach(g=>m[g]=a.shape[g]-1-m[g]),c.set(d.get(...m),...p)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}const JX={kernelName:pf,backendName:"cpu",kernelFunc:ZX},QX={kernelName:Bf,backendName:"cpu",kernelFunc:({inputs:s,attrs:x,backend:n})=>{const{image:r}=s,{radians:a,fillValue:i,center:o}=x,l=n,c=Ke(r.dtype,be(r.shape)),[d,h,p,m]=r.shape,[g,y]=Um(o,h,p),b=255,v=Math.sin(a),w=Math.cos(a),_=l.data.get(r.dataId).values;for(let T=0;T<d;T++){const A=T*p*h*m;for(let E=0;E<h;E++){const M=E*(p*m);for(let I=0;I<p;I++){const C=I*m;for(let k=0;k<m;k++){const O=[d,E,I,k],z=O[2],ee=O[1];let re=(z-g)*w-(ee-y)*v,Y=(z-g)*v+(ee-y)*w;re=Math.round(re+g),Y=Math.round(Y+y);let Q=i;if(typeof i!="number"&&(k===3?Q=b:Q=i[k]),re>=0&&re<p&&Y>=0&&Y<h){const se=Y*(p*m),xe=re*m,ae=A+se+xe+k;Q=_[ae]}const te=A+M+C+k;c[te]=Q}}}}return{dataId:l.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},jX=nx(hu,s=>{const x=Math.floor(s);return s-x<.5?Math.floor(s):s-x>.5?Math.ceil(s):x%2===0?x:x+1}),eK={kernelName:hu,backendName:"cpu",kernelFunc:jX};function tK(s){const{inputs:x,backend:n,attrs:r}=s,{indices:a,updates:i}=x,{shape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=el(i,a,o),m=!0,g=n.bufferSync(a),y=n.bufferSync(i),b=Ni(g,y,o,p,d,c,l,h,0,m);return n.makeTensorInfo(o,b.dtype,b.values)}const xK={kernelName:ff,backendName:"cpu",kernelFunc:tK};function nK(s,x){let n=0,r=s.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),s[a]<x?n=a+1:r=a;return r}function rK(s,x){let n=0,r=s.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),s[a]<=x?n=a+1:r=a;return r}function sK(s,x,n,r,a,i){const o=a0("int32",n*a);for(let l=0;l<n;++l){const c=s.slice(l*r,(l+1)*r),d=l*a;for(let h=0;h<a;++h)o[d+h]=i==="left"?nK(c,x[h+d]):rK(c,x[h+d])}return o}function aK(s){const{inputs:x,backend:n,attrs:r}=s,{sortedSequence:a,values:i}=x,{side:o}=r,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,d=sK(l,c,a.shape[0],a.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",d)}const iK={kernelName:mf,backendName:"cpu",kernelFunc:aK};function oK(s){const{inputs:x,backend:n}=s,{condition:r,t:a,e:i}=x;G0([r,a,i],"select");const o=r.shape.length,l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=n2(a.dtype,i.dtype),p=Ae(be(a.shape),h);let m=0;const g=o===0||o>1||a.shape.length===1?1:be(a.shape.slice(1));for(let y=0;y<l.length;y++)for(let b=0;b<g;b++)l[y]===1?p[m++]=c[y]:p[m++]=d[y];return n.makeTensorInfo(a.shape,h,p)}const lK={kernelName:gf,backendName:"cpu",kernelFunc:oK},cK=Wm,uK=Gm,dK=nx(fu,s=>s>=0?uK*s:cK*(Math.exp(s)-1)),hK={kernelName:fu,backendName:"cpu",kernelFunc:dK},pK=nx(yu,s=>s<0?-1:s>0?1:0),fK={kernelName:yu,backendName:"cpu",kernelFunc:pK},mK=nx(mu,s=>Math.sin(s)),gK={kernelName:mu,backendName:"cpu",kernelFunc:mK},yK=nx(gu,s=>Math.sinh(s)),bK={kernelName:gu,backendName:"cpu",kernelFunc:yK},vK=11920928955078125e-23,dT=Math.log(vK)+2,wK=nx(vu,s=>{const x=s>-dT,n=s<dT,r=Math.exp(s);let a;return n?a=r:x?a=s:a=Math.log(1+r),a}),_K={kernelName:vu,backendName:"cpu",kernelFunc:wK};function SK(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{blockShape:i,paddings:o}=r;G0([a],"spaceToBatchND");const l=be(i),c=[[0,0]];c.push(...o);for(let v=1+i.length;v<a.shape.length;++v)c.push([0,0]);const d=uT.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:c,constantValue:0}}),h=tl(d.shape,i,l,!1),p=xl(h.length,i.length,!1),m=nl(d.shape,i,l,!1),g=dx({inputs:{x:d},backend:n,attrs:{shape:h}}),y=$n({inputs:{x:g},backend:n,attrs:{perm:p}}),b=dx({inputs:{x:y},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),b}const TK={kernelName:vf,backendName:"cpu",kernelFunc:SK};function AK(s){const{inputs:x,backend:n}=s,{indices:r,values:a,denseShape:i,defaultValue:o}=x;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        `+i.shape);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        `+r.shape);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        `+a.shape);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        `+o.shape);const l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values[0],[p,m,g,y,b]=D_(l,r.shape,r.dtype,c,a.dtype,d,h);return[n.makeTensorInfo(m,r.dtype,p),n.makeTensorInfo([m[0]],a.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(v=>Number(v)))),n.makeTensorInfo([b.length],r.dtype,new Int32Array(b))]}const EK={kernelName:Sf,backendName:"cpu",kernelFunc:AK};function CK(s){const{inputs:x,backend:n}=s,{inputIndices:r,inputShape:a,newShape:i}=x;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        `+r.shape);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        `+a.shape);if(i.shape.length!==1)throw new Error("Target shape should be a vector but received shape "+i.shape);const o=Array.from(n.data.get(a.dataId).values),l=n.data.get(r.dataId).values,c=Array.from(n.data.get(i.dataId).values),[d,h,p]=O_(l,r.shape,r.dtype,o,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const MK={kernelName:Tf,backendName:"cpu",kernelFunc:CK};function IK(s){const{inputs:x,backend:n}=s,{data:r,indices:a,segmentIds:i}=x;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          `+a.shape);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          `+i.shape);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h]=Rg(o,r.shape,r.dtype,l,c,!0);return n.makeTensorInfo(h,r.dtype,d)}const kK={kernelName:Af,backendName:"cpu",kernelFunc:IK};function NK(s){const{inputs:x,backend:n}=s,{data:r,indices:a,segmentIds:i}=x;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         `+a.shape);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         `+i.shape);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h]=Rg(o,r.shape,r.dtype,l,c);return n.makeTensorInfo(h,r.dtype,d)}const RK={kernelName:Ef,backendName:"cpu",kernelFunc:NK};function PK(s){const{inputs:x,backend:n,attrs:r}=s,{sparseIndices:a,sparseValues:i,defaultValue:o}=x,{outputShape:l}=r,{sliceRank:c,numUpdates:d,sliceSize:h,strides:p,outputSize:m}=el(i,a,l),g=!1,y=n.bufferSync(a);let b;switch(i.dtype){case"bool":{const v=n.bufferSync(i),w=Boolean(n.data.get(o.dataId).values[0]);b=Ni(y,v,l,m,h,d,c,p,w,g);break}case"float32":{const v=n.bufferSync(i),w=n.data.get(o.dataId).values[0];b=Ni(y,v,l,m,h,d,c,p,w,g);break}case"int32":{const v=n.bufferSync(i),w=n.data.get(o.dataId).values[0];b=Ni(y,v,l,m,h,d,c,p,w,g);break}case"string":{const v=n.bufferSync(i),w=os(n.data.get(o.dataId).values[0]);b=Ni(y,v,l,m,h,d,c,p,w,g);break}default:throw new Error("Unsupported type "+i.dtype)}return n.makeTensorInfo(l,b.dtype,b.values)}const LK={kernelName:Cf,backendName:"cpu",kernelFunc:PK};function DK(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{numOrSizeSplits:i,axis:o}=r,l=_0(o,a.shape)[0],c=xg(a,i,l),d=new Array(a.shape.length).fill(0),h=a.shape.slice();return c.map(p=>{const m=[...h];m[l]=p;const g=va({inputs:{x:a},backend:n,attrs:{begin:d,size:m}});return d[l]+=p,g})}const OK={kernelName:wf,backendName:"cpu",kernelFunc:DK},FK={kernelName:zy,backendName:"cpu",kernelFunc:({inputs:s,backend:x})=>{const{x:n}=s,r=x;G0(n,"square");const a=r.data.get(n.dataId).values,i=new Float32Array(a.length);for(let o=0;o<a.length;++o){const l=a[o];i[o]=l*l}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},UK=nx(Cu,(s,x)=>{const n=x;return isNaN(s)?NaN:s>0?1:n.alpha}),BK={kernelName:Cu,backendName:"cpu",kernelFunc:UK};function zK(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{begin:i,end:o,strides:l,beginMask:c,endMask:d,ellipsisMask:h,newAxisMask:p,shrinkAxisMask:m}=r;G0(a,"stridedSlice");const{finalShapeSparse:g,finalShape:y,isIdentity:b,sliceDim0:v,isSimpleSlice:w,begin:_,end:T,strides:A}=Dm(a.shape,i,o,l,c,d,h,p,m);let E;if(b)E=dx({inputs:{x:a},backend:n,attrs:{shape:y}});else if(v||w){G(a.shape.length>=1,()=>"Input must have rank at least 1, got: "+a.shape.length);const M=Nm(_,T,A),I=va({inputs:{x:a},backend:n,attrs:{begin:_,size:M}});E=dx({inputs:{x:I},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(I)}else{const M=n.bufferSync(a),I=U_(g,M,A,_);E=n.makeTensorInfo(y,I.dtype,I.values)}return E}const WK={kernelName:Mf,backendName:"cpu",kernelFunc:zK};function GK(s){const{inputs:x,backend:n,attrs:r}=s,{separator:a,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:d}=r,{data:h,dataSplits:p}=x,m=n.data.get(h.dataId).values,g=n.data.get(p.dataId).values,[y,b]=B_(m,g,a,i,o,l,c,d);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",b)]}const VK={kernelName:If,backendName:"cpu",kernelFunc:GK};function HK(s){const{inputs:x,backend:n,attrs:r}=s,{skipEmpty:a}=r,{input:i,delimiter:o}=x;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error("Input must be a vector, got shape: "+i.shape);if(o.shape.length!==0)throw new Error("Delimiter must be a scalar, got shape: "+o.shape);const l=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values[0],[d,h,p]=z_(l,c,a),m=h.length;return[n.makeTensorInfo([m,2],"int32",d),n.makeTensorInfo([m],"string",h),n.makeTensorInfo([2],"int32",new Int32Array(p))]}const YK={kernelName:kf,backendName:"cpu",kernelFunc:HK};function qK(s){const{inputs:x,backend:n,attrs:r}=s,{numBuckets:a}=r,{input:i}=x;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.data.get(i.dataId).values,l=W_(o,a);return n.makeTensorInfo(i.shape,"int32",l)}const XK={kernelName:Nf,backendName:"cpu",kernelFunc:qK},KK=nx(Tu,s=>Math.tan(s)),$K={kernelName:Tu,backendName:"cpu",kernelFunc:KK},ZK=nx(Au,s=>Math.tanh(s)),JK={kernelName:Au,backendName:"cpu",kernelFunc:ZK};function QK(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{reps:i}=r;G0(a,"tile");const o=V_(n.bufferSync(a),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const jK={kernelName:Eu,backendName:"cpu",kernelFunc:QK};function e$(s){const{inputs:x,backend:n,attrs:r}=s,{x:a}=x,{k:i,sorted:o}=r;G0(a,"topk");const l=n.data.get(a.dataId).values,[c,d]=Y_(l,a.shape,a.dtype,i,o);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(d.shape,d.dtype,d.values)]}const t$={kernelName:Rf,backendName:"cpu",kernelFunc:e$};function x$(s){const{inputs:x,attrs:n,backend:r}=s,{image:a,transforms:i}=x,{interpolation:o,fillMode:l,fillValue:c,outputShape:d}=n,[h,p,m,g]=a.shape,[y,b]=d??[p,m],v=[h,y,b,g],w=U0(a.shape),_=w[0],T=w[1],A=w[2],E=U0(v),M=E[0],I=E[1],C=E[2],k=Ke(a.dtype,be(v));k.fill(c);const O=r.data.get(a.dataId).values,z=r.data.get(i.dataId).values;for(let ee=0;ee<h;++ee){const re=i.shape[0]===1?z:z.subarray(ee*8,ee*8+8);for(let Y=0;Y<y;++Y)for(let Q=0;Q<b;++Q)for(let te=0;te<g;++te){let se;const xe=re[6]*Q+re[7]*Y+1;if(xe===0)continue;const ae=(re[0]*Q+re[1]*Y+re[2])/xe,le=(re[3]*Q+re[4]*Y+re[5])/xe,de=hT(ae,m,l),ue=hT(le,p,l);switch(o){case"nearest":se=o$(O,p,m,_,T,A,ee,ue,de,te,c);break;case"bilinear":se=l$(O,p,m,_,T,A,ee,ue,de,te,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+o)}const ge=ee*M+Y*I+Q*C+te;k[ge]=se}return r.makeTensorInfo(v,a.dtype,k)}return{dataId:r.write(k,v,a.dtype),shape:a.shape,dtype:a.dtype}}const n$={kernelName:Pf,backendName:"cpu",kernelFunc:x$};function hT(s,x,n){switch(n){case"reflect":return r$(s,x);case"wrap":return s$(s,x);case"nearest":return i$(s,x);case"constant":default:return a$(s)}}function r$(s,x){let n=s;if(n<0)if(x<=1)n=0;else{const r=2*x;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-x?n+r:-n-1}else if(n>x-1)if(x<=1)n=0;else{const r=2*x;n-=r*Math.trunc(n/r),n>=x&&(n=r-n-1)}return w0(0,n,x-1)}function s$(s,x){let n=s;if(n<0)if(x<=1)n=0;else{const r=x-1;n+=x*(Math.trunc(-n/r)+1)}else if(n>x-1)if(x<=1)n=0;else{const r=x-1;n-=x*Math.trunc(n/r)}return w0(0,n,x-1)}function a$(s,x){return s}function i$(s,x){return w0(0,s,x-1)}function bl(s,x,n,r,a,i,o,l,c,d,h){const p=o*r+l*a+c*i+d;return 0<=l&&l<x&&0<=c&&c<n?s[p]:h}function o$(s,x,n,r,a,i,o,l,c,d,h){const p=Math.round(l),m=Math.round(c);return bl(s,x,n,r,a,i,o,p,m,d,h)}function l$(s,x,n,r,a,i,o,l,c,d,h){const p=Math.floor(l),m=Math.floor(c),g=p+1,y=m+1,b=(y-c)*bl(s,x,n,r,a,i,o,p,m,d,h)+(c-m)*bl(s,x,n,r,a,i,o,p,y,d,h),v=(y-c)*bl(s,x,n,r,a,i,o,g,m,d,h)+(c-m)*bl(s,x,n,r,a,i,o,g,y,d,h);return(g-l)*b+(l-p)*v}function c$(s){const{inputs:x,attrs:n,backend:r}=s,{axis:a}=n,{x:i}=x;G0(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:l,outputShape:c,indices:d}=q_(o,a,i.shape,i.dtype);return[r.makeTensorInfo(c,i.dtype,l),r.makeTensorInfo([d.length],"int32",d)]}const u$={kernelName:Lf,backendName:"cpu",kernelFunc:c$};function d$(s){const{inputs:x,backend:n,attrs:r}=s,{value:a}=x;let{axis:i}=r;i<0&&(i+=a.shape.length);const o=a.shape.length,l=a.shape[i],c=new Array(o-1);let d=0;for(let g=0;g<o;g++)g!==i&&(c[d++]=a.shape[g]);const h=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const m=new Array(l);for(let g=0;g<m.length;g++){h[i]=g;const y=va({inputs:{x:a},backend:n,attrs:{begin:h,size:p}});m[g]=dx({inputs:{x:y},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(y)}return m}const h$={kernelName:Df,backendName:"cpu",kernelFunc:d$};function p$(s){const{inputs:x,backend:n,attrs:r}=s,{x:a,segmentIds:i}=x,{numSegments:o}=r;G0(a,"unsortedSegmentSum");const l=a.shape.length,c=i.shape.length,d=[],h=[],p=l-c;let m=i;for(let y=0;y<p;++y){const b=Id({inputs:{input:m},backend:n,attrs:{dim:y+1}});m=b,h.push(b)}for(let y=0;y<o;++y){const b=as(y,"int32"),v=n.makeTensorInfo([],"int32",b),w=s_({inputs:{a:v,b:m},backend:n}),_=ms({inputs:{x:w},backend:n,attrs:{dtype:"float32"}}),T=md({inputs:{a:_,b:a},backend:n}),A=yl({inputs:{x:T},backend:n,attrs:{axis:0,keepDims:!1}});d.push(A),h.push(v),h.push(w),h.push(_),h.push(T),h.push(A)}const g=cT({inputs:d,backend:n,attrs:{axis:0}});return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const f$={kernelName:Of,backendName:"cpu",kernelFunc:p$},m$=[uH,u7,hH,fH,g7,gH,bH,wH,SH,AH,CH,IH,NH,LH,OH,BH,WH,VH,YH,lH,XH,$H,JH,jH,f7,b7,tY,d7,nY,sY,aY,oY,cY,dY,pY,mY,yY,vY,_Y,TY,EY,MY,kY,NY,PY,DY,FY,UY,BY,zY,VY,xH,YY,v7,jY,w7,eq,S7,aq,iq,lq,A7,dq,pq,mq,yq,vq,C7,I7,h7,_q,rY,Tq,Eq,Mq,nH,N7,P7,kq,D7,Rq,Dq,Fq,zq,Gq,Hq,Yq,F7,Xq,$q,Jq,jq,tX,nX,sX,B7,iX,cX,hX,W7,V7,mX,bX,_X,Y7,TX,EX,CX,uT,NX,sH,K7,PX,DX,FX,BX,p7,Yg,WX,aH,iH,oH,VX,YX,XX,$X,JX,QX,eK,xL,xK,iK,lK,hK,rL,fK,gK,bK,sL,uX,_K,TK,EK,MK,kK,RK,LK,OK,oL,FK,cL,BK,WK,VK,YK,XK,pL,WY,$K,JK,jK,t$,n$,q7,u$,h$,f$,AX];for(const s of m$)Vy(s);class g${constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=45/180*Math.PI,this.ratio=1920/1080,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(x,n){var r,a;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const i=vt(()=>{const m=zx(Ov(x,3),"float32"),g=gt(Ht(m,255*.5),1);return Rr(g,0)}),[o,l]=[i.shape[1],i.shape[2]];if(this.bodyTracks.length===0){const m=await((r=this.bodyDetector)==null?void 0:r.process(i))||[];this.bodyTracks=m.map(g=>({center:g.points[0],top:g.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new c5))}const c=this.bodyTracks.length>0?await((a=this.poseDetector)==null?void 0:a.process(i,this.bodyTracks))||[]:[];c.forEach((m,g)=>{var y;if((y=this.poseAligner)==null||y.alignPoints(m.keypoints),n===void 0)return;const b=l/o,v=m.top[0]-m.center[0],w=(m.top[1]-m.center[1])/b,_=Math.sqrt(v*v+w*w)*2*(1+b)*.5;c[g]=this.poseFilters[g].filter(m,n,1/_)}),i.dispose();let d=[],h=[],p=[];for(let m=0;m<this.bodyTracks.length;m++){const g={center:[this.bodyTracks[m].center[0]*l,this.bodyTracks[m].center[1]*o],top:[this.bodyTracks[m].top[0]*l,this.bodyTracks[m].top[1]*o]};let y={center:[c[m].center[0]*l,c[m].center[1]*o],top:[c[m].top[0]*l,c[m].top[1]*o]};const b=[g,y].map(v=>{const{center:w,top:_}=v,T=[_[0]-w[0],_[1]-w[1]],A=Math.sqrt(T[0]*T[0]+T[1]*T[1]);return[[w[0]-A,w[1]-A],[w[0]+A,w[1]+A]]});d5(b[0],b[1])>.5&&c[m].score>this.poseScore&&(d.push({center:[...c[m].center],top:[...c[m].top]}),h.push(this.poseFilters[m]),p.push(c[m]))}return this.bodyTracks=d,this.poseFilters=h,p}setCamera(x,n,r=1){var a;this.angle=x,this.ratio=n,this.near=r,(a=this.poseAligner)==null||a.setCamera(x,n,r)}async init(x,n="./",r=!1,a=!1,i="webgl"){const o=await Sw({locateFile:m=>n+m});o.Loader.prototype.promisify=function(m,...g){return m.call(this,...g),new Promise(y=>{const b=setInterval(()=>{if(this.ready)return clearInterval(b),y(this.status)},5)})},o.Loader.prototype.load=function(m){return this.promisify(this.loadAsync,m,r)},o.Loader.prototype.remove=function(m){return this.promisify(this.removeAsync,m)},o.DictLoader.prototype.loadDict=function(m){return this.promisify(this.loadDictAsync,x,m)};const l=new o.ParseLoader(n);if(r||(await l.remove("pose.wasm"),await l.remove("poseutils.wasm")),!await l.loadDict(["pose.wasm","poseutils.wasm"])||!await l.load("pose.wasm")||!l.parse())return;Ib(i);const c={weightUrlConverter:async m=>m,fetchFunc:async m=>{const g=new Blob([l.file(m)]);return fetch(URL.createObjectURL(g))}},d=await ad("bodymodel.def",c),h=await ad("posemodel.def",c);if(this.bodyDetector=new s5(d),this.poseDetector=new a5(h,a),!await l.load("poseutils.wasm"))return;const p=await h5({wasmBinary:l.data()});l.delete(),p.PoseAligner.prototype.alignPoints=function(m){const g=new p.VectorFloat,y=new p.VectorFloat,b=new p.VectorFloat,v=new p.VectorFloat;m.forEach(_=>{g.push_back(_.pixel[0]),g.push_back(_.pixel[1]),g.push_back(_.pixel[2]),y.push_back(_.metric[0]),y.push_back(_.metric[1]),y.push_back(_.metric[2]),b.push_back(_.score),v.push_back(_.visibility)});const w=this.align(g,y,b,v);m.forEach((_,T)=>{_.metric=[w.get(T*3),w.get(T*3+1),w.get(T*3+2)]}),g.delete(),y.delete(),b.delete(),v.delete(),w.delete()},this.poseModule=p,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax}async prepare(){var x,n;await((x=this.bodyDetector)==null?void 0:x.prepare()),await((n=this.poseDetector)==null?void 0:n.prepare())}dispose(){var x,n,r;this.reset(),(x=this.bodyDetector)==null||x.dispose(),(n=this.poseDetector)==null||n.dispose(),(r=this.poseAligner)==null||r.delete()}}var y$=Object.defineProperty,pT=Object.getOwnPropertySymbols,b$=Object.prototype.hasOwnProperty,v$=Object.prototype.propertyIsEnumerable,fT=(s,x,n)=>x in s?y$(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,w$=(s,x)=>{for(var n in x||(x={}))b$.call(x,n)&&fT(s,n,x[n]);if(pT)for(var n of pT(x))v$.call(x,n)&&fT(s,n,x[n]);return s};class _${constructor(x){this.facesMax=3,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=6,this.model=x,this.modelSize=x.inputs[0].shape?{width:x.inputs[0].shape[2],height:x.inputs[0].shape[1]}:{width:128,height:128},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchors=oa(this.anchorsData),this.size=Xn([this.modelSize.width,this.modelSize.height])}async process(x,n){var r;let a={x:0,y:0};const[i,o,l]=vt(()=>{const v={width:x.shape[2],height:x.shape[1]},w=v.width/v.height;let _=w$({},v),T={x:0,y:0};w>this.modelRatio?(_.height=v.width/this.modelRatio,T.y=Math.floor((_.height-v.height)*.5),a.y=T.y/_.height):w<this.modelRatio&&(_.width=v.height*this.modelRatio,T.x=Math.floor((_.width-v.width)*.5),a.x=T.x/_.width);const A=sa(x,[[0,0],[T.y,T.y],[T.x,T.x],[0,0]],0),E=dr.resizeBilinear(A,[this.modelSize.height,this.modelSize.width]),M=qn(this.model.execute(E,"objects")),I=this.decodeBoxes(M,this.anchors,this.size),C=Ct(M,[0,0],[-1,1]),k=qn(fs(C));return[M,I,k]}),c=await dr.nonMaxSuppressionAsync(o,l,this.facesMax,this.iouThresh,this.scoreThresh),d=await c.array();c.dispose();const h=d.map(v=>({box:Ct(o,[v,0],[1,-1]),score:Ct(l,v,1),anchorI:v,keypoints:n?Be(Ct(i,[v,this.keypointCount-1],[1,-1]),[this.keypointCount,-1]):void 0})),p=await Promise.all(h.map(async v=>{var w,_;const T=await v.box.array(),A=await v.score.array(),E=await((w=v.keypoints)==null?void 0:w.array());return v.box.dispose(),v.score.dispose(),(_=v.keypoints)==null||_.dispose(),{box:T.flat(),score:A[0],anchorI:v.anchorI,keypoints:E}})),m={width:1-2*a.x,height:1-2*a.y};a.x/=m.width,a.y/=m.height;const g=this.modelSize.width*m.width,y=this.modelSize.height*m.height,b=[];for(let v=0;v<p.length;v++){const w=p[v].box,_=this.anchorsData[p[v].anchorI];b.push({rect:{xy:{x:w[0]/g-a.x,y:w[1]/y-a.y},size:{width:(w[2]-w[0])/g,height:(w[3]-w[1])/y}},score:p[v].score,keypoints:(r=p[v].keypoints)==null?void 0:r.map(T=>({x:(T[0]+_[0])/g-a.x,y:(T[1]+_[1])/y-a.y}))})}return i.dispose(),o.dispose(),l.dispose(),b}decodeBoxes(x,n,r){const a=Ct(x,[0,1],[-1,2]),i=j0(a,n),o=Ct(x,[0,3],[-1,2]),l=Ht(o,2),c=gt(i,l),d=j0(i,l);return Wu([c,d],1)}buildAnchors(x){const n=[8,16],r=[2,6],a=[];for(let i=0;i<n.length;i++){const o=n[i],l=Math.floor((x.height+o-1)/o),c=Math.floor((x.width+o-1)/o),d=r[i];for(let h=0;h<l;h++){const p=o*(h+.5);for(let m=0;m<c;m++){const g=o*(m+.5);for(let y=0;y<d;y++)a.push([g,p])}}}return a}async prepare(){const x=vt(()=>{const{width:n,height:r}=this.modelSize,a=X2([1,r,n,3]);return this.model.execute(a,"objects")});await x.array(),x.dispose()}dispose(){this.model.dispose(),this.anchors.dispose()}}var Kg=(s=>(s[s.EyeR=0]="EyeR",s[s.EyeL=1]="EyeL",s[s.Nose=2]="Nose",s[s.Mouth=3]="Mouth",s[s.EarR=4]="EarR",s[s.EarL=5]="EarL",s))(Kg||{}),S$=Object.defineProperty,T$=Object.defineProperties,A$=Object.getOwnPropertyDescriptors,mT=Object.getOwnPropertySymbols,E$=Object.prototype.hasOwnProperty,C$=Object.prototype.propertyIsEnumerable,gT=(s,x,n)=>x in s?S$(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,M$=(s,x)=>{for(var n in x||(x={}))E$.call(x,n)&&gT(s,n,x[n]);if(mT)for(var n of mT(x))C$.call(x,n)&&gT(s,n,x[n]);return s},I$=(s,x)=>T$(s,A$(x));class k${constructor(x){this.boxFactor=1.5,this.symmetryPoints=[13,168],this.model=x,this.modelSize=x.inputs[0].shape?{width:x.inputs[0].shape[2],height:x.inputs[0].shape[1]}:{width:192,height:192},this.modelHighP=this.model.outputs.length===7}async process(x,n){const r=n.map(i=>{const{xy:o,size:l}=i.rect,c={width:l.width*this.boxFactor,height:l.height*this.boxFactor},d={x:o.x+l.width/2,y:o.y+l.height/2},h={xy:{x:d.x-c.width/2,y:d.y-c.height/2},size:c};return I$(M$({},i),{rect:h})});let a={width:x.shape[2],height:x.shape[1]};return vt(()=>r.map((i,o)=>{const l=Math.atan2((i.symmetry[1].x-i.symmetry[0].x)*a.width,(i.symmetry[0].y-i.symmetry[1].y)*a.height),{xy:c,size:d}=i.rect,h=[c.x+d.width/2,c.y+d.height/2],p=dr.rotateWithOffset(x,l,0,h),m=[c.y,c.x,c.y+d.height,c.x+d.width],g=dr.cropAndResize(p,[m],[0],[this.modelSize.height,this.modelSize.width]),y=this.modelHighP?["output_mesh_identity","output_faceflag","output_lips","Identity_1:0","Identity_5:0","Identity_2:0","Identity_6:0"]:["output_mesh","output_faceflag"],[b,v,w,_,T,A,E]=this.model.execute(g,y),M=Be(b,[-1,3]).arraySync(),I=v.arraySync().flat()[0];if(w){const se=Be(w,[-1,2]).arraySync();$g(M,se,N$)}if(_&&T){const se=Be(_,[-1,2]).arraySync(),xe=Be(T,[-1,2]).arraySync();$g(M,se,R$),$g(M,xe,P$)}if(A&&E){const se=Be(A,[-1,2]).arraySync(),xe=Be(E,[-1,2]).arraySync(),ae=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173].map(de=>M[de]),le=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398].map(de=>M[de]);M.push(...se.map(de=>[de[0],de[1],yT(de,ae)])),M.push(...xe.map(de=>[de[0],de[1],yT(de,le)]))}const C=[d.width*a.width/this.modelSize.width,d.height*a.height/this.modelSize.height],k=M.map(se=>[(se[0]-this.modelSize.width/2)*C[0],(se[1]-this.modelSize.height/2)*C[1],se[2]*C[0]]),O=Math.sin(l),z=Math.cos(l),ee=k.map(se=>[(se[0]*z-se[1]*O)/a.width+h[0],(se[0]*O+se[1]*z)/a.height+h[1],se[2]/a.width]),re=k.map(se=>se[0]),Y=k.map(se=>se[1]),Q=[Math.min(...re)/a.width,Math.min(...Y)/a.height],te=[Math.max(...re)/a.width,Math.max(...Y)/a.height];return{keypoints:ee,score:I,rect:[Q[0]+h[0],Q[1]+h[1],te[0]-Q[0],te[1]-Q[1]]}}))}async prepare(){const x=vt(()=>{const{width:n,height:r}=this.modelSize,a=X2([1,r,n,3]);return this.model.execute(a)});await Promise.all(x.map(async n=>{await n.array(),n.dispose()}))}dispose(){this.model.dispose()}}function qne(s,x){return s.keypoints.forEach(n=>{n[0]*=x,n[1]*=x,n[2]*=x}),s.rect.forEach(n=>{}),s}function $g(s,x,n){for(let r=0;r<n.length;r++)s[n[r]][0]=x[r][0],s[n[r]][1]=x[r][1]}function yT(s,x){let n=0,r=Number.MAX_VALUE;for(let a=0;a<x.length;a++){const i=[x[a][0]-s[0],x[a][1]-s[1]],o=i[0]*i[0]+i[1]*i[1];o<r&&(r=o,n=a)}return x[n][2]}const N$=null,R$=null,P$=null;var L$=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(x){x=x||{};var n=typeof x<"u"?x:{},r,a;n.ready=new Promise(function(L,P){r=L,a=P});var i=Object.assign({},n),o=!0,l="";function c(L){return n.locateFile?n.locateFile(L,l):l+L}var d;typeof document<"u"&&document.currentScript&&(l=document.currentScript.src),s&&(l=s),l.indexOf("blob:")!==0?l=l.substr(0,l.replace(/[?#].*/,"").lastIndexOf("/")+1):l="",n.print||console.log.bind(console);var h=n.printErr||console.warn.bind(console);Object.assign(n,i),i=null,n.arguments&&n.arguments,n.thisProgram&&n.thisProgram,n.quit&&n.quit;var p;n.wasmBinary&&(p=n.wasmBinary),n.noExitRuntime,typeof WebAssembly!="object"&&Ye("no native wasm support detected");var m,g=!1;function y(L,P){L||Ye(P)}var b=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function v(L,P,B){for(var j=P+B,fe=P;L[fe]&&!(fe>=j);)++fe;if(fe-P>16&&L.buffer&&b)return b.decode(L.subarray(P,fe));for(var _e="";P<fe;){var Se=L[P++];if(!(Se&128)){_e+=String.fromCharCode(Se);continue}var ve=L[P++]&63;if((Se&224)==192){_e+=String.fromCharCode((Se&31)<<6|ve);continue}var Ue=L[P++]&63;if((Se&240)==224?Se=(Se&15)<<12|ve<<6|Ue:Se=(Se&7)<<18|ve<<12|Ue<<6|L[P++]&63,Se<65536)_e+=String.fromCharCode(Se);else{var Qe=Se-65536;_e+=String.fromCharCode(55296|Qe>>10,56320|Qe&1023)}}return _e}function w(L,P){return L?v(Y,L,P):""}function _(L,P,B,j){if(!(j>0))return 0;for(var fe=B,_e=B+j-1,Se=0;Se<L.length;++Se){var ve=L.charCodeAt(Se);if(ve>=55296&&ve<=57343){var Ue=L.charCodeAt(++Se);ve=65536+((ve&1023)<<10)|Ue&1023}if(ve<=127){if(B>=_e)break;P[B++]=ve}else if(ve<=2047){if(B+1>=_e)break;P[B++]=192|ve>>6,P[B++]=128|ve&63}else if(ve<=65535){if(B+2>=_e)break;P[B++]=224|ve>>12,P[B++]=128|ve>>6&63,P[B++]=128|ve&63}else{if(B+3>=_e)break;P[B++]=240|ve>>18,P[B++]=128|ve>>12&63,P[B++]=128|ve>>6&63,P[B++]=128|ve&63}}return P[B]=0,B-fe}function T(L,P,B){return _(L,Y,P,B)}function A(L){for(var P=0,B=0;B<L.length;++B){var j=L.charCodeAt(B);j>=55296&&j<=57343&&(j=65536+((j&1023)<<10)|L.charCodeAt(++B)&1023),j<=127?++P:j<=2047?P+=2:j<=65535?P+=3:P+=4}return P}var E=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function M(L,P){for(var B=L,j=B>>1,fe=j+P/2;!(j>=fe)&&te[j];)++j;if(B=j<<1,B-L>32&&E)return E.decode(Y.subarray(L,B));for(var _e="",Se=0;!(Se>=P/2);++Se){var ve=Q[L+Se*2>>1];if(ve==0)break;_e+=String.fromCharCode(ve)}return _e}function I(L,P,B){if(B===void 0&&(B=2147483647),B<2)return 0;B-=2;for(var j=P,fe=B<L.length*2?B/2:L.length,_e=0;_e<fe;++_e){var Se=L.charCodeAt(_e);Q[P>>1]=Se,P+=2}return Q[P>>1]=0,P-j}function C(L){return L.length*2}function k(L,P){for(var B=0,j="";!(B>=P/4);){var fe=se[L+B*4>>2];if(fe==0)break;if(++B,fe>=65536){var _e=fe-65536;j+=String.fromCharCode(55296|_e>>10,56320|_e&1023)}else j+=String.fromCharCode(fe)}return j}function O(L,P,B){if(B===void 0&&(B=2147483647),B<4)return 0;for(var j=P,fe=j+B-4,_e=0;_e<L.length;++_e){var Se=L.charCodeAt(_e);if(Se>=55296&&Se<=57343){var ve=L.charCodeAt(++_e);Se=65536+((Se&1023)<<10)|ve&1023}if(se[P>>2]=Se,P+=4,P+4>fe)break}return se[P>>2]=0,P-j}function z(L){for(var P=0,B=0;B<L.length;++B){var j=L.charCodeAt(B);j>=55296&&j<=57343&&++B,P+=4}return P}var ee,re,Y,Q,te,se,xe,ae,le;function de(L){ee=L,n.HEAP8=re=new Int8Array(L),n.HEAP16=Q=new Int16Array(L),n.HEAP32=se=new Int32Array(L),n.HEAPU8=Y=new Uint8Array(L),n.HEAPU16=te=new Uint16Array(L),n.HEAPU32=xe=new Uint32Array(L),n.HEAPF32=ae=new Float32Array(L),n.HEAPF64=le=new Float64Array(L)}n.INITIAL_MEMORY;var ue,ge=[],pe=[],Le=[];function we(){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)i0(n.preRun.shift());$(ge)}function e0(){$(pe)}function Ze(){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;)v0(n.postRun.shift());$(Le)}function i0(L){ge.unshift(L)}function We(L){pe.unshift(L)}function v0(L){Le.unshift(L)}var Te=0,Ie=null;function Xe(L){Te++,n.monitorRunDependencies&&n.monitorRunDependencies(Te)}function c0(L){if(Te--,n.monitorRunDependencies&&n.monitorRunDependencies(Te),Te==0&&Ie){var P=Ie;Ie=null,P()}}function Ye(L){n.onAbort&&n.onAbort(L),L="Aborted("+L+")",h(L),g=!0,L+=". Build with -sASSERTIONS for more info.";var P=new WebAssembly.RuntimeError(L);throw a(P),P}var I0="data:application/octet-stream;base64,";function m0(L){return L.startsWith(I0)}var d0;d0="faceutils.wasm",m0(d0)||(d0=c(d0));function rt(L){try{if(L==d0&&p)return new Uint8Array(p);throw"both async and sync fetching of the wasm failed"}catch(P){Ye(P)}}function ct(){return!p&&o&&typeof fetch=="function"?fetch(d0,{credentials:"same-origin"}).then(function(L){if(!L.ok)throw"failed to load wasm binary file at '"+d0+"'";return L.arrayBuffer()}).catch(function(){return rt(d0)}):Promise.resolve().then(function(){return rt(d0)})}function ie(){var L={a:Ro};function P(Se,ve){var Ue=Se.exports;n.asm=Ue,m=n.asm.B,de(m.buffer),ue=n.asm.F,We(n.asm.C),c0()}Xe();function B(Se){P(Se.instance)}function j(Se){return ct().then(function(ve){return WebAssembly.instantiate(ve,L)}).then(function(ve){return ve}).then(Se,function(ve){h("failed to asynchronously prepare wasm: "+ve),Ye(ve)})}function fe(){return!p&&typeof WebAssembly.instantiateStreaming=="function"&&!m0(d0)&&typeof fetch=="function"?fetch(d0,{credentials:"same-origin"}).then(function(Se){var ve=WebAssembly.instantiateStreaming(Se,L);return ve.then(B,function(Ue){return h("wasm streaming compile failed: "+Ue),h("falling back to ArrayBuffer instantiation"),j(B)})}):j(B)}if(n.instantiateWasm)try{var _e=n.instantiateWasm(L,P);return _e}catch(Se){return h("Module.instantiateWasm callback failed with error: "+Se),!1}return fe().catch(a),{}}function $(L){for(;L.length>0;){var P=L.shift();if(typeof P=="function"){P(n);continue}var B=P.func;typeof B=="number"?P.arg===void 0?Ge(B)():Ge(B)(P.arg):B(P.arg===void 0?null:P.arg)}}var ke=[];function Ge(L){var P=ke[L];return P||(L>=ke.length&&(ke.length=L+1),ke[L]=P=ue.get(L)),P}function s0(L){return _r(L+24)+24}function p0(L){this.excPtr=L,this.ptr=L-24,this.set_type=function(P){xe[this.ptr+4>>2]=P},this.get_type=function(){return xe[this.ptr+4>>2]},this.set_destructor=function(P){xe[this.ptr+8>>2]=P},this.get_destructor=function(){return xe[this.ptr+8>>2]},this.set_refcount=function(P){se[this.ptr>>2]=P},this.set_caught=function(P){P=P?1:0,re[this.ptr+12>>0]=P},this.get_caught=function(){return re[this.ptr+12>>0]!=0},this.set_rethrown=function(P){P=P?1:0,re[this.ptr+13>>0]=P},this.get_rethrown=function(){return re[this.ptr+13>>0]!=0},this.init=function(P,B){this.set_adjusted_ptr(0),this.set_type(P),this.set_destructor(B),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var P=se[this.ptr>>2];se[this.ptr>>2]=P+1},this.release_ref=function(){var P=se[this.ptr>>2];return se[this.ptr>>2]=P-1,P===1},this.set_adjusted_ptr=function(P){xe[this.ptr+16>>2]=P},this.get_adjusted_ptr=function(){return xe[this.ptr+16>>2]},this.get_exception_ptr=function(){var P=F(this.get_type());if(P)return xe[this.excPtr>>2];var B=this.get_adjusted_ptr();return B!==0?B:this.excPtr}}function K0(L,P,B){var j=new p0(L);throw j.init(P,B),L}var Re={};function L0(L){for(;L.length;){var P=L.pop(),B=L.pop();B(P)}}function u0(L){return this.fromWireType(xe[L>>2])}var D0={},b0={},et={},Et=48,xx=57;function ye(L){if(L===void 0)return"_unknown";L=L.replace(/[^a-zA-Z0-9_]/g,"$");var P=L.charCodeAt(0);return P>=Et&&P<=xx?"_"+L:L}function k0(L,P){return L=ye(L),function(){return P.apply(this,arguments)}}function Fe(L,P){var B=k0(P,function(j){this.name=P,this.message=j;var fe=new Error(j).stack;fe!==void 0&&(this.stack=this.toString()+`
`+fe.replace(/^Error(:[^\n]*)?\n/,""))});return B.prototype=Object.create(L.prototype),B.prototype.constructor=B,B.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},B}var h0=void 0;function f0(L){throw new h0(L)}function Y0(L,P,B){L.forEach(function(ve){et[ve]=P});function j(ve){var Ue=B(ve);Ue.length!==L.length&&f0("Mismatched type converter count");for(var Qe=0;Qe<L.length;++Qe)Cx(L[Qe],Ue[Qe])}var fe=new Array(P.length),_e=[],Se=0;P.forEach((ve,Ue)=>{b0.hasOwnProperty(ve)?fe[Ue]=b0[ve]:(_e.push(ve),D0.hasOwnProperty(ve)||(D0[ve]=[]),D0[ve].push(()=>{fe[Ue]=b0[ve],++Se,Se===_e.length&&j(fe)}))}),_e.length===0&&j(fe)}function ox(L){var P=Re[L];delete Re[L];var B=P.elements,j=B.length,fe=B.map(function(ve){return ve.getterReturnType}).concat(B.map(function(ve){return ve.setterArgumentType})),_e=P.rawConstructor,Se=P.rawDestructor;Y0([L],fe,function(ve){return B.forEach((Ue,Qe)=>{var g0=ve[Qe],E0=Ue.getter,ot=Ue.getterContext,St=ve[Qe+j],Kt=Ue.setter,mt=Ue.setterContext;Ue.read=Mx=>g0.fromWireType(E0(ot,Mx)),Ue.write=(Mx,Fx)=>{var Cn=[];Kt(mt,Mx,St.toWireType(Cn,Fx)),L0(Cn)}}),[{name:P.name,fromWireType:function(Ue){for(var Qe=new Array(j),g0=0;g0<j;++g0)Qe[g0]=B[g0].read(Ue);return Se(Ue),Qe},toWireType:function(Ue,Qe){if(j!==Qe.length)throw new TypeError("Incorrect number of tuple elements for "+P.name+": expected="+j+", actual="+Qe.length);for(var g0=_e(),E0=0;E0<j;++E0)B[E0].write(g0,Qe[E0]);return Ue!==null&&Ue.push(Se,g0),g0},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:Se}]})}var qt={};function jx(L){var P=qt[L];delete qt[L];var B=P.rawConstructor,j=P.rawDestructor,fe=P.fields,_e=fe.map(Se=>Se.getterReturnType).concat(fe.map(Se=>Se.setterArgumentType));Y0([L],_e,Se=>{var ve={};return fe.forEach((Ue,Qe)=>{var g0=Ue.fieldName,E0=Se[Qe],ot=Ue.getter,St=Ue.getterContext,Kt=Se[Qe+fe.length],mt=Ue.setter,Mx=Ue.setterContext;ve[g0]={read:Fx=>E0.fromWireType(ot(St,Fx)),write:(Fx,Cn)=>{var Tx=[];mt(Mx,Fx,Kt.toWireType(Tx,Cn)),L0(Tx)}}}),[{name:P.name,fromWireType:function(Ue){var Qe={};for(var g0 in ve)Qe[g0]=ve[g0].read(Ue);return j(Ue),Qe},toWireType:function(Ue,Qe){for(var g0 in ve)if(!(g0 in Qe))throw new TypeError('Missing field:  "'+g0+'"');var E0=B();for(g0 in ve)ve[g0].write(E0,Qe[g0]);return Ue!==null&&Ue.push(j,E0),E0},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:j}]})}function Jt(L,P,B,j,fe){}function Dx(L){switch(L){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+L)}}function zt(){for(var L=new Array(256),P=0;P<256;++P)L[P]=String.fromCharCode(P);en=L}var en=void 0;function o0(L){for(var P="",B=L;Y[B];)P+=en[Y[B++]];return P}var yx=void 0;function ut(L){throw new yx(L)}function Cx(L,P,B={}){if(!("argPackAdvance"in P))throw new TypeError("registerType registeredInstance requires argPackAdvance");var j=P.name;if(L||ut('type "'+j+'" must have a positive integer typeid pointer'),b0.hasOwnProperty(L)){if(B.ignoreDuplicateRegistrations)return;ut("Cannot register type '"+j+"' twice")}if(b0[L]=P,delete et[L],D0.hasOwnProperty(L)){var fe=D0[L];delete D0[L],fe.forEach(_e=>_e())}}function Ox(L,P,B,j,fe){var _e=Dx(B);P=o0(P),Cx(L,{name:P,fromWireType:function(Se){return!!Se},toWireType:function(Se,ve){return ve?j:fe},argPackAdvance:8,readValueFromPointer:function(Se){var ve;if(B===1)ve=re;else if(B===2)ve=Q;else if(B===4)ve=se;else throw new TypeError("Unknown boolean type size: "+P);return this.fromWireType(ve[Se>>_e])},destructorFunction:null})}function ne(L){if(!(this instanceof mx)||!(L instanceof mx))return!1;for(var P=this.$$.ptrType.registeredClass,B=this.$$.ptr,j=L.$$.ptrType.registeredClass,fe=L.$$.ptr;P.baseClass;)B=P.upcast(B),P=P.baseClass;for(;j.baseClass;)fe=j.upcast(fe),j=j.baseClass;return P===j&&B===fe}function Ee(L){return{count:L.count,deleteScheduled:L.deleteScheduled,preservePointerOnDelete:L.preservePointerOnDelete,ptr:L.ptr,ptrType:L.ptrType,smartPtr:L.smartPtr,smartPtrType:L.smartPtrType}}function De(L){function P(B){return B.$$.ptrType.registeredClass.name}ut(P(L)+" instance already deleted")}var Ne=!1;function qe(L){}function at(L){L.smartPtr?L.smartPtrType.rawDestructor(L.smartPtr):L.ptrType.registeredClass.rawDestructor(L.ptr)}function lt(L){L.count.value-=1;var P=L.count.value===0;P&&at(L)}function ht(L,P,B){if(P===B)return L;if(B.baseClass===void 0)return null;var j=ht(L,P,B.baseClass);return j===null?null:B.downcast(j)}var dt={};function kt(){return Object.keys(xn).length}function Mt(){var L=[];for(var P in xn)xn.hasOwnProperty(P)&&L.push(xn[P]);return L}var pt=[];function Xt(){for(;pt.length;){var L=pt.pop();L.$$.deleteScheduled=!1,L.delete()}}var cn=void 0;function tn(L){cn=L,pt.length&&cn&&cn(Xt)}function z2(){n.getInheritedInstanceCount=kt,n.getLiveInheritedInstances=Mt,n.flushPendingDeletes=Xt,n.setDelayFunction=tn}var xn={};function _t(L,P){for(P===void 0&&ut("ptr should not be undefined");L.baseClass;)P=L.upcast(P),L=L.baseClass;return P}function W2(L,P){return P=_t(L,P),xn[P]}function Qt(L,P){(!P.ptrType||!P.ptr)&&f0("makeClassHandle requires ptr and ptrType");var B=!!P.smartPtrType,j=!!P.smartPtr;return B!==j&&f0("Both smartPtrType and smartPtr must be specified"),P.count={value:1},bn(Object.create(L,{$$:{value:P}}))}function Hx(L){var P=this.getPointee(L);if(!P)return this.destructor(L),null;var B=W2(this.registeredClass,P);if(B!==void 0){if(B.$$.count.value===0)return B.$$.ptr=P,B.$$.smartPtr=L,B.clone();var j=B.clone();return this.destructor(L),j}function fe(){return this.isSmartPointer?Qt(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:P,smartPtrType:this,smartPtr:L}):Qt(this.registeredClass.instancePrototype,{ptrType:this,ptr:L})}var _e=this.registeredClass.getActualType(P),Se=dt[_e];if(!Se)return fe.call(this);var ve;this.isConst?ve=Se.constPointerType:ve=Se.pointerType;var Ue=ht(P,this.registeredClass,ve.registeredClass);return Ue===null?fe.call(this):this.isSmartPointer?Qt(ve.registeredClass.instancePrototype,{ptrType:ve,ptr:Ue,smartPtrType:this,smartPtr:L}):Qt(ve.registeredClass.instancePrototype,{ptrType:ve,ptr:Ue})}function bn(L){return typeof FinalizationRegistry>"u"?(bn=P=>P,L):(Ne=new FinalizationRegistry(P=>{lt(P.$$)}),bn=P=>{var B=P.$$,j=!!B.smartPtr;if(j){var fe={$$:B};Ne.register(P,fe,P)}return P},qe=P=>Ne.unregister(P),bn(L))}function e2(){if(this.$$.ptr||De(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var L=bn(Object.create(Object.getPrototypeOf(this),{$$:{value:Ee(this.$$)}}));return L.$$.count.value+=1,L.$$.deleteScheduled=!1,L}function xs(){this.$$.ptr||De(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&ut("Object already scheduled for deletion"),qe(this),lt(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function Yx(){return!this.$$.ptr}function vn(){return this.$$.ptr||De(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&ut("Object already scheduled for deletion"),pt.push(this),pt.length===1&&cn&&cn(Xt),this.$$.deleteScheduled=!0,this}function br(){mx.prototype.isAliasOf=ne,mx.prototype.clone=e2,mx.prototype.delete=xs,mx.prototype.isDeleted=Yx,mx.prototype.deleteLater=vn}function mx(){}function An(L,P,B){if(L[P].overloadTable===void 0){var j=L[P];L[P]=function(){return L[P].overloadTable.hasOwnProperty(arguments.length)||ut("Function '"+B+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+L[P].overloadTable+")!"),L[P].overloadTable[arguments.length].apply(this,arguments)},L[P].overloadTable=[],L[P].overloadTable[j.argCount]=j}}function sr(L,P,B){n.hasOwnProperty(L)?((B===void 0||n[L].overloadTable!==void 0&&n[L].overloadTable[B]!==void 0)&&ut("Cannot register public name '"+L+"' twice"),An(n,L,L),n.hasOwnProperty(B)&&ut("Cannot register multiple overloads of a function with the same number of arguments ("+B+")!"),n[L].overloadTable[B]=P):(n[L]=P,B!==void 0&&(n[L].numArguments=B))}function Us(L,P,B,j,fe,_e,Se,ve){this.name=L,this.constructor=P,this.instancePrototype=B,this.rawDestructor=j,this.baseClass=fe,this.getActualType=_e,this.upcast=Se,this.downcast=ve,this.pureVirtualFunctions=[]}function Bs(L,P,B){for(;P!==B;)P.upcast||ut("Expected null or instance of "+B.name+", got an instance of "+P.name),L=P.upcast(L),P=P.baseClass;return L}function zs(L,P){if(P===null)return this.isReference&&ut("null is not a valid "+this.name),0;P.$$||ut('Cannot pass "'+ai(P)+'" as a '+this.name),P.$$.ptr||ut("Cannot pass deleted object as a pointer of type "+this.name);var B=P.$$.ptrType.registeredClass,j=Bs(P.$$.ptr,B,this.registeredClass);return j}function sc(L,P){var B;if(P===null)return this.isReference&&ut("null is not a valid "+this.name),this.isSmartPointer?(B=this.rawConstructor(),L!==null&&L.push(this.rawDestructor,B),B):0;P.$$||ut('Cannot pass "'+ai(P)+'" as a '+this.name),P.$$.ptr||ut("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&P.$$.ptrType.isConst&&ut("Cannot convert argument of type "+(P.$$.smartPtrType?P.$$.smartPtrType.name:P.$$.ptrType.name)+" to parameter type "+this.name);var j=P.$$.ptrType.registeredClass;if(B=Bs(P.$$.ptr,j,this.registeredClass),this.isSmartPointer)switch(P.$$.smartPtr===void 0&&ut("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:P.$$.smartPtrType===this?B=P.$$.smartPtr:ut("Cannot convert argument of type "+(P.$$.smartPtrType?P.$$.smartPtrType.name:P.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:B=P.$$.smartPtr;break;case 2:if(P.$$.smartPtrType===this)B=P.$$.smartPtr;else{var fe=P.clone();B=this.rawShare(B,wr.toHandle(function(){fe.delete()})),L!==null&&L.push(this.rawDestructor,B)}break;default:ut("Unsupporting sharing policy")}return B}function ac(L,P){if(P===null)return this.isReference&&ut("null is not a valid "+this.name),0;P.$$||ut('Cannot pass "'+ai(P)+'" as a '+this.name),P.$$.ptr||ut("Cannot pass deleted object as a pointer of type "+this.name),P.$$.ptrType.isConst&&ut("Cannot convert argument of type "+P.$$.ptrType.name+" to parameter type "+this.name);var B=P.$$.ptrType.registeredClass,j=Bs(P.$$.ptr,B,this.registeredClass);return j}function ic(L){return this.rawGetPointee&&(L=this.rawGetPointee(L)),L}function Ws(L){this.rawDestructor&&this.rawDestructor(L)}function v2(L){L!==null&&L.delete()}function oc(){w2.prototype.getPointee=ic,w2.prototype.destructor=Ws,w2.prototype.argPackAdvance=8,w2.prototype.readValueFromPointer=u0,w2.prototype.deleteObject=v2,w2.prototype.fromWireType=Hx}function w2(L,P,B,j,fe,_e,Se,ve,Ue,Qe,g0){this.name=L,this.registeredClass=P,this.isReference=B,this.isConst=j,this.isSmartPointer=fe,this.pointeeType=_e,this.sharingPolicy=Se,this.rawGetPointee=ve,this.rawConstructor=Ue,this.rawShare=Qe,this.rawDestructor=g0,!fe&&P.baseClass===void 0?j?(this.toWireType=zs,this.destructorFunction=null):(this.toWireType=ac,this.destructorFunction=null):this.toWireType=sc}function lc(L,P,B){n.hasOwnProperty(L)||f0("Replacing nonexistant public symbol"),n[L].overloadTable!==void 0&&B!==void 0?n[L].overloadTable[B]=P:(n[L]=P,n[L].argCount=B)}function _2(L,P,B){var j=n["dynCall_"+L];return B&&B.length?j.apply(null,[P].concat(B)):j.call(null,P)}function Wn(L,P,B){return L.includes("j")?_2(L,P,B):Ge(P).apply(null,B)}function Ao(L,P){var B=[];return function(){return B.length=0,Object.assign(B,arguments),Wn(L,P,B)}}function qx(L,P){L=o0(L);function B(){return L.includes("j")?Ao(L,P):Ge(P)}var j=B();return typeof j!="function"&&ut("unknown function pointer with signature "+L+": "+P),j}var vr=void 0;function S2(L){var P=W(L),B=o0(P);return Hn(P),B}function ar(L,P){var B=[],j={};function fe(_e){if(!j[_e]&&!b0[_e]){if(et[_e]){et[_e].forEach(fe);return}B.push(_e),j[_e]=!0}}throw P.forEach(fe),new vr(L+": "+B.map(S2).join([", "]))}function Eo(L,P,B,j,fe,_e,Se,ve,Ue,Qe,g0,E0,ot){g0=o0(g0),_e=qx(fe,_e),ve&&(ve=qx(Se,ve)),Qe&&(Qe=qx(Ue,Qe)),ot=qx(E0,ot);var St=ye(g0);sr(St,function(){ar("Cannot construct "+g0+" due to unbound types",[j])}),Y0([L,P,B],j?[j]:[],function(Kt){Kt=Kt[0];var mt,Mx;j?(mt=Kt.registeredClass,Mx=mt.instancePrototype):Mx=mx.prototype;var Fx=k0(St,function(){if(Object.getPrototypeOf(this)!==Cn)throw new yx("Use 'new' to construct "+g0);if(Tx.constructor_body===void 0)throw new yx(g0+" has no accessible constructor");var Sr=Tx.constructor_body[arguments.length];if(Sr===void 0)throw new yx("Tried to invoke ctor of "+g0+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(Tx.constructor_body).toString()+") parameters instead!");return Sr.apply(this,arguments)}),Cn=Object.create(Mx,{constructor:{value:Fx}});Fx.prototype=Cn;var Tx=new Us(g0,Fx,Cn,ot,mt,_e,ve,Qe),Tc=new w2(g0,Tx,!0,!1,!1),Kh=new w2(g0+"*",Tx,!1,!1,!1),$h=new w2(g0+" const*",Tx,!1,!0,!1);return dt[L]={pointerType:Kh,constPointerType:$h},lc(St,Fx),[Tc,Kh,$h]})}function ir(L,P){for(var B=[],j=0;j<L;j++)B.push(se[(P>>2)+j]);return B}function cc(L,P,B,j,fe,_e){y(P>0);var Se=ir(P,B);fe=qx(j,fe),Y0([],[L],function(ve){ve=ve[0];var Ue="constructor "+ve.name;if(ve.registeredClass.constructor_body===void 0&&(ve.registeredClass.constructor_body=[]),ve.registeredClass.constructor_body[P-1]!==void 0)throw new yx("Cannot register multiple constructors with identical number of parameters ("+(P-1)+") for class '"+ve.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return ve.registeredClass.constructor_body[P-1]=()=>{ar("Cannot construct "+ve.name+" due to unbound types",Se)},Y0([],Se,function(Qe){return Qe.splice(1,0,null),ve.registeredClass.constructor_body[P-1]=Gs(Ue,Qe,null,fe,_e),[]}),[]})}function Gs(L,P,B,j,fe){var _e=P.length;_e<2&&ut("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var Se=P[1]!==null&&B!==null,ve=!1,Ue=1;Ue<P.length;++Ue)if(P[Ue]!==null&&P[Ue].destructorFunction===void 0){ve=!0;break}var Qe=P[0].name!=="void",g0=_e-2,E0=new Array(g0),ot=[],St=[];return function(){arguments.length!==g0&&ut("function "+L+" called with "+arguments.length+" arguments, expected "+g0+" args!"),St.length=0;var Kt;ot.length=Se?2:1,ot[0]=fe,Se&&(Kt=P[1].toWireType(St,this),ot[1]=Kt);for(var mt=0;mt<g0;++mt)E0[mt]=P[mt+2].toWireType(St,arguments[mt]),ot.push(E0[mt]);var Mx=j.apply(null,ot);function Fx(Cn){if(ve)L0(St);else for(var Tx=Se?1:2;Tx<P.length;Tx++){var Tc=Tx===1?Kt:E0[Tx-2];P[Tx].destructorFunction!==null&&P[Tx].destructorFunction(Tc)}if(Qe)return P[0].fromWireType(Cn)}return Fx(Mx)}}function ni(L,P,B,j,fe,_e,Se,ve){var Ue=ir(B,j);P=o0(P),_e=qx(fe,_e),Y0([],[L],function(Qe){Qe=Qe[0];var g0=Qe.name+"."+P;P.startsWith("@@")&&(P=Symbol[P.substring(2)]),ve&&Qe.registeredClass.pureVirtualFunctions.push(P);function E0(){ar("Cannot call "+g0+" due to unbound types",Ue)}var ot=Qe.registeredClass.instancePrototype,St=ot[P];return St===void 0||St.overloadTable===void 0&&St.className!==Qe.name&&St.argCount===B-2?(E0.argCount=B-2,E0.className=Qe.name,ot[P]=E0):(An(ot,P,g0),ot[P].overloadTable[B-2]=E0),Y0([],Ue,function(Kt){var mt=Gs(g0,Kt,Qe,_e,Se);return ot[P].overloadTable===void 0?(mt.argCount=B-2,ot[P]=mt):ot[P].overloadTable[B-2]=mt,[]}),[]})}function Vs(L,P,B){return L instanceof Object||ut(B+' with invalid "this": '+L),L instanceof P.registeredClass.constructor||ut(B+' incompatible with "this" of type '+L.constructor.name),L.$$.ptr||ut("cannot call emscripten binding method "+B+" on deleted object"),Bs(L.$$.ptr,L.$$.ptrType.registeredClass,P.registeredClass)}function Gn(L,P,B,j,fe,_e,Se,ve,Ue,Qe){P=o0(P),fe=qx(j,fe),Y0([],[L],function(g0){g0=g0[0];var E0=g0.name+"."+P,ot={get:function(){ar("Cannot access "+E0+" due to unbound types",[B,Se])},enumerable:!0,configurable:!0};return Ue?ot.set=()=>{ar("Cannot access "+E0+" due to unbound types",[B,Se])}:ot.set=St=>{ut(E0+" is a read-only property")},Object.defineProperty(g0.registeredClass.instancePrototype,P,ot),Y0([],Ue?[B,Se]:[B],function(St){var Kt=St[0],mt={get:function(){var Fx=Vs(this,g0,E0+" getter");return Kt.fromWireType(fe(_e,Fx))},enumerable:!0};if(Ue){Ue=qx(ve,Ue);var Mx=St[1];mt.set=function(Fx){var Cn=Vs(this,g0,E0+" setter"),Tx=[];Ue(Qe,Cn,Mx.toWireType(Tx,Fx)),L0(Tx)}}return Object.defineProperty(g0.registeredClass.instancePrototype,P,mt),[]}),[]})}var Hs=[],Vn=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Co(L){L>4&&--Vn[L].refcount===0&&(Vn[L]=void 0,Hs.push(L))}function ri(){for(var L=0,P=5;P<Vn.length;++P)Vn[P]!==void 0&&++L;return L}function wn(){for(var L=5;L<Vn.length;++L)if(Vn[L]!==void 0)return Vn[L];return null}function si(){n.count_emval_handles=ri,n.get_first_emval=wn}var wr={toValue:L=>(L||ut("Cannot use deleted val. handle = "+L),Vn[L].value),toHandle:L=>{switch(L){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var P=Hs.length?Hs.pop():Vn.length;return Vn[P]={refcount:1,value:L},P}}}};function uc(L,P){P=o0(P),Cx(L,{name:P,fromWireType:function(B){var j=wr.toValue(B);return Co(B),j},toWireType:function(B,j){return wr.toHandle(j)},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:null})}function ai(L){if(L===null)return"null";var P=typeof L;return P==="object"||P==="array"||P==="function"?L.toString():""+L}function En(L,P){switch(P){case 2:return function(B){return this.fromWireType(ae[B>>2])};case 3:return function(B){return this.fromWireType(le[B>>3])};default:throw new TypeError("Unknown float type: "+L)}}function dc(L,P,B){var j=Dx(B);P=o0(P),Cx(L,{name:P,fromWireType:function(fe){return fe},toWireType:function(fe,_e){return _e},argPackAdvance:8,readValueFromPointer:En(P,j),destructorFunction:null})}function ii(L,P,B){switch(P){case 0:return B?function(j){return re[j]}:function(j){return Y[j]};case 1:return B?function(j){return Q[j>>1]}:function(j){return te[j>>1]};case 2:return B?function(j){return se[j>>2]}:function(j){return xe[j>>2]};default:throw new TypeError("Unknown integer type: "+L)}}function hc(L,P,B,j,fe){P=o0(P);var _e=Dx(B),Se=E0=>E0;if(j===0){var ve=32-8*B;Se=E0=>E0<<ve>>>ve}var Ue=P.includes("unsigned"),Qe=(E0,ot)=>{},g0;Ue?g0=function(E0,ot){return Qe(ot,this.name),ot>>>0}:g0=function(E0,ot){return Qe(ot,this.name),ot},Cx(L,{name:P,fromWireType:Se,toWireType:g0,argPackAdvance:8,readValueFromPointer:ii(P,_e,j!==0),destructorFunction:null})}function pc(L,P,B){var j=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],fe=j[P];function _e(Se){Se=Se>>2;var ve=xe,Ue=ve[Se],Qe=ve[Se+1];return new fe(ee,Qe,Ue)}B=o0(B),Cx(L,{name:B,fromWireType:_e,argPackAdvance:8,readValueFromPointer:_e},{ignoreDuplicateRegistrations:!0})}function fc(L,P){P=o0(P);var B=P==="std::string";Cx(L,{name:P,fromWireType:function(j){var fe=xe[j>>2],_e;if(B)for(var Se=j+4,ve=0;ve<=fe;++ve){var Ue=j+4+ve;if(ve==fe||Y[Ue]==0){var Qe=Ue-Se,g0=w(Se,Qe);_e===void 0?_e=g0:(_e+=String.fromCharCode(0),_e+=g0),Se=Ue+1}}else{for(var E0=new Array(fe),ve=0;ve<fe;++ve)E0[ve]=String.fromCharCode(Y[j+4+ve]);_e=E0.join("")}return Hn(j),_e},toWireType:function(j,fe){fe instanceof ArrayBuffer&&(fe=new Uint8Array(fe));var _e,Se=typeof fe=="string";Se||fe instanceof Uint8Array||fe instanceof Uint8ClampedArray||fe instanceof Int8Array||ut("Cannot pass non-string to std::string"),B&&Se?_e=()=>A(fe):_e=()=>fe.length;var ve=_e(),Ue=_r(4+ve+1);if(xe[Ue>>2]=ve,B&&Se)T(fe,Ue+4,ve+1);else if(Se)for(var Qe=0;Qe<ve;++Qe){var g0=fe.charCodeAt(Qe);g0>255&&(Hn(Ue),ut("String has UTF-16 code units that do not fit in 8 bits")),Y[Ue+4+Qe]=g0}else for(var Qe=0;Qe<ve;++Qe)Y[Ue+4+Qe]=fe[Qe];return j!==null&&j.push(Hn,Ue),Ue},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:function(j){Hn(j)}})}function mc(L,P,B){B=o0(B);var j,fe,_e,Se,ve;P===2?(j=M,fe=I,Se=C,_e=()=>te,ve=1):P===4&&(j=k,fe=O,Se=z,_e=()=>xe,ve=2),Cx(L,{name:B,fromWireType:function(Ue){for(var Qe=xe[Ue>>2],g0=_e(),E0,ot=Ue+4,St=0;St<=Qe;++St){var Kt=Ue+4+St*P;if(St==Qe||g0[Kt>>ve]==0){var mt=Kt-ot,Mx=j(ot,mt);E0===void 0?E0=Mx:(E0+=String.fromCharCode(0),E0+=Mx),ot=Kt+P}}return Hn(Ue),E0},toWireType:function(Ue,Qe){typeof Qe!="string"&&ut("Cannot pass non-string to C++ string type "+B);var g0=Se(Qe),E0=_r(4+g0+P);return xe[E0>>2]=g0>>ve,fe(Qe,E0+4,g0+P),Ue!==null&&Ue.push(Hn,E0),E0},argPackAdvance:8,readValueFromPointer:u0,destructorFunction:function(Ue){Hn(Ue)}})}function gc(L,P,B,j,fe,_e){Re[L]={name:o0(P),rawConstructor:qx(B,j),rawDestructor:qx(fe,_e),elements:[]}}function yc(L,P,B,j,fe,_e,Se,ve,Ue){Re[L].elements.push({getterReturnType:P,getter:qx(B,j),getterContext:fe,setterArgumentType:_e,setter:qx(Se,ve),setterContext:Ue})}function bc(L,P,B,j,fe,_e){qt[L]={name:o0(P),rawConstructor:qx(B,j),rawDestructor:qx(fe,_e),fields:[]}}function vc(L,P,B,j,fe,_e,Se,ve,Ue,Qe){qt[L].fields.push({fieldName:o0(P),getterReturnType:B,getter:qx(j,fe),getterContext:_e,setterArgumentType:Se,setter:qx(ve,Ue),setterContext:Qe})}function wc(L,P){P=o0(P),Cx(L,{isVoid:!0,name:P,argPackAdvance:0,fromWireType:function(){},toWireType:function(B,j){}})}function Mo(L){L>4&&(Vn[L].refcount+=1)}function _c(L,P){var B=b0[L];return B===void 0&&ut(P+" has unknown type "+S2(L)),B}function Sc(L,P){L=_c(L,"_emval_take_value");var B=L.readValueFromPointer(P);return wr.toHandle(B)}function Io(){Ye("")}function ko(L,P,B){Y.copyWithin(L,P,P+B)}function T2(){return 2147483648}function Ys(L){try{return m.grow(L-ee.byteLength+65535>>>16),de(m.buffer),1}catch{}}function No(L){var P=Y.length;L=L>>>0;var B=T2();if(L>B)return!1;let j=(Ue,Qe)=>Ue+(Qe-Ue%Qe)%Qe;for(var fe=1;fe<=4;fe*=2){var _e=P*(1+.2/fe);_e=Math.min(_e,L+100663296);var Se=Math.min(B,j(Math.max(L,_e),65536)),ve=Ys(Se);if(ve)return!0}return!1}h0=n.InternalError=Fe(Error,"InternalError"),zt(),yx=n.BindingError=Fe(Error,"BindingError"),br(),z2(),oc(),vr=n.UnboundTypeError=Fe(Error,"UnboundTypeError"),si();var Ro={b:s0,a:K0,i:ox,x:jx,q:Jt,v:Ox,m:Eo,h:cc,c:ni,g:Gn,u:uc,o:dc,f:hc,d:pc,n:fc,k:mc,j:gc,e:yc,y:bc,l:vc,w:wc,z:Co,A:Mo,p:Sc,r:Io,t:ko,s:No};ie(),n.___wasm_call_ctors=function(){return(n.___wasm_call_ctors=n.asm.C).apply(null,arguments)};var Hn=n._free=function(){return(Hn=n._free=n.asm.D).apply(null,arguments)},_r=n._malloc=function(){return(_r=n._malloc=n.asm.E).apply(null,arguments)},W=n.___getTypeName=function(){return(W=n.___getTypeName=n.asm.G).apply(null,arguments)};n.___embind_register_native_and_builtin_types=function(){return(n.___embind_register_native_and_builtin_types=n.asm.H).apply(null,arguments)};var F=n.___cxa_is_pointer_type=function(){return(F=n.___cxa_is_pointer_type=n.asm.I).apply(null,arguments)},oe;Ie=function L(){oe||Me(),oe||(Ie=L)};function Me(L){if(Te>0||(we(),Te>0))return;function P(){oe||(oe=!0,n.calledRun=!0,!g&&(e0(),r(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),Ze()))}n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),P()},1)):P()}if(n.run=Me,n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);n.preInit.length>0;)n.preInit.pop()();return Me(),x.ready}})();class Xne{constructor(){this.faceTracks=[],this.faceFilters=[],this.meshScore=.9}async process(x,n){var r,a,i,o;const l=vt(()=>{const y=zx(Ov(x,3),"float32"),b=gt(Ht(y,255*.5),1);return Rr(b,0)}),c=Ce().get("WEBGL_PACK_DEPTHWISECONV");Ce().set("WEBGL_PACK_DEPTHWISECONV",!0);let d=[];this.faceTracks.length===0&&(d=await((r=this.faceDetector)==null?void 0:r.process(l,!0))||[],d.forEach(y=>{if(!y.keypoints)return;const{xy:b,size:v}=y.rect,w=b.y+v.height/2,_=v.height*1.3;this.faceTracks.push({rect:{xy:{x:b.x,y:w-_/2},size:{width:v.width,height:_}},symmetry:[y.keypoints[Kg.Mouth],y.keypoints[Kg.Nose]]}),this.faceFilters.push(new this.faceModule.FaceFilter({minCutOff:1,minCutOffD:2,beta:30},{minCutOff:1,minCutOffD:2,beta:30},1))})),Ce().set("WEBGL_PACK_DEPTHWISECONV",c);const h=this.faceTracks.length>0?await((a=this.meshDetector)==null?void 0:a.process(l,this.faceTracks))||[]:[];l.dispose();let p=[],m=[],g=[];for(let y=0;y<this.faceTracks.length;y++){const b=h[y],{rect:v}=b,w={xy:{x:v[0],y:v[1]},size:{width:v[2],height:v[3]}},_=[b.keypoints[((i=this.meshDetector)==null?void 0:i.symmetryPoints[0])||0],b.keypoints[((o=this.meshDetector)==null?void 0:o.symmetryPoints[1])||0]];if(u5(this.faceTracks[y].rect,w)>.5&&b.score>this.meshScore){if(g.push(b),p.push({rect:w,symmetry:[{x:_[0][0],y:_[0][1]},{x:_[1][0],y:_[1][1]}]}),n===void 0)continue;const[T,A]=[l.shape[1],l.shape[2]],{width:E,height:M}=this.faceTracks[y].rect.size,I=(E+M*A/T)*.5;this.faceFilters[y].smoothFilter(b,n,1/I),b.keypoints=this.faceFilters[y].smoothPixel(),m.push(this.faceFilters[y])}else this.faceFilters[y].delete()}return this.faceTracks=p,this.faceFilters=m,g}align(x){var n;const r=new this.faceModule.VectorFloat;return x.flat().forEach(a=>r.push_back(a)),(n=this.faceAligner)==null||n.align(r),r.delete(),this.alignTransform()}alignTransform(){if(!this.faceAligner)return;const x=this.faceAligner.rotation,n=this.faceAligner.translation,r=this.faceAligner.scale,a=this.faceAligner.shapeScale;return{rotation:[x[0],x[1],x[2],x[3]],translation:[n[0],n[1],n[2]],scale:r,shapeScale:[a[0],a[1],a[2]]}}metricPoints(){if(!this.faceAligner)return;let x=[];const n=this.faceAligner.metricPoints();for(let r=0;r<n.size();r+=3)x.push([n.get(r+0),n.get(r+1),n.get(r+2)]);return n.delete(),x}referencePoints(){if(!this.faceAligner)return;let x=[];const n=this.faceAligner.referencePoints();for(let r=0;r<n.size();r+=3)x.push([n.get(r+0),n.get(r+1),n.get(r+2)]);return n.delete(),x}backprojPoints(){if(!this.faceAligner)return;let x=[];const n=this.faceAligner.backprojPoints();for(let r=0;r<n.size();r+=3)x.push([n.get(r+0),n.get(r+1),n.get(r+2)]);return n.delete(),x}setCamera(x,n,r){var a;(a=this.faceAligner)==null||a.setCamera(x,n,r)}async init(x,n="./",r=!1,a=!1,i="webgl"){const o=await Sw({locateFile:y=>n+y});o.Loader.prototype.promisify=function(y,...b){return y.call(this,...b),new Promise(v=>{const w=setInterval(()=>{if(this.ready)return clearInterval(w),v(this.status)},5)})},o.Loader.prototype.load=function(y){return this.promisify(this.loadAsync,y,r)},o.Loader.prototype.remove=function(y){return this.promisify(this.removeAsync,y)},o.DictLoader.prototype.loadDict=function(y){return this.promisify(this.loadDictAsync,x,y)};const l=new o.ParseLoader(n),[c,d]=a?["faceext.wasm","meshextmodel.def"]:["face.wasm","meshmodel.def"];if(r||(await l.remove(c),await l.remove("faceutils.wasm")),!await l.loadDict([c,"faceutils.wasm"])||!await l.load(c)||!l.parse())return;Ib(i);const h={weightUrlConverter:async y=>y,fetchFunc:async y=>{const b=new Blob([l.file(y)]);return fetch(URL.createObjectURL(b))}},p=await ad("facemodel.def",h),m=await ad(d,h);if(this.faceDetector=new _$(p),this.meshDetector=new k$(m),!await l.load("faceutils.wasm"))return;const g=await L$({wasmBinary:l.data()});l.delete(),g.FaceFilter.prototype.smoothFilter=function(y,b){const v=new g.VectorFloat,w=new g.VectorFloat;y.keypoints.flat().forEach(_=>v.push_back(_)),y.rect.forEach(_=>w.push_back(_)),this.filter(v,w,y.score,b,1),v.delete(),w.delete()},g.FaceFilter.prototype.smoothPixel=function(){let y=[];const b=this.pixel();for(let v=0;v<b.size();v+=3)y.push([b.get(v+0),b.get(v+1),b.get(v+2)]);return b.delete(),y},this.faceModule=g,this.faceAligner=new this.faceModule.FaceAligner}reset(){this.faceFilters.forEach(x=>x.delete()),this.faceFilters=[],this.faceTracks=[]}async prepare(){var x,n;await((x=this.faceDetector)==null?void 0:x.prepare()),await((n=this.meshDetector)==null?void 0:n.prepare())}dispose(){var x,n,r;this.reset(),(x=this.faceDetector)==null||x.dispose(),(n=this.meshDetector)==null||n.dispose(),(r=this.faceAligner)==null||r.delete()}}const Kne={lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyebrowUpper:[156,70,63,105,66,107,55],rightEyebrowLower:[124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyebrowUpper:[383,300,293,334,296,336,285],leftEyebrowLower:[353,276,283,282,295],leftEyeIris:[468,469,470,471,472]},$ne=null,Zne=null,Jne=null;class Qne{constructor(){this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.meancolor",this.canvas.hidden=!0,this.canvas.width=1,this.canvas.height=1,this.context=this.canvas.getContext("2d",{alpha:!1,desynchronized:!0})}mean(x){if(!this.context)return;this.context.drawImage(x,0,0,1,1);const n=this.context.getImageData(0,0,1,1);return[n.data[0],n.data[1],n.data[2]]}brightness(x){const n=this.mean(x);return n?(.2989*n[0]+.587*n[1]+.1141*n[2])/255:void 0}dispose(){this.context=null,this.canvas&&document.removeChild(this.canvas),delete this.canvas}}var D$=o2(187);class vl extends D$.EventEmitter{}var O$=Object.defineProperty,bT=Object.getOwnPropertySymbols,F$=Object.prototype.hasOwnProperty,U$=Object.prototype.propertyIsEnumerable,vT=(s,x,n)=>x in s?O$(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,wT=(s,x)=>{for(var n in x||(x={}))F$.call(x,n)&&vT(s,n,x[n]);if(bT)for(var n of bT(x))U$.call(x,n)&&vT(s,n,x[n]);return s};class _T{constructor(x="canvas"){this.size={width:0,height:0},this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+x,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(x){const{context:n}=this;if(!n)return!1;const{width:r,height:a}=this.size;return n.drawImage(x,0,0,r,a),!0}data(){const{context:x}=this;if(!x)return;const{width:n,height:r}=this.size;return x.getImageData(0,0,n,r)}setSize(x){this.size=wT({},x),this.canvas.width=x.width,this.canvas.height=x.height}fill(){const{context:x}=this;!x||(x.fillStyle="rgba(255, 255, 255, 1)",x.fillRect(0,0,this.size.width,this.size.height))}dispose(){this.context=null,this.canvas.remove()}}class B$ extends vl{constructor(){super(),this.buffer=new _T("capture"),this.captureTime=0}async setup(x){const n=x&&(r=>typeof r!="string"&&"size"in r)(x)&&x.size||{width:1920,height:1080};return this.updateSize(n),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return wT({},this.buffer.size)}ratio(){const x=this.buffer.size;return x.width/x.height}updateSize(x){this.buffer.setSize(x),this.emit("resize",this.buffer.size)}}class ST extends B${constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(x){const n=l=>typeof l=="string"||"getVideoTracks"in l,r=l=>"video"in l,a=l=>{if(!l)return{video:!0,audio:!1};if(r(l))return l;const c=l.size;return{video:{facingMode:l.rear?"environment":"user",width:c?.width,height:c?.height},audio:!1}},i=x!==void 0&&n(x)?x:await navigator.mediaDevices.getUserMedia(a(x)).catch(()=>{});if(!i)return!1;const{videoRef:o}=this;return new Promise(l=>{o.onloadedmetadata=()=>{this.updateSize({width:o.videoWidth,height:o.videoHeight}),o.onresize=()=>{this.updateSize({width:o.videoWidth,height:o.videoHeight})},o.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},l(!0)},typeof i=="string"?o.src=i:o.srcObject=i})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(x=>x.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:x,buffer:n}=this,r=x.currentTime+this.timeShift;return r<=this.captureTime?!1:(this.captureTime=r,n.capture(x))}}class z$ extends vl{constructor(x,n,r=ST){super(),this.engineParams=n,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async a=>{const i=await this.setupProcessor(a);return this.emit("init",i),i},this.setup=async a=>{this.pause();const i=await this.setupVideo(a);return this.emit("setup",i),i},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var a;const{video:i,streamCanvas:o,processCanvas:l}=this;if(!i.capture()||!o||!l)return this.enqueue();this.resizeEnabled&&((a=this.resizeBuffer)==null||a.capture(i.buffer.canvas));const c=await this.processor.process(l,i.captureTime);c&&await Promise.all(this.renderers.map(d=>d.update(c,o))),this.enqueue()},this.processor=new x,this.video=new r,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(x){this.renderers.push(x),await x.load(),x.setupVideo(this.video.size(),this.video.ratio()),x.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(x){const{renderers:n}=this,r=n.indexOf(x);r<0||(n[r].dispose(),n.slice(r,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(x){var n;const r=this.resizeEnabled&&((n=this.resizeBuffer)==null?void 0:n.size)||this.video.size();return this.processor.init(x,r,this.video.ratio())}async setupVideo(x){return this.video.reset(),await this.video.setup(x)?(this.setupSize(this.video.size()),!0):!1}async setupSize(x){var n,r;const{width:a,height:i}=x;this.videoRatio=a/i;const o=Math.max(a,i),l=((n=this.engineParams)==null?void 0:n.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,l<o){this.resizeEnabled=!0;const c=o/l;this.resizeBuffer||(this.resizeBuffer=new _T("resize")),this.resizeBuffer.setSize({width:a/c,height:i/c})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((r=this.engineParams)==null?void 0:r.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(x){this.setupSize(x),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(n=>n.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(n=>n.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}class jne extends null{constructor(){super(...arguments),this.iterate=async()=>{var x;const{video:n,streamCanvas:r,processCanvas:a}=this;if(!r||!a)return this.enqueue();const i=this.result&&await this.result;if(i!==void 0&&await Promise.all(this.renderers.map(o=>o.update(i,r))),!n.capture())return delete this.result,this.enqueue();this.resizeEnabled&&((x=this.resizeBuffer)==null||x.capture(n.buffer.canvas)),this.result=this.processor.process(a,n.captureTime),this.enqueue()}}}var W$=Object.defineProperty,TT=Object.getOwnPropertySymbols,G$=Object.prototype.hasOwnProperty,V$=Object.prototype.propertyIsEnumerable,AT=(s,x,n)=>x in s?W$(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,H$=(s,x)=>{for(var n in x||(x={}))G$.call(x,n)&&AT(s,n,x[n]);if(TT)for(var n of TT(x))V$.call(x,n)&&AT(s,n,x[n]);return s};class Y$ extends vl{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(x,n){}async init(x,n,r){return this.params=x,!r&&n&&(r=n?.width/n?.height),this.setupVideo(n||this.videoSize,r||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(x,n){n=n||x.width/x.height,this.videoSize=H$({},x),this.videoRatio=n,this.cameraRatio=n}}class q$ extends vl{constructor(x,n="crop",r=1,a=!1,i=1){super(),this.container=x,this.mode=n,this.layerCount=r,this.mirror=a,this.aspectRatio=i,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=o=>{this.aspectRatio=o,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=o=>{this.mirror=o,this.layers.forEach(l=>{l.style.transform=o?"scaleX(-1)":""})},this.updateSizes=o=>{let l=1,c=1;o>this.aspectRatio?this.mode==="crop"?c=o/this.aspectRatio:l=this.aspectRatio/o:this.mode==="crop"?l=this.aspectRatio/o:c=o/this.aspectRatio;const d=(1-l)/2,h=(1-c)/2,p=l*100+"%",m=c*100+"%",g=d*100+"%",y=h*100+"%";for(const b of this.layers)b.style.width=p,b.style.height=m,b.style.left=g,b.style.top=y;if(this.pads){this.padsSize=d>0?[d,1]:[1,h];const b=10,{clientWidth:v,clientHeight:w}=this.container,_=[2*b/v,2*b/w],T=(this.padsSize[0]+2*_[0])*100+"%",A=(this.padsSize[1]+2*_[1])*100+"%";this.pads[0].style.width=T,this.pads[0].style.height=A,this.pads[1].style.width=T,this.pads[1].style.height=A;const E=-_[0]*100+"%",M=-_[1]*100+"%";this.pads[0].style.top=M,this.pads[1].style.bottom=M,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=E,this.pads[this.mirror?0:1].style.right=E;const I=d>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=I,this.pads[1].style.transform=I;const C="blur("+b+"px)";this.pads[0].style.filter=C,this.pads[1].style.filter=C}this.emit("resize")},this.handleResize=o=>{if(o.length<1)return;const l=o[0].contentRect;this.updateSizes(l.width/l.height)};for(let o=0;o<r;o++){const l=document.createElement("canvas");l.id="engeenee.canvas.layer"+o,l.style.position="absolute",l.style.zIndex=-10*(r-o)+"",this.mirror&&(l.style.transform="scaleX(-1)"),this.container.appendChild(l),this.layers.push(l)}if(this.mode==="pad"){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const o=-10*(this.layerCount+1)+"";for(let l=0;l<2;l++)this.pads[l].id="engeenee.canvas.pad"+l,this.pads[l].style.position="absolute",this.pads[l].style.zIndex=o,this.container.appendChild(this.pads[l])}this.setAspectRatio(i),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var X$=Object.defineProperty,ET=Object.getOwnPropertySymbols,K$=Object.prototype.hasOwnProperty,$$=Object.prototype.propertyIsEnumerable,CT=(s,x,n)=>x in s?X$(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,Z$=(s,x)=>{for(var n in x||(x={}))K$.call(x,n)&&CT(s,n,x[n]);if(ET)for(var n of ET(x))$$.call(x,n)&&CT(s,n,x[n]);return s};class J$ extends vl{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){!this.loaded||(this.loaded=!1)}async update(x,n){!this.loaded||(this.updateVideo(n),this.updateScene(),this.emit("render"))}updateVideo(x){}updateScene(){}dispose(){this.unload()}setupVideo(x,n){this.videoSize=Z$({},x),this.videoRatio=n||x.width/x.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(x,n){this.cameraRatio=x,this.cameraAngle=n}}class Q$ extends J${constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(x=>x.load(this))),super.load()}unload(){this.plugins.forEach(x=>x.unload()),super.unload()}async update(x,n){if(this.loaded)return await this.updatePlugins(x,n),super.update(x,n)}async updatePlugins(x,n){for(let r of this.plugins)r.loaded&&await r.update(x,n)}dispose(){this.plugins.forEach(x=>x.dispose()),this.plugins=[],super.dispose()}async addPlugin(x){this.loaded&&!x.loaded&&await x.load(this),this.plugins.push(x)}removePlugin(x){const{plugins:n}=this,r=n.indexOf(x);r<0||(n[r].dispose(),n.splice(r,1))}removeAllPlugins(){this.plugins.forEach(x=>x.dispose()),this.plugins=[]}setupVideo(x,n){super.setupVideo(x,n),this.plugins.forEach(r=>r.setupVideo(x))}}class j$ extends Q${constructor(x){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:n,height:r}=this.videoSize,{padsSize:a}=this.canvas,i=n*a[0]/(a[0]<.5?1-2*a[0]:1),o=r*a[1]/(a[1]<.5?1-2*a[1]:1);this.canvas.pads[0].width=i,this.canvas.pads[0].height=o,this.canvas.pads[1].width=i,this.canvas.pads[1].height=o},this.canvas=new q$(x.container,x.mode,x.layerCount,x.mirror,x.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")],this.canvas.addListener("resize",this.setupPadding))}updateVideo(x){super.updateVideo(x),this.updatePads(x)}setupVideo(x,n){super.setupVideo(x,n),this.canvas.setAspectRatio(this.videoRatio)}setMirror(x){this.canvas.setMirror(x)}updatePads(x){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:n,height:r}}=this,{width:a,height:i}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,a,i),this.padCtx[0].drawImage(x,0,0,a,i,0,0,a,i),this.padCtx[1].clearRect(0,0,a,i),this.padCtx[1].drawImage(x,n-a,r-i,a,i,0,0,a,i)}}class eZ extends null{constructor(x){super(x),this.videoCtx=null;const n=this.canvas.layers[0];this.videoCtx=n.getContext("2d")}updateVideo(x){const{videoCtx:n}=this;if(!n)return;const{width:r,height:a}=this.videoSize;n.clearRect(0,0,r,a),n.drawImage(x,0,0),super.updateVideo(x)}setupVideo(x,n){super.setupVideo(x,n);const{width:r,height:a}=this.videoSize;this.canvas.layers[0].width=r,this.canvas.layers[0].height=a}}class MT{constructor(x,n={width:1920,height:1080},r=!1,a=!1){this.gl=x,this.size=n,this.grayscale=r,this.linear=a,this.buffer=null,this.resize(n)}update(x){const{gl:n,size:{width:r,height:a}}=this,i=n.getParameter(n.TEXTURE_BINDING_2D),o=n.getParameter(n.UNPACK_FLIP_Y_WEBGL);n.bindTexture(n.TEXTURE_2D,this.buffer),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1),x instanceof Uint8Array?n.texSubImage2D(n.TEXTURE_2D,0,0,0,r,a,this.grayscale?n.RED:n.RGBA,n.UNSIGNED_BYTE,x):n.texSubImage2D(n.TEXTURE_2D,0,0,0,r,a,this.grayscale?n.RED:n.RGBA,n.UNSIGNED_BYTE,x),n.bindTexture(n.TEXTURE_2D,i),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,o)}resize(x){if(x.width===this.size.width&&x.height===this.size.height&&this.buffer)return!0;const{gl:n}=this;if(n.deleteTexture(this.buffer),this.buffer=null,(x.width>0||x.height>0)&&(this.buffer=n.createTexture()),!this.buffer)return!1;const r=this.linear?n.LINEAR:n.NEAREST,a=n.getParameter(n.TEXTURE_BINDING_2D),i=n.getParameter(n.UNPACK_FLIP_Y_WEBGL);return n.bindTexture(n.TEXTURE_2D,this.buffer),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,r),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,r),this.size={width:x.width,height:x.height},n.texStorage2D(n.TEXTURE_2D,1,this.grayscale?n.R8:n.RGBA8,x.width,x.height),n.bindTexture(n.TEXTURE_2D,a),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,i),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}valid(){return!!this.buffer}}var tZ=Object.defineProperty,IT=Object.getOwnPropertySymbols,xZ=Object.prototype.hasOwnProperty,nZ=Object.prototype.propertyIsEnumerable,kT=(s,x,n)=>x in s?tZ(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,NT=(s,x)=>{for(var n in x||(x={}))xZ.call(x,n)&&kT(s,n,x[n]);if(IT)for(var n of IT(x))nZ.call(x,n)&&kT(s,n,x[n]);return s};class RT{constructor(x,n={width:1920,height:1080},r=["image"],a={size:"2f",flip:"1f"},i=sZ,o=rZ,l=!1){this.gl=x,this.size=n,this.inputs=r,this.uniforms=a,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.frameBuffer=null,this.uniformsLoc={},this.positionLoc=0,this.output=new MT(x,n,!1,l),this.compile(i,o),this.resize(n)}process(x,n={}){const{gl:r,output:a}=this;if(!r||!a||x.length!==this.inputs.length)return;const i=this.save(r);r.bindFramebuffer(r.FRAMEBUFFER,this.frameBuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,a.texture(),0),n=NT({flip:[-1]},n),this.prepare(r,x,n),r.drawArrays(r.TRIANGLES,0,6),this.restore(r,i)}render(x,n={}){const{gl:r,output:a}=this;if(!r||!a||x.length!==this.inputs.length)return;const i=this.save(r);r.bindFramebuffer(r.FRAMEBUFFER,null),n=NT({flip:[1]},n),this.prepare(r,x,n),r.drawArrays(r.TRIANGLES,0,6),this.restore(r,i)}resize(x){var n;const{gl:r}=this;this.size={width:x.width,height:x.height},(n=this.output)==null||n.resize(x);const a=r.getParameter(r.CURRENT_PROGRAM);r.useProgram(this.shaderProgram),this.uniformsLoc.size&&r.uniform2f(this.uniformsLoc.size,x.width,x.height),r.useProgram(a)}dispose(){var x;const{gl:n}=this;n.deleteBuffer(this.vertBuffer),this.vertBuffer=null,n.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,n.deleteShader(this.vertShader),this.vertShader=null,n.deleteShader(this.fragShader),this.fragShader=null,n.deleteProgram(this.shaderProgram),this.shaderProgram=null,(x=this.output)==null||x.dispose(),delete this.output}program(){return this.shaderProgram}compile(x,n){const{gl:r}=this,a=this.save(r);if(this.vertBuffer=r.createBuffer(),this.frameBuffer=r.createFramebuffer(),!this.vertBuffer||!this.frameBuffer){r.deleteBuffer(this.vertBuffer),this.vertBuffer=null,r.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null;return}if(r.bindVertexArray(null),r.bindBuffer(r.ARRAY_BUFFER,this.vertBuffer),r.bufferData(r.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),r.STATIC_DRAW),this.vertShader=r.createShader(r.VERTEX_SHADER),this.fragShader=r.createShader(r.FRAGMENT_SHADER),this.shaderProgram=r.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){r.deleteBuffer(this.vertBuffer),this.vertBuffer=null,r.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,r.deleteShader(this.vertShader),this.vertShader=null,r.deleteShader(this.fragShader),this.fragShader=null,r.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}r.shaderSource(this.vertShader,n),r.shaderSource(this.fragShader,x),r.compileShader(this.vertShader),r.compileShader(this.fragShader),r.attachShader(this.shaderProgram,this.vertShader),r.attachShader(this.shaderProgram,this.fragShader),r.linkProgram(this.shaderProgram),r.useProgram(this.shaderProgram),this.positionLoc=r.getAttribLocation(this.shaderProgram,"position"),r.vertexAttribPointer(this.positionLoc,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(this.positionLoc),this.uniformsLoc={};for(let i in this.uniforms)this.uniformsLoc[i]=r.getUniformLocation(this.shaderProgram,i);for(let i=0;i<this.inputs.length;i++)r.uniform1i(r.getUniformLocation(this.shaderProgram,this.inputs[i]),i);this.restore(r,a)}prepare(x,n,r={}){const{size:{width:a,height:i}}=this;for(let o=0;o<n.length;o++)x.activeTexture(x.TEXTURE0+o),x.bindTexture(x.TEXTURE_2D,n[o]);x.useProgram(this.shaderProgram),x.bindVertexArray(null),x.bindBuffer(x.ARRAY_BUFFER,this.vertBuffer),x.vertexAttribPointer(this.positionLoc,2,x.FLOAT,!1,0,0),x.enableVertexAttribArray(this.positionLoc),x.disable(x.CULL_FACE);for(let o in r)switch(this.uniforms[o]){case"1f":this.uniformsLoc[o]&&r[o].length===1&&x.uniform1f(this.uniformsLoc[o],r[o][0]);break;case"2f":this.uniformsLoc[o]&&r[o].length===2&&x.uniform2f(this.uniformsLoc[o],r[o][0],r[o][1]);break;case"3f":this.uniformsLoc[o]&&r[o].length===3&&x.uniform3f(this.uniformsLoc[o],r[o][0],r[o][1],r[o][2]);break;case"4f":this.uniformsLoc[o]&&r[o].length===4&&x.uniform4f(this.uniformsLoc[o],r[o][0],r[o][1],r[o][2],r[o][3]);break}x.viewport(0,0,a,i),x.scissor(0,0,a,i)}save(x){return{program:x.getParameter(x.CURRENT_PROGRAM),arrayBuffer:x.getParameter(x.ARRAY_BUFFER_BINDING),framebuffer:x.getParameter(x.FRAMEBUFFER_BINDING),vertexArray:x.getParameter(x.VERTEX_ARRAY_BINDING),viewport:x.getParameter(x.VIEWPORT),scissor:x.getParameter(x.SCISSOR_BOX),cullFace:x.getParameter(x.CULL_FACE),activeTexture:x.getParameter(x.ACTIVE_TEXTURE),textures:this.inputs.map((n,r)=>(x.activeTexture(x.TEXTURE0+r),x.getParameter(x.TEXTURE_BINDING_2D)))}}restore(x,n){x.useProgram(n.program),x.bindBuffer(x.ARRAY_BUFFER,n.arrayBuffer),x.bindFramebuffer(x.FRAMEBUFFER,n.framebuffer),x.bindVertexArray(n.vertexArray),x.viewport(n.viewport[0],n.viewport[1],n.viewport[2],n.viewport[3]),x.scissor(n.scissor[0],n.scissor[1],n.scissor[2],n.scissor[3]);for(let r=0;r<n.textures.length;r++)x.activeTexture(x.TEXTURE0+r),x.bindTexture(x.TEXTURE_2D,n.textures[r]);x.activeTexture(n.activeTexture),n.cullFace?x.enable(x.CULL_FACE):x.disable(x.CULL_FACE)}}const rZ=`
    attribute vec2 position;
    varying vec2 coords;
    uniform float flip;
    void main() {
        coords = (vec2(position.x, -position.y) + 1.0) * 0.5;
        gl_Position = vec4(position.x, position.y * flip, 0, 1.0);
    }
`,sZ=`
    precision mediump float;
    varying vec2 coords;
    uniform vec2 size;
    uniform sampler2D image;
    void main() {
        gl_FragColor = texture2D(image, coords);
    }
`;class Zg extends j${constructor(x){super(x),this.shaderCtx=null,this.current=null;const n=this.canvas.layers[0];this.shaderCtx=n.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){const{shaderCtx:x,videoSize:n}=this;if(x)return this.shader=new RT(x,n),this.input=new MT(x,n),super.load()}unload(){var x,n;(x=this.input)==null||x.dispose(),delete this.input,(n=this.shader)==null||n.dispose(),delete this.shader,super.unload()}async update(x,n){if(!this.loaded)return;const{input:r}=this,a=r?.texture();if(!(!r||!a))return r?.update(n),this.current=a,super.update(x,n)}updateVideo(x){!this.shader||(this.shader.render([this.current]),super.updateVideo(x))}setupVideo(x,n){var r,a;super.setupVideo(x,n);const{width:i,height:o}=this.videoSize;this.canvas.layers[0].width=i,this.canvas.layers[0].height=o,(r=this.input)==null||r.resize({width:i,height:o}),(a=this.shader)==null||a.resize({width:i,height:o})}}class PT extends Zg{dispose(){delete this.scene,super.dispose()}}class aZ{constructor(){this.loaded=!1}async load(x){this.loaded||(this.renderer=x,this.loaded=!0)}unload(){!this.loaded||(this.loaded=!1)}async update(x,n){this.loaded}dispose(){this.unload()}setupVideo(x){}}class e2e extends null{async load(x){if(!(this.loaded||!(x instanceof eZ)||!x.videoCtx))return this.videoCtx=x.videoCtx,super.load(x)}unload(){!this.loaded||(delete this.videoCtx,super.unload())}}var iZ=Object.defineProperty,LT=Object.getOwnPropertySymbols,oZ=Object.prototype.hasOwnProperty,lZ=Object.prototype.propertyIsEnumerable,DT=(s,x,n)=>x in s?iZ(s,x,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[x]=n,cZ=(s,x)=>{for(var n in x||(x={}))oZ.call(x,n)&&DT(s,n,x[n]);if(LT)for(var n of LT(x))lZ.call(x,n)&&DT(s,n,x[n]);return s};class t2e extends null{constructor(x,n,r,a){super(),this.inputs=x,this.uniforms=n,this.fragSrc=r,this.vertSrc=a,this.size={width:0,height:0}}async load(x){if(!(this.loaded||!(x instanceof Zg)||!x.shaderCtx))return this.shader=new RT(x.shaderCtx,this.size,this.inputs,this.uniforms,this.fragSrc,this.vertSrc),super.load(x)}unload(){var x;!this.loaded||((x=this.shader)==null||x.dispose(),delete this.shader,super.unload())}async update(x,n){var r,a;const{renderer:i}=this;if(!this.loaded||!(i instanceof Zg)||!i.current)return;const o=this.process(x,i.current)&&((a=(r=this.shader)==null?void 0:r.output)==null?void 0:a.texture());o&&(i.current=o)}process(x,n){var r;return(r=this.shader)==null||r.process([n]),!0}setupVideo(x){var n;this.size=cZ({},x),(n=this.shader)==null||n.resize(x)}}class uZ extends aZ{async load(x){if(!(this.loaded||!(x instanceof PT)||!x.scene))return this.scene=x.scene,super.load(x)}unload(){!this.loaded||(delete this.scene,super.unload())}}class x2e{constructor(x,n=!1,r="video",a){this.renderer=x,this.mirror=n,this.sizeMode=r,this.sizeMax=a}async snapshot(){return new Promise(x=>{this.renderer.once("render",()=>{const{renderer:n}=this,{layers:r}=n.canvas;let{width:a,height:i}=n.canvas.layers[0];this.sizeMode==="max"?(a=Math.max(...r.map(d=>d.width)),i=Math.max(...r.map(d=>d.height))):this.sizeMode==="min"&&(a=Math.min(...r.map(d=>d.width)),i=Math.min(...r.map(d=>d.height)));const o=document.createElement("canvas");o.id="engeenee.snapshot",o.hidden=!0,o.width=a,o.height=i;const l=o.getContext("2d",{alpha:!0});if(!l)return;this.mirror&&(l.translate(a,0),l.scale(-1,1)),r.forEach(d=>l.drawImage(d,0,0,a,i));const c=l.getImageData(0,0,a,i);o.remove(),x(c)})})}async snapshotLayers(){return new Promise(x=>{this.renderer.once("render",()=>{const n=document.createElement("canvas");n.id="engeenee.snapshot",n.hidden=!0;const r=n.getContext("2d",{alpha:!0});if(!r)return;const a=this.renderer.canvas.layers.map(i=>{const{width:o,height:l}=i;return n.width=o,n.height=l,r.resetTransform(),this.mirror&&(r.translate(o,0),r.scale(-1,1)),r.drawImage(i,0,0),r.getImageData(0,0,o,l)});n.remove(),x(a)})})}}class dZ{constructor(x,n="video/webm",r=!1,a="video",i,o){this.renderer=x,this.type=n,this.mirror=r,this.sizeMode=a,this.sizeMax=i,this.bitRate=o,this.context=null,this.records=[],this.frame=()=>{var l;const{renderer:c,context:d,stream:h}=this,{width:p,height:m}=this.canvas;!h||!d||(c.canvas.layers.map(g=>d.drawImage(g,0,0,p,m)),(l=h.getVideoTracks()[0])==null||l.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:x,context:n,renderer:r}=this;if(!x||!n)return!1;const{layers:a}=r.canvas;let{width:i,height:o}=a[0];this.sizeMode==="max"?(i=Math.max(...a.map(c=>c.width)),o=Math.max(...a.map(c=>c.height))):this.sizeMode==="min"&&(i=Math.min(...a.map(c=>c.width)),o=Math.min(...a.map(c=>c.height)));const l=Math.max(i,o);if(this.sizeMax&&l>this.sizeMax){const c=this.sizeMax/l;i*=c,o*=c}return x.width=i,x.height=o,n.resetTransform(),this.mirror&&(n.translate(i,0),n.scale(-1,1)),r.on("render",this.frame),this.records=[],this.stream=x.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=c=>this.records.push(c.data),this.recorder.start(),!0}async stop(){const{recorder:x}=this;if(!(!x||x.state!="recording"))return new Promise(n=>{x.onstop=()=>{var r;n(new Blob(this.records,{type:this.type})),this.records=[],(r=this.stream)==null||r.getVideoTracks().forEach(a=>a.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},x.stop()})}dispose(){this.canvas.remove()}}class n2e{constructor(x,n=!1,r="video",a){this.renderer=x,this.mirror=n,this.sizeMode=r,this.sizeMax=a,this.context=null,this.render=()=>{const{canvas:i,context:o}=this;!i||!o||this.renderer.canvas.layers.map(l=>o.drawImage(l,0,0,i.width,i.height))},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.mirror&&(this.canvas.style.transform="scaleX(-1)"),this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:x,context:n,renderer:r}=this;if(!x||!n)return!1;const{layers:a}=r.canvas;let{width:i,height:o}=a[0];this.sizeMode==="max"?(i=Math.max(...a.map(c=>c.width)),o=Math.max(...a.map(c=>c.height))):this.sizeMode==="min"&&(i=Math.min(...a.map(c=>c.width)),o=Math.min(...a.map(c=>c.height)));const l=Math.max(i,o);if(this.sizeMax&&l>this.sizeMax){const c=this.sizeMax/l;i*=c,o*=c}return x.width=i,x.height=o,n.resetTransform(),this.mirror&&(n.translate(i,0),n.scale(-1,1)),this.renderer.on("render",this.render),this.stream=x.captureStream(),!0}pause(){this.renderer.removeListener("render",this.render)}mediaStream(){return this.stream}}class hZ extends null{constructor(){super(...arguments),this.faceTracker=new f,this.cameraAngleBase=10/180*Math.PI}async init(x,n,r){return await this.faceTracker.init(x.token,x.root,x.cache,x.highp),await this.faceTracker.prepare(),super.init(x,n,r)}reset(){this.faceTracker.reset(),super.reset()}dispose(){this.faceTracker.dispose()}async process(x,n){return{faces:(await this.faceTracker.process(x,n)).map(r=>{const a=r&&this.params.transform?this.faceTracker.align(r.keypoints):void 0,i=a&&this.params.metric?this.faceTracker.metricPoints():void 0,o=a&&this.params.backproj?this.faceTracker.backprojPoints():void 0;return{mesh:r,transform:a,metric:i,backproj:o}})}}setupVideo(x,n){super.setupVideo(x,n),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.faceTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.faceTracker.reset()}}class r2e extends null{constructor(x,n=e){super(hZ,x,n)}}class pZ extends Y${constructor(){super(),this.poseTracker=new g$,this.cameraAngleBase=15/180*Math.PI;const x=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=x?512:1024}async init(x,n,r){return await this.poseTracker.init(x.token,x.root,x.cache,x.mask),await this.poseTracker.prepare(),super.init(x,n,r)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(x,n){return{poses:(await this.poseTracker.process(x,n)).map(r=>({points:mZ.reduce((a,i,o)=>(a[i]=r.keypoints[o],a),{}),score:r.score,mask:r.mask,debug:r.debug}))}}setupVideo(x,n){super.setupVideo(x,n),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class fZ extends z${constructor(x,n=ST){super(pZ,x,n)}}const mZ=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];const Jg="143",s2e={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},a2e={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},gZ=0,OT=1,yZ=2,i2e=3,o2e=0,FT=1,bZ=2,wl=3,Ui=0,Z2=1,Sa=2,vZ=1,l2e=2,ws=0,Bi=1,UT=2,BT=3,zT=4,wZ=5,zi=100,_Z=101,SZ=102,WT=103,GT=104,TZ=200,AZ=201,EZ=202,CZ=203,VT=204,HT=205,MZ=206,IZ=207,kZ=208,NZ=209,RZ=210,PZ=0,LZ=1,DZ=2,Qg=3,OZ=4,FZ=5,UZ=6,BZ=7,Nd=0,zZ=1,WZ=2,Wr=0,GZ=1,VZ=2,HZ=3,YZ=4,qZ=5,jg=300,Ta=301,Aa=302,_l=303,Rd=304,Sl=306,Ea=1e3,Zn=1001,Tl=1002,Zx=1003,Pd=1004,c2e=1004,Ld=1005,u2e=1005,Sx=1006,e1=1007,d2e=1007,_s=1008,h2e=1008,Ca=1009,XZ=1010,KZ=1011,YT=1012,$Z=1013,Ma=1014,J2=1015,Gr=1016,ZZ=1017,JZ=1018,Wi=1020,QZ=1021,jZ=1022,Q2=1023,eJ=1024,tJ=1025,Ia=1026,Gi=1027,xJ=1028,nJ=1029,rJ=1030,sJ=1031,aJ=1033,t1=33776,x1=33777,n1=33778,r1=33779,qT=35840,XT=35841,KT=35842,$T=35843,iJ=36196,ZT=37492,JT=37496,QT=37808,jT=37809,eA=37810,tA=37811,xA=37812,nA=37813,rA=37814,sA=37815,aA=37816,iA=37817,oA=37818,lA=37819,cA=37820,uA=37821,dA=36492,oJ=2200,lJ=2201,cJ=2202,Al=2300,Vi=2301,s1=2302,Hi=2400,Yi=2401,Dd=2402,a1=2500,hA=2501,p2e=0,uJ=1,pA=2,Ss=3e3,rx=3001,dJ=3200,hJ=3201,ka=0,pJ=1,f2e="",Vr="srgb",Na="srgb-linear",m2e=0,i1=7680,g2e=7681,y2e=7682,b2e=7683,v2e=34055,w2e=34056,_2e=5386,S2e=512,T2e=513,A2e=514,E2e=515,C2e=516,M2e=517,I2e=518,fJ=519,Od=35044,k2e=35048,N2e=35040,R2e=35045,P2e=35049,L2e=35041,D2e=35046,O2e=35050,F2e=35042,U2e="100",fA="300 es",o1=1035;class qi{addEventListener(x,n){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[x]===void 0&&(r[x]=[]),r[x].indexOf(n)===-1&&r[x].push(n)}hasEventListener(x,n){if(this._listeners===void 0)return!1;const r=this._listeners;return r[x]!==void 0&&r[x].indexOf(n)!==-1}removeEventListener(x,n){if(this._listeners===void 0)return;const a=this._listeners[x];if(a!==void 0){const i=a.indexOf(n);i!==-1&&a.splice(i,1)}}dispatchEvent(x){if(this._listeners===void 0)return;const r=this._listeners[x.type];if(r!==void 0){x.target=this;const a=r.slice(0);for(let i=0,o=a.length;i<o;i++)a[i].call(this,x);x.target=null}}}const Un=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let mA=1234567;const Ra=Math.PI/180,El=180/Math.PI;function f2(){const s=Math.random()*4294967295|0,x=Math.random()*4294967295|0,n=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(Un[s&255]+Un[s>>8&255]+Un[s>>16&255]+Un[s>>24&255]+"-"+Un[x&255]+Un[x>>8&255]+"-"+Un[x>>16&15|64]+Un[x>>24&255]+"-"+Un[n&63|128]+Un[n>>8&255]+"-"+Un[n>>16&255]+Un[n>>24&255]+Un[r&255]+Un[r>>8&255]+Un[r>>16&255]+Un[r>>24&255]).toLowerCase()}function Gx(s,x,n){return Math.max(x,Math.min(n,s))}function l1(s,x){return(s%x+x)%x}function mJ(s,x,n,r,a){return r+(s-x)*(a-r)/(n-x)}function gJ(s,x,n){return s!==x?(n-s)/(x-s):0}function Cl(s,x,n){return(1-n)*s+n*x}function yJ(s,x,n,r){return Cl(s,x,1-Math.exp(-n*r))}function bJ(s,x=1){return x-Math.abs(l1(s,x*2)-x)}function vJ(s,x,n){return s<=x?0:s>=n?1:(s=(s-x)/(n-x),s*s*(3-2*s))}function wJ(s,x,n){return s<=x?0:s>=n?1:(s=(s-x)/(n-x),s*s*s*(s*(s*6-15)+10))}function _J(s,x){return s+Math.floor(Math.random()*(x-s+1))}function SJ(s,x){return s+Math.random()*(x-s)}function TJ(s){return s*(.5-Math.random())}function AJ(s){s!==void 0&&(mA=s);let x=mA+=1831565813;return x=Math.imul(x^x>>>15,x|1),x^=x+Math.imul(x^x>>>7,x|61),((x^x>>>14)>>>0)/4294967296}function EJ(s){return s*Ra}function CJ(s){return s*El}function c1(s){return(s&s-1)===0&&s!==0}function gA(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function Fd(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function MJ(s,x,n,r,a){const i=Math.cos,o=Math.sin,l=i(n/2),c=o(n/2),d=i((x+r)/2),h=o((x+r)/2),p=i((x-r)/2),m=o((x-r)/2),g=i((r-x)/2),y=o((r-x)/2);switch(a){case"XYX":s.set(l*h,c*p,c*m,l*d);break;case"YZY":s.set(c*m,l*h,c*p,l*d);break;case"ZXZ":s.set(c*p,c*m,l*h,l*d);break;case"XZX":s.set(l*h,c*y,c*g,l*d);break;case"YXY":s.set(c*g,l*h,c*y,l*d);break;case"ZYZ":s.set(c*y,c*g,l*h,l*d);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+a)}}function IJ(s,x){switch(x.constructor){case Float32Array:return s;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function kJ(s,x){switch(x.constructor){case Float32Array:return s;case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}var NJ=Object.freeze({__proto__:null,DEG2RAD:Ra,RAD2DEG:El,generateUUID:f2,clamp:Gx,euclideanModulo:l1,mapLinear:mJ,inverseLerp:gJ,lerp:Cl,damp:yJ,pingpong:bJ,smoothstep:vJ,smootherstep:wJ,randInt:_J,randFloat:SJ,randFloatSpread:TJ,seededRandom:AJ,degToRad:EJ,radToDeg:CJ,isPowerOfTwo:c1,ceilPowerOfTwo:gA,floorPowerOfTwo:Fd,setQuaternionFromProperEuler:MJ,normalize:kJ,denormalize:IJ});class n0{constructor(x=0,n=0){n0.prototype.isVector2=!0,this.x=x,this.y=n}get width(){return this.x}set width(x){this.x=x}get height(){return this.y}set height(x){this.y=x}set(x,n){return this.x=x,this.y=n,this}setScalar(x){return this.x=x,this.y=x,this}setX(x){return this.x=x,this}setY(x){return this.y=x,this}setComponent(x,n){switch(x){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+x)}return this}getComponent(x){switch(x){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+x)}}clone(){return new this.constructor(this.x,this.y)}copy(x){return this.x=x.x,this.y=x.y,this}add(x){return this.x+=x.x,this.y+=x.y,this}addScalar(x){return this.x+=x,this.y+=x,this}addVectors(x,n){return this.x=x.x+n.x,this.y=x.y+n.y,this}addScaledVector(x,n){return this.x+=x.x*n,this.y+=x.y*n,this}sub(x){return this.x-=x.x,this.y-=x.y,this}subScalar(x){return this.x-=x,this.y-=x,this}subVectors(x,n){return this.x=x.x-n.x,this.y=x.y-n.y,this}multiply(x){return this.x*=x.x,this.y*=x.y,this}multiplyScalar(x){return this.x*=x,this.y*=x,this}divide(x){return this.x/=x.x,this.y/=x.y,this}divideScalar(x){return this.multiplyScalar(1/x)}applyMatrix3(x){const n=this.x,r=this.y,a=x.elements;return this.x=a[0]*n+a[3]*r+a[6],this.y=a[1]*n+a[4]*r+a[7],this}min(x){return this.x=Math.min(this.x,x.x),this.y=Math.min(this.y,x.y),this}max(x){return this.x=Math.max(this.x,x.x),this.y=Math.max(this.y,x.y),this}clamp(x,n){return this.x=Math.max(x.x,Math.min(n.x,this.x)),this.y=Math.max(x.y,Math.min(n.y,this.y)),this}clampScalar(x,n){return this.x=Math.max(x,Math.min(n,this.x)),this.y=Math.max(x,Math.min(n,this.y)),this}clampLength(x,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(x,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(x){return this.x*x.x+this.y*x.y}cross(x){return this.x*x.y-this.y*x.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(x){return Math.sqrt(this.distanceToSquared(x))}distanceToSquared(x){const n=this.x-x.x,r=this.y-x.y;return n*n+r*r}manhattanDistanceTo(x){return Math.abs(this.x-x.x)+Math.abs(this.y-x.y)}setLength(x){return this.normalize().multiplyScalar(x)}lerp(x,n){return this.x+=(x.x-this.x)*n,this.y+=(x.y-this.y)*n,this}lerpVectors(x,n,r){return this.x=x.x+(n.x-x.x)*r,this.y=x.y+(n.y-x.y)*r,this}equals(x){return x.x===this.x&&x.y===this.y}fromArray(x,n=0){return this.x=x[n],this.y=x[n+1],this}toArray(x=[],n=0){return x[n]=this.x,x[n+1]=this.y,x}fromBufferAttribute(x,n){return this.x=x.getX(n),this.y=x.getY(n),this}rotateAround(x,n){const r=Math.cos(n),a=Math.sin(n),i=this.x-x.x,o=this.y-x.y;return this.x=i*r-o*a+x.x,this.y=i*a+o*r+x.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class m2{constructor(){m2.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(x,n,r,a,i,o,l,c,d){const h=this.elements;return h[0]=x,h[1]=a,h[2]=l,h[3]=n,h[4]=i,h[5]=c,h[6]=r,h[7]=o,h[8]=d,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(x){const n=this.elements,r=x.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],this}extractBasis(x,n,r){return x.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(x){const n=x.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(x){return this.multiplyMatrices(this,x)}premultiply(x){return this.multiplyMatrices(x,this)}multiplyMatrices(x,n){const r=x.elements,a=n.elements,i=this.elements,o=r[0],l=r[3],c=r[6],d=r[1],h=r[4],p=r[7],m=r[2],g=r[5],y=r[8],b=a[0],v=a[3],w=a[6],_=a[1],T=a[4],A=a[7],E=a[2],M=a[5],I=a[8];return i[0]=o*b+l*_+c*E,i[3]=o*v+l*T+c*M,i[6]=o*w+l*A+c*I,i[1]=d*b+h*_+p*E,i[4]=d*v+h*T+p*M,i[7]=d*w+h*A+p*I,i[2]=m*b+g*_+y*E,i[5]=m*v+g*T+y*M,i[8]=m*w+g*A+y*I,this}multiplyScalar(x){const n=this.elements;return n[0]*=x,n[3]*=x,n[6]*=x,n[1]*=x,n[4]*=x,n[7]*=x,n[2]*=x,n[5]*=x,n[8]*=x,this}determinant(){const x=this.elements,n=x[0],r=x[1],a=x[2],i=x[3],o=x[4],l=x[5],c=x[6],d=x[7],h=x[8];return n*o*h-n*l*d-r*i*h+r*l*c+a*i*d-a*o*c}invert(){const x=this.elements,n=x[0],r=x[1],a=x[2],i=x[3],o=x[4],l=x[5],c=x[6],d=x[7],h=x[8],p=h*o-l*d,m=l*c-h*i,g=d*i-o*c,y=n*p+r*m+a*g;if(y===0)return this.set(0,0,0,0,0,0,0,0,0);const b=1/y;return x[0]=p*b,x[1]=(a*d-h*r)*b,x[2]=(l*r-a*o)*b,x[3]=m*b,x[4]=(h*n-a*c)*b,x[5]=(a*i-l*n)*b,x[6]=g*b,x[7]=(r*c-d*n)*b,x[8]=(o*n-r*i)*b,this}transpose(){let x;const n=this.elements;return x=n[1],n[1]=n[3],n[3]=x,x=n[2],n[2]=n[6],n[6]=x,x=n[5],n[5]=n[7],n[7]=x,this}getNormalMatrix(x){return this.setFromMatrix4(x).invert().transpose()}transposeIntoArray(x){const n=this.elements;return x[0]=n[0],x[1]=n[3],x[2]=n[6],x[3]=n[1],x[4]=n[4],x[5]=n[7],x[6]=n[2],x[7]=n[5],x[8]=n[8],this}setUvTransform(x,n,r,a,i,o,l){const c=Math.cos(i),d=Math.sin(i);return this.set(r*c,r*d,-r*(c*o+d*l)+o+x,-a*d,a*c,-a*(-d*o+c*l)+l+n,0,0,1),this}scale(x,n){const r=this.elements;return r[0]*=x,r[3]*=x,r[6]*=x,r[1]*=n,r[4]*=n,r[7]*=n,this}rotate(x){const n=Math.cos(x),r=Math.sin(x),a=this.elements,i=a[0],o=a[3],l=a[6],c=a[1],d=a[4],h=a[7];return a[0]=n*i+r*c,a[3]=n*o+r*d,a[6]=n*l+r*h,a[1]=-r*i+n*c,a[4]=-r*o+n*d,a[7]=-r*l+n*h,this}translate(x,n){const r=this.elements;return r[0]+=x*r[2],r[3]+=x*r[5],r[6]+=x*r[8],r[1]+=n*r[2],r[4]+=n*r[5],r[7]+=n*r[8],this}equals(x){const n=this.elements,r=x.elements;for(let a=0;a<9;a++)if(n[a]!==r[a])return!1;return!0}fromArray(x,n=0){for(let r=0;r<9;r++)this.elements[r]=x[r+n];return this}toArray(x=[],n=0){const r=this.elements;return x[n]=r[0],x[n+1]=r[1],x[n+2]=r[2],x[n+3]=r[3],x[n+4]=r[4],x[n+5]=r[5],x[n+6]=r[6],x[n+7]=r[7],x[n+8]=r[8],x}clone(){return new this.constructor().fromArray(this.elements)}}function yA(s){for(let x=s.length-1;x>=0;--x)if(s[x]>65535)return!0;return!1}const RJ={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Xi(s,x){return new RJ[s](x)}function Ml(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}function Pa(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function Ud(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}const u1={[Vr]:{[Na]:Pa},[Na]:{[Vr]:Ud}},j2={legacyMode:!0,get workingColorSpace(){return Na},set workingColorSpace(s){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(s,x,n){if(this.legacyMode||x===n||!x||!n)return s;if(u1[x]&&u1[x][n]!==void 0){const r=u1[x][n];return s.r=r(s.r),s.g=r(s.g),s.b=r(s.b),s}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(s,x){return this.convert(s,this.workingColorSpace,x)},toWorkingColorSpace:function(s,x){return this.convert(s,x,this.workingColorSpace)}},bA={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},on={r:0,g:0,b:0},er={h:0,s:0,l:0},Bd={h:0,s:0,l:0};function d1(s,x,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?s+(x-s)*6*n:n<1/2?x:n<2/3?s+(x-s)*6*(2/3-n):s}function zd(s,x){return x.r=s.r,x.g=s.g,x.b=s.b,x}class M0{constructor(x,n,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,n===void 0&&r===void 0?this.set(x):this.setRGB(x,n,r)}set(x){return x&&x.isColor?this.copy(x):typeof x=="number"?this.setHex(x):typeof x=="string"&&this.setStyle(x),this}setScalar(x){return this.r=x,this.g=x,this.b=x,this}setHex(x,n=Vr){return x=Math.floor(x),this.r=(x>>16&255)/255,this.g=(x>>8&255)/255,this.b=(x&255)/255,j2.toWorkingColorSpace(this,n),this}setRGB(x,n,r,a=Na){return this.r=x,this.g=n,this.b=r,j2.toWorkingColorSpace(this,a),this}setHSL(x,n,r,a=Na){if(x=l1(x,1),n=Gx(n,0,1),r=Gx(r,0,1),n===0)this.r=this.g=this.b=r;else{const i=r<=.5?r*(1+n):r+n-r*n,o=2*r-i;this.r=d1(o,i,x+1/3),this.g=d1(o,i,x),this.b=d1(o,i,x-1/3)}return j2.toWorkingColorSpace(this,a),this}setStyle(x,n=Vr){function r(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+x+" will be ignored.")}let a;if(a=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(x)){let i;const o=a[1],l=a[2];switch(o){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,j2.toWorkingColorSpace(this,n),r(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,j2.toWorkingColorSpace(this,n),r(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)){const c=parseFloat(i[1])/360,d=parseInt(i[2],10)/100,h=parseInt(i[3],10)/100;return r(i[4]),this.setHSL(c,d,h,n)}break}}else if(a=/^\#([A-Fa-f\d]+)$/.exec(x)){const i=a[1],o=i.length;if(o===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,j2.toWorkingColorSpace(this,n),this;if(o===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,j2.toWorkingColorSpace(this,n),this}return x&&x.length>0?this.setColorName(x,n):this}setColorName(x,n=Vr){const r=bA[x.toLowerCase()];return r!==void 0?this.setHex(r,n):console.warn("THREE.Color: Unknown color "+x),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(x){return this.r=x.r,this.g=x.g,this.b=x.b,this}copySRGBToLinear(x){return this.r=Pa(x.r),this.g=Pa(x.g),this.b=Pa(x.b),this}copyLinearToSRGB(x){return this.r=Ud(x.r),this.g=Ud(x.g),this.b=Ud(x.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(x=Vr){return j2.fromWorkingColorSpace(zd(this,on),x),Gx(on.r*255,0,255)<<16^Gx(on.g*255,0,255)<<8^Gx(on.b*255,0,255)<<0}getHexString(x=Vr){return("000000"+this.getHex(x).toString(16)).slice(-6)}getHSL(x,n=Na){j2.fromWorkingColorSpace(zd(this,on),n);const r=on.r,a=on.g,i=on.b,o=Math.max(r,a,i),l=Math.min(r,a,i);let c,d;const h=(l+o)/2;if(l===o)c=0,d=0;else{const p=o-l;switch(d=h<=.5?p/(o+l):p/(2-o-l),o){case r:c=(a-i)/p+(a<i?6:0);break;case a:c=(i-r)/p+2;break;case i:c=(r-a)/p+4;break}c/=6}return x.h=c,x.s=d,x.l=h,x}getRGB(x,n=Na){return j2.fromWorkingColorSpace(zd(this,on),n),x.r=on.r,x.g=on.g,x.b=on.b,x}getStyle(x=Vr){return j2.fromWorkingColorSpace(zd(this,on),x),x!==Vr?`color(${x} ${on.r} ${on.g} ${on.b})`:`rgb(${on.r*255|0},${on.g*255|0},${on.b*255|0})`}offsetHSL(x,n,r){return this.getHSL(er),er.h+=x,er.s+=n,er.l+=r,this.setHSL(er.h,er.s,er.l),this}add(x){return this.r+=x.r,this.g+=x.g,this.b+=x.b,this}addColors(x,n){return this.r=x.r+n.r,this.g=x.g+n.g,this.b=x.b+n.b,this}addScalar(x){return this.r+=x,this.g+=x,this.b+=x,this}sub(x){return this.r=Math.max(0,this.r-x.r),this.g=Math.max(0,this.g-x.g),this.b=Math.max(0,this.b-x.b),this}multiply(x){return this.r*=x.r,this.g*=x.g,this.b*=x.b,this}multiplyScalar(x){return this.r*=x,this.g*=x,this.b*=x,this}lerp(x,n){return this.r+=(x.r-this.r)*n,this.g+=(x.g-this.g)*n,this.b+=(x.b-this.b)*n,this}lerpColors(x,n,r){return this.r=x.r+(n.r-x.r)*r,this.g=x.g+(n.g-x.g)*r,this.b=x.b+(n.b-x.b)*r,this}lerpHSL(x,n){this.getHSL(er),x.getHSL(Bd);const r=Cl(er.h,Bd.h,n),a=Cl(er.s,Bd.s,n),i=Cl(er.l,Bd.l,n);return this.setHSL(r,a,i),this}equals(x){return x.r===this.r&&x.g===this.g&&x.b===this.b}fromArray(x,n=0){return this.r=x[n],this.g=x[n+1],this.b=x[n+2],this}toArray(x=[],n=0){return x[n]=this.r,x[n+1]=this.g,x[n+2]=this.b,x}fromBufferAttribute(x,n){return this.r=x.getX(n),this.g=x.getY(n),this.b=x.getZ(n),x.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}M0.NAMES=bA;let Ki;class vA{static getDataURL(x){if(/^data:/i.test(x.src)||typeof HTMLCanvasElement>"u")return x.src;let n;if(x instanceof HTMLCanvasElement)n=x;else{Ki===void 0&&(Ki=Ml("canvas")),Ki.width=x.width,Ki.height=x.height;const r=Ki.getContext("2d");x instanceof ImageData?r.putImageData(x,0,0):r.drawImage(x,0,0,x.width,x.height),n=Ki}return n.width>2048||n.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",x),n.toDataURL("image/jpeg",.6)):n.toDataURL("image/png")}static sRGBToLinear(x){if(typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap){const n=Ml("canvas");n.width=x.width,n.height=x.height;const r=n.getContext("2d");r.drawImage(x,0,0,x.width,x.height);const a=r.getImageData(0,0,x.width,x.height),i=a.data;for(let o=0;o<i.length;o++)i[o]=Pa(i[o]/255)*255;return r.putImageData(a,0,0),n}else if(x.data){const n=x.data.slice(0);for(let r=0;r<n.length;r++)n instanceof Uint8Array||n instanceof Uint8ClampedArray?n[r]=Math.floor(Pa(n[r]/255)*255):n[r]=Pa(n[r]);return{data:n,width:x.width,height:x.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),x}}class $i{constructor(x=null){this.isSource=!0,this.uuid=f2(),this.data=x,this.version=0}set needsUpdate(x){x===!0&&this.version++}toJSON(x){const n=x===void 0||typeof x=="string";if(!n&&x.images[this.uuid]!==void 0)return x.images[this.uuid];const r={uuid:this.uuid,url:""},a=this.data;if(a!==null){let i;if(Array.isArray(a)){i=[];for(let o=0,l=a.length;o<l;o++)a[o].isDataTexture?i.push(h1(a[o].image)):i.push(h1(a[o]))}else i=h1(a);r.url=i}return n||(x.images[this.uuid]=r),r}}function h1(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?vA.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let PJ=0;class Tn extends qi{constructor(x=Tn.DEFAULT_IMAGE,n=Tn.DEFAULT_MAPPING,r=Zn,a=Zn,i=Sx,o=_s,l=Q2,c=Ca,d=1,h=Ss){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:PJ++}),this.uuid=f2(),this.name="",this.source=new $i(x),this.mipmaps=[],this.mapping=n,this.wrapS=r,this.wrapT=a,this.magFilter=i,this.minFilter=o,this.anisotropy=d,this.format=l,this.internalFormat=null,this.type=c,this.offset=new n0(0,0),this.repeat=new n0(1,1),this.center=new n0(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new m2,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(x){this.source.data=x}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(x){return this.name=x.name,this.source=x.source,this.mipmaps=x.mipmaps.slice(0),this.mapping=x.mapping,this.wrapS=x.wrapS,this.wrapT=x.wrapT,this.magFilter=x.magFilter,this.minFilter=x.minFilter,this.anisotropy=x.anisotropy,this.format=x.format,this.internalFormat=x.internalFormat,this.type=x.type,this.offset.copy(x.offset),this.repeat.copy(x.repeat),this.center.copy(x.center),this.rotation=x.rotation,this.matrixAutoUpdate=x.matrixAutoUpdate,this.matrix.copy(x.matrix),this.generateMipmaps=x.generateMipmaps,this.premultiplyAlpha=x.premultiplyAlpha,this.flipY=x.flipY,this.unpackAlignment=x.unpackAlignment,this.encoding=x.encoding,this.userData=JSON.parse(JSON.stringify(x.userData)),this.needsUpdate=!0,this}toJSON(x){const n=x===void 0||typeof x=="string";if(!n&&x.textures[this.uuid]!==void 0)return x.textures[this.uuid];const r={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(x).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),n||(x.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(x){if(this.mapping!==jg)return x;if(x.applyMatrix3(this.matrix),x.x<0||x.x>1)switch(this.wrapS){case Ea:x.x=x.x-Math.floor(x.x);break;case Zn:x.x=x.x<0?0:1;break;case Tl:Math.abs(Math.floor(x.x)%2)===1?x.x=Math.ceil(x.x)-x.x:x.x=x.x-Math.floor(x.x);break}if(x.y<0||x.y>1)switch(this.wrapT){case Ea:x.y=x.y-Math.floor(x.y);break;case Zn:x.y=x.y<0?0:1;break;case Tl:Math.abs(Math.floor(x.y)%2)===1?x.y=Math.ceil(x.y)-x.y:x.y=x.y-Math.floor(x.y);break}return this.flipY&&(x.y=1-x.y),x}set needsUpdate(x){x===!0&&(this.version++,this.source.needsUpdate=!0)}}Tn.DEFAULT_IMAGE=null,Tn.DEFAULT_MAPPING=jg;class ix{constructor(x=0,n=0,r=0,a=1){ix.prototype.isVector4=!0,this.x=x,this.y=n,this.z=r,this.w=a}get width(){return this.z}set width(x){this.z=x}get height(){return this.w}set height(x){this.w=x}set(x,n,r,a){return this.x=x,this.y=n,this.z=r,this.w=a,this}setScalar(x){return this.x=x,this.y=x,this.z=x,this.w=x,this}setX(x){return this.x=x,this}setY(x){return this.y=x,this}setZ(x){return this.z=x,this}setW(x){return this.w=x,this}setComponent(x,n){switch(x){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+x)}return this}getComponent(x){switch(x){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+x)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(x){return this.x=x.x,this.y=x.y,this.z=x.z,this.w=x.w!==void 0?x.w:1,this}add(x){return this.x+=x.x,this.y+=x.y,this.z+=x.z,this.w+=x.w,this}addScalar(x){return this.x+=x,this.y+=x,this.z+=x,this.w+=x,this}addVectors(x,n){return this.x=x.x+n.x,this.y=x.y+n.y,this.z=x.z+n.z,this.w=x.w+n.w,this}addScaledVector(x,n){return this.x+=x.x*n,this.y+=x.y*n,this.z+=x.z*n,this.w+=x.w*n,this}sub(x){return this.x-=x.x,this.y-=x.y,this.z-=x.z,this.w-=x.w,this}subScalar(x){return this.x-=x,this.y-=x,this.z-=x,this.w-=x,this}subVectors(x,n){return this.x=x.x-n.x,this.y=x.y-n.y,this.z=x.z-n.z,this.w=x.w-n.w,this}multiply(x){return this.x*=x.x,this.y*=x.y,this.z*=x.z,this.w*=x.w,this}multiplyScalar(x){return this.x*=x,this.y*=x,this.z*=x,this.w*=x,this}applyMatrix4(x){const n=this.x,r=this.y,a=this.z,i=this.w,o=x.elements;return this.x=o[0]*n+o[4]*r+o[8]*a+o[12]*i,this.y=o[1]*n+o[5]*r+o[9]*a+o[13]*i,this.z=o[2]*n+o[6]*r+o[10]*a+o[14]*i,this.w=o[3]*n+o[7]*r+o[11]*a+o[15]*i,this}divideScalar(x){return this.multiplyScalar(1/x)}setAxisAngleFromQuaternion(x){this.w=2*Math.acos(x.w);const n=Math.sqrt(1-x.w*x.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=x.x/n,this.y=x.y/n,this.z=x.z/n),this}setAxisAngleFromRotationMatrix(x){let n,r,a,i;const c=x.elements,d=c[0],h=c[4],p=c[8],m=c[1],g=c[5],y=c[9],b=c[2],v=c[6],w=c[10];if(Math.abs(h-m)<.01&&Math.abs(p-b)<.01&&Math.abs(y-v)<.01){if(Math.abs(h+m)<.1&&Math.abs(p+b)<.1&&Math.abs(y+v)<.1&&Math.abs(d+g+w-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const T=(d+1)/2,A=(g+1)/2,E=(w+1)/2,M=(h+m)/4,I=(p+b)/4,C=(y+v)/4;return T>A&&T>E?T<.01?(r=0,a=.707106781,i=.707106781):(r=Math.sqrt(T),a=M/r,i=I/r):A>E?A<.01?(r=.707106781,a=0,i=.707106781):(a=Math.sqrt(A),r=M/a,i=C/a):E<.01?(r=.707106781,a=.707106781,i=0):(i=Math.sqrt(E),r=I/i,a=C/i),this.set(r,a,i,n),this}let _=Math.sqrt((v-y)*(v-y)+(p-b)*(p-b)+(m-h)*(m-h));return Math.abs(_)<.001&&(_=1),this.x=(v-y)/_,this.y=(p-b)/_,this.z=(m-h)/_,this.w=Math.acos((d+g+w-1)/2),this}min(x){return this.x=Math.min(this.x,x.x),this.y=Math.min(this.y,x.y),this.z=Math.min(this.z,x.z),this.w=Math.min(this.w,x.w),this}max(x){return this.x=Math.max(this.x,x.x),this.y=Math.max(this.y,x.y),this.z=Math.max(this.z,x.z),this.w=Math.max(this.w,x.w),this}clamp(x,n){return this.x=Math.max(x.x,Math.min(n.x,this.x)),this.y=Math.max(x.y,Math.min(n.y,this.y)),this.z=Math.max(x.z,Math.min(n.z,this.z)),this.w=Math.max(x.w,Math.min(n.w,this.w)),this}clampScalar(x,n){return this.x=Math.max(x,Math.min(n,this.x)),this.y=Math.max(x,Math.min(n,this.y)),this.z=Math.max(x,Math.min(n,this.z)),this.w=Math.max(x,Math.min(n,this.w)),this}clampLength(x,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(x,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(x){return this.x*x.x+this.y*x.y+this.z*x.z+this.w*x.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(x){return this.normalize().multiplyScalar(x)}lerp(x,n){return this.x+=(x.x-this.x)*n,this.y+=(x.y-this.y)*n,this.z+=(x.z-this.z)*n,this.w+=(x.w-this.w)*n,this}lerpVectors(x,n,r){return this.x=x.x+(n.x-x.x)*r,this.y=x.y+(n.y-x.y)*r,this.z=x.z+(n.z-x.z)*r,this.w=x.w+(n.w-x.w)*r,this}equals(x){return x.x===this.x&&x.y===this.y&&x.z===this.z&&x.w===this.w}fromArray(x,n=0){return this.x=x[n],this.y=x[n+1],this.z=x[n+2],this.w=x[n+3],this}toArray(x=[],n=0){return x[n]=this.x,x[n+1]=this.y,x[n+2]=this.z,x[n+3]=this.w,x}fromBufferAttribute(x,n){return this.x=x.getX(n),this.y=x.getY(n),this.z=x.getZ(n),this.w=x.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class La extends qi{constructor(x,n,r={}){super(),this.isWebGLRenderTarget=!0,this.width=x,this.height=n,this.depth=1,this.scissor=new ix(0,0,x,n),this.scissorTest=!1,this.viewport=new ix(0,0,x,n);const a={width:x,height:n,depth:1};this.texture=new Tn(a,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=r.generateMipmaps!==void 0?r.generateMipmaps:!1,this.texture.internalFormat=r.internalFormat!==void 0?r.internalFormat:null,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:Sx,this.depthBuffer=r.depthBuffer!==void 0?r.depthBuffer:!0,this.stencilBuffer=r.stencilBuffer!==void 0?r.stencilBuffer:!1,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null,this.samples=r.samples!==void 0?r.samples:0}setSize(x,n,r=1){(this.width!==x||this.height!==n||this.depth!==r)&&(this.width=x,this.height=n,this.depth=r,this.texture.image.width=x,this.texture.image.height=n,this.texture.image.depth=r,this.dispose()),this.viewport.set(0,0,x,n),this.scissor.set(0,0,x,n)}clone(){return new this.constructor().copy(this)}copy(x){this.width=x.width,this.height=x.height,this.depth=x.depth,this.viewport.copy(x.viewport),this.texture=x.texture.clone(),this.texture.isRenderTargetTexture=!0;const n=Object.assign({},x.texture.image);return this.texture.source=new $i(n),this.depthBuffer=x.depthBuffer,this.stencilBuffer=x.stencilBuffer,x.depthTexture!==null&&(this.depthTexture=x.depthTexture.clone()),this.samples=x.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class p1 extends Tn{constructor(x=null,n=1,r=1,a=1){super(null),this.isDataArrayTexture=!0,this.image={data:x,width:n,height:r,depth:a},this.magFilter=Zx,this.minFilter=Zx,this.wrapR=Zn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class B2e extends null{constructor(x,n,r){super(x,n),this.isWebGLArrayRenderTarget=!0,this.depth=r,this.texture=new p1(null,x,n,r),this.texture.isRenderTargetTexture=!0}}class wA extends Tn{constructor(x=null,n=1,r=1,a=1){super(null),this.isData3DTexture=!0,this.image={data:x,width:n,height:r,depth:a},this.magFilter=Zx,this.minFilter=Zx,this.wrapR=Zn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class z2e extends null{constructor(x,n,r){super(x,n),this.isWebGL3DRenderTarget=!0,this.depth=r,this.texture=new wA(null,x,n,r),this.texture.isRenderTargetTexture=!0}}class W2e extends null{constructor(x,n,r,a={}){super(x,n,a),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let o=0;o<r;o++)this.texture[o]=i.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(x,n,r=1){if(this.width!==x||this.height!==n||this.depth!==r){this.width=x,this.height=n,this.depth=r;for(let a=0,i=this.texture.length;a<i;a++)this.texture[a].image.width=x,this.texture[a].image.height=n,this.texture[a].image.depth=r;this.dispose()}return this.viewport.set(0,0,x,n),this.scissor.set(0,0,x,n),this}copy(x){this.dispose(),this.width=x.width,this.height=x.height,this.depth=x.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=x.depthBuffer,this.stencilBuffer=x.stencilBuffer,x.depthTexture!==null&&(this.depthTexture=x.depthTexture.clone()),this.texture.length=0;for(let n=0,r=x.texture.length;n<r;n++)this.texture[n]=x.texture[n].clone(),this.texture[n].isRenderTargetTexture=!0;return this}}class Bn{constructor(x=0,n=0,r=0,a=1){this.isQuaternion=!0,this._x=x,this._y=n,this._z=r,this._w=a}static slerpFlat(x,n,r,a,i,o,l){let c=r[a+0],d=r[a+1],h=r[a+2],p=r[a+3];const m=i[o+0],g=i[o+1],y=i[o+2],b=i[o+3];if(l===0){x[n+0]=c,x[n+1]=d,x[n+2]=h,x[n+3]=p;return}if(l===1){x[n+0]=m,x[n+1]=g,x[n+2]=y,x[n+3]=b;return}if(p!==b||c!==m||d!==g||h!==y){let v=1-l;const w=c*m+d*g+h*y+p*b,_=w>=0?1:-1,T=1-w*w;if(T>Number.EPSILON){const E=Math.sqrt(T),M=Math.atan2(E,w*_);v=Math.sin(v*M)/E,l=Math.sin(l*M)/E}const A=l*_;if(c=c*v+m*A,d=d*v+g*A,h=h*v+y*A,p=p*v+b*A,v===1-l){const E=1/Math.sqrt(c*c+d*d+h*h+p*p);c*=E,d*=E,h*=E,p*=E}}x[n]=c,x[n+1]=d,x[n+2]=h,x[n+3]=p}static multiplyQuaternionsFlat(x,n,r,a,i,o){const l=r[a],c=r[a+1],d=r[a+2],h=r[a+3],p=i[o],m=i[o+1],g=i[o+2],y=i[o+3];return x[n]=l*y+h*p+c*g-d*m,x[n+1]=c*y+h*m+d*p-l*g,x[n+2]=d*y+h*g+l*m-c*p,x[n+3]=h*y-l*p-c*m-d*g,x}get x(){return this._x}set x(x){this._x=x,this._onChangeCallback()}get y(){return this._y}set y(x){this._y=x,this._onChangeCallback()}get z(){return this._z}set z(x){this._z=x,this._onChangeCallback()}get w(){return this._w}set w(x){this._w=x,this._onChangeCallback()}set(x,n,r,a){return this._x=x,this._y=n,this._z=r,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(x){return this._x=x.x,this._y=x.y,this._z=x.z,this._w=x.w,this._onChangeCallback(),this}setFromEuler(x,n){if(!(x&&x.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=x._x,a=x._y,i=x._z,o=x._order,l=Math.cos,c=Math.sin,d=l(r/2),h=l(a/2),p=l(i/2),m=c(r/2),g=c(a/2),y=c(i/2);switch(o){case"XYZ":this._x=m*h*p+d*g*y,this._y=d*g*p-m*h*y,this._z=d*h*y+m*g*p,this._w=d*h*p-m*g*y;break;case"YXZ":this._x=m*h*p+d*g*y,this._y=d*g*p-m*h*y,this._z=d*h*y-m*g*p,this._w=d*h*p+m*g*y;break;case"ZXY":this._x=m*h*p-d*g*y,this._y=d*g*p+m*h*y,this._z=d*h*y+m*g*p,this._w=d*h*p-m*g*y;break;case"ZYX":this._x=m*h*p-d*g*y,this._y=d*g*p+m*h*y,this._z=d*h*y-m*g*p,this._w=d*h*p+m*g*y;break;case"YZX":this._x=m*h*p+d*g*y,this._y=d*g*p+m*h*y,this._z=d*h*y-m*g*p,this._w=d*h*p-m*g*y;break;case"XZY":this._x=m*h*p-d*g*y,this._y=d*g*p-m*h*y,this._z=d*h*y+m*g*p,this._w=d*h*p+m*g*y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return n!==!1&&this._onChangeCallback(),this}setFromAxisAngle(x,n){const r=n/2,a=Math.sin(r);return this._x=x.x*a,this._y=x.y*a,this._z=x.z*a,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(x){const n=x.elements,r=n[0],a=n[4],i=n[8],o=n[1],l=n[5],c=n[9],d=n[2],h=n[6],p=n[10],m=r+l+p;if(m>0){const g=.5/Math.sqrt(m+1);this._w=.25/g,this._x=(h-c)*g,this._y=(i-d)*g,this._z=(o-a)*g}else if(r>l&&r>p){const g=2*Math.sqrt(1+r-l-p);this._w=(h-c)/g,this._x=.25*g,this._y=(a+o)/g,this._z=(i+d)/g}else if(l>p){const g=2*Math.sqrt(1+l-r-p);this._w=(i-d)/g,this._x=(a+o)/g,this._y=.25*g,this._z=(c+h)/g}else{const g=2*Math.sqrt(1+p-r-l);this._w=(o-a)/g,this._x=(i+d)/g,this._y=(c+h)/g,this._z=.25*g}return this._onChangeCallback(),this}setFromUnitVectors(x,n){let r=x.dot(n)+1;return r<Number.EPSILON?(r=0,Math.abs(x.x)>Math.abs(x.z)?(this._x=-x.y,this._y=x.x,this._z=0,this._w=r):(this._x=0,this._y=-x.z,this._z=x.y,this._w=r)):(this._x=x.y*n.z-x.z*n.y,this._y=x.z*n.x-x.x*n.z,this._z=x.x*n.y-x.y*n.x,this._w=r),this.normalize()}angleTo(x){return 2*Math.acos(Math.abs(Gx(this.dot(x),-1,1)))}rotateTowards(x,n){const r=this.angleTo(x);if(r===0)return this;const a=Math.min(1,n/r);return this.slerp(x,a),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(x){return this._x*x._x+this._y*x._y+this._z*x._z+this._w*x._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let x=this.length();return x===0?(this._x=0,this._y=0,this._z=0,this._w=1):(x=1/x,this._x=this._x*x,this._y=this._y*x,this._z=this._z*x,this._w=this._w*x),this._onChangeCallback(),this}multiply(x){return this.multiplyQuaternions(this,x)}premultiply(x){return this.multiplyQuaternions(x,this)}multiplyQuaternions(x,n){const r=x._x,a=x._y,i=x._z,o=x._w,l=n._x,c=n._y,d=n._z,h=n._w;return this._x=r*h+o*l+a*d-i*c,this._y=a*h+o*c+i*l-r*d,this._z=i*h+o*d+r*c-a*l,this._w=o*h-r*l-a*c-i*d,this._onChangeCallback(),this}slerp(x,n){if(n===0)return this;if(n===1)return this.copy(x);const r=this._x,a=this._y,i=this._z,o=this._w;let l=o*x._w+r*x._x+a*x._y+i*x._z;if(l<0?(this._w=-x._w,this._x=-x._x,this._y=-x._y,this._z=-x._z,l=-l):this.copy(x),l>=1)return this._w=o,this._x=r,this._y=a,this._z=i,this;const c=1-l*l;if(c<=Number.EPSILON){const g=1-n;return this._w=g*o+n*this._w,this._x=g*r+n*this._x,this._y=g*a+n*this._y,this._z=g*i+n*this._z,this.normalize(),this._onChangeCallback(),this}const d=Math.sqrt(c),h=Math.atan2(d,l),p=Math.sin((1-n)*h)/d,m=Math.sin(n*h)/d;return this._w=o*p+this._w*m,this._x=r*p+this._x*m,this._y=a*p+this._y*m,this._z=i*p+this._z*m,this._onChangeCallback(),this}slerpQuaternions(x,n,r){return this.copy(x).slerp(n,r)}random(){const x=Math.random(),n=Math.sqrt(1-x),r=Math.sqrt(x),a=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(n*Math.cos(a),r*Math.sin(i),r*Math.cos(i),n*Math.sin(a))}equals(x){return x._x===this._x&&x._y===this._y&&x._z===this._z&&x._w===this._w}fromArray(x,n=0){return this._x=x[n],this._y=x[n+1],this._z=x[n+2],this._w=x[n+3],this._onChangeCallback(),this}toArray(x=[],n=0){return x[n]=this._x,x[n+1]=this._y,x[n+2]=this._z,x[n+3]=this._w,x}fromBufferAttribute(x,n){return this._x=x.getX(n),this._y=x.getY(n),this._z=x.getZ(n),this._w=x.getW(n),this}_onChange(x){return this._onChangeCallback=x,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class K{constructor(x=0,n=0,r=0){K.prototype.isVector3=!0,this.x=x,this.y=n,this.z=r}set(x,n,r){return r===void 0&&(r=this.z),this.x=x,this.y=n,this.z=r,this}setScalar(x){return this.x=x,this.y=x,this.z=x,this}setX(x){return this.x=x,this}setY(x){return this.y=x,this}setZ(x){return this.z=x,this}setComponent(x,n){switch(x){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+x)}return this}getComponent(x){switch(x){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+x)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(x){return this.x=x.x,this.y=x.y,this.z=x.z,this}add(x){return this.x+=x.x,this.y+=x.y,this.z+=x.z,this}addScalar(x){return this.x+=x,this.y+=x,this.z+=x,this}addVectors(x,n){return this.x=x.x+n.x,this.y=x.y+n.y,this.z=x.z+n.z,this}addScaledVector(x,n){return this.x+=x.x*n,this.y+=x.y*n,this.z+=x.z*n,this}sub(x){return this.x-=x.x,this.y-=x.y,this.z-=x.z,this}subScalar(x){return this.x-=x,this.y-=x,this.z-=x,this}subVectors(x,n){return this.x=x.x-n.x,this.y=x.y-n.y,this.z=x.z-n.z,this}multiply(x){return this.x*=x.x,this.y*=x.y,this.z*=x.z,this}multiplyScalar(x){return this.x*=x,this.y*=x,this.z*=x,this}multiplyVectors(x,n){return this.x=x.x*n.x,this.y=x.y*n.y,this.z=x.z*n.z,this}applyEuler(x){return this.applyQuaternion(_A.setFromEuler(x))}applyAxisAngle(x,n){return this.applyQuaternion(_A.setFromAxisAngle(x,n))}applyMatrix3(x){const n=this.x,r=this.y,a=this.z,i=x.elements;return this.x=i[0]*n+i[3]*r+i[6]*a,this.y=i[1]*n+i[4]*r+i[7]*a,this.z=i[2]*n+i[5]*r+i[8]*a,this}applyNormalMatrix(x){return this.applyMatrix3(x).normalize()}applyMatrix4(x){const n=this.x,r=this.y,a=this.z,i=x.elements,o=1/(i[3]*n+i[7]*r+i[11]*a+i[15]);return this.x=(i[0]*n+i[4]*r+i[8]*a+i[12])*o,this.y=(i[1]*n+i[5]*r+i[9]*a+i[13])*o,this.z=(i[2]*n+i[6]*r+i[10]*a+i[14])*o,this}applyQuaternion(x){const n=this.x,r=this.y,a=this.z,i=x.x,o=x.y,l=x.z,c=x.w,d=c*n+o*a-l*r,h=c*r+l*n-i*a,p=c*a+i*r-o*n,m=-i*n-o*r-l*a;return this.x=d*c+m*-i+h*-l-p*-o,this.y=h*c+m*-o+p*-i-d*-l,this.z=p*c+m*-l+d*-o-h*-i,this}project(x){return this.applyMatrix4(x.matrixWorldInverse).applyMatrix4(x.projectionMatrix)}unproject(x){return this.applyMatrix4(x.projectionMatrixInverse).applyMatrix4(x.matrixWorld)}transformDirection(x){const n=this.x,r=this.y,a=this.z,i=x.elements;return this.x=i[0]*n+i[4]*r+i[8]*a,this.y=i[1]*n+i[5]*r+i[9]*a,this.z=i[2]*n+i[6]*r+i[10]*a,this.normalize()}divide(x){return this.x/=x.x,this.y/=x.y,this.z/=x.z,this}divideScalar(x){return this.multiplyScalar(1/x)}min(x){return this.x=Math.min(this.x,x.x),this.y=Math.min(this.y,x.y),this.z=Math.min(this.z,x.z),this}max(x){return this.x=Math.max(this.x,x.x),this.y=Math.max(this.y,x.y),this.z=Math.max(this.z,x.z),this}clamp(x,n){return this.x=Math.max(x.x,Math.min(n.x,this.x)),this.y=Math.max(x.y,Math.min(n.y,this.y)),this.z=Math.max(x.z,Math.min(n.z,this.z)),this}clampScalar(x,n){return this.x=Math.max(x,Math.min(n,this.x)),this.y=Math.max(x,Math.min(n,this.y)),this.z=Math.max(x,Math.min(n,this.z)),this}clampLength(x,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(x,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(x){return this.x*x.x+this.y*x.y+this.z*x.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(x){return this.normalize().multiplyScalar(x)}lerp(x,n){return this.x+=(x.x-this.x)*n,this.y+=(x.y-this.y)*n,this.z+=(x.z-this.z)*n,this}lerpVectors(x,n,r){return this.x=x.x+(n.x-x.x)*r,this.y=x.y+(n.y-x.y)*r,this.z=x.z+(n.z-x.z)*r,this}cross(x){return this.crossVectors(this,x)}crossVectors(x,n){const r=x.x,a=x.y,i=x.z,o=n.x,l=n.y,c=n.z;return this.x=a*c-i*l,this.y=i*o-r*c,this.z=r*l-a*o,this}projectOnVector(x){const n=x.lengthSq();if(n===0)return this.set(0,0,0);const r=x.dot(this)/n;return this.copy(x).multiplyScalar(r)}projectOnPlane(x){return f1.copy(this).projectOnVector(x),this.sub(f1)}reflect(x){return this.sub(f1.copy(x).multiplyScalar(2*this.dot(x)))}angleTo(x){const n=Math.sqrt(this.lengthSq()*x.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(x)/n;return Math.acos(Gx(r,-1,1))}distanceTo(x){return Math.sqrt(this.distanceToSquared(x))}distanceToSquared(x){const n=this.x-x.x,r=this.y-x.y,a=this.z-x.z;return n*n+r*r+a*a}manhattanDistanceTo(x){return Math.abs(this.x-x.x)+Math.abs(this.y-x.y)+Math.abs(this.z-x.z)}setFromSpherical(x){return this.setFromSphericalCoords(x.radius,x.phi,x.theta)}setFromSphericalCoords(x,n,r){const a=Math.sin(n)*x;return this.x=a*Math.sin(r),this.y=Math.cos(n)*x,this.z=a*Math.cos(r),this}setFromCylindrical(x){return this.setFromCylindricalCoords(x.radius,x.theta,x.y)}setFromCylindricalCoords(x,n,r){return this.x=x*Math.sin(n),this.y=r,this.z=x*Math.cos(n),this}setFromMatrixPosition(x){const n=x.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(x){const n=this.setFromMatrixColumn(x,0).length(),r=this.setFromMatrixColumn(x,1).length(),a=this.setFromMatrixColumn(x,2).length();return this.x=n,this.y=r,this.z=a,this}setFromMatrixColumn(x,n){return this.fromArray(x.elements,n*4)}setFromMatrix3Column(x,n){return this.fromArray(x.elements,n*3)}setFromEuler(x){return this.x=x._x,this.y=x._y,this.z=x._z,this}equals(x){return x.x===this.x&&x.y===this.y&&x.z===this.z}fromArray(x,n=0){return this.x=x[n],this.y=x[n+1],this.z=x[n+2],this}toArray(x=[],n=0){return x[n]=this.x,x[n+1]=this.y,x[n+2]=this.z,x}fromBufferAttribute(x,n){return this.x=x.getX(n),this.y=x.getY(n),this.z=x.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const x=(Math.random()-.5)*2,n=Math.random()*Math.PI*2,r=Math.sqrt(1-x**2);return this.x=r*Math.cos(n),this.y=r*Math.sin(n),this.z=x,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const f1=new K,_A=new Bn;class Da{constructor(x=new K(1/0,1/0,1/0),n=new K(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=x,this.max=n}set(x,n){return this.min.copy(x),this.max.copy(n),this}setFromArray(x){let n=1/0,r=1/0,a=1/0,i=-1/0,o=-1/0,l=-1/0;for(let c=0,d=x.length;c<d;c+=3){const h=x[c],p=x[c+1],m=x[c+2];h<n&&(n=h),p<r&&(r=p),m<a&&(a=m),h>i&&(i=h),p>o&&(o=p),m>l&&(l=m)}return this.min.set(n,r,a),this.max.set(i,o,l),this}setFromBufferAttribute(x){let n=1/0,r=1/0,a=1/0,i=-1/0,o=-1/0,l=-1/0;for(let c=0,d=x.count;c<d;c++){const h=x.getX(c),p=x.getY(c),m=x.getZ(c);h<n&&(n=h),p<r&&(r=p),m<a&&(a=m),h>i&&(i=h),p>o&&(o=p),m>l&&(l=m)}return this.min.set(n,r,a),this.max.set(i,o,l),this}setFromPoints(x){this.makeEmpty();for(let n=0,r=x.length;n<r;n++)this.expandByPoint(x[n]);return this}setFromCenterAndSize(x,n){const r=Oa.copy(n).multiplyScalar(.5);return this.min.copy(x).sub(r),this.max.copy(x).add(r),this}setFromObject(x,n=!1){return this.makeEmpty(),this.expandByObject(x,n)}clone(){return new this.constructor().copy(this)}copy(x){return this.min.copy(x.min),this.max.copy(x.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(x){return this.isEmpty()?x.set(0,0,0):x.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(x){return this.isEmpty()?x.set(0,0,0):x.subVectors(this.max,this.min)}expandByPoint(x){return this.min.min(x),this.max.max(x),this}expandByVector(x){return this.min.sub(x),this.max.add(x),this}expandByScalar(x){return this.min.addScalar(-x),this.max.addScalar(x),this}expandByObject(x,n=!1){x.updateWorldMatrix(!1,!1);const r=x.geometry;if(r!==void 0)if(n&&r.attributes!=null&&r.attributes.position!==void 0){const i=r.attributes.position;for(let o=0,l=i.count;o<l;o++)Oa.fromBufferAttribute(i,o).applyMatrix4(x.matrixWorld),this.expandByPoint(Oa)}else r.boundingBox===null&&r.computeBoundingBox(),m1.copy(r.boundingBox),m1.applyMatrix4(x.matrixWorld),this.union(m1);const a=x.children;for(let i=0,o=a.length;i<o;i++)this.expandByObject(a[i],n);return this}containsPoint(x){return!(x.x<this.min.x||x.x>this.max.x||x.y<this.min.y||x.y>this.max.y||x.z<this.min.z||x.z>this.max.z)}containsBox(x){return this.min.x<=x.min.x&&x.max.x<=this.max.x&&this.min.y<=x.min.y&&x.max.y<=this.max.y&&this.min.z<=x.min.z&&x.max.z<=this.max.z}getParameter(x,n){return n.set((x.x-this.min.x)/(this.max.x-this.min.x),(x.y-this.min.y)/(this.max.y-this.min.y),(x.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(x){return!(x.max.x<this.min.x||x.min.x>this.max.x||x.max.y<this.min.y||x.min.y>this.max.y||x.max.z<this.min.z||x.min.z>this.max.z)}intersectsSphere(x){return this.clampPoint(x.center,Oa),Oa.distanceToSquared(x.center)<=x.radius*x.radius}intersectsPlane(x){let n,r;return x.normal.x>0?(n=x.normal.x*this.min.x,r=x.normal.x*this.max.x):(n=x.normal.x*this.max.x,r=x.normal.x*this.min.x),x.normal.y>0?(n+=x.normal.y*this.min.y,r+=x.normal.y*this.max.y):(n+=x.normal.y*this.max.y,r+=x.normal.y*this.min.y),x.normal.z>0?(n+=x.normal.z*this.min.z,r+=x.normal.z*this.max.z):(n+=x.normal.z*this.max.z,r+=x.normal.z*this.min.z),n<=-x.constant&&r>=-x.constant}intersectsTriangle(x){if(this.isEmpty())return!1;this.getCenter(Il),Wd.subVectors(this.max,Il),Zi.subVectors(x.a,Il),Ji.subVectors(x.b,Il),Qi.subVectors(x.c,Il),Ts.subVectors(Ji,Zi),As.subVectors(Qi,Ji),Fa.subVectors(Zi,Qi);let n=[0,-Ts.z,Ts.y,0,-As.z,As.y,0,-Fa.z,Fa.y,Ts.z,0,-Ts.x,As.z,0,-As.x,Fa.z,0,-Fa.x,-Ts.y,Ts.x,0,-As.y,As.x,0,-Fa.y,Fa.x,0];return!g1(n,Zi,Ji,Qi,Wd)||(n=[1,0,0,0,1,0,0,0,1],!g1(n,Zi,Ji,Qi,Wd))?!1:(Gd.crossVectors(Ts,As),n=[Gd.x,Gd.y,Gd.z],g1(n,Zi,Ji,Qi,Wd))}clampPoint(x,n){return n.copy(x).clamp(this.min,this.max)}distanceToPoint(x){return Oa.copy(x).clamp(this.min,this.max).sub(x).length()}getBoundingSphere(x){return this.getCenter(x.center),x.radius=this.getSize(Oa).length()*.5,x}intersect(x){return this.min.max(x.min),this.max.min(x.max),this.isEmpty()&&this.makeEmpty(),this}union(x){return this.min.min(x.min),this.max.max(x.max),this}applyMatrix4(x){return this.isEmpty()?this:(Hr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(x),Hr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(x),Hr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(x),Hr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(x),Hr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(x),Hr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(x),Hr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(x),Hr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(x),this.setFromPoints(Hr),this)}translate(x){return this.min.add(x),this.max.add(x),this}equals(x){return x.min.equals(this.min)&&x.max.equals(this.max)}}const Hr=[new K,new K,new K,new K,new K,new K,new K,new K],Oa=new K,m1=new Da,Zi=new K,Ji=new K,Qi=new K,Ts=new K,As=new K,Fa=new K,Il=new K,Wd=new K,Gd=new K,Ua=new K;function g1(s,x,n,r,a){for(let i=0,o=s.length-3;i<=o;i+=3){Ua.fromArray(s,i);const l=a.x*Math.abs(Ua.x)+a.y*Math.abs(Ua.y)+a.z*Math.abs(Ua.z),c=x.dot(Ua),d=n.dot(Ua),h=r.dot(Ua);if(Math.max(-Math.max(c,d,h),Math.min(c,d,h))>l)return!1}return!0}const LJ=new Da,SA=new K,Vd=new K,y1=new K;class Ba{constructor(x=new K,n=-1){this.center=x,this.radius=n}set(x,n){return this.center.copy(x),this.radius=n,this}setFromPoints(x,n){const r=this.center;n!==void 0?r.copy(n):LJ.setFromPoints(x).getCenter(r);let a=0;for(let i=0,o=x.length;i<o;i++)a=Math.max(a,r.distanceToSquared(x[i]));return this.radius=Math.sqrt(a),this}copy(x){return this.center.copy(x.center),this.radius=x.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(x){return x.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(x){return x.distanceTo(this.center)-this.radius}intersectsSphere(x){const n=this.radius+x.radius;return x.center.distanceToSquared(this.center)<=n*n}intersectsBox(x){return x.intersectsSphere(this)}intersectsPlane(x){return Math.abs(x.distanceToPoint(this.center))<=this.radius}clampPoint(x,n){const r=this.center.distanceToSquared(x);return n.copy(x),r>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(x){return this.isEmpty()?(x.makeEmpty(),x):(x.set(this.center,this.center),x.expandByScalar(this.radius),x)}applyMatrix4(x){return this.center.applyMatrix4(x),this.radius=this.radius*x.getMaxScaleOnAxis(),this}translate(x){return this.center.add(x),this}expandByPoint(x){y1.subVectors(x,this.center);const n=y1.lengthSq();if(n>this.radius*this.radius){const r=Math.sqrt(n),a=(r-this.radius)*.5;this.center.add(y1.multiplyScalar(a/r)),this.radius+=a}return this}union(x){return this.center.equals(x.center)===!0?Vd.set(0,0,1).multiplyScalar(x.radius):Vd.subVectors(x.center,this.center).normalize().multiplyScalar(x.radius),this.expandByPoint(SA.copy(x.center).add(Vd)),this.expandByPoint(SA.copy(x.center).sub(Vd)),this}equals(x){return x.center.equals(this.center)&&x.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Yr=new K,b1=new K,Hd=new K,Es=new K,v1=new K,Yd=new K,w1=new K;class qd{constructor(x=new K,n=new K(0,0,-1)){this.origin=x,this.direction=n}set(x,n){return this.origin.copy(x),this.direction.copy(n),this}copy(x){return this.origin.copy(x.origin),this.direction.copy(x.direction),this}at(x,n){return n.copy(this.direction).multiplyScalar(x).add(this.origin)}lookAt(x){return this.direction.copy(x).sub(this.origin).normalize(),this}recast(x){return this.origin.copy(this.at(x,Yr)),this}closestPointToPoint(x,n){n.subVectors(x,this.origin);const r=n.dot(this.direction);return r<0?n.copy(this.origin):n.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(x){return Math.sqrt(this.distanceSqToPoint(x))}distanceSqToPoint(x){const n=Yr.subVectors(x,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(x):(Yr.copy(this.direction).multiplyScalar(n).add(this.origin),Yr.distanceToSquared(x))}distanceSqToSegment(x,n,r,a){b1.copy(x).add(n).multiplyScalar(.5),Hd.copy(n).sub(x).normalize(),Es.copy(this.origin).sub(b1);const i=x.distanceTo(n)*.5,o=-this.direction.dot(Hd),l=Es.dot(this.direction),c=-Es.dot(Hd),d=Es.lengthSq(),h=Math.abs(1-o*o);let p,m,g,y;if(h>0)if(p=o*c-l,m=o*l-c,y=i*h,p>=0)if(m>=-y)if(m<=y){const b=1/h;p*=b,m*=b,g=p*(p+o*m+2*l)+m*(o*p+m+2*c)+d}else m=i,p=Math.max(0,-(o*m+l)),g=-p*p+m*(m+2*c)+d;else m=-i,p=Math.max(0,-(o*m+l)),g=-p*p+m*(m+2*c)+d;else m<=-y?(p=Math.max(0,-(-o*i+l)),m=p>0?-i:Math.min(Math.max(-i,-c),i),g=-p*p+m*(m+2*c)+d):m<=y?(p=0,m=Math.min(Math.max(-i,-c),i),g=m*(m+2*c)+d):(p=Math.max(0,-(o*i+l)),m=p>0?i:Math.min(Math.max(-i,-c),i),g=-p*p+m*(m+2*c)+d);else m=o>0?-i:i,p=Math.max(0,-(o*m+l)),g=-p*p+m*(m+2*c)+d;return r&&r.copy(this.direction).multiplyScalar(p).add(this.origin),a&&a.copy(Hd).multiplyScalar(m).add(b1),g}intersectSphere(x,n){Yr.subVectors(x.center,this.origin);const r=Yr.dot(this.direction),a=Yr.dot(Yr)-r*r,i=x.radius*x.radius;if(a>i)return null;const o=Math.sqrt(i-a),l=r-o,c=r+o;return l<0&&c<0?null:l<0?this.at(c,n):this.at(l,n)}intersectsSphere(x){return this.distanceSqToPoint(x.center)<=x.radius*x.radius}distanceToPlane(x){const n=x.normal.dot(this.direction);if(n===0)return x.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(x.normal)+x.constant)/n;return r>=0?r:null}intersectPlane(x,n){const r=this.distanceToPlane(x);return r===null?null:this.at(r,n)}intersectsPlane(x){const n=x.distanceToPoint(this.origin);return n===0||x.normal.dot(this.direction)*n<0}intersectBox(x,n){let r,a,i,o,l,c;const d=1/this.direction.x,h=1/this.direction.y,p=1/this.direction.z,m=this.origin;return d>=0?(r=(x.min.x-m.x)*d,a=(x.max.x-m.x)*d):(r=(x.max.x-m.x)*d,a=(x.min.x-m.x)*d),h>=0?(i=(x.min.y-m.y)*h,o=(x.max.y-m.y)*h):(i=(x.max.y-m.y)*h,o=(x.min.y-m.y)*h),r>o||i>a||((i>r||r!==r)&&(r=i),(o<a||a!==a)&&(a=o),p>=0?(l=(x.min.z-m.z)*p,c=(x.max.z-m.z)*p):(l=(x.max.z-m.z)*p,c=(x.min.z-m.z)*p),r>c||l>a)||((l>r||r!==r)&&(r=l),(c<a||a!==a)&&(a=c),a<0)?null:this.at(r>=0?r:a,n)}intersectsBox(x){return this.intersectBox(x,Yr)!==null}intersectTriangle(x,n,r,a,i){v1.subVectors(n,x),Yd.subVectors(r,x),w1.crossVectors(v1,Yd);let o=this.direction.dot(w1),l;if(o>0){if(a)return null;l=1}else if(o<0)l=-1,o=-o;else return null;Es.subVectors(this.origin,x);const c=l*this.direction.dot(Yd.crossVectors(Es,Yd));if(c<0)return null;const d=l*this.direction.dot(v1.cross(Es));if(d<0||c+d>o)return null;const h=-l*Es.dot(w1);return h<0?null:this.at(h/o,i)}applyMatrix4(x){return this.origin.applyMatrix4(x),this.direction.transformDirection(x),this}equals(x){return x.origin.equals(this.origin)&&x.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class wt{constructor(){wt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(x,n,r,a,i,o,l,c,d,h,p,m,g,y,b,v){const w=this.elements;return w[0]=x,w[4]=n,w[8]=r,w[12]=a,w[1]=i,w[5]=o,w[9]=l,w[13]=c,w[2]=d,w[6]=h,w[10]=p,w[14]=m,w[3]=g,w[7]=y,w[11]=b,w[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new wt().fromArray(this.elements)}copy(x){const n=this.elements,r=x.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],n[9]=r[9],n[10]=r[10],n[11]=r[11],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15],this}copyPosition(x){const n=this.elements,r=x.elements;return n[12]=r[12],n[13]=r[13],n[14]=r[14],this}setFromMatrix3(x){const n=x.elements;return this.set(n[0],n[3],n[6],0,n[1],n[4],n[7],0,n[2],n[5],n[8],0,0,0,0,1),this}extractBasis(x,n,r){return x.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(x,n,r){return this.set(x.x,n.x,r.x,0,x.y,n.y,r.y,0,x.z,n.z,r.z,0,0,0,0,1),this}extractRotation(x){const n=this.elements,r=x.elements,a=1/ji.setFromMatrixColumn(x,0).length(),i=1/ji.setFromMatrixColumn(x,1).length(),o=1/ji.setFromMatrixColumn(x,2).length();return n[0]=r[0]*a,n[1]=r[1]*a,n[2]=r[2]*a,n[3]=0,n[4]=r[4]*i,n[5]=r[5]*i,n[6]=r[6]*i,n[7]=0,n[8]=r[8]*o,n[9]=r[9]*o,n[10]=r[10]*o,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(x){const n=this.elements,r=x.x,a=x.y,i=x.z,o=Math.cos(r),l=Math.sin(r),c=Math.cos(a),d=Math.sin(a),h=Math.cos(i),p=Math.sin(i);if(x.order==="XYZ"){const m=o*h,g=o*p,y=l*h,b=l*p;n[0]=c*h,n[4]=-c*p,n[8]=d,n[1]=g+y*d,n[5]=m-b*d,n[9]=-l*c,n[2]=b-m*d,n[6]=y+g*d,n[10]=o*c}else if(x.order==="YXZ"){const m=c*h,g=c*p,y=d*h,b=d*p;n[0]=m+b*l,n[4]=y*l-g,n[8]=o*d,n[1]=o*p,n[5]=o*h,n[9]=-l,n[2]=g*l-y,n[6]=b+m*l,n[10]=o*c}else if(x.order==="ZXY"){const m=c*h,g=c*p,y=d*h,b=d*p;n[0]=m-b*l,n[4]=-o*p,n[8]=y+g*l,n[1]=g+y*l,n[5]=o*h,n[9]=b-m*l,n[2]=-o*d,n[6]=l,n[10]=o*c}else if(x.order==="ZYX"){const m=o*h,g=o*p,y=l*h,b=l*p;n[0]=c*h,n[4]=y*d-g,n[8]=m*d+b,n[1]=c*p,n[5]=b*d+m,n[9]=g*d-y,n[2]=-d,n[6]=l*c,n[10]=o*c}else if(x.order==="YZX"){const m=o*c,g=o*d,y=l*c,b=l*d;n[0]=c*h,n[4]=b-m*p,n[8]=y*p+g,n[1]=p,n[5]=o*h,n[9]=-l*h,n[2]=-d*h,n[6]=g*p+y,n[10]=m-b*p}else if(x.order==="XZY"){const m=o*c,g=o*d,y=l*c,b=l*d;n[0]=c*h,n[4]=-p,n[8]=d*h,n[1]=m*p+b,n[5]=o*h,n[9]=g*p-y,n[2]=y*p-g,n[6]=l*h,n[10]=b*p+m}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(x){return this.compose(DJ,x,OJ)}lookAt(x,n,r){const a=this.elements;return g2.subVectors(x,n),g2.lengthSq()===0&&(g2.z=1),g2.normalize(),Cs.crossVectors(r,g2),Cs.lengthSq()===0&&(Math.abs(r.z)===1?g2.x+=1e-4:g2.z+=1e-4,g2.normalize(),Cs.crossVectors(r,g2)),Cs.normalize(),Xd.crossVectors(g2,Cs),a[0]=Cs.x,a[4]=Xd.x,a[8]=g2.x,a[1]=Cs.y,a[5]=Xd.y,a[9]=g2.y,a[2]=Cs.z,a[6]=Xd.z,a[10]=g2.z,this}multiply(x){return this.multiplyMatrices(this,x)}premultiply(x){return this.multiplyMatrices(x,this)}multiplyMatrices(x,n){const r=x.elements,a=n.elements,i=this.elements,o=r[0],l=r[4],c=r[8],d=r[12],h=r[1],p=r[5],m=r[9],g=r[13],y=r[2],b=r[6],v=r[10],w=r[14],_=r[3],T=r[7],A=r[11],E=r[15],M=a[0],I=a[4],C=a[8],k=a[12],O=a[1],z=a[5],ee=a[9],re=a[13],Y=a[2],Q=a[6],te=a[10],se=a[14],xe=a[3],ae=a[7],le=a[11],de=a[15];return i[0]=o*M+l*O+c*Y+d*xe,i[4]=o*I+l*z+c*Q+d*ae,i[8]=o*C+l*ee+c*te+d*le,i[12]=o*k+l*re+c*se+d*de,i[1]=h*M+p*O+m*Y+g*xe,i[5]=h*I+p*z+m*Q+g*ae,i[9]=h*C+p*ee+m*te+g*le,i[13]=h*k+p*re+m*se+g*de,i[2]=y*M+b*O+v*Y+w*xe,i[6]=y*I+b*z+v*Q+w*ae,i[10]=y*C+b*ee+v*te+w*le,i[14]=y*k+b*re+v*se+w*de,i[3]=_*M+T*O+A*Y+E*xe,i[7]=_*I+T*z+A*Q+E*ae,i[11]=_*C+T*ee+A*te+E*le,i[15]=_*k+T*re+A*se+E*de,this}multiplyScalar(x){const n=this.elements;return n[0]*=x,n[4]*=x,n[8]*=x,n[12]*=x,n[1]*=x,n[5]*=x,n[9]*=x,n[13]*=x,n[2]*=x,n[6]*=x,n[10]*=x,n[14]*=x,n[3]*=x,n[7]*=x,n[11]*=x,n[15]*=x,this}determinant(){const x=this.elements,n=x[0],r=x[4],a=x[8],i=x[12],o=x[1],l=x[5],c=x[9],d=x[13],h=x[2],p=x[6],m=x[10],g=x[14],y=x[3],b=x[7],v=x[11],w=x[15];return y*(+i*c*p-a*d*p-i*l*m+r*d*m+a*l*g-r*c*g)+b*(+n*c*g-n*d*m+i*o*m-a*o*g+a*d*h-i*c*h)+v*(+n*d*p-n*l*g-i*o*p+r*o*g+i*l*h-r*d*h)+w*(-a*l*h-n*c*p+n*l*m+a*o*p-r*o*m+r*c*h)}transpose(){const x=this.elements;let n;return n=x[1],x[1]=x[4],x[4]=n,n=x[2],x[2]=x[8],x[8]=n,n=x[6],x[6]=x[9],x[9]=n,n=x[3],x[3]=x[12],x[12]=n,n=x[7],x[7]=x[13],x[13]=n,n=x[11],x[11]=x[14],x[14]=n,this}setPosition(x,n,r){const a=this.elements;return x.isVector3?(a[12]=x.x,a[13]=x.y,a[14]=x.z):(a[12]=x,a[13]=n,a[14]=r),this}invert(){const x=this.elements,n=x[0],r=x[1],a=x[2],i=x[3],o=x[4],l=x[5],c=x[6],d=x[7],h=x[8],p=x[9],m=x[10],g=x[11],y=x[12],b=x[13],v=x[14],w=x[15],_=p*v*d-b*m*d+b*c*g-l*v*g-p*c*w+l*m*w,T=y*m*d-h*v*d-y*c*g+o*v*g+h*c*w-o*m*w,A=h*b*d-y*p*d+y*l*g-o*b*g-h*l*w+o*p*w,E=y*p*c-h*b*c-y*l*m+o*b*m+h*l*v-o*p*v,M=n*_+r*T+a*A+i*E;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const I=1/M;return x[0]=_*I,x[1]=(b*m*i-p*v*i-b*a*g+r*v*g+p*a*w-r*m*w)*I,x[2]=(l*v*i-b*c*i+b*a*d-r*v*d-l*a*w+r*c*w)*I,x[3]=(p*c*i-l*m*i-p*a*d+r*m*d+l*a*g-r*c*g)*I,x[4]=T*I,x[5]=(h*v*i-y*m*i+y*a*g-n*v*g-h*a*w+n*m*w)*I,x[6]=(y*c*i-o*v*i-y*a*d+n*v*d+o*a*w-n*c*w)*I,x[7]=(o*m*i-h*c*i+h*a*d-n*m*d-o*a*g+n*c*g)*I,x[8]=A*I,x[9]=(y*p*i-h*b*i-y*r*g+n*b*g+h*r*w-n*p*w)*I,x[10]=(o*b*i-y*l*i+y*r*d-n*b*d-o*r*w+n*l*w)*I,x[11]=(h*l*i-o*p*i-h*r*d+n*p*d+o*r*g-n*l*g)*I,x[12]=E*I,x[13]=(h*b*a-y*p*a+y*r*m-n*b*m-h*r*v+n*p*v)*I,x[14]=(y*l*a-o*b*a-y*r*c+n*b*c+o*r*v-n*l*v)*I,x[15]=(o*p*a-h*l*a+h*r*c-n*p*c-o*r*m+n*l*m)*I,this}scale(x){const n=this.elements,r=x.x,a=x.y,i=x.z;return n[0]*=r,n[4]*=a,n[8]*=i,n[1]*=r,n[5]*=a,n[9]*=i,n[2]*=r,n[6]*=a,n[10]*=i,n[3]*=r,n[7]*=a,n[11]*=i,this}getMaxScaleOnAxis(){const x=this.elements,n=x[0]*x[0]+x[1]*x[1]+x[2]*x[2],r=x[4]*x[4]+x[5]*x[5]+x[6]*x[6],a=x[8]*x[8]+x[9]*x[9]+x[10]*x[10];return Math.sqrt(Math.max(n,r,a))}makeTranslation(x,n,r){return this.set(1,0,0,x,0,1,0,n,0,0,1,r,0,0,0,1),this}makeRotationX(x){const n=Math.cos(x),r=Math.sin(x);return this.set(1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1),this}makeRotationY(x){const n=Math.cos(x),r=Math.sin(x);return this.set(n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1),this}makeRotationZ(x){const n=Math.cos(x),r=Math.sin(x);return this.set(n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(x,n){const r=Math.cos(n),a=Math.sin(n),i=1-r,o=x.x,l=x.y,c=x.z,d=i*o,h=i*l;return this.set(d*o+r,d*l-a*c,d*c+a*l,0,d*l+a*c,h*l+r,h*c-a*o,0,d*c-a*l,h*c+a*o,i*c*c+r,0,0,0,0,1),this}makeScale(x,n,r){return this.set(x,0,0,0,0,n,0,0,0,0,r,0,0,0,0,1),this}makeShear(x,n,r,a,i,o){return this.set(1,r,i,0,x,1,o,0,n,a,1,0,0,0,0,1),this}compose(x,n,r){const a=this.elements,i=n._x,o=n._y,l=n._z,c=n._w,d=i+i,h=o+o,p=l+l,m=i*d,g=i*h,y=i*p,b=o*h,v=o*p,w=l*p,_=c*d,T=c*h,A=c*p,E=r.x,M=r.y,I=r.z;return a[0]=(1-(b+w))*E,a[1]=(g+A)*E,a[2]=(y-T)*E,a[3]=0,a[4]=(g-A)*M,a[5]=(1-(m+w))*M,a[6]=(v+_)*M,a[7]=0,a[8]=(y+T)*I,a[9]=(v-_)*I,a[10]=(1-(m+b))*I,a[11]=0,a[12]=x.x,a[13]=x.y,a[14]=x.z,a[15]=1,this}decompose(x,n,r){const a=this.elements;let i=ji.set(a[0],a[1],a[2]).length();const o=ji.set(a[4],a[5],a[6]).length(),l=ji.set(a[8],a[9],a[10]).length();this.determinant()<0&&(i=-i),x.x=a[12],x.y=a[13],x.z=a[14],tr.copy(this);const d=1/i,h=1/o,p=1/l;return tr.elements[0]*=d,tr.elements[1]*=d,tr.elements[2]*=d,tr.elements[4]*=h,tr.elements[5]*=h,tr.elements[6]*=h,tr.elements[8]*=p,tr.elements[9]*=p,tr.elements[10]*=p,n.setFromRotationMatrix(tr),r.x=i,r.y=o,r.z=l,this}makePerspective(x,n,r,a,i,o){const l=this.elements,c=2*i/(n-x),d=2*i/(r-a),h=(n+x)/(n-x),p=(r+a)/(r-a),m=-(o+i)/(o-i),g=-2*o*i/(o-i);return l[0]=c,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=d,l[9]=p,l[13]=0,l[2]=0,l[6]=0,l[10]=m,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(x,n,r,a,i,o){const l=this.elements,c=1/(n-x),d=1/(r-a),h=1/(o-i),p=(n+x)*c,m=(r+a)*d,g=(o+i)*h;return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-p,l[1]=0,l[5]=2*d,l[9]=0,l[13]=-m,l[2]=0,l[6]=0,l[10]=-2*h,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(x){const n=this.elements,r=x.elements;for(let a=0;a<16;a++)if(n[a]!==r[a])return!1;return!0}fromArray(x,n=0){for(let r=0;r<16;r++)this.elements[r]=x[r+n];return this}toArray(x=[],n=0){const r=this.elements;return x[n]=r[0],x[n+1]=r[1],x[n+2]=r[2],x[n+3]=r[3],x[n+4]=r[4],x[n+5]=r[5],x[n+6]=r[6],x[n+7]=r[7],x[n+8]=r[8],x[n+9]=r[9],x[n+10]=r[10],x[n+11]=r[11],x[n+12]=r[12],x[n+13]=r[13],x[n+14]=r[14],x[n+15]=r[15],x}}const ji=new K,tr=new wt,DJ=new K(0,0,0),OJ=new K(1,1,1),Cs=new K,Xd=new K,g2=new K,TA=new wt,AA=new Bn;class kl{constructor(x=0,n=0,r=0,a=kl.DefaultOrder){this.isEuler=!0,this._x=x,this._y=n,this._z=r,this._order=a}get x(){return this._x}set x(x){this._x=x,this._onChangeCallback()}get y(){return this._y}set y(x){this._y=x,this._onChangeCallback()}get z(){return this._z}set z(x){this._z=x,this._onChangeCallback()}get order(){return this._order}set order(x){this._order=x,this._onChangeCallback()}set(x,n,r,a=this._order){return this._x=x,this._y=n,this._z=r,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(x){return this._x=x._x,this._y=x._y,this._z=x._z,this._order=x._order,this._onChangeCallback(),this}setFromRotationMatrix(x,n=this._order,r=!0){const a=x.elements,i=a[0],o=a[4],l=a[8],c=a[1],d=a[5],h=a[9],p=a[2],m=a[6],g=a[10];switch(n){case"XYZ":this._y=Math.asin(Gx(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,g),this._z=Math.atan2(-o,i)):(this._x=Math.atan2(m,d),this._z=0);break;case"YXZ":this._x=Math.asin(-Gx(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,g),this._z=Math.atan2(c,d)):(this._y=Math.atan2(-p,i),this._z=0);break;case"ZXY":this._x=Math.asin(Gx(m,-1,1)),Math.abs(m)<.9999999?(this._y=Math.atan2(-p,g),this._z=Math.atan2(-o,d)):(this._y=0,this._z=Math.atan2(c,i));break;case"ZYX":this._y=Math.asin(-Gx(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(m,g),this._z=Math.atan2(c,i)):(this._x=0,this._z=Math.atan2(-o,d));break;case"YZX":this._z=Math.asin(Gx(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,d),this._y=Math.atan2(-p,i)):(this._x=0,this._y=Math.atan2(l,g));break;case"XZY":this._z=Math.asin(-Gx(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(m,d),this._y=Math.atan2(l,i)):(this._x=Math.atan2(-h,g),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,r===!0&&this._onChangeCallback(),this}setFromQuaternion(x,n,r){return TA.makeRotationFromQuaternion(x),this.setFromRotationMatrix(TA,n,r)}setFromVector3(x,n=this._order){return this.set(x.x,x.y,x.z,n)}reorder(x){return AA.setFromEuler(this),this.setFromQuaternion(AA,x)}equals(x){return x._x===this._x&&x._y===this._y&&x._z===this._z&&x._order===this._order}fromArray(x){return this._x=x[0],this._y=x[1],this._z=x[2],x[3]!==void 0&&(this._order=x[3]),this._onChangeCallback(),this}toArray(x=[],n=0){return x[n]=this._x,x[n+1]=this._y,x[n+2]=this._z,x[n+3]=this._order,x}_onChange(x){return this._onChangeCallback=x,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}kl.DefaultOrder="XYZ",kl.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class _1{constructor(){this.mask=1}set(x){this.mask=(1<<x|0)>>>0}enable(x){this.mask|=1<<x|0}enableAll(){this.mask=-1}toggle(x){this.mask^=1<<x|0}disable(x){this.mask&=~(1<<x|0)}disableAll(){this.mask=0}test(x){return(this.mask&x.mask)!==0}isEnabled(x){return(this.mask&(1<<x|0))!==0}}let FJ=0;const EA=new K,eo=new Bn,qr=new wt,Kd=new K,Nl=new K,UJ=new K,BJ=new Bn,CA=new K(1,0,0),MA=new K(0,1,0),IA=new K(0,0,1),zJ={type:"added"},kA={type:"removed"};class Px extends qi{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:FJ++}),this.uuid=f2(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Px.DefaultUp.clone();const x=new K,n=new kl,r=new Bn,a=new K(1,1,1);function i(){r.setFromEuler(n,!1)}function o(){n.setFromQuaternion(r,void 0,!1)}n._onChange(i),r._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:x},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new wt},normalMatrix:{value:new m2}}),this.matrix=new wt,this.matrixWorld=new wt,this.matrixAutoUpdate=Px.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new _1,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(x){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(x),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(x){return this.quaternion.premultiply(x),this}setRotationFromAxisAngle(x,n){this.quaternion.setFromAxisAngle(x,n)}setRotationFromEuler(x){this.quaternion.setFromEuler(x,!0)}setRotationFromMatrix(x){this.quaternion.setFromRotationMatrix(x)}setRotationFromQuaternion(x){this.quaternion.copy(x)}rotateOnAxis(x,n){return eo.setFromAxisAngle(x,n),this.quaternion.multiply(eo),this}rotateOnWorldAxis(x,n){return eo.setFromAxisAngle(x,n),this.quaternion.premultiply(eo),this}rotateX(x){return this.rotateOnAxis(CA,x)}rotateY(x){return this.rotateOnAxis(MA,x)}rotateZ(x){return this.rotateOnAxis(IA,x)}translateOnAxis(x,n){return EA.copy(x).applyQuaternion(this.quaternion),this.position.add(EA.multiplyScalar(n)),this}translateX(x){return this.translateOnAxis(CA,x)}translateY(x){return this.translateOnAxis(MA,x)}translateZ(x){return this.translateOnAxis(IA,x)}localToWorld(x){return x.applyMatrix4(this.matrixWorld)}worldToLocal(x){return x.applyMatrix4(qr.copy(this.matrixWorld).invert())}lookAt(x,n,r){x.isVector3?Kd.copy(x):Kd.set(x,n,r);const a=this.parent;this.updateWorldMatrix(!0,!1),Nl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qr.lookAt(Nl,Kd,this.up):qr.lookAt(Kd,Nl,this.up),this.quaternion.setFromRotationMatrix(qr),a&&(qr.extractRotation(a.matrixWorld),eo.setFromRotationMatrix(qr),this.quaternion.premultiply(eo.invert()))}add(x){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return x===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",x),this):(x&&x.isObject3D?(x.parent!==null&&x.parent.remove(x),x.parent=this,this.children.push(x),x.dispatchEvent(zJ)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",x),this)}remove(x){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const n=this.children.indexOf(x);return n!==-1&&(x.parent=null,this.children.splice(n,1),x.dispatchEvent(kA)),this}removeFromParent(){const x=this.parent;return x!==null&&x.remove(this),this}clear(){for(let x=0;x<this.children.length;x++){const n=this.children[x];n.parent=null,n.dispatchEvent(kA)}return this.children.length=0,this}attach(x){return this.updateWorldMatrix(!0,!1),qr.copy(this.matrixWorld).invert(),x.parent!==null&&(x.parent.updateWorldMatrix(!0,!1),qr.multiply(x.parent.matrixWorld)),x.applyMatrix4(qr),this.add(x),x.updateWorldMatrix(!1,!0),this}getObjectById(x){return this.getObjectByProperty("id",x)}getObjectByName(x){return this.getObjectByProperty("name",x)}getObjectByProperty(x,n){if(this[x]===n)return this;for(let r=0,a=this.children.length;r<a;r++){const o=this.children[r].getObjectByProperty(x,n);if(o!==void 0)return o}}getWorldPosition(x){return this.updateWorldMatrix(!0,!1),x.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(x){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Nl,x,UJ),x}getWorldScale(x){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Nl,BJ,x),x}getWorldDirection(x){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return x.set(n[8],n[9],n[10]).normalize()}raycast(){}traverse(x){x(this);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].traverse(x)}traverseVisible(x){if(this.visible===!1)return;x(this);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].traverseVisible(x)}traverseAncestors(x){const n=this.parent;n!==null&&(x(n),n.traverseAncestors(x))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(x){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||x)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,x=!0);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].updateMatrixWorld(x)}updateWorldMatrix(x,n){const r=this.parent;if(x===!0&&r!==null&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),n===!0){const a=this.children;for(let i=0,o=a.length;i<o;i++)a[i].updateWorldMatrix(!1,!0)}}toJSON(x){const n=x===void 0||typeof x=="string",r={};n&&(x={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const a={};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.castShadow===!0&&(a.castShadow=!0),this.receiveShadow===!0&&(a.receiveShadow=!0),this.visible===!1&&(a.visible=!1),this.frustumCulled===!1&&(a.frustumCulled=!1),this.renderOrder!==0&&(a.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(a.instanceColor=this.instanceColor.toJSON()));function i(l,c){return l[c.uuid]===void 0&&(l[c.uuid]=c.toJSON(x)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(x).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(a.environment=this.environment.toJSON(x).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=i(x.geometries,this.geometry);const l=this.geometry.parameters;if(l!==void 0&&l.shapes!==void 0){const c=l.shapes;if(Array.isArray(c))for(let d=0,h=c.length;d<h;d++){const p=c[d];i(x.shapes,p)}else i(x.shapes,c)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(x.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const l=[];for(let c=0,d=this.material.length;c<d;c++)l.push(i(x.materials,this.material[c]));a.material=l}else a.material=i(x.materials,this.material);if(this.children.length>0){a.children=[];for(let l=0;l<this.children.length;l++)a.children.push(this.children[l].toJSON(x).object)}if(this.animations.length>0){a.animations=[];for(let l=0;l<this.animations.length;l++){const c=this.animations[l];a.animations.push(i(x.animations,c))}}if(n){const l=o(x.geometries),c=o(x.materials),d=o(x.textures),h=o(x.images),p=o(x.shapes),m=o(x.skeletons),g=o(x.animations),y=o(x.nodes);l.length>0&&(r.geometries=l),c.length>0&&(r.materials=c),d.length>0&&(r.textures=d),h.length>0&&(r.images=h),p.length>0&&(r.shapes=p),m.length>0&&(r.skeletons=m),g.length>0&&(r.animations=g),y.length>0&&(r.nodes=y)}return r.object=a,r;function o(l){const c=[];for(const d in l){const h=l[d];delete h.metadata,c.push(h)}return c}}clone(x){return new this.constructor().copy(this,x)}copy(x,n=!0){if(this.name=x.name,this.up.copy(x.up),this.position.copy(x.position),this.rotation.order=x.rotation.order,this.quaternion.copy(x.quaternion),this.scale.copy(x.scale),this.matrix.copy(x.matrix),this.matrixWorld.copy(x.matrixWorld),this.matrixAutoUpdate=x.matrixAutoUpdate,this.matrixWorldNeedsUpdate=x.matrixWorldNeedsUpdate,this.layers.mask=x.layers.mask,this.visible=x.visible,this.castShadow=x.castShadow,this.receiveShadow=x.receiveShadow,this.frustumCulled=x.frustumCulled,this.renderOrder=x.renderOrder,this.userData=JSON.parse(JSON.stringify(x.userData)),n===!0)for(let r=0;r<x.children.length;r++){const a=x.children[r];this.add(a.clone())}return this}}Px.DefaultUp=new K(0,1,0),Px.DefaultMatrixAutoUpdate=!0;const xr=new K,Xr=new K,S1=new K,Kr=new K,to=new K,xo=new K,NA=new K,T1=new K,A1=new K,E1=new K;class nr{constructor(x=new K,n=new K,r=new K){this.a=x,this.b=n,this.c=r}static getNormal(x,n,r,a){a.subVectors(r,n),xr.subVectors(x,n),a.cross(xr);const i=a.lengthSq();return i>0?a.multiplyScalar(1/Math.sqrt(i)):a.set(0,0,0)}static getBarycoord(x,n,r,a,i){xr.subVectors(a,n),Xr.subVectors(r,n),S1.subVectors(x,n);const o=xr.dot(xr),l=xr.dot(Xr),c=xr.dot(S1),d=Xr.dot(Xr),h=Xr.dot(S1),p=o*d-l*l;if(p===0)return i.set(-2,-1,-1);const m=1/p,g=(d*c-l*h)*m,y=(o*h-l*c)*m;return i.set(1-g-y,y,g)}static containsPoint(x,n,r,a){return this.getBarycoord(x,n,r,a,Kr),Kr.x>=0&&Kr.y>=0&&Kr.x+Kr.y<=1}static getUV(x,n,r,a,i,o,l,c){return this.getBarycoord(x,n,r,a,Kr),c.set(0,0),c.addScaledVector(i,Kr.x),c.addScaledVector(o,Kr.y),c.addScaledVector(l,Kr.z),c}static isFrontFacing(x,n,r,a){return xr.subVectors(r,n),Xr.subVectors(x,n),xr.cross(Xr).dot(a)<0}set(x,n,r){return this.a.copy(x),this.b.copy(n),this.c.copy(r),this}setFromPointsAndIndices(x,n,r,a){return this.a.copy(x[n]),this.b.copy(x[r]),this.c.copy(x[a]),this}setFromAttributeAndIndices(x,n,r,a){return this.a.fromBufferAttribute(x,n),this.b.fromBufferAttribute(x,r),this.c.fromBufferAttribute(x,a),this}clone(){return new this.constructor().copy(this)}copy(x){return this.a.copy(x.a),this.b.copy(x.b),this.c.copy(x.c),this}getArea(){return xr.subVectors(this.c,this.b),Xr.subVectors(this.a,this.b),xr.cross(Xr).length()*.5}getMidpoint(x){return x.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(x){return nr.getNormal(this.a,this.b,this.c,x)}getPlane(x){return x.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(x,n){return nr.getBarycoord(x,this.a,this.b,this.c,n)}getUV(x,n,r,a,i){return nr.getUV(x,this.a,this.b,this.c,n,r,a,i)}containsPoint(x){return nr.containsPoint(x,this.a,this.b,this.c)}isFrontFacing(x){return nr.isFrontFacing(this.a,this.b,this.c,x)}intersectsBox(x){return x.intersectsTriangle(this)}closestPointToPoint(x,n){const r=this.a,a=this.b,i=this.c;let o,l;to.subVectors(a,r),xo.subVectors(i,r),T1.subVectors(x,r);const c=to.dot(T1),d=xo.dot(T1);if(c<=0&&d<=0)return n.copy(r);A1.subVectors(x,a);const h=to.dot(A1),p=xo.dot(A1);if(h>=0&&p<=h)return n.copy(a);const m=c*p-h*d;if(m<=0&&c>=0&&h<=0)return o=c/(c-h),n.copy(r).addScaledVector(to,o);E1.subVectors(x,i);const g=to.dot(E1),y=xo.dot(E1);if(y>=0&&g<=y)return n.copy(i);const b=g*d-c*y;if(b<=0&&d>=0&&y<=0)return l=d/(d-y),n.copy(r).addScaledVector(xo,l);const v=h*y-g*p;if(v<=0&&p-h>=0&&g-y>=0)return NA.subVectors(i,a),l=(p-h)/(p-h+(g-y)),n.copy(a).addScaledVector(NA,l);const w=1/(v+b+m);return o=b*w,l=m*w,n.copy(r).addScaledVector(to,o).addScaledVector(xo,l)}equals(x){return x.a.equals(this.a)&&x.b.equals(this.b)&&x.c.equals(this.c)}}let WJ=0;class y2 extends qi{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:WJ++}),this.uuid=f2(),this.name="",this.type="Material",this.blending=Bi,this.side=Ui,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=VT,this.blendDst=HT,this.blendEquation=zi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Qg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=fJ,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=i1,this.stencilZFail=i1,this.stencilZPass=i1,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(x){this._alphaTest>0!=x>0&&this.version++,this._alphaTest=x}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(x){if(x!==void 0)for(const n in x){const r=x[n];if(r===void 0){console.warn("THREE.Material: '"+n+"' parameter is undefined.");continue}if(n==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=r===vZ;continue}const a=this[n];if(a===void 0){console.warn("THREE."+this.type+": '"+n+"' is not a property of this material.");continue}a&&a.isColor?a.set(r):a&&a.isVector3&&r&&r.isVector3?a.copy(r):this[n]=r}}toJSON(x){const n=x===void 0||typeof x=="string";n&&(x={textures:{},images:{}});const r={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(x).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(x).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(x).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(x).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(x).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(x).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(x).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(x).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(x).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(x).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(x).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(x).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(x).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(x).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(x).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(x).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(x).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(x).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(x).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(x).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(x).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(x).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(x).uuid),this.attenuationDistance!==void 0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==Bi&&(r.blending=this.blending),this.side!==Ui&&(r.side=this.side),this.vertexColors&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=this.transparent),r.depthFunc=this.depthFunc,r.depthTest=this.depthTest,r.depthWrite=this.depthWrite,r.colorWrite=this.colorWrite,r.stencilWrite=this.stencilWrite,r.stencilWriteMask=this.stencilWriteMask,r.stencilFunc=this.stencilFunc,r.stencilRef=this.stencilRef,r.stencilFuncMask=this.stencilFuncMask,r.stencilFail=this.stencilFail,r.stencilZFail=this.stencilZFail,r.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(r.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(r.wireframe=this.wireframe),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=this.flatShading),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData);function a(i){const o=[];for(const l in i){const c=i[l];delete c.metadata,o.push(c)}return o}if(n){const i=a(x.textures),o=a(x.images);i.length>0&&(r.textures=i),o.length>0&&(r.images=o)}return r}clone(){return new this.constructor().copy(this)}copy(x){this.name=x.name,this.blending=x.blending,this.side=x.side,this.vertexColors=x.vertexColors,this.opacity=x.opacity,this.transparent=x.transparent,this.blendSrc=x.blendSrc,this.blendDst=x.blendDst,this.blendEquation=x.blendEquation,this.blendSrcAlpha=x.blendSrcAlpha,this.blendDstAlpha=x.blendDstAlpha,this.blendEquationAlpha=x.blendEquationAlpha,this.depthFunc=x.depthFunc,this.depthTest=x.depthTest,this.depthWrite=x.depthWrite,this.stencilWriteMask=x.stencilWriteMask,this.stencilFunc=x.stencilFunc,this.stencilRef=x.stencilRef,this.stencilFuncMask=x.stencilFuncMask,this.stencilFail=x.stencilFail,this.stencilZFail=x.stencilZFail,this.stencilZPass=x.stencilZPass,this.stencilWrite=x.stencilWrite;const n=x.clippingPlanes;let r=null;if(n!==null){const a=n.length;r=new Array(a);for(let i=0;i!==a;++i)r[i]=n[i].clone()}return this.clippingPlanes=r,this.clipIntersection=x.clipIntersection,this.clipShadows=x.clipShadows,this.shadowSide=x.shadowSide,this.colorWrite=x.colorWrite,this.precision=x.precision,this.polygonOffset=x.polygonOffset,this.polygonOffsetFactor=x.polygonOffsetFactor,this.polygonOffsetUnits=x.polygonOffsetUnits,this.dithering=x.dithering,this.alphaTest=x.alphaTest,this.alphaToCoverage=x.alphaToCoverage,this.premultipliedAlpha=x.premultipliedAlpha,this.visible=x.visible,this.toneMapped=x.toneMapped,this.userData=JSON.parse(JSON.stringify(x.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(x){x===!0&&this.version++}}class F2 extends y2{constructor(x){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new M0(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Nd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.map=x.map,this.lightMap=x.lightMap,this.lightMapIntensity=x.lightMapIntensity,this.aoMap=x.aoMap,this.aoMapIntensity=x.aoMapIntensity,this.specularMap=x.specularMap,this.alphaMap=x.alphaMap,this.envMap=x.envMap,this.combine=x.combine,this.reflectivity=x.reflectivity,this.refractionRatio=x.refractionRatio,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.wireframeLinecap=x.wireframeLinecap,this.wireframeLinejoin=x.wireframeLinejoin,this.fog=x.fog,this}}const Jx=new K,$d=new n0;class Qx{constructor(x,n,r){if(Array.isArray(x))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=x,this.itemSize=n,this.count=x!==void 0?x.length/n:0,this.normalized=r===!0,this.usage=Od,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(x){x===!0&&this.version++}setUsage(x){return this.usage=x,this}copy(x){return this.name=x.name,this.array=new x.array.constructor(x.array),this.itemSize=x.itemSize,this.count=x.count,this.normalized=x.normalized,this.usage=x.usage,this}copyAt(x,n,r){x*=this.itemSize,r*=n.itemSize;for(let a=0,i=this.itemSize;a<i;a++)this.array[x+a]=n.array[r+a];return this}copyArray(x){return this.array.set(x),this}copyColorsArray(x){const n=this.array;let r=0;for(let a=0,i=x.length;a<i;a++){let o=x[a];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",a),o=new M0),n[r++]=o.r,n[r++]=o.g,n[r++]=o.b}return this}copyVector2sArray(x){const n=this.array;let r=0;for(let a=0,i=x.length;a<i;a++){let o=x[a];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",a),o=new n0),n[r++]=o.x,n[r++]=o.y}return this}copyVector3sArray(x){const n=this.array;let r=0;for(let a=0,i=x.length;a<i;a++){let o=x[a];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",a),o=new K),n[r++]=o.x,n[r++]=o.y,n[r++]=o.z}return this}copyVector4sArray(x){const n=this.array;let r=0;for(let a=0,i=x.length;a<i;a++){let o=x[a];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",a),o=new ix),n[r++]=o.x,n[r++]=o.y,n[r++]=o.z,n[r++]=o.w}return this}applyMatrix3(x){if(this.itemSize===2)for(let n=0,r=this.count;n<r;n++)$d.fromBufferAttribute(this,n),$d.applyMatrix3(x),this.setXY(n,$d.x,$d.y);else if(this.itemSize===3)for(let n=0,r=this.count;n<r;n++)Jx.fromBufferAttribute(this,n),Jx.applyMatrix3(x),this.setXYZ(n,Jx.x,Jx.y,Jx.z);return this}applyMatrix4(x){for(let n=0,r=this.count;n<r;n++)Jx.fromBufferAttribute(this,n),Jx.applyMatrix4(x),this.setXYZ(n,Jx.x,Jx.y,Jx.z);return this}applyNormalMatrix(x){for(let n=0,r=this.count;n<r;n++)Jx.fromBufferAttribute(this,n),Jx.applyNormalMatrix(x),this.setXYZ(n,Jx.x,Jx.y,Jx.z);return this}transformDirection(x){for(let n=0,r=this.count;n<r;n++)Jx.fromBufferAttribute(this,n),Jx.transformDirection(x),this.setXYZ(n,Jx.x,Jx.y,Jx.z);return this}set(x,n=0){return this.array.set(x,n),this}getX(x){return this.array[x*this.itemSize]}setX(x,n){return this.array[x*this.itemSize]=n,this}getY(x){return this.array[x*this.itemSize+1]}setY(x,n){return this.array[x*this.itemSize+1]=n,this}getZ(x){return this.array[x*this.itemSize+2]}setZ(x,n){return this.array[x*this.itemSize+2]=n,this}getW(x){return this.array[x*this.itemSize+3]}setW(x,n){return this.array[x*this.itemSize+3]=n,this}setXY(x,n,r){return x*=this.itemSize,this.array[x+0]=n,this.array[x+1]=r,this}setXYZ(x,n,r,a){return x*=this.itemSize,this.array[x+0]=n,this.array[x+1]=r,this.array[x+2]=a,this}setXYZW(x,n,r,a,i){return x*=this.itemSize,this.array[x+0]=n,this.array[x+1]=r,this.array[x+2]=a,this.array[x+3]=i,this}onUpload(x){return this.onUploadCallback=x,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const x={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(x.name=this.name),this.usage!==Od&&(x.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(x.updateRange=this.updateRange),x}}class G2e extends null{constructor(x,n,r){super(new Int8Array(x),n,r)}}class V2e extends null{constructor(x,n,r){super(new Uint8Array(x),n,r)}}class H2e extends null{constructor(x,n,r){super(new Uint8ClampedArray(x),n,r)}}class Y2e extends null{constructor(x,n,r){super(new Int16Array(x),n,r)}}class RA extends Qx{constructor(x,n,r){super(new Uint16Array(x),n,r)}}class q2e extends null{constructor(x,n,r){super(new Int32Array(x),n,r)}}class PA extends Qx{constructor(x,n,r){super(new Uint32Array(x),n,r)}}class X2e extends null{constructor(x,n,r){super(new Uint16Array(x),n,r),this.isFloat16BufferAttribute=!0}}class q0 extends Qx{constructor(x,n,r){super(new Float32Array(x),n,r)}}class K2e extends null{constructor(x,n,r){super(new Float64Array(x),n,r)}}let GJ=0;const U2=new wt,C1=new Px,no=new K,b2=new Da,Rl=new Da,gn=new K;class Rt extends qi{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:GJ++}),this.uuid=f2(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(x){return Array.isArray(x)?this.index=new(yA(x)?PA:RA)(x,1):this.index=x,this}getAttribute(x){return this.attributes[x]}setAttribute(x,n){return this.attributes[x]=n,this}deleteAttribute(x){return delete this.attributes[x],this}hasAttribute(x){return this.attributes[x]!==void 0}addGroup(x,n,r=0){this.groups.push({start:x,count:n,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(x,n){this.drawRange.start=x,this.drawRange.count=n}applyMatrix4(x){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(x),n.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const i=new m2().getNormalMatrix(x);r.applyNormalMatrix(i),r.needsUpdate=!0}const a=this.attributes.tangent;return a!==void 0&&(a.transformDirection(x),a.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(x){return U2.makeRotationFromQuaternion(x),this.applyMatrix4(U2),this}rotateX(x){return U2.makeRotationX(x),this.applyMatrix4(U2),this}rotateY(x){return U2.makeRotationY(x),this.applyMatrix4(U2),this}rotateZ(x){return U2.makeRotationZ(x),this.applyMatrix4(U2),this}translate(x,n,r){return U2.makeTranslation(x,n,r),this.applyMatrix4(U2),this}scale(x,n,r){return U2.makeScale(x,n,r),this.applyMatrix4(U2),this}lookAt(x){return C1.lookAt(x),C1.updateMatrix(),this.applyMatrix4(C1.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(no).negate(),this.translate(no.x,no.y,no.z),this}setFromPoints(x){const n=[];for(let r=0,a=x.length;r<a;r++){const i=x[r];n.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new q0(n,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Da);const x=this.attributes.position,n=this.morphAttributes.position;if(x&&x.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new K(-1/0,-1/0,-1/0),new K(1/0,1/0,1/0));return}if(x!==void 0){if(this.boundingBox.setFromBufferAttribute(x),n)for(let r=0,a=n.length;r<a;r++){const i=n[r];b2.setFromBufferAttribute(i),this.morphTargetsRelative?(gn.addVectors(this.boundingBox.min,b2.min),this.boundingBox.expandByPoint(gn),gn.addVectors(this.boundingBox.max,b2.max),this.boundingBox.expandByPoint(gn)):(this.boundingBox.expandByPoint(b2.min),this.boundingBox.expandByPoint(b2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ba);const x=this.attributes.position,n=this.morphAttributes.position;if(x&&x.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new K,1/0);return}if(x){const r=this.boundingSphere.center;if(b2.setFromBufferAttribute(x),n)for(let i=0,o=n.length;i<o;i++){const l=n[i];Rl.setFromBufferAttribute(l),this.morphTargetsRelative?(gn.addVectors(b2.min,Rl.min),b2.expandByPoint(gn),gn.addVectors(b2.max,Rl.max),b2.expandByPoint(gn)):(b2.expandByPoint(Rl.min),b2.expandByPoint(Rl.max))}b2.getCenter(r);let a=0;for(let i=0,o=x.count;i<o;i++)gn.fromBufferAttribute(x,i),a=Math.max(a,r.distanceToSquared(gn));if(n)for(let i=0,o=n.length;i<o;i++){const l=n[i],c=this.morphTargetsRelative;for(let d=0,h=l.count;d<h;d++)gn.fromBufferAttribute(l,d),c&&(no.fromBufferAttribute(x,d),gn.add(no)),a=Math.max(a,r.distanceToSquared(gn))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const x=this.index,n=this.attributes;if(x===null||n.position===void 0||n.normal===void 0||n.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=x.array,a=n.position.array,i=n.normal.array,o=n.uv.array,l=a.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Qx(new Float32Array(4*l),4));const c=this.getAttribute("tangent").array,d=[],h=[];for(let O=0;O<l;O++)d[O]=new K,h[O]=new K;const p=new K,m=new K,g=new K,y=new n0,b=new n0,v=new n0,w=new K,_=new K;function T(O,z,ee){p.fromArray(a,O*3),m.fromArray(a,z*3),g.fromArray(a,ee*3),y.fromArray(o,O*2),b.fromArray(o,z*2),v.fromArray(o,ee*2),m.sub(p),g.sub(p),b.sub(y),v.sub(y);const re=1/(b.x*v.y-v.x*b.y);!isFinite(re)||(w.copy(m).multiplyScalar(v.y).addScaledVector(g,-b.y).multiplyScalar(re),_.copy(g).multiplyScalar(b.x).addScaledVector(m,-v.x).multiplyScalar(re),d[O].add(w),d[z].add(w),d[ee].add(w),h[O].add(_),h[z].add(_),h[ee].add(_))}let A=this.groups;A.length===0&&(A=[{start:0,count:r.length}]);for(let O=0,z=A.length;O<z;++O){const ee=A[O],re=ee.start,Y=ee.count;for(let Q=re,te=re+Y;Q<te;Q+=3)T(r[Q+0],r[Q+1],r[Q+2])}const E=new K,M=new K,I=new K,C=new K;function k(O){I.fromArray(i,O*3),C.copy(I);const z=d[O];E.copy(z),E.sub(I.multiplyScalar(I.dot(z))).normalize(),M.crossVectors(C,z);const re=M.dot(h[O])<0?-1:1;c[O*4]=E.x,c[O*4+1]=E.y,c[O*4+2]=E.z,c[O*4+3]=re}for(let O=0,z=A.length;O<z;++O){const ee=A[O],re=ee.start,Y=ee.count;for(let Q=re,te=re+Y;Q<te;Q+=3)k(r[Q+0]),k(r[Q+1]),k(r[Q+2])}}computeVertexNormals(){const x=this.index,n=this.getAttribute("position");if(n!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Qx(new Float32Array(n.count*3),3),this.setAttribute("normal",r);else for(let m=0,g=r.count;m<g;m++)r.setXYZ(m,0,0,0);const a=new K,i=new K,o=new K,l=new K,c=new K,d=new K,h=new K,p=new K;if(x)for(let m=0,g=x.count;m<g;m+=3){const y=x.getX(m+0),b=x.getX(m+1),v=x.getX(m+2);a.fromBufferAttribute(n,y),i.fromBufferAttribute(n,b),o.fromBufferAttribute(n,v),h.subVectors(o,i),p.subVectors(a,i),h.cross(p),l.fromBufferAttribute(r,y),c.fromBufferAttribute(r,b),d.fromBufferAttribute(r,v),l.add(h),c.add(h),d.add(h),r.setXYZ(y,l.x,l.y,l.z),r.setXYZ(b,c.x,c.y,c.z),r.setXYZ(v,d.x,d.y,d.z)}else for(let m=0,g=n.count;m<g;m+=3)a.fromBufferAttribute(n,m+0),i.fromBufferAttribute(n,m+1),o.fromBufferAttribute(n,m+2),h.subVectors(o,i),p.subVectors(a,i),h.cross(p),r.setXYZ(m+0,h.x,h.y,h.z),r.setXYZ(m+1,h.x,h.y,h.z),r.setXYZ(m+2,h.x,h.y,h.z);this.normalizeNormals(),r.needsUpdate=!0}}merge(x,n){if(!(x&&x.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",x);return}n===void 0&&(n=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const r=this.attributes;for(const a in r){if(x.attributes[a]===void 0)continue;const o=r[a].array,l=x.attributes[a],c=l.array,d=l.itemSize*n,h=Math.min(c.length,o.length-d);for(let p=0,m=d;p<h;p++,m++)o[m]=c[p]}return this}normalizeNormals(){const x=this.attributes.normal;for(let n=0,r=x.count;n<r;n++)gn.fromBufferAttribute(x,n),gn.normalize(),x.setXYZ(n,gn.x,gn.y,gn.z)}toNonIndexed(){function x(l,c){const d=l.array,h=l.itemSize,p=l.normalized,m=new d.constructor(c.length*h);let g=0,y=0;for(let b=0,v=c.length;b<v;b++){l.isInterleavedBufferAttribute?g=c[b]*l.data.stride+l.offset:g=c[b]*h;for(let w=0;w<h;w++)m[y++]=d[g++]}return new Qx(m,h,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const n=new Rt,r=this.index.array,a=this.attributes;for(const l in a){const c=a[l],d=x(c,r);n.setAttribute(l,d)}const i=this.morphAttributes;for(const l in i){const c=[],d=i[l];for(let h=0,p=d.length;h<p;h++){const m=d[h],g=x(m,r);c.push(g)}n.morphAttributes[l]=c}n.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let l=0,c=o.length;l<c;l++){const d=o[l];n.addGroup(d.start,d.count,d.materialIndex)}return n}toJSON(){const x={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(x.uuid=this.uuid,x.type=this.type,this.name!==""&&(x.name=this.name),Object.keys(this.userData).length>0&&(x.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const d in c)c[d]!==void 0&&(x[d]=c[d]);return x}x.data={attributes:{}};const n=this.index;n!==null&&(x.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const r=this.attributes;for(const c in r){const d=r[c];x.data.attributes[c]=d.toJSON(x.data)}const a={};let i=!1;for(const c in this.morphAttributes){const d=this.morphAttributes[c],h=[];for(let p=0,m=d.length;p<m;p++){const g=d[p];h.push(g.toJSON(x.data))}h.length>0&&(a[c]=h,i=!0)}i&&(x.data.morphAttributes=a,x.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(x.data.groups=JSON.parse(JSON.stringify(o)));const l=this.boundingSphere;return l!==null&&(x.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),x}clone(){return new this.constructor().copy(this)}copy(x){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=x.name;const r=x.index;r!==null&&this.setIndex(r.clone(n));const a=x.attributes;for(const d in a){const h=a[d];this.setAttribute(d,h.clone(n))}const i=x.morphAttributes;for(const d in i){const h=[],p=i[d];for(let m=0,g=p.length;m<g;m++)h.push(p[m].clone(n));this.morphAttributes[d]=h}this.morphTargetsRelative=x.morphTargetsRelative;const o=x.groups;for(let d=0,h=o.length;d<h;d++){const p=o[d];this.addGroup(p.start,p.count,p.materialIndex)}const l=x.boundingBox;l!==null&&(this.boundingBox=l.clone());const c=x.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=x.drawRange.start,this.drawRange.count=x.drawRange.count,this.userData=x.userData,x.parameters!==void 0&&(this.parameters=Object.assign({},x.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const LA=new wt,ro=new qd,M1=new Ba,Ms=new K,Is=new K,ks=new K,I1=new K,k1=new K,N1=new K,Zd=new K,Jd=new K,Qd=new K,jd=new n0,eh=new n0,th=new n0,R1=new K,xh=new K;class yn extends Px{constructor(x=new Rt,n=new F2){super(),this.isMesh=!0,this.type="Mesh",this.geometry=x,this.material=n,this.updateMorphTargets()}copy(x,n){return super.copy(x,n),x.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=x.morphTargetInfluences.slice()),x.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},x.morphTargetDictionary)),this.material=x.material,this.geometry=x.geometry,this}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const a=n[r[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=a.length;i<o;i++){const l=a[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=i}}}}raycast(x,n){const r=this.geometry,a=this.material,i=this.matrixWorld;if(a===void 0||(r.boundingSphere===null&&r.computeBoundingSphere(),M1.copy(r.boundingSphere),M1.applyMatrix4(i),x.ray.intersectsSphere(M1)===!1)||(LA.copy(i).invert(),ro.copy(x.ray).applyMatrix4(LA),r.boundingBox!==null&&ro.intersectsBox(r.boundingBox)===!1))return;let o;const l=r.index,c=r.attributes.position,d=r.morphAttributes.position,h=r.morphTargetsRelative,p=r.attributes.uv,m=r.attributes.uv2,g=r.groups,y=r.drawRange;if(l!==null)if(Array.isArray(a))for(let b=0,v=g.length;b<v;b++){const w=g[b],_=a[w.materialIndex],T=Math.max(w.start,y.start),A=Math.min(l.count,Math.min(w.start+w.count,y.start+y.count));for(let E=T,M=A;E<M;E+=3){const I=l.getX(E),C=l.getX(E+1),k=l.getX(E+2);o=nh(this,_,x,ro,c,d,h,p,m,I,C,k),o&&(o.faceIndex=Math.floor(E/3),o.face.materialIndex=w.materialIndex,n.push(o))}}else{const b=Math.max(0,y.start),v=Math.min(l.count,y.start+y.count);for(let w=b,_=v;w<_;w+=3){const T=l.getX(w),A=l.getX(w+1),E=l.getX(w+2);o=nh(this,a,x,ro,c,d,h,p,m,T,A,E),o&&(o.faceIndex=Math.floor(w/3),n.push(o))}}else if(c!==void 0)if(Array.isArray(a))for(let b=0,v=g.length;b<v;b++){const w=g[b],_=a[w.materialIndex],T=Math.max(w.start,y.start),A=Math.min(c.count,Math.min(w.start+w.count,y.start+y.count));for(let E=T,M=A;E<M;E+=3){const I=E,C=E+1,k=E+2;o=nh(this,_,x,ro,c,d,h,p,m,I,C,k),o&&(o.faceIndex=Math.floor(E/3),o.face.materialIndex=w.materialIndex,n.push(o))}}else{const b=Math.max(0,y.start),v=Math.min(c.count,y.start+y.count);for(let w=b,_=v;w<_;w+=3){const T=w,A=w+1,E=w+2;o=nh(this,a,x,ro,c,d,h,p,m,T,A,E),o&&(o.faceIndex=Math.floor(w/3),n.push(o))}}}}function VJ(s,x,n,r,a,i,o,l){let c;if(x.side===Z2?c=r.intersectTriangle(o,i,a,!0,l):c=r.intersectTriangle(a,i,o,x.side!==Sa,l),c===null)return null;xh.copy(l),xh.applyMatrix4(s.matrixWorld);const d=n.ray.origin.distanceTo(xh);return d<n.near||d>n.far?null:{distance:d,point:xh.clone(),object:s}}function nh(s,x,n,r,a,i,o,l,c,d,h,p){Ms.fromBufferAttribute(a,d),Is.fromBufferAttribute(a,h),ks.fromBufferAttribute(a,p);const m=s.morphTargetInfluences;if(i&&m){Zd.set(0,0,0),Jd.set(0,0,0),Qd.set(0,0,0);for(let y=0,b=i.length;y<b;y++){const v=m[y],w=i[y];v!==0&&(I1.fromBufferAttribute(w,d),k1.fromBufferAttribute(w,h),N1.fromBufferAttribute(w,p),o?(Zd.addScaledVector(I1,v),Jd.addScaledVector(k1,v),Qd.addScaledVector(N1,v)):(Zd.addScaledVector(I1.sub(Ms),v),Jd.addScaledVector(k1.sub(Is),v),Qd.addScaledVector(N1.sub(ks),v)))}Ms.add(Zd),Is.add(Jd),ks.add(Qd)}s.isSkinnedMesh&&(s.boneTransform(d,Ms),s.boneTransform(h,Is),s.boneTransform(p,ks));const g=VJ(s,x,n,r,Ms,Is,ks,R1);if(g){l&&(jd.fromBufferAttribute(l,d),eh.fromBufferAttribute(l,h),th.fromBufferAttribute(l,p),g.uv=nr.getUV(R1,Ms,Is,ks,jd,eh,th,new n0)),c&&(jd.fromBufferAttribute(c,d),eh.fromBufferAttribute(c,h),th.fromBufferAttribute(c,p),g.uv2=nr.getUV(R1,Ms,Is,ks,jd,eh,th,new n0));const y={a:d,b:h,c:p,normal:new K,materialIndex:0};nr.getNormal(Ms,Is,ks,y.normal),g.face=y}return g}class za extends Rt{constructor(x=1,n=1,r=1,a=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:x,height:n,depth:r,widthSegments:a,heightSegments:i,depthSegments:o};const l=this;a=Math.floor(a),i=Math.floor(i),o=Math.floor(o);const c=[],d=[],h=[],p=[];let m=0,g=0;y("z","y","x",-1,-1,r,n,x,o,i,0),y("z","y","x",1,-1,r,n,-x,o,i,1),y("x","z","y",1,1,x,r,n,a,o,2),y("x","z","y",1,-1,x,r,-n,a,o,3),y("x","y","z",1,-1,x,n,r,a,i,4),y("x","y","z",-1,-1,x,n,-r,a,i,5),this.setIndex(c),this.setAttribute("position",new q0(d,3)),this.setAttribute("normal",new q0(h,3)),this.setAttribute("uv",new q0(p,2));function y(b,v,w,_,T,A,E,M,I,C,k){const O=A/I,z=E/C,ee=A/2,re=E/2,Y=M/2,Q=I+1,te=C+1;let se=0,xe=0;const ae=new K;for(let le=0;le<te;le++){const de=le*z-re;for(let ue=0;ue<Q;ue++){const ge=ue*O-ee;ae[b]=ge*_,ae[v]=de*T,ae[w]=Y,d.push(ae.x,ae.y,ae.z),ae[b]=0,ae[v]=0,ae[w]=M>0?1:-1,h.push(ae.x,ae.y,ae.z),p.push(ue/I),p.push(1-le/C),se+=1}}for(let le=0;le<C;le++)for(let de=0;de<I;de++){const ue=m+de+Q*le,ge=m+de+Q*(le+1),pe=m+(de+1)+Q*(le+1),Le=m+(de+1)+Q*le;c.push(ue,ge,Le),c.push(ge,pe,Le),xe+=6}l.addGroup(g,xe,k),g+=xe,m+=se}}static fromJSON(x){return new za(x.width,x.height,x.depth,x.widthSegments,x.heightSegments,x.depthSegments)}}function so(s){const x={};for(const n in s){x[n]={};for(const r in s[n]){const a=s[n][r];a&&(a.isColor||a.isMatrix3||a.isMatrix4||a.isVector2||a.isVector3||a.isVector4||a.isTexture||a.isQuaternion)?x[n][r]=a.clone():Array.isArray(a)?x[n][r]=a.slice():x[n][r]=a}}return x}function zn(s){const x={};for(let n=0;n<s.length;n++){const r=so(s[n]);for(const a in r)x[a]=r[a]}return x}function HJ(s){const x=[];for(let n=0;n<s.length;n++)x.push(s[n].clone());return x}const YJ={clone:so,merge:zn};var qJ=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,XJ=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Ns extends y2{constructor(x){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=qJ,this.fragmentShader=XJ,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,x!==void 0&&(x.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(x))}copy(x){return super.copy(x),this.fragmentShader=x.fragmentShader,this.vertexShader=x.vertexShader,this.uniforms=so(x.uniforms),this.uniformsGroups=HJ(x.uniformsGroups),this.defines=Object.assign({},x.defines),this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.fog=x.fog,this.lights=x.lights,this.clipping=x.clipping,this.extensions=Object.assign({},x.extensions),this.glslVersion=x.glslVersion,this}toJSON(x){const n=super.toJSON(x);n.glslVersion=this.glslVersion,n.uniforms={};for(const a in this.uniforms){const o=this.uniforms[a].value;o&&o.isTexture?n.uniforms[a]={type:"t",value:o.toJSON(x).uuid}:o&&o.isColor?n.uniforms[a]={type:"c",value:o.getHex()}:o&&o.isVector2?n.uniforms[a]={type:"v2",value:o.toArray()}:o&&o.isVector3?n.uniforms[a]={type:"v3",value:o.toArray()}:o&&o.isVector4?n.uniforms[a]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?n.uniforms[a]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?n.uniforms[a]={type:"m4",value:o.toArray()}:n.uniforms[a]={value:o}}Object.keys(this.defines).length>0&&(n.defines=this.defines),n.vertexShader=this.vertexShader,n.fragmentShader=this.fragmentShader;const r={};for(const a in this.extensions)this.extensions[a]===!0&&(r[a]=!0);return Object.keys(r).length>0&&(n.extensions=r),n}}class P1 extends Px{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new wt,this.projectionMatrix=new wt,this.projectionMatrixInverse=new wt}copy(x,n){return super.copy(x,n),this.matrixWorldInverse.copy(x.matrixWorldInverse),this.projectionMatrix.copy(x.projectionMatrix),this.projectionMatrixInverse.copy(x.projectionMatrixInverse),this}getWorldDirection(x){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return x.set(-n[8],-n[9],-n[10]).normalize()}updateMatrixWorld(x){super.updateMatrixWorld(x),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(x,n){super.updateWorldMatrix(x,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class ln extends P1{constructor(x=50,n=1,r=.1,a=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=x,this.zoom=1,this.near=r,this.far=a,this.focus=10,this.aspect=n,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(x,n){return super.copy(x,n),this.fov=x.fov,this.zoom=x.zoom,this.near=x.near,this.far=x.far,this.focus=x.focus,this.aspect=x.aspect,this.view=x.view===null?null:Object.assign({},x.view),this.filmGauge=x.filmGauge,this.filmOffset=x.filmOffset,this}setFocalLength(x){const n=.5*this.getFilmHeight()/x;this.fov=El*2*Math.atan(n),this.updateProjectionMatrix()}getFocalLength(){const x=Math.tan(Ra*.5*this.fov);return .5*this.getFilmHeight()/x}getEffectiveFOV(){return El*2*Math.atan(Math.tan(Ra*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(x,n,r,a,i,o){this.aspect=x/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=x,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=a,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const x=this.near;let n=x*Math.tan(Ra*.5*this.fov)/this.zoom,r=2*n,a=this.aspect*r,i=-.5*a;const o=this.view;if(this.view!==null&&this.view.enabled){const c=o.fullWidth,d=o.fullHeight;i+=o.offsetX*a/c,n-=o.offsetY*r/d,a*=o.width/c,r*=o.height/d}const l=this.filmOffset;l!==0&&(i+=x*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+a,n,n-r,x,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(x){const n=super.toJSON(x);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}}const ao=90,io=1;class KJ extends Px{constructor(x,n,r){if(super(),this.type="CubeCamera",r.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=r;const a=new ln(ao,io,x,n);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new K(1,0,0)),this.add(a);const i=new ln(ao,io,x,n);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new K(-1,0,0)),this.add(i);const o=new ln(ao,io,x,n);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new K(0,1,0)),this.add(o);const l=new ln(ao,io,x,n);l.layers=this.layers,l.up.set(0,0,-1),l.lookAt(new K(0,-1,0)),this.add(l);const c=new ln(ao,io,x,n);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new K(0,0,1)),this.add(c);const d=new ln(ao,io,x,n);d.layers=this.layers,d.up.set(0,-1,0),d.lookAt(new K(0,0,-1)),this.add(d)}update(x,n){this.parent===null&&this.updateMatrixWorld();const r=this.renderTarget,[a,i,o,l,c,d]=this.children,h=x.getRenderTarget(),p=x.toneMapping,m=x.xr.enabled;x.toneMapping=Wr,x.xr.enabled=!1;const g=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,x.setRenderTarget(r,0),x.render(n,a),x.setRenderTarget(r,1),x.render(n,i),x.setRenderTarget(r,2),x.render(n,o),x.setRenderTarget(r,3),x.render(n,l),x.setRenderTarget(r,4),x.render(n,c),r.texture.generateMipmaps=g,x.setRenderTarget(r,5),x.render(n,d),x.setRenderTarget(h),x.toneMapping=p,x.xr.enabled=m,r.texture.needsPMREMUpdate=!0}}class rh extends Tn{constructor(x,n,r,a,i,o,l,c,d,h){x=x!==void 0?x:[],n=n!==void 0?n:Ta,super(x,n,r,a,i,o,l,c,d,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(x){this.image=x}}class $J extends La{constructor(x,n={}){super(x,x,n),this.isWebGLCubeRenderTarget=!0;const r={width:x,height:x,depth:1},a=[r,r,r,r,r,r];this.texture=new rh(a,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Sx}fromEquirectangularTexture(x,n){this.texture.type=n.type,this.texture.encoding=n.encoding,this.texture.generateMipmaps=n.generateMipmaps,this.texture.minFilter=n.minFilter,this.texture.magFilter=n.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},a=new za(5,5,5),i=new Ns({name:"CubemapFromEquirect",uniforms:so(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:Z2,blending:ws});i.uniforms.tEquirect.value=n;const o=new yn(a,i),l=n.minFilter;return n.minFilter===_s&&(n.minFilter=Sx),new KJ(1,10,this).update(x,o),n.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(x,n,r,a){const i=x.getRenderTarget();for(let o=0;o<6;o++)x.setRenderTarget(this,o),x.clear(n,r,a);x.setRenderTarget(i)}}const L1=new K,ZJ=new K,JJ=new m2;class Wa{constructor(x=new K(1,0,0),n=0){this.isPlane=!0,this.normal=x,this.constant=n}set(x,n){return this.normal.copy(x),this.constant=n,this}setComponents(x,n,r,a){return this.normal.set(x,n,r),this.constant=a,this}setFromNormalAndCoplanarPoint(x,n){return this.normal.copy(x),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(x,n,r){const a=L1.subVectors(r,n).cross(ZJ.subVectors(x,n)).normalize();return this.setFromNormalAndCoplanarPoint(a,x),this}copy(x){return this.normal.copy(x.normal),this.constant=x.constant,this}normalize(){const x=1/this.normal.length();return this.normal.multiplyScalar(x),this.constant*=x,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(x){return this.normal.dot(x)+this.constant}distanceToSphere(x){return this.distanceToPoint(x.center)-x.radius}projectPoint(x,n){return n.copy(this.normal).multiplyScalar(-this.distanceToPoint(x)).add(x)}intersectLine(x,n){const r=x.delta(L1),a=this.normal.dot(r);if(a===0)return this.distanceToPoint(x.start)===0?n.copy(x.start):null;const i=-(x.start.dot(this.normal)+this.constant)/a;return i<0||i>1?null:n.copy(r).multiplyScalar(i).add(x.start)}intersectsLine(x){const n=this.distanceToPoint(x.start),r=this.distanceToPoint(x.end);return n<0&&r>0||r<0&&n>0}intersectsBox(x){return x.intersectsPlane(this)}intersectsSphere(x){return x.intersectsPlane(this)}coplanarPoint(x){return x.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(x,n){const r=n||JJ.getNormalMatrix(x),a=this.coplanarPoint(L1).applyMatrix4(x),i=this.normal.applyMatrix3(r).normalize();return this.constant=-a.dot(i),this}translate(x){return this.constant-=x.dot(this.normal),this}equals(x){return x.normal.equals(this.normal)&&x.constant===this.constant}clone(){return new this.constructor().copy(this)}}const oo=new Ba,sh=new K;class D1{constructor(x=new Wa,n=new Wa,r=new Wa,a=new Wa,i=new Wa,o=new Wa){this.planes=[x,n,r,a,i,o]}set(x,n,r,a,i,o){const l=this.planes;return l[0].copy(x),l[1].copy(n),l[2].copy(r),l[3].copy(a),l[4].copy(i),l[5].copy(o),this}copy(x){const n=this.planes;for(let r=0;r<6;r++)n[r].copy(x.planes[r]);return this}setFromProjectionMatrix(x){const n=this.planes,r=x.elements,a=r[0],i=r[1],o=r[2],l=r[3],c=r[4],d=r[5],h=r[6],p=r[7],m=r[8],g=r[9],y=r[10],b=r[11],v=r[12],w=r[13],_=r[14],T=r[15];return n[0].setComponents(l-a,p-c,b-m,T-v).normalize(),n[1].setComponents(l+a,p+c,b+m,T+v).normalize(),n[2].setComponents(l+i,p+d,b+g,T+w).normalize(),n[3].setComponents(l-i,p-d,b-g,T-w).normalize(),n[4].setComponents(l-o,p-h,b-y,T-_).normalize(),n[5].setComponents(l+o,p+h,b+y,T+_).normalize(),this}intersectsObject(x){const n=x.geometry;return n.boundingSphere===null&&n.computeBoundingSphere(),oo.copy(n.boundingSphere).applyMatrix4(x.matrixWorld),this.intersectsSphere(oo)}intersectsSprite(x){return oo.center.set(0,0,0),oo.radius=.7071067811865476,oo.applyMatrix4(x.matrixWorld),this.intersectsSphere(oo)}intersectsSphere(x){const n=this.planes,r=x.center,a=-x.radius;for(let i=0;i<6;i++)if(n[i].distanceToPoint(r)<a)return!1;return!0}intersectsBox(x){const n=this.planes;for(let r=0;r<6;r++){const a=n[r];if(sh.x=a.normal.x>0?x.max.x:x.min.x,sh.y=a.normal.y>0?x.max.y:x.min.y,sh.z=a.normal.z>0?x.max.z:x.min.z,a.distanceToPoint(sh)<0)return!1}return!0}containsPoint(x){const n=this.planes;for(let r=0;r<6;r++)if(n[r].distanceToPoint(x)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function DA(){let s=null,x=!1,n=null,r=null;function a(i,o){n(i,o),r=s.requestAnimationFrame(a)}return{start:function(){x!==!0&&n!==null&&(r=s.requestAnimationFrame(a),x=!0)},stop:function(){s.cancelAnimationFrame(r),x=!1},setAnimationLoop:function(i){n=i},setContext:function(i){s=i}}}function QJ(s,x){const n=x.isWebGL2,r=new WeakMap;function a(d,h){const p=d.array,m=d.usage,g=s.createBuffer();s.bindBuffer(h,g),s.bufferData(h,p,m),d.onUploadCallback();let y;if(p instanceof Float32Array)y=5126;else if(p instanceof Uint16Array)if(d.isFloat16BufferAttribute)if(n)y=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else y=5123;else if(p instanceof Int16Array)y=5122;else if(p instanceof Uint32Array)y=5125;else if(p instanceof Int32Array)y=5124;else if(p instanceof Int8Array)y=5120;else if(p instanceof Uint8Array)y=5121;else if(p instanceof Uint8ClampedArray)y=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+p);return{buffer:g,type:y,bytesPerElement:p.BYTES_PER_ELEMENT,version:d.version}}function i(d,h,p){const m=h.array,g=h.updateRange;s.bindBuffer(p,d),g.count===-1?s.bufferSubData(p,0,m):(n?s.bufferSubData(p,g.offset*m.BYTES_PER_ELEMENT,m,g.offset,g.count):s.bufferSubData(p,g.offset*m.BYTES_PER_ELEMENT,m.subarray(g.offset,g.offset+g.count)),g.count=-1)}function o(d){return d.isInterleavedBufferAttribute&&(d=d.data),r.get(d)}function l(d){d.isInterleavedBufferAttribute&&(d=d.data);const h=r.get(d);h&&(s.deleteBuffer(h.buffer),r.delete(d))}function c(d,h){if(d.isGLBufferAttribute){const m=r.get(d);(!m||m.version<d.version)&&r.set(d,{buffer:d.buffer,type:d.type,bytesPerElement:d.elementSize,version:d.version});return}d.isInterleavedBufferAttribute&&(d=d.data);const p=r.get(d);p===void 0?r.set(d,a(d,h)):p.version<d.version&&(i(p.buffer,d,h),p.version=d.version)}return{get:o,remove:l,update:c}}class Pl extends Rt{constructor(x=1,n=1,r=1,a=1){super(),this.type="PlaneGeometry",this.parameters={width:x,height:n,widthSegments:r,heightSegments:a};const i=x/2,o=n/2,l=Math.floor(r),c=Math.floor(a),d=l+1,h=c+1,p=x/l,m=n/c,g=[],y=[],b=[],v=[];for(let w=0;w<h;w++){const _=w*m-o;for(let T=0;T<d;T++){const A=T*p-i;y.push(A,-_,0),b.push(0,0,1),v.push(T/l),v.push(1-w/c)}}for(let w=0;w<c;w++)for(let _=0;_<l;_++){const T=_+d*w,A=_+d*(w+1),E=_+1+d*(w+1),M=_+1+d*w;g.push(T,A,M),g.push(A,E,M)}this.setIndex(g),this.setAttribute("position",new q0(y,3)),this.setAttribute("normal",new q0(b,3)),this.setAttribute("uv",new q0(v,2))}static fromJSON(x){return new Pl(x.width,x.height,x.widthSegments,x.heightSegments)}}var jJ=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,eQ=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,tQ=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,xQ=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,nQ=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,rQ=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,sQ="vec3 transformed = vec3( position );",aQ=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,iQ=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,oQ=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,lQ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,cQ=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,uQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,dQ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,hQ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,pQ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,fQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,mQ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,gQ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,yQ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,bQ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,vQ=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,wQ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,_Q=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,SQ=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,TQ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,AQ="gl_FragColor = linearToOutputTexel( gl_FragColor );",EQ=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,CQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,MQ=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,IQ=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,kQ=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,NQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,RQ=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,PQ=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,LQ=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,DQ=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,OQ=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,FQ=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,UQ=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,BQ=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,zQ=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,WQ=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,GQ=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,VQ=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,HQ=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,YQ=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,qQ=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,XQ=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,KQ=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,$Q=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,ZQ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,JQ=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,QQ=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,jQ=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,ej=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,tj=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,xj=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,nj=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,rj=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,sj=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,aj=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,ij=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,oj=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,lj=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,cj=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,uj=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,dj=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,hj=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,pj=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,fj=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,mj=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,gj=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,yj=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,bj=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,vj=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,wj=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,_j=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Sj=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Tj=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Aj=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Ej=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Cj=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Mj=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Ij=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,kj=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Nj=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Rj=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Pj=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Lj=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,Dj=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Oj=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Fj=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Uj=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Bj=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,zj=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Wj=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,Gj=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Vj=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Hj=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Yj=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,qj=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Xj=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Kj=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,$j=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Ft={alphamap_fragment:jJ,alphamap_pars_fragment:eQ,alphatest_fragment:tQ,alphatest_pars_fragment:xQ,aomap_fragment:nQ,aomap_pars_fragment:rQ,begin_vertex:sQ,beginnormal_vertex:aQ,bsdfs:iQ,iridescence_fragment:oQ,bumpmap_pars_fragment:lQ,clipping_planes_fragment:cQ,clipping_planes_pars_fragment:uQ,clipping_planes_pars_vertex:dQ,clipping_planes_vertex:hQ,color_fragment:pQ,color_pars_fragment:fQ,color_pars_vertex:mQ,color_vertex:gQ,common:yQ,cube_uv_reflection_fragment:bQ,defaultnormal_vertex:vQ,displacementmap_pars_vertex:wQ,displacementmap_vertex:_Q,emissivemap_fragment:SQ,emissivemap_pars_fragment:TQ,encodings_fragment:AQ,encodings_pars_fragment:EQ,envmap_fragment:CQ,envmap_common_pars_fragment:MQ,envmap_pars_fragment:IQ,envmap_pars_vertex:kQ,envmap_physical_pars_fragment:WQ,envmap_vertex:NQ,fog_vertex:RQ,fog_pars_vertex:PQ,fog_fragment:LQ,fog_pars_fragment:DQ,gradientmap_pars_fragment:OQ,lightmap_fragment:FQ,lightmap_pars_fragment:UQ,lights_lambert_vertex:BQ,lights_pars_begin:zQ,lights_toon_fragment:GQ,lights_toon_pars_fragment:VQ,lights_phong_fragment:HQ,lights_phong_pars_fragment:YQ,lights_physical_fragment:qQ,lights_physical_pars_fragment:XQ,lights_fragment_begin:KQ,lights_fragment_maps:$Q,lights_fragment_end:ZQ,logdepthbuf_fragment:JQ,logdepthbuf_pars_fragment:QQ,logdepthbuf_pars_vertex:jQ,logdepthbuf_vertex:ej,map_fragment:tj,map_pars_fragment:xj,map_particle_fragment:nj,map_particle_pars_fragment:rj,metalnessmap_fragment:sj,metalnessmap_pars_fragment:aj,morphcolor_vertex:ij,morphnormal_vertex:oj,morphtarget_pars_vertex:lj,morphtarget_vertex:cj,normal_fragment_begin:uj,normal_fragment_maps:dj,normal_pars_fragment:hj,normal_pars_vertex:pj,normal_vertex:fj,normalmap_pars_fragment:mj,clearcoat_normal_fragment_begin:gj,clearcoat_normal_fragment_maps:yj,clearcoat_pars_fragment:bj,iridescence_pars_fragment:vj,output_fragment:wj,packing:_j,premultiplied_alpha_fragment:Sj,project_vertex:Tj,dithering_fragment:Aj,dithering_pars_fragment:Ej,roughnessmap_fragment:Cj,roughnessmap_pars_fragment:Mj,shadowmap_pars_fragment:Ij,shadowmap_pars_vertex:kj,shadowmap_vertex:Nj,shadowmask_pars_fragment:Rj,skinbase_vertex:Pj,skinning_pars_vertex:Lj,skinning_vertex:Dj,skinnormal_vertex:Oj,specularmap_fragment:Fj,specularmap_pars_fragment:Uj,tonemapping_fragment:Bj,tonemapping_pars_fragment:zj,transmission_fragment:Wj,transmission_pars_fragment:Gj,uv_pars_fragment:Vj,uv_pars_vertex:Hj,uv_vertex:Yj,uv2_pars_fragment:qj,uv2_pars_vertex:Xj,uv2_vertex:Kj,worldpos_vertex:$j,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`},R0={common:{diffuse:{value:new M0(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new m2},uv2Transform:{value:new m2},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new n0(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new M0(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new M0(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new m2}},sprite:{diffuse:{value:new M0(16777215)},opacity:{value:1},center:{value:new n0(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new m2}}},mr={basic:{uniforms:zn([R0.common,R0.specularmap,R0.envmap,R0.aomap,R0.lightmap,R0.fog]),vertexShader:Ft.meshbasic_vert,fragmentShader:Ft.meshbasic_frag},lambert:{uniforms:zn([R0.common,R0.specularmap,R0.envmap,R0.aomap,R0.lightmap,R0.emissivemap,R0.fog,R0.lights,{emissive:{value:new M0(0)}}]),vertexShader:Ft.meshlambert_vert,fragmentShader:Ft.meshlambert_frag},phong:{uniforms:zn([R0.common,R0.specularmap,R0.envmap,R0.aomap,R0.lightmap,R0.emissivemap,R0.bumpmap,R0.normalmap,R0.displacementmap,R0.fog,R0.lights,{emissive:{value:new M0(0)},specular:{value:new M0(1118481)},shininess:{value:30}}]),vertexShader:Ft.meshphong_vert,fragmentShader:Ft.meshphong_frag},standard:{uniforms:zn([R0.common,R0.envmap,R0.aomap,R0.lightmap,R0.emissivemap,R0.bumpmap,R0.normalmap,R0.displacementmap,R0.roughnessmap,R0.metalnessmap,R0.fog,R0.lights,{emissive:{value:new M0(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag},toon:{uniforms:zn([R0.common,R0.aomap,R0.lightmap,R0.emissivemap,R0.bumpmap,R0.normalmap,R0.displacementmap,R0.gradientmap,R0.fog,R0.lights,{emissive:{value:new M0(0)}}]),vertexShader:Ft.meshtoon_vert,fragmentShader:Ft.meshtoon_frag},matcap:{uniforms:zn([R0.common,R0.bumpmap,R0.normalmap,R0.displacementmap,R0.fog,{matcap:{value:null}}]),vertexShader:Ft.meshmatcap_vert,fragmentShader:Ft.meshmatcap_frag},points:{uniforms:zn([R0.points,R0.fog]),vertexShader:Ft.points_vert,fragmentShader:Ft.points_frag},dashed:{uniforms:zn([R0.common,R0.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ft.linedashed_vert,fragmentShader:Ft.linedashed_frag},depth:{uniforms:zn([R0.common,R0.displacementmap]),vertexShader:Ft.depth_vert,fragmentShader:Ft.depth_frag},normal:{uniforms:zn([R0.common,R0.bumpmap,R0.normalmap,R0.displacementmap,{opacity:{value:1}}]),vertexShader:Ft.meshnormal_vert,fragmentShader:Ft.meshnormal_frag},sprite:{uniforms:zn([R0.sprite,R0.fog]),vertexShader:Ft.sprite_vert,fragmentShader:Ft.sprite_frag},background:{uniforms:{uvTransform:{value:new m2},t2D:{value:null}},vertexShader:Ft.background_vert,fragmentShader:Ft.background_frag},cube:{uniforms:zn([R0.envmap,{opacity:{value:1}}]),vertexShader:Ft.cube_vert,fragmentShader:Ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ft.equirect_vert,fragmentShader:Ft.equirect_frag},distanceRGBA:{uniforms:zn([R0.common,R0.displacementmap,{referencePosition:{value:new K},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ft.distanceRGBA_vert,fragmentShader:Ft.distanceRGBA_frag},shadow:{uniforms:zn([R0.lights,R0.fog,{color:{value:new M0(0)},opacity:{value:1}}]),vertexShader:Ft.shadow_vert,fragmentShader:Ft.shadow_frag}};mr.physical={uniforms:zn([mr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new n0(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new M0(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new n0},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new M0(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new M0(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ft.meshphysical_vert,fragmentShader:Ft.meshphysical_frag};function Zj(s,x,n,r,a,i){const o=new M0(0);let l=a===!0?0:1,c,d,h=null,p=0,m=null;function g(b,v){let w=!1,_=v.isScene===!0?v.background:null;_&&_.isTexture&&(_=x.get(_));const T=s.xr,A=T.getSession&&T.getSession();A&&A.environmentBlendMode==="additive"&&(_=null),_===null?y(o,l):_&&_.isColor&&(y(_,1),w=!0),(s.autoClear||w)&&s.clear(s.autoClearColor,s.autoClearDepth,s.autoClearStencil),_&&(_.isCubeTexture||_.mapping===Sl)?(d===void 0&&(d=new yn(new za(1,1,1),new Ns({name:"BackgroundCubeMaterial",uniforms:so(mr.cube.uniforms),vertexShader:mr.cube.vertexShader,fragmentShader:mr.cube.fragmentShader,side:Z2,depthTest:!1,depthWrite:!1,fog:!1})),d.geometry.deleteAttribute("normal"),d.geometry.deleteAttribute("uv"),d.onBeforeRender=function(E,M,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(d.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(d)),d.material.uniforms.envMap.value=_,d.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,(h!==_||p!==_.version||m!==s.toneMapping)&&(d.material.needsUpdate=!0,h=_,p=_.version,m=s.toneMapping),d.layers.enableAll(),b.unshift(d,d.geometry,d.material,0,0,null)):_&&_.isTexture&&(c===void 0&&(c=new yn(new Pl(2,2),new Ns({name:"BackgroundMaterial",uniforms:so(mr.background.uniforms),vertexShader:mr.background.vertexShader,fragmentShader:mr.background.fragmentShader,side:Ui,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(c)),c.material.uniforms.t2D.value=_,_.matrixAutoUpdate===!0&&_.updateMatrix(),c.material.uniforms.uvTransform.value.copy(_.matrix),(h!==_||p!==_.version||m!==s.toneMapping)&&(c.material.needsUpdate=!0,h=_,p=_.version,m=s.toneMapping),c.layers.enableAll(),b.unshift(c,c.geometry,c.material,0,0,null))}function y(b,v){n.buffers.color.setClear(b.r,b.g,b.b,v,i)}return{getClearColor:function(){return o},setClearColor:function(b,v=1){o.set(b),l=v,y(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(b){l=b,y(o,l)},render:g}}function Jj(s,x,n,r){const a=s.getParameter(34921),i=r.isWebGL2?null:x.get("OES_vertex_array_object"),o=r.isWebGL2||i!==null,l={},c=v(null);let d=c,h=!1;function p(Y,Q,te,se,xe){let ae=!1;if(o){const le=b(se,te,Q);d!==le&&(d=le,g(d.object)),ae=w(Y,se,te,xe),ae&&_(Y,se,te,xe)}else{const le=Q.wireframe===!0;(d.geometry!==se.id||d.program!==te.id||d.wireframe!==le)&&(d.geometry=se.id,d.program=te.id,d.wireframe=le,ae=!0)}xe!==null&&n.update(xe,34963),(ae||h)&&(h=!1,C(Y,Q,te,se),xe!==null&&s.bindBuffer(34963,n.get(xe).buffer))}function m(){return r.isWebGL2?s.createVertexArray():i.createVertexArrayOES()}function g(Y){return r.isWebGL2?s.bindVertexArray(Y):i.bindVertexArrayOES(Y)}function y(Y){return r.isWebGL2?s.deleteVertexArray(Y):i.deleteVertexArrayOES(Y)}function b(Y,Q,te){const se=te.wireframe===!0;let xe=l[Y.id];xe===void 0&&(xe={},l[Y.id]=xe);let ae=xe[Q.id];ae===void 0&&(ae={},xe[Q.id]=ae);let le=ae[se];return le===void 0&&(le=v(m()),ae[se]=le),le}function v(Y){const Q=[],te=[],se=[];for(let xe=0;xe<a;xe++)Q[xe]=0,te[xe]=0,se[xe]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Q,enabledAttributes:te,attributeDivisors:se,object:Y,attributes:{},index:null}}function w(Y,Q,te,se){const xe=d.attributes,ae=Q.attributes;let le=0;const de=te.getAttributes();for(const ue in de)if(de[ue].location>=0){const pe=xe[ue];let Le=ae[ue];if(Le===void 0&&(ue==="instanceMatrix"&&Y.instanceMatrix&&(Le=Y.instanceMatrix),ue==="instanceColor"&&Y.instanceColor&&(Le=Y.instanceColor)),pe===void 0||pe.attribute!==Le||Le&&pe.data!==Le.data)return!0;le++}return d.attributesNum!==le||d.index!==se}function _(Y,Q,te,se){const xe={},ae=Q.attributes;let le=0;const de=te.getAttributes();for(const ue in de)if(de[ue].location>=0){let pe=ae[ue];pe===void 0&&(ue==="instanceMatrix"&&Y.instanceMatrix&&(pe=Y.instanceMatrix),ue==="instanceColor"&&Y.instanceColor&&(pe=Y.instanceColor));const Le={};Le.attribute=pe,pe&&pe.data&&(Le.data=pe.data),xe[ue]=Le,le++}d.attributes=xe,d.attributesNum=le,d.index=se}function T(){const Y=d.newAttributes;for(let Q=0,te=Y.length;Q<te;Q++)Y[Q]=0}function A(Y){E(Y,0)}function E(Y,Q){const te=d.newAttributes,se=d.enabledAttributes,xe=d.attributeDivisors;te[Y]=1,se[Y]===0&&(s.enableVertexAttribArray(Y),se[Y]=1),xe[Y]!==Q&&((r.isWebGL2?s:x.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](Y,Q),xe[Y]=Q)}function M(){const Y=d.newAttributes,Q=d.enabledAttributes;for(let te=0,se=Q.length;te<se;te++)Q[te]!==Y[te]&&(s.disableVertexAttribArray(te),Q[te]=0)}function I(Y,Q,te,se,xe,ae){r.isWebGL2===!0&&(te===5124||te===5125)?s.vertexAttribIPointer(Y,Q,te,xe,ae):s.vertexAttribPointer(Y,Q,te,se,xe,ae)}function C(Y,Q,te,se){if(r.isWebGL2===!1&&(Y.isInstancedMesh||se.isInstancedBufferGeometry)&&x.get("ANGLE_instanced_arrays")===null)return;T();const xe=se.attributes,ae=te.getAttributes(),le=Q.defaultAttributeValues;for(const de in ae){const ue=ae[de];if(ue.location>=0){let ge=xe[de];if(ge===void 0&&(de==="instanceMatrix"&&Y.instanceMatrix&&(ge=Y.instanceMatrix),de==="instanceColor"&&Y.instanceColor&&(ge=Y.instanceColor)),ge!==void 0){const pe=ge.normalized,Le=ge.itemSize,we=n.get(ge);if(we===void 0)continue;const e0=we.buffer,Ze=we.type,i0=we.bytesPerElement;if(ge.isInterleavedBufferAttribute){const We=ge.data,v0=We.stride,Te=ge.offset;if(We.isInstancedInterleavedBuffer){for(let Ie=0;Ie<ue.locationSize;Ie++)E(ue.location+Ie,We.meshPerAttribute);Y.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=We.meshPerAttribute*We.count)}else for(let Ie=0;Ie<ue.locationSize;Ie++)A(ue.location+Ie);s.bindBuffer(34962,e0);for(let Ie=0;Ie<ue.locationSize;Ie++)I(ue.location+Ie,Le/ue.locationSize,Ze,pe,v0*i0,(Te+Le/ue.locationSize*Ie)*i0)}else{if(ge.isInstancedBufferAttribute){for(let We=0;We<ue.locationSize;We++)E(ue.location+We,ge.meshPerAttribute);Y.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=ge.meshPerAttribute*ge.count)}else for(let We=0;We<ue.locationSize;We++)A(ue.location+We);s.bindBuffer(34962,e0);for(let We=0;We<ue.locationSize;We++)I(ue.location+We,Le/ue.locationSize,Ze,pe,Le*i0,Le/ue.locationSize*We*i0)}}else if(le!==void 0){const pe=le[de];if(pe!==void 0)switch(pe.length){case 2:s.vertexAttrib2fv(ue.location,pe);break;case 3:s.vertexAttrib3fv(ue.location,pe);break;case 4:s.vertexAttrib4fv(ue.location,pe);break;default:s.vertexAttrib1fv(ue.location,pe)}}}}M()}function k(){ee();for(const Y in l){const Q=l[Y];for(const te in Q){const se=Q[te];for(const xe in se)y(se[xe].object),delete se[xe];delete Q[te]}delete l[Y]}}function O(Y){if(l[Y.id]===void 0)return;const Q=l[Y.id];for(const te in Q){const se=Q[te];for(const xe in se)y(se[xe].object),delete se[xe];delete Q[te]}delete l[Y.id]}function z(Y){for(const Q in l){const te=l[Q];if(te[Y.id]===void 0)continue;const se=te[Y.id];for(const xe in se)y(se[xe].object),delete se[xe];delete te[Y.id]}}function ee(){re(),h=!0,d!==c&&(d=c,g(d.object))}function re(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:p,reset:ee,resetDefaultState:re,dispose:k,releaseStatesOfGeometry:O,releaseStatesOfProgram:z,initAttributes:T,enableAttribute:A,disableUnusedAttributes:M}}function Qj(s,x,n,r){const a=r.isWebGL2;let i;function o(d){i=d}function l(d,h){s.drawArrays(i,d,h),n.update(h,i,1)}function c(d,h,p){if(p===0)return;let m,g;if(a)m=s,g="drawArraysInstanced";else if(m=x.get("ANGLE_instanced_arrays"),g="drawArraysInstancedANGLE",m===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](i,d,h,p),n.update(h,i,p)}this.setMode=o,this.render=l,this.renderInstances=c}function jj(s,x,n){let r;function a(){if(r!==void 0)return r;if(x.has("EXT_texture_filter_anisotropic")===!0){const I=x.get("EXT_texture_filter_anisotropic");r=s.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function i(I){if(I==="highp"){if(s.getShaderPrecisionFormat(35633,36338).precision>0&&s.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";I="mediump"}return I==="mediump"&&s.getShaderPrecisionFormat(35633,36337).precision>0&&s.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&s instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&s instanceof WebGL2ComputeRenderingContext;let l=n.precision!==void 0?n.precision:"highp";const c=i(l);c!==l&&(console.warn("THREE.WebGLRenderer:",l,"not supported, using",c,"instead."),l=c);const d=o||x.has("WEBGL_draw_buffers"),h=n.logarithmicDepthBuffer===!0,p=s.getParameter(34930),m=s.getParameter(35660),g=s.getParameter(3379),y=s.getParameter(34076),b=s.getParameter(34921),v=s.getParameter(36347),w=s.getParameter(36348),_=s.getParameter(36349),T=m>0,A=o||x.has("OES_texture_float"),E=T&&A,M=o?s.getParameter(36183):0;return{isWebGL2:o,drawBuffers:d,getMaxAnisotropy:a,getMaxPrecision:i,precision:l,logarithmicDepthBuffer:h,maxTextures:p,maxVertexTextures:m,maxTextureSize:g,maxCubemapSize:y,maxAttributes:b,maxVertexUniforms:v,maxVaryings:w,maxFragmentUniforms:_,vertexTextures:T,floatFragmentTextures:A,floatVertexTextures:E,maxSamples:M}}function eee(s){const x=this;let n=null,r=0,a=!1,i=!1;const o=new Wa,l=new m2,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(p,m,g){const y=p.length!==0||m||r!==0||a;return a=m,n=h(p,g,0),r=p.length,y},this.beginShadows=function(){i=!0,h(null)},this.endShadows=function(){i=!1,d()},this.setState=function(p,m,g){const y=p.clippingPlanes,b=p.clipIntersection,v=p.clipShadows,w=s.get(p);if(!a||y===null||y.length===0||i&&!v)i?h(null):d();else{const _=i?0:r,T=_*4;let A=w.clippingState||null;c.value=A,A=h(y,m,T,g);for(let E=0;E!==T;++E)A[E]=n[E];w.clippingState=A,this.numIntersection=b?this.numPlanes:0,this.numPlanes+=_}};function d(){c.value!==n&&(c.value=n,c.needsUpdate=r>0),x.numPlanes=r,x.numIntersection=0}function h(p,m,g,y){const b=p!==null?p.length:0;let v=null;if(b!==0){if(v=c.value,y!==!0||v===null){const w=g+b*4,_=m.matrixWorldInverse;l.getNormalMatrix(_),(v===null||v.length<w)&&(v=new Float32Array(w));for(let T=0,A=g;T!==b;++T,A+=4)o.copy(p[T]).applyMatrix4(_,l),o.normal.toArray(v,A),v[A+3]=o.constant}c.value=v,c.needsUpdate=!0}return x.numPlanes=b,x.numIntersection=0,v}}function tee(s){let x=new WeakMap;function n(o,l){return l===_l?o.mapping=Ta:l===Rd&&(o.mapping=Aa),o}function r(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const l=o.mapping;if(l===_l||l===Rd)if(x.has(o)){const c=x.get(o).texture;return n(c,o.mapping)}else{const c=o.image;if(c&&c.height>0){const d=new $J(c.height/2);return d.fromEquirectangularTexture(s,o),x.set(o,d),o.addEventListener("dispose",a),n(d.texture,o.mapping)}else return null}}return o}function a(o){const l=o.target;l.removeEventListener("dispose",a);const c=x.get(l);c!==void 0&&(x.delete(l),c.dispose())}function i(){x=new WeakMap}return{get:r,dispose:i}}class Ll extends P1{constructor(x=-1,n=1,r=1,a=-1,i=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=x,this.right=n,this.top=r,this.bottom=a,this.near=i,this.far=o,this.updateProjectionMatrix()}copy(x,n){return super.copy(x,n),this.left=x.left,this.right=x.right,this.top=x.top,this.bottom=x.bottom,this.near=x.near,this.far=x.far,this.zoom=x.zoom,this.view=x.view===null?null:Object.assign({},x.view),this}setViewOffset(x,n,r,a,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=x,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=a,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const x=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,a=(this.top+this.bottom)/2;let i=r-x,o=r+x,l=a+n,c=a-n;if(this.view!==null&&this.view.enabled){const d=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=d*this.view.offsetX,o=i+d*this.view.width,l-=h*this.view.offsetY,c=l-h*this.view.height}this.projectionMatrix.makeOrthographic(i,o,l,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(x){const n=super.toJSON(x);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}}const lo=4,OA=[.125,.215,.35,.446,.526,.582],Ga=20,O1=new Ll,FA=new M0;let F1=null;const Va=(1+Math.sqrt(5))/2,co=1/Va,UA=[new K(1,1,1),new K(-1,1,1),new K(1,1,-1),new K(-1,1,-1),new K(0,Va,co),new K(0,Va,-co),new K(co,0,Va),new K(-co,0,Va),new K(Va,co,0),new K(-Va,co,0)];class BA{constructor(x){this._renderer=x,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(x,n=0,r=.1,a=100){F1=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(x,r,a,i),n>0&&this._blur(i,0,0,n),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(x,n=null){return this._fromTexture(x,n)}fromCubemap(x,n=null){return this._fromTexture(x,n)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=GA(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=WA(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(x){this._lodMax=Math.floor(Math.log2(x)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let x=0;x<this._lodPlanes.length;x++)this._lodPlanes[x].dispose()}_cleanup(x){this._renderer.setRenderTarget(F1),x.scissorTest=!1,ah(x,0,0,x.width,x.height)}_fromTexture(x,n){x.mapping===Ta||x.mapping===Aa?this._setSize(x.image.length===0?16:x.image[0].width||x.image[0].image.width):this._setSize(x.image.width/4),F1=this._renderer.getRenderTarget();const r=n||this._allocateTargets();return this._textureToCubeUV(x,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const x=3*Math.max(this._cubeSize,112),n=4*this._cubeSize,r={magFilter:Sx,minFilter:Sx,generateMipmaps:!1,type:Gr,format:Q2,encoding:Ss,depthBuffer:!1},a=zA(x,n,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==x){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=zA(x,n,r);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=xee(i)),this._blurMaterial=nee(i,x,n)}return a}_compileMaterial(x){const n=new yn(this._lodPlanes[0],x);this._renderer.compile(n,O1)}_sceneToCubeUV(x,n,r,a){const l=new ln(90,1,n,r),c=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],h=this._renderer,p=h.autoClear,m=h.toneMapping;h.getClearColor(FA),h.toneMapping=Wr,h.autoClear=!1;const g=new F2({name:"PMREM.Background",side:Z2,depthWrite:!1,depthTest:!1}),y=new yn(new za,g);let b=!1;const v=x.background;v?v.isColor&&(g.color.copy(v),x.background=null,b=!0):(g.color.copy(FA),b=!0);for(let w=0;w<6;w++){const _=w%3;_===0?(l.up.set(0,c[w],0),l.lookAt(d[w],0,0)):_===1?(l.up.set(0,0,c[w]),l.lookAt(0,d[w],0)):(l.up.set(0,c[w],0),l.lookAt(0,0,d[w]));const T=this._cubeSize;ah(a,_*T,w>2?T:0,T,T),h.setRenderTarget(a),b&&h.render(y,l),h.render(x,l)}y.geometry.dispose(),y.material.dispose(),h.toneMapping=m,h.autoClear=p,x.background=v}_textureToCubeUV(x,n){const r=this._renderer,a=x.mapping===Ta||x.mapping===Aa;a?(this._cubemapMaterial===null&&(this._cubemapMaterial=GA()),this._cubemapMaterial.uniforms.flipEnvMap.value=x.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=WA());const i=a?this._cubemapMaterial:this._equirectMaterial,o=new yn(this._lodPlanes[0],i),l=i.uniforms;l.envMap.value=x;const c=this._cubeSize;ah(n,0,0,3*c,2*c),r.setRenderTarget(n),r.render(o,O1)}_applyPMREM(x){const n=this._renderer,r=n.autoClear;n.autoClear=!1;for(let a=1;a<this._lodPlanes.length;a++){const i=Math.sqrt(this._sigmas[a]*this._sigmas[a]-this._sigmas[a-1]*this._sigmas[a-1]),o=UA[(a-1)%UA.length];this._blur(x,a-1,a,i,o)}n.autoClear=r}_blur(x,n,r,a,i){const o=this._pingPongRenderTarget;this._halfBlur(x,o,n,r,a,"latitudinal",i),this._halfBlur(o,x,r,r,a,"longitudinal",i)}_halfBlur(x,n,r,a,i,o,l){const c=this._renderer,d=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,p=new yn(this._lodPlanes[a],d),m=d.uniforms,g=this._sizeLods[r]-1,y=isFinite(i)?Math.PI/(2*g):2*Math.PI/(2*Ga-1),b=i/y,v=isFinite(i)?1+Math.floor(h*b):Ga;v>Ga&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Ga}`);const w=[];let _=0;for(let I=0;I<Ga;++I){const C=I/b,k=Math.exp(-C*C/2);w.push(k),I===0?_+=k:I<v&&(_+=2*k)}for(let I=0;I<w.length;I++)w[I]=w[I]/_;m.envMap.value=x.texture,m.samples.value=v,m.weights.value=w,m.latitudinal.value=o==="latitudinal",l&&(m.poleAxis.value=l);const{_lodMax:T}=this;m.dTheta.value=y,m.mipInt.value=T-r;const A=this._sizeLods[a],E=3*A*(a>T-lo?a-T+lo:0),M=4*(this._cubeSize-A);ah(n,E,M,3*A,2*A),c.setRenderTarget(n),c.render(p,O1)}}function xee(s){const x=[],n=[],r=[];let a=s;const i=s-lo+1+OA.length;for(let o=0;o<i;o++){const l=Math.pow(2,a);n.push(l);let c=1/l;o>s-lo?c=OA[o-s+lo-1]:o===0&&(c=0),r.push(c);const d=1/(l-2),h=-d,p=1+d,m=[h,h,p,h,p,p,h,h,p,p,h,p],g=6,y=6,b=3,v=2,w=1,_=new Float32Array(b*y*g),T=new Float32Array(v*y*g),A=new Float32Array(w*y*g);for(let M=0;M<g;M++){const I=M%3*2/3-1,C=M>2?0:-1,k=[I,C,0,I+2/3,C,0,I+2/3,C+1,0,I,C,0,I+2/3,C+1,0,I,C+1,0];_.set(k,b*y*M),T.set(m,v*y*M);const O=[M,M,M,M,M,M];A.set(O,w*y*M)}const E=new Rt;E.setAttribute("position",new Qx(_,b)),E.setAttribute("uv",new Qx(T,v)),E.setAttribute("faceIndex",new Qx(A,w)),x.push(E),a>lo&&a--}return{lodPlanes:x,sizeLods:n,sigmas:r}}function zA(s,x,n){const r=new La(s,x,n);return r.texture.mapping=Sl,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function ah(s,x,n,r,a){s.viewport.set(x,n,r,a),s.scissor.set(x,n,r,a)}function nee(s,x,n){const r=new Float32Array(Ga),a=new K(0,1,0);return new Ns({name:"SphericalGaussianBlur",defines:{n:Ga,CUBEUV_TEXEL_WIDTH:1/x,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${s}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:U1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function WA(){return new Ns({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:U1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function GA(){return new Ns({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:U1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function U1(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function ree(s){let x=new WeakMap,n=null;function r(l){if(l&&l.isTexture){const c=l.mapping,d=c===_l||c===Rd,h=c===Ta||c===Aa;if(d||h)if(l.isRenderTargetTexture&&l.needsPMREMUpdate===!0){l.needsPMREMUpdate=!1;let p=x.get(l);return n===null&&(n=new BA(s)),p=d?n.fromEquirectangular(l,p):n.fromCubemap(l,p),x.set(l,p),p.texture}else{if(x.has(l))return x.get(l).texture;{const p=l.image;if(d&&p&&p.height>0||h&&p&&a(p)){n===null&&(n=new BA(s));const m=d?n.fromEquirectangular(l):n.fromCubemap(l);return x.set(l,m),l.addEventListener("dispose",i),m.texture}else return null}}}return l}function a(l){let c=0;const d=6;for(let h=0;h<d;h++)l[h]!==void 0&&c++;return c===d}function i(l){const c=l.target;c.removeEventListener("dispose",i);const d=x.get(c);d!==void 0&&(x.delete(c),d.dispose())}function o(){x=new WeakMap,n!==null&&(n.dispose(),n=null)}return{get:r,dispose:o}}function see(s){const x={};function n(r){if(x[r]!==void 0)return x[r];let a;switch(r){case"WEBGL_depth_texture":a=s.getExtension("WEBGL_depth_texture")||s.getExtension("MOZ_WEBGL_depth_texture")||s.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":a=s.getExtension("EXT_texture_filter_anisotropic")||s.getExtension("MOZ_EXT_texture_filter_anisotropic")||s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":a=s.getExtension("WEBGL_compressed_texture_s3tc")||s.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":a=s.getExtension("WEBGL_compressed_texture_pvrtc")||s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:a=s.getExtension(r)}return x[r]=a,a}return{has:function(r){return n(r)!==null},init:function(r){r.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(r){const a=n(r);return a===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),a}}}function aee(s,x,n,r){const a={},i=new WeakMap;function o(p){const m=p.target;m.index!==null&&x.remove(m.index);for(const y in m.attributes)x.remove(m.attributes[y]);m.removeEventListener("dispose",o),delete a[m.id];const g=i.get(m);g&&(x.remove(g),i.delete(m)),r.releaseStatesOfGeometry(m),m.isInstancedBufferGeometry===!0&&delete m._maxInstanceCount,n.memory.geometries--}function l(p,m){return a[m.id]===!0||(m.addEventListener("dispose",o),a[m.id]=!0,n.memory.geometries++),m}function c(p){const m=p.attributes;for(const y in m)x.update(m[y],34962);const g=p.morphAttributes;for(const y in g){const b=g[y];for(let v=0,w=b.length;v<w;v++)x.update(b[v],34962)}}function d(p){const m=[],g=p.index,y=p.attributes.position;let b=0;if(g!==null){const _=g.array;b=g.version;for(let T=0,A=_.length;T<A;T+=3){const E=_[T+0],M=_[T+1],I=_[T+2];m.push(E,M,M,I,I,E)}}else{const _=y.array;b=y.version;for(let T=0,A=_.length/3-1;T<A;T+=3){const E=T+0,M=T+1,I=T+2;m.push(E,M,M,I,I,E)}}const v=new(yA(m)?PA:RA)(m,1);v.version=b;const w=i.get(p);w&&x.remove(w),i.set(p,v)}function h(p){const m=i.get(p);if(m){const g=p.index;g!==null&&m.version<g.version&&d(p)}else d(p);return i.get(p)}return{get:l,update:c,getWireframeAttribute:h}}function iee(s,x,n,r){const a=r.isWebGL2;let i;function o(m){i=m}let l,c;function d(m){l=m.type,c=m.bytesPerElement}function h(m,g){s.drawElements(i,g,l,m*c),n.update(g,i,1)}function p(m,g,y){if(y===0)return;let b,v;if(a)b=s,v="drawElementsInstanced";else if(b=x.get("ANGLE_instanced_arrays"),v="drawElementsInstancedANGLE",b===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}b[v](i,g,l,m*c,y),n.update(g,i,y)}this.setMode=o,this.setIndex=d,this.render=h,this.renderInstances=p}function oee(s){const x={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function r(i,o,l){switch(n.calls++,o){case 4:n.triangles+=l*(i/3);break;case 1:n.lines+=l*(i/2);break;case 3:n.lines+=l*(i-1);break;case 2:n.lines+=l*i;break;case 0:n.points+=l*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function a(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:x,render:n,programs:null,autoReset:!0,reset:a,update:r}}function lee(s,x){return s[0]-x[0]}function cee(s,x){return Math.abs(x[1])-Math.abs(s[1])}function B1(s,x){let n=1;const r=x.isInterleavedBufferAttribute?x.data.array:x.array;r instanceof Int8Array?n=127:r instanceof Uint8Array?n=255:r instanceof Uint16Array?n=65535:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),s.divideScalar(n)}function uee(s,x,n){const r={},a=new Float32Array(8),i=new WeakMap,o=new ix,l=[];for(let d=0;d<8;d++)l[d]=[d,0];function c(d,h,p,m){const g=d.morphTargetInfluences;if(x.isWebGL2===!0){const y=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,b=y!==void 0?y.length:0;let v=i.get(h);if(v===void 0||v.count!==b){let Q=function(){re.dispose(),i.delete(h),h.removeEventListener("dispose",Q)};v!==void 0&&v.texture.dispose();const T=h.morphAttributes.position!==void 0,A=h.morphAttributes.normal!==void 0,E=h.morphAttributes.color!==void 0,M=h.morphAttributes.position||[],I=h.morphAttributes.normal||[],C=h.morphAttributes.color||[];let k=0;T===!0&&(k=1),A===!0&&(k=2),E===!0&&(k=3);let O=h.attributes.position.count*k,z=1;O>x.maxTextureSize&&(z=Math.ceil(O/x.maxTextureSize),O=x.maxTextureSize);const ee=new Float32Array(O*z*4*b),re=new p1(ee,O,z,b);re.type=J2,re.needsUpdate=!0;const Y=k*4;for(let te=0;te<b;te++){const se=M[te],xe=I[te],ae=C[te],le=O*z*4*te;for(let de=0;de<se.count;de++){const ue=de*Y;T===!0&&(o.fromBufferAttribute(se,de),se.normalized===!0&&B1(o,se),ee[le+ue+0]=o.x,ee[le+ue+1]=o.y,ee[le+ue+2]=o.z,ee[le+ue+3]=0),A===!0&&(o.fromBufferAttribute(xe,de),xe.normalized===!0&&B1(o,xe),ee[le+ue+4]=o.x,ee[le+ue+5]=o.y,ee[le+ue+6]=o.z,ee[le+ue+7]=0),E===!0&&(o.fromBufferAttribute(ae,de),ae.normalized===!0&&B1(o,ae),ee[le+ue+8]=o.x,ee[le+ue+9]=o.y,ee[le+ue+10]=o.z,ee[le+ue+11]=ae.itemSize===4?o.w:1)}}v={count:b,texture:re,size:new n0(O,z)},i.set(h,v),h.addEventListener("dispose",Q)}let w=0;for(let T=0;T<g.length;T++)w+=g[T];const _=h.morphTargetsRelative?1:1-w;m.getUniforms().setValue(s,"morphTargetBaseInfluence",_),m.getUniforms().setValue(s,"morphTargetInfluences",g),m.getUniforms().setValue(s,"morphTargetsTexture",v.texture,n),m.getUniforms().setValue(s,"morphTargetsTextureSize",v.size)}else{const y=g===void 0?0:g.length;let b=r[h.id];if(b===void 0||b.length!==y){b=[];for(let A=0;A<y;A++)b[A]=[A,0];r[h.id]=b}for(let A=0;A<y;A++){const E=b[A];E[0]=A,E[1]=g[A]}b.sort(cee);for(let A=0;A<8;A++)A<y&&b[A][1]?(l[A][0]=b[A][0],l[A][1]=b[A][1]):(l[A][0]=Number.MAX_SAFE_INTEGER,l[A][1]=0);l.sort(lee);const v=h.morphAttributes.position,w=h.morphAttributes.normal;let _=0;for(let A=0;A<8;A++){const E=l[A],M=E[0],I=E[1];M!==Number.MAX_SAFE_INTEGER&&I?(v&&h.getAttribute("morphTarget"+A)!==v[M]&&h.setAttribute("morphTarget"+A,v[M]),w&&h.getAttribute("morphNormal"+A)!==w[M]&&h.setAttribute("morphNormal"+A,w[M]),a[A]=I,_+=I):(v&&h.hasAttribute("morphTarget"+A)===!0&&h.deleteAttribute("morphTarget"+A),w&&h.hasAttribute("morphNormal"+A)===!0&&h.deleteAttribute("morphNormal"+A),a[A]=0)}const T=h.morphTargetsRelative?1:1-_;m.getUniforms().setValue(s,"morphTargetBaseInfluence",T),m.getUniforms().setValue(s,"morphTargetInfluences",a)}}return{update:c}}function dee(s,x,n,r){let a=new WeakMap;function i(c){const d=r.render.frame,h=c.geometry,p=x.get(c,h);return a.get(p)!==d&&(x.update(p),a.set(p,d)),c.isInstancedMesh&&(c.hasEventListener("dispose",l)===!1&&c.addEventListener("dispose",l),n.update(c.instanceMatrix,34962),c.instanceColor!==null&&n.update(c.instanceColor,34962)),p}function o(){a=new WeakMap}function l(c){const d=c.target;d.removeEventListener("dispose",l),n.remove(d.instanceMatrix),d.instanceColor!==null&&n.remove(d.instanceColor)}return{update:i,dispose:o}}const VA=new Tn,HA=new p1,YA=new wA,qA=new rh,XA=[],KA=[],$A=new Float32Array(16),ZA=new Float32Array(9),JA=new Float32Array(4);function uo(s,x,n){const r=s[0];if(r<=0||r>0)return s;const a=x*n;let i=XA[a];if(i===void 0&&(i=new Float32Array(a),XA[a]=i),x!==0){r.toArray(i,0);for(let o=1,l=0;o!==x;++o)l+=n,s[o].toArray(i,l)}return i}function Jn(s,x){if(s.length!==x.length)return!1;for(let n=0,r=s.length;n<r;n++)if(s[n]!==x[n])return!1;return!0}function Qn(s,x){for(let n=0,r=x.length;n<r;n++)s[n]=x[n]}function ih(s,x){let n=KA[x];n===void 0&&(n=new Int32Array(x),KA[x]=n);for(let r=0;r!==x;++r)n[r]=s.allocateTextureUnit();return n}function hee(s,x){const n=this.cache;n[0]!==x&&(s.uniform1f(this.addr,x),n[0]=x)}function pee(s,x){const n=this.cache;if(x.x!==void 0)(n[0]!==x.x||n[1]!==x.y)&&(s.uniform2f(this.addr,x.x,x.y),n[0]=x.x,n[1]=x.y);else{if(Jn(n,x))return;s.uniform2fv(this.addr,x),Qn(n,x)}}function fee(s,x){const n=this.cache;if(x.x!==void 0)(n[0]!==x.x||n[1]!==x.y||n[2]!==x.z)&&(s.uniform3f(this.addr,x.x,x.y,x.z),n[0]=x.x,n[1]=x.y,n[2]=x.z);else if(x.r!==void 0)(n[0]!==x.r||n[1]!==x.g||n[2]!==x.b)&&(s.uniform3f(this.addr,x.r,x.g,x.b),n[0]=x.r,n[1]=x.g,n[2]=x.b);else{if(Jn(n,x))return;s.uniform3fv(this.addr,x),Qn(n,x)}}function mee(s,x){const n=this.cache;if(x.x!==void 0)(n[0]!==x.x||n[1]!==x.y||n[2]!==x.z||n[3]!==x.w)&&(s.uniform4f(this.addr,x.x,x.y,x.z,x.w),n[0]=x.x,n[1]=x.y,n[2]=x.z,n[3]=x.w);else{if(Jn(n,x))return;s.uniform4fv(this.addr,x),Qn(n,x)}}function gee(s,x){const n=this.cache,r=x.elements;if(r===void 0){if(Jn(n,x))return;s.uniformMatrix2fv(this.addr,!1,x),Qn(n,x)}else{if(Jn(n,r))return;JA.set(r),s.uniformMatrix2fv(this.addr,!1,JA),Qn(n,r)}}function yee(s,x){const n=this.cache,r=x.elements;if(r===void 0){if(Jn(n,x))return;s.uniformMatrix3fv(this.addr,!1,x),Qn(n,x)}else{if(Jn(n,r))return;ZA.set(r),s.uniformMatrix3fv(this.addr,!1,ZA),Qn(n,r)}}function bee(s,x){const n=this.cache,r=x.elements;if(r===void 0){if(Jn(n,x))return;s.uniformMatrix4fv(this.addr,!1,x),Qn(n,x)}else{if(Jn(n,r))return;$A.set(r),s.uniformMatrix4fv(this.addr,!1,$A),Qn(n,r)}}function vee(s,x){const n=this.cache;n[0]!==x&&(s.uniform1i(this.addr,x),n[0]=x)}function wee(s,x){const n=this.cache;Jn(n,x)||(s.uniform2iv(this.addr,x),Qn(n,x))}function _ee(s,x){const n=this.cache;Jn(n,x)||(s.uniform3iv(this.addr,x),Qn(n,x))}function See(s,x){const n=this.cache;Jn(n,x)||(s.uniform4iv(this.addr,x),Qn(n,x))}function Tee(s,x){const n=this.cache;n[0]!==x&&(s.uniform1ui(this.addr,x),n[0]=x)}function Aee(s,x){const n=this.cache;Jn(n,x)||(s.uniform2uiv(this.addr,x),Qn(n,x))}function Eee(s,x){const n=this.cache;Jn(n,x)||(s.uniform3uiv(this.addr,x),Qn(n,x))}function Cee(s,x){const n=this.cache;Jn(n,x)||(s.uniform4uiv(this.addr,x),Qn(n,x))}function Mee(s,x,n){const r=this.cache,a=n.allocateTextureUnit();r[0]!==a&&(s.uniform1i(this.addr,a),r[0]=a),n.setTexture2D(x||VA,a)}function Iee(s,x,n){const r=this.cache,a=n.allocateTextureUnit();r[0]!==a&&(s.uniform1i(this.addr,a),r[0]=a),n.setTexture3D(x||YA,a)}function kee(s,x,n){const r=this.cache,a=n.allocateTextureUnit();r[0]!==a&&(s.uniform1i(this.addr,a),r[0]=a),n.setTextureCube(x||qA,a)}function Nee(s,x,n){const r=this.cache,a=n.allocateTextureUnit();r[0]!==a&&(s.uniform1i(this.addr,a),r[0]=a),n.setTexture2DArray(x||HA,a)}function Ree(s){switch(s){case 5126:return hee;case 35664:return pee;case 35665:return fee;case 35666:return mee;case 35674:return gee;case 35675:return yee;case 35676:return bee;case 5124:case 35670:return vee;case 35667:case 35671:return wee;case 35668:case 35672:return _ee;case 35669:case 35673:return See;case 5125:return Tee;case 36294:return Aee;case 36295:return Eee;case 36296:return Cee;case 35678:case 36198:case 36298:case 36306:case 35682:return Mee;case 35679:case 36299:case 36307:return Iee;case 35680:case 36300:case 36308:case 36293:return kee;case 36289:case 36303:case 36311:case 36292:return Nee}}function Pee(s,x){s.uniform1fv(this.addr,x)}function Lee(s,x){const n=uo(x,this.size,2);s.uniform2fv(this.addr,n)}function Dee(s,x){const n=uo(x,this.size,3);s.uniform3fv(this.addr,n)}function Oee(s,x){const n=uo(x,this.size,4);s.uniform4fv(this.addr,n)}function Fee(s,x){const n=uo(x,this.size,4);s.uniformMatrix2fv(this.addr,!1,n)}function Uee(s,x){const n=uo(x,this.size,9);s.uniformMatrix3fv(this.addr,!1,n)}function Bee(s,x){const n=uo(x,this.size,16);s.uniformMatrix4fv(this.addr,!1,n)}function zee(s,x){s.uniform1iv(this.addr,x)}function Wee(s,x){s.uniform2iv(this.addr,x)}function Gee(s,x){s.uniform3iv(this.addr,x)}function Vee(s,x){s.uniform4iv(this.addr,x)}function Hee(s,x){s.uniform1uiv(this.addr,x)}function Yee(s,x){s.uniform2uiv(this.addr,x)}function qee(s,x){s.uniform3uiv(this.addr,x)}function Xee(s,x){s.uniform4uiv(this.addr,x)}function Kee(s,x,n){const r=x.length,a=ih(n,r);s.uniform1iv(this.addr,a);for(let i=0;i!==r;++i)n.setTexture2D(x[i]||VA,a[i])}function $ee(s,x,n){const r=x.length,a=ih(n,r);s.uniform1iv(this.addr,a);for(let i=0;i!==r;++i)n.setTexture3D(x[i]||YA,a[i])}function Zee(s,x,n){const r=x.length,a=ih(n,r);s.uniform1iv(this.addr,a);for(let i=0;i!==r;++i)n.setTextureCube(x[i]||qA,a[i])}function Jee(s,x,n){const r=x.length,a=ih(n,r);s.uniform1iv(this.addr,a);for(let i=0;i!==r;++i)n.setTexture2DArray(x[i]||HA,a[i])}function Qee(s){switch(s){case 5126:return Pee;case 35664:return Lee;case 35665:return Dee;case 35666:return Oee;case 35674:return Fee;case 35675:return Uee;case 35676:return Bee;case 5124:case 35670:return zee;case 35667:case 35671:return Wee;case 35668:case 35672:return Gee;case 35669:case 35673:return Vee;case 5125:return Hee;case 36294:return Yee;case 36295:return qee;case 36296:return Xee;case 35678:case 36198:case 36298:case 36306:case 35682:return Kee;case 35679:case 36299:case 36307:return $ee;case 35680:case 36300:case 36308:case 36293:return Zee;case 36289:case 36303:case 36311:case 36292:return Jee}}class jee{constructor(x,n,r){this.id=x,this.addr=r,this.cache=[],this.setValue=Ree(n.type)}}class e0e{constructor(x,n,r){this.id=x,this.addr=r,this.cache=[],this.size=n.size,this.setValue=Qee(n.type)}}class t0e{constructor(x){this.id=x,this.seq=[],this.map={}}setValue(x,n,r){const a=this.seq;for(let i=0,o=a.length;i!==o;++i){const l=a[i];l.setValue(x,n[l.id],r)}}}const z1=/(\w+)(\])?(\[|\.)?/g;function QA(s,x){s.seq.push(x),s.map[x.id]=x}function x0e(s,x,n){const r=s.name,a=r.length;for(z1.lastIndex=0;;){const i=z1.exec(r),o=z1.lastIndex;let l=i[1];const c=i[2]==="]",d=i[3];if(c&&(l=l|0),d===void 0||d==="["&&o+2===a){QA(n,d===void 0?new jee(l,s,x):new e0e(l,s,x));break}else{let p=n.map[l];p===void 0&&(p=new t0e(l),QA(n,p)),n=p}}}class oh{constructor(x,n){this.seq=[],this.map={};const r=x.getProgramParameter(n,35718);for(let a=0;a<r;++a){const i=x.getActiveUniform(n,a),o=x.getUniformLocation(n,i.name);x0e(i,o,this)}}setValue(x,n,r,a){const i=this.map[n];i!==void 0&&i.setValue(x,r,a)}setOptional(x,n,r){const a=n[r];a!==void 0&&this.setValue(x,r,a)}static upload(x,n,r,a){for(let i=0,o=n.length;i!==o;++i){const l=n[i],c=r[l.id];c.needsUpdate!==!1&&l.setValue(x,c.value,a)}}static seqWithValue(x,n){const r=[];for(let a=0,i=x.length;a!==i;++a){const o=x[a];o.id in n&&r.push(o)}return r}}function jA(s,x,n){const r=s.createShader(x);return s.shaderSource(r,n),s.compileShader(r),r}let n0e=0;function r0e(s,x){const n=s.split(`
`),r=[],a=Math.max(x-6,0),i=Math.min(x+6,n.length);for(let o=a;o<i;o++){const l=o+1;r.push(`${l===x?">":" "} ${l}: ${n[o]}`)}return r.join(`
`)}function s0e(s){switch(s){case Ss:return["Linear","( value )"];case rx:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",s),["Linear","( value )"]}}function eE(s,x,n){const r=s.getShaderParameter(x,35713),a=s.getShaderInfoLog(x).trim();if(r&&a==="")return"";const i=/ERROR: 0:(\d+)/.exec(a);if(i){const o=parseInt(i[1]);return n.toUpperCase()+`

`+a+`

`+r0e(s.getShaderSource(x),o)}else return a}function a0e(s,x){const n=s0e(x);return"vec4 "+s+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function i0e(s,x){let n;switch(x){case GZ:n="Linear";break;case VZ:n="Reinhard";break;case HZ:n="OptimizedCineon";break;case YZ:n="ACESFilmic";break;case qZ:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",x),n="Linear"}return"vec3 "+s+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function o0e(s){return[s.extensionDerivatives||!!s.envMapCubeUVHeight||s.bumpMap||s.tangentSpaceNormalMap||s.clearcoatNormalMap||s.flatShading||s.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(s.extensionFragDepth||s.logarithmicDepthBuffer)&&s.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",s.extensionDrawBuffers&&s.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(s.extensionShaderTextureLOD||s.envMap||s.transmission)&&s.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Dl).join(`
`)}function l0e(s){const x=[];for(const n in s){const r=s[n];r!==!1&&x.push("#define "+n+" "+r)}return x.join(`
`)}function c0e(s,x){const n={},r=s.getProgramParameter(x,35721);for(let a=0;a<r;a++){const i=s.getActiveAttrib(x,a),o=i.name;let l=1;i.type===35674&&(l=2),i.type===35675&&(l=3),i.type===35676&&(l=4),n[o]={type:i.type,location:s.getAttribLocation(x,o),locationSize:l}}return n}function Dl(s){return s!==""}function tE(s,x){return s.replace(/NUM_DIR_LIGHTS/g,x.numDirLights).replace(/NUM_SPOT_LIGHTS/g,x.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,x.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,x.numPointLights).replace(/NUM_HEMI_LIGHTS/g,x.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,x.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,x.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,x.numPointLightShadows)}function xE(s,x){return s.replace(/NUM_CLIPPING_PLANES/g,x.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,x.numClippingPlanes-x.numClipIntersection)}const u0e=/^[ \t]*#include +<([\w\d./]+)>/gm;function W1(s){return s.replace(u0e,d0e)}function d0e(s,x){const n=Ft[x];if(n===void 0)throw new Error("Can not resolve #include <"+x+">");return W1(n)}const h0e=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,p0e=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nE(s){return s.replace(p0e,rE).replace(h0e,f0e)}function f0e(s,x,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),rE(s,x,n,r)}function rE(s,x,n,r){let a="";for(let i=parseInt(x);i<parseInt(n);i++)a+=r.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return a}function sE(s){let x="precision "+s.precision+` float;
precision `+s.precision+" int;";return s.precision==="highp"?x+=`
#define HIGH_PRECISION`:s.precision==="mediump"?x+=`
#define MEDIUM_PRECISION`:s.precision==="lowp"&&(x+=`
#define LOW_PRECISION`),x}function m0e(s){let x="SHADOWMAP_TYPE_BASIC";return s.shadowMapType===FT?x="SHADOWMAP_TYPE_PCF":s.shadowMapType===bZ?x="SHADOWMAP_TYPE_PCF_SOFT":s.shadowMapType===wl&&(x="SHADOWMAP_TYPE_VSM"),x}function g0e(s){let x="ENVMAP_TYPE_CUBE";if(s.envMap)switch(s.envMapMode){case Ta:case Aa:x="ENVMAP_TYPE_CUBE";break;case Sl:x="ENVMAP_TYPE_CUBE_UV";break}return x}function y0e(s){let x="ENVMAP_MODE_REFLECTION";if(s.envMap)switch(s.envMapMode){case Aa:x="ENVMAP_MODE_REFRACTION";break}return x}function b0e(s){let x="ENVMAP_BLENDING_NONE";if(s.envMap)switch(s.combine){case Nd:x="ENVMAP_BLENDING_MULTIPLY";break;case zZ:x="ENVMAP_BLENDING_MIX";break;case WZ:x="ENVMAP_BLENDING_ADD";break}return x}function v0e(s){const x=s.envMapCubeUVHeight;if(x===null)return null;const n=Math.log2(x)-2,r=1/x;return{texelWidth:1/(3*Math.max(Math.pow(2,n),7*16)),texelHeight:r,maxMip:n}}function w0e(s,x,n,r){const a=s.getContext(),i=n.defines;let o=n.vertexShader,l=n.fragmentShader;const c=m0e(n),d=g0e(n),h=y0e(n),p=b0e(n),m=v0e(n),g=n.isWebGL2?"":o0e(n),y=l0e(i),b=a.createProgram();let v,w,_=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(v=[y].filter(Dl).join(`
`),v.length>0&&(v+=`
`),w=[g,y].filter(Dl).join(`
`),w.length>0&&(w+=`
`)):(v=[sE(n),"#define SHADER_NAME "+n.shaderName,y,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Dl).join(`
`),w=[g,sE(n),"#define SHADER_NAME "+n.shaderName,y,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.envMap?"#define "+h:"",n.envMap?"#define "+p:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Wr?"#define TONE_MAPPING":"",n.toneMapping!==Wr?Ft.tonemapping_pars_fragment:"",n.toneMapping!==Wr?i0e("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Ft.encodings_pars_fragment,a0e("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(Dl).join(`
`)),o=W1(o),o=tE(o,n),o=xE(o,n),l=W1(l),l=tE(l,n),l=xE(l,n),o=nE(o),l=nE(l),n.isWebGL2&&n.isRawShaderMaterial!==!0&&(_=`#version 300 es
`,v=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+v,w=["#define varying in",n.glslVersion===fA?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===fA?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+w);const T=_+v+o,A=_+w+l,E=jA(a,35633,T),M=jA(a,35632,A);if(a.attachShader(b,E),a.attachShader(b,M),n.index0AttributeName!==void 0?a.bindAttribLocation(b,0,n.index0AttributeName):n.morphTargets===!0&&a.bindAttribLocation(b,0,"position"),a.linkProgram(b),s.debug.checkShaderErrors){const k=a.getProgramInfoLog(b).trim(),O=a.getShaderInfoLog(E).trim(),z=a.getShaderInfoLog(M).trim();let ee=!0,re=!0;if(a.getProgramParameter(b,35714)===!1){ee=!1;const Y=eE(a,E,"vertex"),Q=eE(a,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+a.getError()+" - VALIDATE_STATUS "+a.getProgramParameter(b,35715)+`

Program Info Log: `+k+`
`+Y+`
`+Q)}else k!==""?console.warn("THREE.WebGLProgram: Program Info Log:",k):(O===""||z==="")&&(re=!1);re&&(this.diagnostics={runnable:ee,programLog:k,vertexShader:{log:O,prefix:v},fragmentShader:{log:z,prefix:w}})}a.deleteShader(E),a.deleteShader(M);let I;this.getUniforms=function(){return I===void 0&&(I=new oh(a,b)),I};let C;return this.getAttributes=function(){return C===void 0&&(C=c0e(a,b)),C},this.destroy=function(){r.releaseStatesOfProgram(this),a.deleteProgram(b),this.program=void 0},this.name=n.shaderName,this.id=n0e++,this.cacheKey=x,this.usedTimes=1,this.program=b,this.vertexShader=E,this.fragmentShader=M,this}let _0e=0;class S0e{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(x){const n=x.vertexShader,r=x.fragmentShader,a=this._getShaderStage(n),i=this._getShaderStage(r),o=this._getShaderCacheForMaterial(x);return o.has(a)===!1&&(o.add(a),a.usedTimes++),o.has(i)===!1&&(o.add(i),i.usedTimes++),this}remove(x){const n=this.materialCache.get(x);for(const r of n)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(x),this}getVertexShaderID(x){return this._getShaderStage(x.vertexShader).id}getFragmentShaderID(x){return this._getShaderStage(x.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(x){const n=this.materialCache;return n.has(x)===!1&&n.set(x,new Set),n.get(x)}_getShaderStage(x){const n=this.shaderCache;if(n.has(x)===!1){const r=new T0e(x);n.set(x,r)}return n.get(x)}}class T0e{constructor(x){this.id=_0e++,this.code=x,this.usedTimes=0}}function A0e(s,x,n,r,a,i,o){const l=new _1,c=new S0e,d=[],h=a.isWebGL2,p=a.logarithmicDepthBuffer,m=a.vertexTextures;let g=a.precision;const y={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function b(C,k,O,z,ee){const re=z.fog,Y=ee.geometry,Q=C.isMeshStandardMaterial?z.environment:null,te=(C.isMeshStandardMaterial?n:x).get(C.envMap||Q),se=!!te&&te.mapping===Sl?te.image.height:null,xe=y[C.type];C.precision!==null&&(g=a.getMaxPrecision(C.precision),g!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",g,"instead."));const ae=Y.morphAttributes.position||Y.morphAttributes.normal||Y.morphAttributes.color,le=ae!==void 0?ae.length:0;let de=0;Y.morphAttributes.position!==void 0&&(de=1),Y.morphAttributes.normal!==void 0&&(de=2),Y.morphAttributes.color!==void 0&&(de=3);let ue,ge,pe,Le;if(xe){const v0=mr[xe];ue=v0.vertexShader,ge=v0.fragmentShader}else ue=C.vertexShader,ge=C.fragmentShader,c.update(C),pe=c.getVertexShaderID(C),Le=c.getFragmentShaderID(C);const we=s.getRenderTarget(),e0=C.alphaTest>0,Ze=C.clearcoat>0,i0=C.iridescence>0;return{isWebGL2:h,shaderID:xe,shaderName:C.type,vertexShader:ue,fragmentShader:ge,defines:C.defines,customVertexShaderID:pe,customFragmentShaderID:Le,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:g,instancing:ee.isInstancedMesh===!0,instancingColor:ee.isInstancedMesh===!0&&ee.instanceColor!==null,supportsVertexTextures:m,outputEncoding:we===null?s.outputEncoding:we.isXRRenderTarget===!0?we.texture.encoding:Ss,map:!!C.map,matcap:!!C.matcap,envMap:!!te,envMapMode:te&&te.mapping,envMapCubeUVHeight:se,lightMap:!!C.lightMap,aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===pJ,tangentSpaceNormalMap:C.normalMapType===ka,decodeVideoTexture:!!C.map&&C.map.isVideoTexture===!0&&C.map.encoding===rx,clearcoat:Ze,clearcoatMap:Ze&&!!C.clearcoatMap,clearcoatRoughnessMap:Ze&&!!C.clearcoatRoughnessMap,clearcoatNormalMap:Ze&&!!C.clearcoatNormalMap,iridescence:i0,iridescenceMap:i0&&!!C.iridescenceMap,iridescenceThicknessMap:i0&&!!C.iridescenceThicknessMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,specularIntensityMap:!!C.specularIntensityMap,specularColorMap:!!C.specularColorMap,opaque:C.transparent===!1&&C.blending===Bi,alphaMap:!!C.alphaMap,alphaTest:e0,gradientMap:!!C.gradientMap,sheen:C.sheen>0,sheenColorMap:!!C.sheenColorMap,sheenRoughnessMap:!!C.sheenRoughnessMap,transmission:C.transmission>0,transmissionMap:!!C.transmissionMap,thicknessMap:!!C.thicknessMap,combine:C.combine,vertexTangents:!!C.normalMap&&!!Y.attributes.tangent,vertexColors:C.vertexColors,vertexAlphas:C.vertexColors===!0&&!!Y.attributes.color&&Y.attributes.color.itemSize===4,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.iridescenceMap||!!C.iridescenceThicknessMap||!!C.displacementMap||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularColorMap||!!C.sheenColorMap||!!C.sheenRoughnessMap,uvsVertexOnly:!(!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatNormalMap||!!C.iridescenceMap||!!C.iridescenceThicknessMap||C.transmission>0||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularColorMap||C.sheen>0||!!C.sheenColorMap||!!C.sheenRoughnessMap)&&!!C.displacementMap,fog:!!re,useFog:C.fog===!0,fogExp2:re&&re.isFogExp2,flatShading:!!C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:p,skinning:ee.isSkinnedMesh===!0,morphTargets:Y.morphAttributes.position!==void 0,morphNormals:Y.morphAttributes.normal!==void 0,morphColors:Y.morphAttributes.color!==void 0,morphTargetsCount:le,morphTextureStride:de,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:C.dithering,shadowMapEnabled:s.shadowMap.enabled&&O.length>0,shadowMapType:s.shadowMap.type,toneMapping:C.toneMapped?s.toneMapping:Wr,physicallyCorrectLights:s.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,doubleSided:C.side===Sa,flipSided:C.side===Z2,useDepthPacking:!!C.depthPacking,depthPacking:C.depthPacking||0,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function v(C){const k=[];if(C.shaderID?k.push(C.shaderID):(k.push(C.customVertexShaderID),k.push(C.customFragmentShaderID)),C.defines!==void 0)for(const O in C.defines)k.push(O),k.push(C.defines[O]);return C.isRawShaderMaterial===!1&&(w(k,C),_(k,C),k.push(s.outputEncoding)),k.push(C.customProgramCacheKey),k.join()}function w(C,k){C.push(k.precision),C.push(k.outputEncoding),C.push(k.envMapMode),C.push(k.envMapCubeUVHeight),C.push(k.combine),C.push(k.vertexUvs),C.push(k.fogExp2),C.push(k.sizeAttenuation),C.push(k.morphTargetsCount),C.push(k.morphAttributeCount),C.push(k.numDirLights),C.push(k.numPointLights),C.push(k.numSpotLights),C.push(k.numHemiLights),C.push(k.numRectAreaLights),C.push(k.numDirLightShadows),C.push(k.numPointLightShadows),C.push(k.numSpotLightShadows),C.push(k.shadowMapType),C.push(k.toneMapping),C.push(k.numClippingPlanes),C.push(k.numClipIntersection),C.push(k.depthPacking)}function _(C,k){l.disableAll(),k.isWebGL2&&l.enable(0),k.supportsVertexTextures&&l.enable(1),k.instancing&&l.enable(2),k.instancingColor&&l.enable(3),k.map&&l.enable(4),k.matcap&&l.enable(5),k.envMap&&l.enable(6),k.lightMap&&l.enable(7),k.aoMap&&l.enable(8),k.emissiveMap&&l.enable(9),k.bumpMap&&l.enable(10),k.normalMap&&l.enable(11),k.objectSpaceNormalMap&&l.enable(12),k.tangentSpaceNormalMap&&l.enable(13),k.clearcoat&&l.enable(14),k.clearcoatMap&&l.enable(15),k.clearcoatRoughnessMap&&l.enable(16),k.clearcoatNormalMap&&l.enable(17),k.iridescence&&l.enable(18),k.iridescenceMap&&l.enable(19),k.iridescenceThicknessMap&&l.enable(20),k.displacementMap&&l.enable(21),k.specularMap&&l.enable(22),k.roughnessMap&&l.enable(23),k.metalnessMap&&l.enable(24),k.gradientMap&&l.enable(25),k.alphaMap&&l.enable(26),k.alphaTest&&l.enable(27),k.vertexColors&&l.enable(28),k.vertexAlphas&&l.enable(29),k.vertexUvs&&l.enable(30),k.vertexTangents&&l.enable(31),k.uvsVertexOnly&&l.enable(32),k.fog&&l.enable(33),C.push(l.mask),l.disableAll(),k.useFog&&l.enable(0),k.flatShading&&l.enable(1),k.logarithmicDepthBuffer&&l.enable(2),k.skinning&&l.enable(3),k.morphTargets&&l.enable(4),k.morphNormals&&l.enable(5),k.morphColors&&l.enable(6),k.premultipliedAlpha&&l.enable(7),k.shadowMapEnabled&&l.enable(8),k.physicallyCorrectLights&&l.enable(9),k.doubleSided&&l.enable(10),k.flipSided&&l.enable(11),k.useDepthPacking&&l.enable(12),k.dithering&&l.enable(13),k.specularIntensityMap&&l.enable(14),k.specularColorMap&&l.enable(15),k.transmission&&l.enable(16),k.transmissionMap&&l.enable(17),k.thicknessMap&&l.enable(18),k.sheen&&l.enable(19),k.sheenColorMap&&l.enable(20),k.sheenRoughnessMap&&l.enable(21),k.decodeVideoTexture&&l.enable(22),k.opaque&&l.enable(23),C.push(l.mask)}function T(C){const k=y[C.type];let O;if(k){const z=mr[k];O=YJ.clone(z.uniforms)}else O=C.uniforms;return O}function A(C,k){let O;for(let z=0,ee=d.length;z<ee;z++){const re=d[z];if(re.cacheKey===k){O=re,++O.usedTimes;break}}return O===void 0&&(O=new w0e(s,k,C,i),d.push(O)),O}function E(C){if(--C.usedTimes===0){const k=d.indexOf(C);d[k]=d[d.length-1],d.pop(),C.destroy()}}function M(C){c.remove(C)}function I(){c.dispose()}return{getParameters:b,getProgramCacheKey:v,getUniforms:T,acquireProgram:A,releaseProgram:E,releaseShaderCache:M,programs:d,dispose:I}}function E0e(){let s=new WeakMap;function x(i){let o=s.get(i);return o===void 0&&(o={},s.set(i,o)),o}function n(i){s.delete(i)}function r(i,o,l){s.get(i)[o]=l}function a(){s=new WeakMap}return{get:x,remove:n,update:r,dispose:a}}function C0e(s,x){return s.groupOrder!==x.groupOrder?s.groupOrder-x.groupOrder:s.renderOrder!==x.renderOrder?s.renderOrder-x.renderOrder:s.material.id!==x.material.id?s.material.id-x.material.id:s.z!==x.z?s.z-x.z:s.id-x.id}function aE(s,x){return s.groupOrder!==x.groupOrder?s.groupOrder-x.groupOrder:s.renderOrder!==x.renderOrder?s.renderOrder-x.renderOrder:s.z!==x.z?x.z-s.z:s.id-x.id}function iE(){const s=[];let x=0;const n=[],r=[],a=[];function i(){x=0,n.length=0,r.length=0,a.length=0}function o(p,m,g,y,b,v){let w=s[x];return w===void 0?(w={id:p.id,object:p,geometry:m,material:g,groupOrder:y,renderOrder:p.renderOrder,z:b,group:v},s[x]=w):(w.id=p.id,w.object=p,w.geometry=m,w.material=g,w.groupOrder=y,w.renderOrder=p.renderOrder,w.z=b,w.group=v),x++,w}function l(p,m,g,y,b,v){const w=o(p,m,g,y,b,v);g.transmission>0?r.push(w):g.transparent===!0?a.push(w):n.push(w)}function c(p,m,g,y,b,v){const w=o(p,m,g,y,b,v);g.transmission>0?r.unshift(w):g.transparent===!0?a.unshift(w):n.unshift(w)}function d(p,m){n.length>1&&n.sort(p||C0e),r.length>1&&r.sort(m||aE),a.length>1&&a.sort(m||aE)}function h(){for(let p=x,m=s.length;p<m;p++){const g=s[p];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.group=null}}return{opaque:n,transmissive:r,transparent:a,init:i,push:l,unshift:c,finish:h,sort:d}}function M0e(){let s=new WeakMap;function x(r,a){let i;return s.has(r)===!1?(i=new iE,s.set(r,[i])):a>=s.get(r).length?(i=new iE,s.get(r).push(i)):i=s.get(r)[a],i}function n(){s=new WeakMap}return{get:x,dispose:n}}function I0e(){const s={};return{get:function(x){if(s[x.id]!==void 0)return s[x.id];let n;switch(x.type){case"DirectionalLight":n={direction:new K,color:new M0};break;case"SpotLight":n={position:new K,direction:new K,color:new M0,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new K,color:new M0,distance:0,decay:0};break;case"HemisphereLight":n={direction:new K,skyColor:new M0,groundColor:new M0};break;case"RectAreaLight":n={color:new M0,position:new K,halfWidth:new K,halfHeight:new K};break}return s[x.id]=n,n}}}function k0e(){const s={};return{get:function(x){if(s[x.id]!==void 0)return s[x.id];let n;switch(x.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new n0};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new n0};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new n0,shadowCameraNear:1,shadowCameraFar:1e3};break}return s[x.id]=n,n}}}let N0e=0;function R0e(s,x){return(x.castShadow?1:0)-(s.castShadow?1:0)}function P0e(s,x){const n=new I0e,r=k0e(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)a.probe.push(new K);const i=new K,o=new wt,l=new wt;function c(h,p){let m=0,g=0,y=0;for(let k=0;k<9;k++)a.probe[k].set(0,0,0);let b=0,v=0,w=0,_=0,T=0,A=0,E=0,M=0;h.sort(R0e);const I=p!==!0?Math.PI:1;for(let k=0,O=h.length;k<O;k++){const z=h[k],ee=z.color,re=z.intensity,Y=z.distance,Q=z.shadow&&z.shadow.map?z.shadow.map.texture:null;if(z.isAmbientLight)m+=ee.r*re*I,g+=ee.g*re*I,y+=ee.b*re*I;else if(z.isLightProbe)for(let te=0;te<9;te++)a.probe[te].addScaledVector(z.sh.coefficients[te],re);else if(z.isDirectionalLight){const te=n.get(z);if(te.color.copy(z.color).multiplyScalar(z.intensity*I),z.castShadow){const se=z.shadow,xe=r.get(z);xe.shadowBias=se.bias,xe.shadowNormalBias=se.normalBias,xe.shadowRadius=se.radius,xe.shadowMapSize=se.mapSize,a.directionalShadow[b]=xe,a.directionalShadowMap[b]=Q,a.directionalShadowMatrix[b]=z.shadow.matrix,A++}a.directional[b]=te,b++}else if(z.isSpotLight){const te=n.get(z);if(te.position.setFromMatrixPosition(z.matrixWorld),te.color.copy(ee).multiplyScalar(re*I),te.distance=Y,te.coneCos=Math.cos(z.angle),te.penumbraCos=Math.cos(z.angle*(1-z.penumbra)),te.decay=z.decay,z.castShadow){const se=z.shadow,xe=r.get(z);xe.shadowBias=se.bias,xe.shadowNormalBias=se.normalBias,xe.shadowRadius=se.radius,xe.shadowMapSize=se.mapSize,a.spotShadow[w]=xe,a.spotShadowMap[w]=Q,a.spotShadowMatrix[w]=z.shadow.matrix,M++}a.spot[w]=te,w++}else if(z.isRectAreaLight){const te=n.get(z);te.color.copy(ee).multiplyScalar(re),te.halfWidth.set(z.width*.5,0,0),te.halfHeight.set(0,z.height*.5,0),a.rectArea[_]=te,_++}else if(z.isPointLight){const te=n.get(z);if(te.color.copy(z.color).multiplyScalar(z.intensity*I),te.distance=z.distance,te.decay=z.decay,z.castShadow){const se=z.shadow,xe=r.get(z);xe.shadowBias=se.bias,xe.shadowNormalBias=se.normalBias,xe.shadowRadius=se.radius,xe.shadowMapSize=se.mapSize,xe.shadowCameraNear=se.camera.near,xe.shadowCameraFar=se.camera.far,a.pointShadow[v]=xe,a.pointShadowMap[v]=Q,a.pointShadowMatrix[v]=z.shadow.matrix,E++}a.point[v]=te,v++}else if(z.isHemisphereLight){const te=n.get(z);te.skyColor.copy(z.color).multiplyScalar(re*I),te.groundColor.copy(z.groundColor).multiplyScalar(re*I),a.hemi[T]=te,T++}}_>0&&(x.isWebGL2||s.has("OES_texture_float_linear")===!0?(a.rectAreaLTC1=R0.LTC_FLOAT_1,a.rectAreaLTC2=R0.LTC_FLOAT_2):s.has("OES_texture_half_float_linear")===!0?(a.rectAreaLTC1=R0.LTC_HALF_1,a.rectAreaLTC2=R0.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),a.ambient[0]=m,a.ambient[1]=g,a.ambient[2]=y;const C=a.hash;(C.directionalLength!==b||C.pointLength!==v||C.spotLength!==w||C.rectAreaLength!==_||C.hemiLength!==T||C.numDirectionalShadows!==A||C.numPointShadows!==E||C.numSpotShadows!==M)&&(a.directional.length=b,a.spot.length=w,a.rectArea.length=_,a.point.length=v,a.hemi.length=T,a.directionalShadow.length=A,a.directionalShadowMap.length=A,a.pointShadow.length=E,a.pointShadowMap.length=E,a.spotShadow.length=M,a.spotShadowMap.length=M,a.directionalShadowMatrix.length=A,a.pointShadowMatrix.length=E,a.spotShadowMatrix.length=M,C.directionalLength=b,C.pointLength=v,C.spotLength=w,C.rectAreaLength=_,C.hemiLength=T,C.numDirectionalShadows=A,C.numPointShadows=E,C.numSpotShadows=M,a.version=N0e++)}function d(h,p){let m=0,g=0,y=0,b=0,v=0;const w=p.matrixWorldInverse;for(let _=0,T=h.length;_<T;_++){const A=h[_];if(A.isDirectionalLight){const E=a.directional[m];E.direction.setFromMatrixPosition(A.matrixWorld),i.setFromMatrixPosition(A.target.matrixWorld),E.direction.sub(i),E.direction.transformDirection(w),m++}else if(A.isSpotLight){const E=a.spot[y];E.position.setFromMatrixPosition(A.matrixWorld),E.position.applyMatrix4(w),E.direction.setFromMatrixPosition(A.matrixWorld),i.setFromMatrixPosition(A.target.matrixWorld),E.direction.sub(i),E.direction.transformDirection(w),y++}else if(A.isRectAreaLight){const E=a.rectArea[b];E.position.setFromMatrixPosition(A.matrixWorld),E.position.applyMatrix4(w),l.identity(),o.copy(A.matrixWorld),o.premultiply(w),l.extractRotation(o),E.halfWidth.set(A.width*.5,0,0),E.halfHeight.set(0,A.height*.5,0),E.halfWidth.applyMatrix4(l),E.halfHeight.applyMatrix4(l),b++}else if(A.isPointLight){const E=a.point[g];E.position.setFromMatrixPosition(A.matrixWorld),E.position.applyMatrix4(w),g++}else if(A.isHemisphereLight){const E=a.hemi[v];E.direction.setFromMatrixPosition(A.matrixWorld),E.direction.transformDirection(w),v++}}}return{setup:c,setupView:d,state:a}}function oE(s,x){const n=new P0e(s,x),r=[],a=[];function i(){r.length=0,a.length=0}function o(p){r.push(p)}function l(p){a.push(p)}function c(p){n.setup(r,p)}function d(p){n.setupView(r,p)}return{init:i,state:{lightsArray:r,shadowsArray:a,lights:n},setupLights:c,setupLightsView:d,pushLight:o,pushShadow:l}}function L0e(s,x){let n=new WeakMap;function r(i,o=0){let l;return n.has(i)===!1?(l=new oE(s,x),n.set(i,[l])):o>=n.get(i).length?(l=new oE(s,x),n.get(i).push(l)):l=n.get(i)[o],l}function a(){n=new WeakMap}return{get:r,dispose:a}}class lE extends y2{constructor(x){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=dJ,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(x)}copy(x){return super.copy(x),this.depthPacking=x.depthPacking,this.map=x.map,this.alphaMap=x.alphaMap,this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this}}class cE extends y2{constructor(x){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new K,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(x)}copy(x){return super.copy(x),this.referencePosition.copy(x.referencePosition),this.nearDistance=x.nearDistance,this.farDistance=x.farDistance,this.map=x.map,this.alphaMap=x.alphaMap,this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this}}const D0e=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,O0e=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function F0e(s,x,n){let r=new D1;const a=new n0,i=new n0,o=new ix,l=new lE({depthPacking:hJ}),c=new cE,d={},h=n.maxTextureSize,p={0:Z2,1:Ui,2:Sa},m=new Ns({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new n0},radius:{value:4}},vertexShader:D0e,fragmentShader:O0e}),g=m.clone();g.defines.HORIZONTAL_PASS=1;const y=new Rt;y.setAttribute("position",new Qx(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new yn(y,m),v=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=FT,this.render=function(A,E,M){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||A.length===0)return;const I=s.getRenderTarget(),C=s.getActiveCubeFace(),k=s.getActiveMipmapLevel(),O=s.state;O.setBlending(ws),O.buffers.color.setClear(1,1,1,1),O.buffers.depth.setTest(!0),O.setScissorTest(!1);for(let z=0,ee=A.length;z<ee;z++){const re=A[z],Y=re.shadow;if(Y===void 0){console.warn("THREE.WebGLShadowMap:",re,"has no shadow.");continue}if(Y.autoUpdate===!1&&Y.needsUpdate===!1)continue;a.copy(Y.mapSize);const Q=Y.getFrameExtents();if(a.multiply(Q),i.copy(Y.mapSize),(a.x>h||a.y>h)&&(a.x>h&&(i.x=Math.floor(h/Q.x),a.x=i.x*Q.x,Y.mapSize.x=i.x),a.y>h&&(i.y=Math.floor(h/Q.y),a.y=i.y*Q.y,Y.mapSize.y=i.y)),Y.map===null){const se=this.type!==wl?{minFilter:Zx,magFilter:Zx}:{};Y.map=new La(a.x,a.y,se),Y.map.texture.name=re.name+".shadowMap",Y.camera.updateProjectionMatrix()}s.setRenderTarget(Y.map),s.clear();const te=Y.getViewportCount();for(let se=0;se<te;se++){const xe=Y.getViewport(se);o.set(i.x*xe.x,i.y*xe.y,i.x*xe.z,i.y*xe.w),O.viewport(o),Y.updateMatrices(re,se),r=Y.getFrustum(),T(E,M,Y.camera,re,this.type)}Y.isPointLightShadow!==!0&&this.type===wl&&w(Y,M),Y.needsUpdate=!1}v.needsUpdate=!1,s.setRenderTarget(I,C,k)};function w(A,E){const M=x.update(b);m.defines.VSM_SAMPLES!==A.blurSamples&&(m.defines.VSM_SAMPLES=A.blurSamples,g.defines.VSM_SAMPLES=A.blurSamples,m.needsUpdate=!0,g.needsUpdate=!0),A.mapPass===null&&(A.mapPass=new La(a.x,a.y)),m.uniforms.shadow_pass.value=A.map.texture,m.uniforms.resolution.value=A.mapSize,m.uniforms.radius.value=A.radius,s.setRenderTarget(A.mapPass),s.clear(),s.renderBufferDirect(E,null,M,m,b,null),g.uniforms.shadow_pass.value=A.mapPass.texture,g.uniforms.resolution.value=A.mapSize,g.uniforms.radius.value=A.radius,s.setRenderTarget(A.map),s.clear(),s.renderBufferDirect(E,null,M,g,b,null)}function _(A,E,M,I,C,k){let O=null;const z=M.isPointLight===!0?A.customDistanceMaterial:A.customDepthMaterial;if(z!==void 0?O=z:O=M.isPointLight===!0?c:l,s.localClippingEnabled&&E.clipShadows===!0&&Array.isArray(E.clippingPlanes)&&E.clippingPlanes.length!==0||E.displacementMap&&E.displacementScale!==0||E.alphaMap&&E.alphaTest>0){const ee=O.uuid,re=E.uuid;let Y=d[ee];Y===void 0&&(Y={},d[ee]=Y);let Q=Y[re];Q===void 0&&(Q=O.clone(),Y[re]=Q),O=Q}return O.visible=E.visible,O.wireframe=E.wireframe,k===wl?O.side=E.shadowSide!==null?E.shadowSide:E.side:O.side=E.shadowSide!==null?E.shadowSide:p[E.side],O.alphaMap=E.alphaMap,O.alphaTest=E.alphaTest,O.clipShadows=E.clipShadows,O.clippingPlanes=E.clippingPlanes,O.clipIntersection=E.clipIntersection,O.displacementMap=E.displacementMap,O.displacementScale=E.displacementScale,O.displacementBias=E.displacementBias,O.wireframeLinewidth=E.wireframeLinewidth,O.linewidth=E.linewidth,M.isPointLight===!0&&O.isMeshDistanceMaterial===!0&&(O.referencePosition.setFromMatrixPosition(M.matrixWorld),O.nearDistance=I,O.farDistance=C),O}function T(A,E,M,I,C){if(A.visible===!1)return;if(A.layers.test(E.layers)&&(A.isMesh||A.isLine||A.isPoints)&&(A.castShadow||A.receiveShadow&&C===wl)&&(!A.frustumCulled||r.intersectsObject(A))){A.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse,A.matrixWorld);const z=x.update(A),ee=A.material;if(Array.isArray(ee)){const re=z.groups;for(let Y=0,Q=re.length;Y<Q;Y++){const te=re[Y],se=ee[te.materialIndex];if(se&&se.visible){const xe=_(A,se,I,M.near,M.far,C);s.renderBufferDirect(M,null,z,xe,A,te)}}}else if(ee.visible){const re=_(A,ee,I,M.near,M.far,C);s.renderBufferDirect(M,null,z,re,A,null)}}const O=A.children;for(let z=0,ee=O.length;z<ee;z++)T(O[z],E,M,I,C)}}function U0e(s,x,n){const r=n.isWebGL2;function a(){let ye=!1;const k0=new ix;let Fe=null;const h0=new ix(0,0,0,0);return{setMask:function(f0){Fe!==f0&&!ye&&(s.colorMask(f0,f0,f0,f0),Fe=f0)},setLocked:function(f0){ye=f0},setClear:function(f0,Y0,ox,qt,jx){jx===!0&&(f0*=qt,Y0*=qt,ox*=qt),k0.set(f0,Y0,ox,qt),h0.equals(k0)===!1&&(s.clearColor(f0,Y0,ox,qt),h0.copy(k0))},reset:function(){ye=!1,Fe=null,h0.set(-1,0,0,0)}}}function i(){let ye=!1,k0=null,Fe=null,h0=null;return{setTest:function(f0){f0?e0(2929):Ze(2929)},setMask:function(f0){k0!==f0&&!ye&&(s.depthMask(f0),k0=f0)},setFunc:function(f0){if(Fe!==f0){if(f0)switch(f0){case PZ:s.depthFunc(512);break;case LZ:s.depthFunc(519);break;case DZ:s.depthFunc(513);break;case Qg:s.depthFunc(515);break;case OZ:s.depthFunc(514);break;case FZ:s.depthFunc(518);break;case UZ:s.depthFunc(516);break;case BZ:s.depthFunc(517);break;default:s.depthFunc(515)}else s.depthFunc(515);Fe=f0}},setLocked:function(f0){ye=f0},setClear:function(f0){h0!==f0&&(s.clearDepth(f0),h0=f0)},reset:function(){ye=!1,k0=null,Fe=null,h0=null}}}function o(){let ye=!1,k0=null,Fe=null,h0=null,f0=null,Y0=null,ox=null,qt=null,jx=null;return{setTest:function(Jt){ye||(Jt?e0(2960):Ze(2960))},setMask:function(Jt){k0!==Jt&&!ye&&(s.stencilMask(Jt),k0=Jt)},setFunc:function(Jt,Dx,zt){(Fe!==Jt||h0!==Dx||f0!==zt)&&(s.stencilFunc(Jt,Dx,zt),Fe=Jt,h0=Dx,f0=zt)},setOp:function(Jt,Dx,zt){(Y0!==Jt||ox!==Dx||qt!==zt)&&(s.stencilOp(Jt,Dx,zt),Y0=Jt,ox=Dx,qt=zt)},setLocked:function(Jt){ye=Jt},setClear:function(Jt){jx!==Jt&&(s.clearStencil(Jt),jx=Jt)},reset:function(){ye=!1,k0=null,Fe=null,h0=null,f0=null,Y0=null,ox=null,qt=null,jx=null}}}const l=new a,c=new i,d=new o,h=new WeakMap,p=new WeakMap;let m={},g={},y=new WeakMap,b=[],v=null,w=!1,_=null,T=null,A=null,E=null,M=null,I=null,C=null,k=!1,O=null,z=null,ee=null,re=null,Y=null;const Q=s.getParameter(35661);let te=!1,se=0;const xe=s.getParameter(7938);xe.indexOf("WebGL")!==-1?(se=parseFloat(/^WebGL (\d)/.exec(xe)[1]),te=se>=1):xe.indexOf("OpenGL ES")!==-1&&(se=parseFloat(/^OpenGL ES (\d)/.exec(xe)[1]),te=se>=2);let ae=null,le={};const de=s.getParameter(3088),ue=s.getParameter(2978),ge=new ix().fromArray(de),pe=new ix().fromArray(ue);function Le(ye,k0,Fe){const h0=new Uint8Array(4),f0=s.createTexture();s.bindTexture(ye,f0),s.texParameteri(ye,10241,9728),s.texParameteri(ye,10240,9728);for(let Y0=0;Y0<Fe;Y0++)s.texImage2D(k0+Y0,0,6408,1,1,0,6408,5121,h0);return f0}const we={};we[3553]=Le(3553,3553,1),we[34067]=Le(34067,34069,6),l.setClear(0,0,0,1),c.setClear(1),d.setClear(0),e0(2929),c.setFunc(Qg),Ye(!1),I0(OT),e0(2884),Xe(ws);function e0(ye){m[ye]!==!0&&(s.enable(ye),m[ye]=!0)}function Ze(ye){m[ye]!==!1&&(s.disable(ye),m[ye]=!1)}function i0(ye,k0){return g[ye]!==k0?(s.bindFramebuffer(ye,k0),g[ye]=k0,r&&(ye===36009&&(g[36160]=k0),ye===36160&&(g[36009]=k0)),!0):!1}function We(ye,k0){let Fe=b,h0=!1;if(ye)if(Fe=y.get(k0),Fe===void 0&&(Fe=[],y.set(k0,Fe)),ye.isWebGLMultipleRenderTargets){const f0=ye.texture;if(Fe.length!==f0.length||Fe[0]!==36064){for(let Y0=0,ox=f0.length;Y0<ox;Y0++)Fe[Y0]=36064+Y0;Fe.length=f0.length,h0=!0}}else Fe[0]!==36064&&(Fe[0]=36064,h0=!0);else Fe[0]!==1029&&(Fe[0]=1029,h0=!0);h0&&(n.isWebGL2?s.drawBuffers(Fe):x.get("WEBGL_draw_buffers").drawBuffersWEBGL(Fe))}function v0(ye){return v!==ye?(s.useProgram(ye),v=ye,!0):!1}const Te={[zi]:32774,[_Z]:32778,[SZ]:32779};if(r)Te[WT]=32775,Te[GT]=32776;else{const ye=x.get("EXT_blend_minmax");ye!==null&&(Te[WT]=ye.MIN_EXT,Te[GT]=ye.MAX_EXT)}const Ie={[TZ]:0,[AZ]:1,[EZ]:768,[VT]:770,[RZ]:776,[kZ]:774,[MZ]:772,[CZ]:769,[HT]:771,[NZ]:775,[IZ]:773};function Xe(ye,k0,Fe,h0,f0,Y0,ox,qt){if(ye===ws){w===!0&&(Ze(3042),w=!1);return}if(w===!1&&(e0(3042),w=!0),ye!==wZ){if(ye!==_||qt!==k){if((T!==zi||M!==zi)&&(s.blendEquation(32774),T=zi,M=zi),qt)switch(ye){case Bi:s.blendFuncSeparate(1,771,1,771);break;case UT:s.blendFunc(1,1);break;case BT:s.blendFuncSeparate(0,769,0,1);break;case zT:s.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}else switch(ye){case Bi:s.blendFuncSeparate(770,771,1,771);break;case UT:s.blendFunc(770,1);break;case BT:s.blendFuncSeparate(0,769,0,1);break;case zT:s.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}A=null,E=null,I=null,C=null,_=ye,k=qt}return}f0=f0||k0,Y0=Y0||Fe,ox=ox||h0,(k0!==T||f0!==M)&&(s.blendEquationSeparate(Te[k0],Te[f0]),T=k0,M=f0),(Fe!==A||h0!==E||Y0!==I||ox!==C)&&(s.blendFuncSeparate(Ie[Fe],Ie[h0],Ie[Y0],Ie[ox]),A=Fe,E=h0,I=Y0,C=ox),_=ye,k=null}function c0(ye,k0){ye.side===Sa?Ze(2884):e0(2884);let Fe=ye.side===Z2;k0&&(Fe=!Fe),Ye(Fe),ye.blending===Bi&&ye.transparent===!1?Xe(ws):Xe(ye.blending,ye.blendEquation,ye.blendSrc,ye.blendDst,ye.blendEquationAlpha,ye.blendSrcAlpha,ye.blendDstAlpha,ye.premultipliedAlpha),c.setFunc(ye.depthFunc),c.setTest(ye.depthTest),c.setMask(ye.depthWrite),l.setMask(ye.colorWrite);const h0=ye.stencilWrite;d.setTest(h0),h0&&(d.setMask(ye.stencilWriteMask),d.setFunc(ye.stencilFunc,ye.stencilRef,ye.stencilFuncMask),d.setOp(ye.stencilFail,ye.stencilZFail,ye.stencilZPass)),d0(ye.polygonOffset,ye.polygonOffsetFactor,ye.polygonOffsetUnits),ye.alphaToCoverage===!0?e0(32926):Ze(32926)}function Ye(ye){O!==ye&&(ye?s.frontFace(2304):s.frontFace(2305),O=ye)}function I0(ye){ye!==gZ?(e0(2884),ye!==z&&(ye===OT?s.cullFace(1029):ye===yZ?s.cullFace(1028):s.cullFace(1032))):Ze(2884),z=ye}function m0(ye){ye!==ee&&(te&&s.lineWidth(ye),ee=ye)}function d0(ye,k0,Fe){ye?(e0(32823),(re!==k0||Y!==Fe)&&(s.polygonOffset(k0,Fe),re=k0,Y=Fe)):Ze(32823)}function rt(ye){ye?e0(3089):Ze(3089)}function ct(ye){ye===void 0&&(ye=33984+Q-1),ae!==ye&&(s.activeTexture(ye),ae=ye)}function ie(ye,k0){ae===null&&ct();let Fe=le[ae];Fe===void 0&&(Fe={type:void 0,texture:void 0},le[ae]=Fe),(Fe.type!==ye||Fe.texture!==k0)&&(s.bindTexture(ye,k0||we[ye]),Fe.type=ye,Fe.texture=k0)}function $(){const ye=le[ae];ye!==void 0&&ye.type!==void 0&&(s.bindTexture(ye.type,null),ye.type=void 0,ye.texture=void 0)}function ke(){try{s.compressedTexImage2D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function Ge(){try{s.texSubImage2D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function s0(){try{s.texSubImage3D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function p0(){try{s.compressedTexSubImage2D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function K0(){try{s.texStorage2D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function Re(){try{s.texStorage3D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function L0(){try{s.texImage2D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function u0(){try{s.texImage3D.apply(s,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function D0(ye){ge.equals(ye)===!1&&(s.scissor(ye.x,ye.y,ye.z,ye.w),ge.copy(ye))}function b0(ye){pe.equals(ye)===!1&&(s.viewport(ye.x,ye.y,ye.z,ye.w),pe.copy(ye))}function et(ye,k0){let Fe=p.get(k0);Fe===void 0&&(Fe=new WeakMap,p.set(k0,Fe));let h0=Fe.get(ye);h0===void 0&&(h0=s.getUniformBlockIndex(k0,ye.name),Fe.set(ye,h0))}function Et(ye,k0){const h0=p.get(k0).get(ye);h.get(ye)!==h0&&(s.uniformBlockBinding(k0,h0,ye.__bindingPointIndex),h.set(ye,h0))}function xx(){s.disable(3042),s.disable(2884),s.disable(2929),s.disable(32823),s.disable(3089),s.disable(2960),s.disable(32926),s.blendEquation(32774),s.blendFunc(1,0),s.blendFuncSeparate(1,0,1,0),s.colorMask(!0,!0,!0,!0),s.clearColor(0,0,0,0),s.depthMask(!0),s.depthFunc(513),s.clearDepth(1),s.stencilMask(4294967295),s.stencilFunc(519,0,4294967295),s.stencilOp(7680,7680,7680),s.clearStencil(0),s.cullFace(1029),s.frontFace(2305),s.polygonOffset(0,0),s.activeTexture(33984),s.bindFramebuffer(36160,null),r===!0&&(s.bindFramebuffer(36009,null),s.bindFramebuffer(36008,null)),s.useProgram(null),s.lineWidth(1),s.scissor(0,0,s.canvas.width,s.canvas.height),s.viewport(0,0,s.canvas.width,s.canvas.height),m={},ae=null,le={},g={},y=new WeakMap,b=[],v=null,w=!1,_=null,T=null,A=null,E=null,M=null,I=null,C=null,k=!1,O=null,z=null,ee=null,re=null,Y=null,ge.set(0,0,s.canvas.width,s.canvas.height),pe.set(0,0,s.canvas.width,s.canvas.height),l.reset(),c.reset(),d.reset()}return{buffers:{color:l,depth:c,stencil:d},enable:e0,disable:Ze,bindFramebuffer:i0,drawBuffers:We,useProgram:v0,setBlending:Xe,setMaterial:c0,setFlipSided:Ye,setCullFace:I0,setLineWidth:m0,setPolygonOffset:d0,setScissorTest:rt,activeTexture:ct,bindTexture:ie,unbindTexture:$,compressedTexImage2D:ke,texImage2D:L0,texImage3D:u0,updateUBOMapping:et,uniformBlockBinding:Et,texStorage2D:K0,texStorage3D:Re,texSubImage2D:Ge,texSubImage3D:s0,compressedTexSubImage2D:p0,scissor:D0,viewport:b0,reset:xx}}function B0e(s,x,n,r,a,i,o){const l=a.isWebGL2,c=a.maxTextures,d=a.maxCubemapSize,h=a.maxTextureSize,p=a.maxSamples,m=x.has("WEBGL_multisampled_render_to_texture")?x.get("WEBGL_multisampled_render_to_texture"):null,g=/OculusBrowser/g.test(navigator.userAgent),y=new WeakMap;let b;const v=new WeakMap;let w=!1;try{w=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _(ie,$){return w?new OffscreenCanvas(ie,$):Ml("canvas")}function T(ie,$,ke,Ge){let s0=1;if((ie.width>Ge||ie.height>Ge)&&(s0=Ge/Math.max(ie.width,ie.height)),s0<1||$===!0)if(typeof HTMLImageElement<"u"&&ie instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ie instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ie instanceof ImageBitmap){const p0=$?Fd:Math.floor,K0=p0(s0*ie.width),Re=p0(s0*ie.height);b===void 0&&(b=_(K0,Re));const L0=ke?_(K0,Re):b;return L0.width=K0,L0.height=Re,L0.getContext("2d").drawImage(ie,0,0,K0,Re),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ie.width+"x"+ie.height+") to ("+K0+"x"+Re+")."),L0}else return"data"in ie&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ie.width+"x"+ie.height+")."),ie;return ie}function A(ie){return c1(ie.width)&&c1(ie.height)}function E(ie){return l?!1:ie.wrapS!==Zn||ie.wrapT!==Zn||ie.minFilter!==Zx&&ie.minFilter!==Sx}function M(ie,$){return ie.generateMipmaps&&$&&ie.minFilter!==Zx&&ie.minFilter!==Sx}function I(ie){s.generateMipmap(ie)}function C(ie,$,ke,Ge,s0=!1){if(l===!1)return $;if(ie!==null){if(s[ie]!==void 0)return s[ie];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ie+"'")}let p0=$;return $===6403&&(ke===5126&&(p0=33326),ke===5131&&(p0=33325),ke===5121&&(p0=33321)),$===33319&&(ke===5126&&(p0=33328),ke===5131&&(p0=33327),ke===5121&&(p0=33323)),$===6408&&(ke===5126&&(p0=34836),ke===5131&&(p0=34842),ke===5121&&(p0=Ge===rx&&s0===!1?35907:32856),ke===32819&&(p0=32854),ke===32820&&(p0=32855)),(p0===33325||p0===33326||p0===33327||p0===33328||p0===34842||p0===34836)&&x.get("EXT_color_buffer_float"),p0}function k(ie,$,ke){return M(ie,ke)===!0||ie.isFramebufferTexture&&ie.minFilter!==Zx&&ie.minFilter!==Sx?Math.log2(Math.max($.width,$.height))+1:ie.mipmaps!==void 0&&ie.mipmaps.length>0?ie.mipmaps.length:ie.isCompressedTexture&&Array.isArray(ie.image)?$.mipmaps.length:1}function O(ie){return ie===Zx||ie===Pd||ie===Ld?9728:9729}function z(ie){const $=ie.target;$.removeEventListener("dispose",z),re($),$.isVideoTexture&&y.delete($)}function ee(ie){const $=ie.target;$.removeEventListener("dispose",ee),Q($)}function re(ie){const $=r.get(ie);if($.__webglInit===void 0)return;const ke=ie.source,Ge=v.get(ke);if(Ge){const s0=Ge[$.__cacheKey];s0.usedTimes--,s0.usedTimes===0&&Y(ie),Object.keys(Ge).length===0&&v.delete(ke)}r.remove(ie)}function Y(ie){const $=r.get(ie);s.deleteTexture($.__webglTexture);const ke=ie.source,Ge=v.get(ke);delete Ge[$.__cacheKey],o.memory.textures--}function Q(ie){const $=ie.texture,ke=r.get(ie),Ge=r.get($);if(Ge.__webglTexture!==void 0&&(s.deleteTexture(Ge.__webglTexture),o.memory.textures--),ie.depthTexture&&ie.depthTexture.dispose(),ie.isWebGLCubeRenderTarget)for(let s0=0;s0<6;s0++)s.deleteFramebuffer(ke.__webglFramebuffer[s0]),ke.__webglDepthbuffer&&s.deleteRenderbuffer(ke.__webglDepthbuffer[s0]);else{if(s.deleteFramebuffer(ke.__webglFramebuffer),ke.__webglDepthbuffer&&s.deleteRenderbuffer(ke.__webglDepthbuffer),ke.__webglMultisampledFramebuffer&&s.deleteFramebuffer(ke.__webglMultisampledFramebuffer),ke.__webglColorRenderbuffer)for(let s0=0;s0<ke.__webglColorRenderbuffer.length;s0++)ke.__webglColorRenderbuffer[s0]&&s.deleteRenderbuffer(ke.__webglColorRenderbuffer[s0]);ke.__webglDepthRenderbuffer&&s.deleteRenderbuffer(ke.__webglDepthRenderbuffer)}if(ie.isWebGLMultipleRenderTargets)for(let s0=0,p0=$.length;s0<p0;s0++){const K0=r.get($[s0]);K0.__webglTexture&&(s.deleteTexture(K0.__webglTexture),o.memory.textures--),r.remove($[s0])}r.remove($),r.remove(ie)}let te=0;function se(){te=0}function xe(){const ie=te;return ie>=c&&console.warn("THREE.WebGLTextures: Trying to use "+ie+" texture units while this GPU supports only "+c),te+=1,ie}function ae(ie){const $=[];return $.push(ie.wrapS),$.push(ie.wrapT),$.push(ie.magFilter),$.push(ie.minFilter),$.push(ie.anisotropy),$.push(ie.internalFormat),$.push(ie.format),$.push(ie.type),$.push(ie.generateMipmaps),$.push(ie.premultiplyAlpha),$.push(ie.flipY),$.push(ie.unpackAlignment),$.push(ie.encoding),$.join()}function le(ie,$){const ke=r.get(ie);if(ie.isVideoTexture&&rt(ie),ie.isRenderTargetTexture===!1&&ie.version>0&&ke.__version!==ie.version){const Ge=ie.image;if(Ge===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ze(ke,ie,$);return}}n.activeTexture(33984+$),n.bindTexture(3553,ke.__webglTexture)}function de(ie,$){const ke=r.get(ie);if(ie.version>0&&ke.__version!==ie.version){Ze(ke,ie,$);return}n.activeTexture(33984+$),n.bindTexture(35866,ke.__webglTexture)}function ue(ie,$){const ke=r.get(ie);if(ie.version>0&&ke.__version!==ie.version){Ze(ke,ie,$);return}n.activeTexture(33984+$),n.bindTexture(32879,ke.__webglTexture)}function ge(ie,$){const ke=r.get(ie);if(ie.version>0&&ke.__version!==ie.version){i0(ke,ie,$);return}n.activeTexture(33984+$),n.bindTexture(34067,ke.__webglTexture)}const pe={[Ea]:10497,[Zn]:33071,[Tl]:33648},Le={[Zx]:9728,[Pd]:9984,[Ld]:9986,[Sx]:9729,[e1]:9985,[_s]:9987};function we(ie,$,ke){if(ke?(s.texParameteri(ie,10242,pe[$.wrapS]),s.texParameteri(ie,10243,pe[$.wrapT]),(ie===32879||ie===35866)&&s.texParameteri(ie,32882,pe[$.wrapR]),s.texParameteri(ie,10240,Le[$.magFilter]),s.texParameteri(ie,10241,Le[$.minFilter])):(s.texParameteri(ie,10242,33071),s.texParameteri(ie,10243,33071),(ie===32879||ie===35866)&&s.texParameteri(ie,32882,33071),($.wrapS!==Zn||$.wrapT!==Zn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),s.texParameteri(ie,10240,O($.magFilter)),s.texParameteri(ie,10241,O($.minFilter)),$.minFilter!==Zx&&$.minFilter!==Sx&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),x.has("EXT_texture_filter_anisotropic")===!0){const Ge=x.get("EXT_texture_filter_anisotropic");if($.type===J2&&x.has("OES_texture_float_linear")===!1||l===!1&&$.type===Gr&&x.has("OES_texture_half_float_linear")===!1)return;($.anisotropy>1||r.get($).__currentAnisotropy)&&(s.texParameterf(ie,Ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min($.anisotropy,a.getMaxAnisotropy())),r.get($).__currentAnisotropy=$.anisotropy)}}function e0(ie,$){let ke=!1;ie.__webglInit===void 0&&(ie.__webglInit=!0,$.addEventListener("dispose",z));const Ge=$.source;let s0=v.get(Ge);s0===void 0&&(s0={},v.set(Ge,s0));const p0=ae($);if(p0!==ie.__cacheKey){s0[p0]===void 0&&(s0[p0]={texture:s.createTexture(),usedTimes:0},o.memory.textures++,ke=!0),s0[p0].usedTimes++;const K0=s0[ie.__cacheKey];K0!==void 0&&(s0[ie.__cacheKey].usedTimes--,K0.usedTimes===0&&Y($)),ie.__cacheKey=p0,ie.__webglTexture=s0[p0].texture}return ke}function Ze(ie,$,ke){let Ge=3553;$.isDataArrayTexture&&(Ge=35866),$.isData3DTexture&&(Ge=32879);const s0=e0(ie,$),p0=$.source;if(n.activeTexture(33984+ke),n.bindTexture(Ge,ie.__webglTexture),p0.version!==p0.__currentVersion||s0===!0){s.pixelStorei(37440,$.flipY),s.pixelStorei(37441,$.premultiplyAlpha),s.pixelStorei(3317,$.unpackAlignment),s.pixelStorei(37443,0);const K0=E($)&&A($.image)===!1;let Re=T($.image,K0,!1,h);Re=ct($,Re);const L0=A(Re)||l,u0=i.convert($.format,$.encoding);let D0=i.convert($.type),b0=C($.internalFormat,u0,D0,$.encoding,$.isVideoTexture);we(Ge,$,L0);let et;const Et=$.mipmaps,xx=l&&$.isVideoTexture!==!0,ye=p0.__currentVersion===void 0||s0===!0,k0=k($,Re,L0);if($.isDepthTexture)b0=6402,l?$.type===J2?b0=36012:$.type===Ma?b0=33190:$.type===Wi?b0=35056:b0=33189:$.type===J2&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),$.format===Ia&&b0===6402&&$.type!==YT&&$.type!==Ma&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),$.type=Ma,D0=i.convert($.type)),$.format===Gi&&b0===6402&&(b0=34041,$.type!==Wi&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),$.type=Wi,D0=i.convert($.type))),ye&&(xx?n.texStorage2D(3553,1,b0,Re.width,Re.height):n.texImage2D(3553,0,b0,Re.width,Re.height,0,u0,D0,null));else if($.isDataTexture)if(Et.length>0&&L0){xx&&ye&&n.texStorage2D(3553,k0,b0,Et[0].width,Et[0].height);for(let Fe=0,h0=Et.length;Fe<h0;Fe++)et=Et[Fe],xx?n.texSubImage2D(3553,Fe,0,0,et.width,et.height,u0,D0,et.data):n.texImage2D(3553,Fe,b0,et.width,et.height,0,u0,D0,et.data);$.generateMipmaps=!1}else xx?(ye&&n.texStorage2D(3553,k0,b0,Re.width,Re.height),n.texSubImage2D(3553,0,0,0,Re.width,Re.height,u0,D0,Re.data)):n.texImage2D(3553,0,b0,Re.width,Re.height,0,u0,D0,Re.data);else if($.isCompressedTexture){xx&&ye&&n.texStorage2D(3553,k0,b0,Et[0].width,Et[0].height);for(let Fe=0,h0=Et.length;Fe<h0;Fe++)et=Et[Fe],$.format!==Q2?u0!==null?xx?n.compressedTexSubImage2D(3553,Fe,0,0,et.width,et.height,u0,et.data):n.compressedTexImage2D(3553,Fe,b0,et.width,et.height,0,et.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):xx?n.texSubImage2D(3553,Fe,0,0,et.width,et.height,u0,D0,et.data):n.texImage2D(3553,Fe,b0,et.width,et.height,0,u0,D0,et.data)}else if($.isDataArrayTexture)xx?(ye&&n.texStorage3D(35866,k0,b0,Re.width,Re.height,Re.depth),n.texSubImage3D(35866,0,0,0,0,Re.width,Re.height,Re.depth,u0,D0,Re.data)):n.texImage3D(35866,0,b0,Re.width,Re.height,Re.depth,0,u0,D0,Re.data);else if($.isData3DTexture)xx?(ye&&n.texStorage3D(32879,k0,b0,Re.width,Re.height,Re.depth),n.texSubImage3D(32879,0,0,0,0,Re.width,Re.height,Re.depth,u0,D0,Re.data)):n.texImage3D(32879,0,b0,Re.width,Re.height,Re.depth,0,u0,D0,Re.data);else if($.isFramebufferTexture){if(ye)if(xx)n.texStorage2D(3553,k0,b0,Re.width,Re.height);else{let Fe=Re.width,h0=Re.height;for(let f0=0;f0<k0;f0++)n.texImage2D(3553,f0,b0,Fe,h0,0,u0,D0,null),Fe>>=1,h0>>=1}}else if(Et.length>0&&L0){xx&&ye&&n.texStorage2D(3553,k0,b0,Et[0].width,Et[0].height);for(let Fe=0,h0=Et.length;Fe<h0;Fe++)et=Et[Fe],xx?n.texSubImage2D(3553,Fe,0,0,u0,D0,et):n.texImage2D(3553,Fe,b0,u0,D0,et);$.generateMipmaps=!1}else xx?(ye&&n.texStorage2D(3553,k0,b0,Re.width,Re.height),n.texSubImage2D(3553,0,0,0,u0,D0,Re)):n.texImage2D(3553,0,b0,u0,D0,Re);M($,L0)&&I(Ge),p0.__currentVersion=p0.version,$.onUpdate&&$.onUpdate($)}ie.__version=$.version}function i0(ie,$,ke){if($.image.length!==6)return;const Ge=e0(ie,$),s0=$.source;if(n.activeTexture(33984+ke),n.bindTexture(34067,ie.__webglTexture),s0.version!==s0.__currentVersion||Ge===!0){s.pixelStorei(37440,$.flipY),s.pixelStorei(37441,$.premultiplyAlpha),s.pixelStorei(3317,$.unpackAlignment),s.pixelStorei(37443,0);const p0=$.isCompressedTexture||$.image[0].isCompressedTexture,K0=$.image[0]&&$.image[0].isDataTexture,Re=[];for(let Fe=0;Fe<6;Fe++)!p0&&!K0?Re[Fe]=T($.image[Fe],!1,!0,d):Re[Fe]=K0?$.image[Fe].image:$.image[Fe],Re[Fe]=ct($,Re[Fe]);const L0=Re[0],u0=A(L0)||l,D0=i.convert($.format,$.encoding),b0=i.convert($.type),et=C($.internalFormat,D0,b0,$.encoding),Et=l&&$.isVideoTexture!==!0,xx=s0.__currentVersion===void 0||Ge===!0;let ye=k($,L0,u0);we(34067,$,u0);let k0;if(p0){Et&&xx&&n.texStorage2D(34067,ye,et,L0.width,L0.height);for(let Fe=0;Fe<6;Fe++){k0=Re[Fe].mipmaps;for(let h0=0;h0<k0.length;h0++){const f0=k0[h0];$.format!==Q2?D0!==null?Et?n.compressedTexSubImage2D(34069+Fe,h0,0,0,f0.width,f0.height,D0,f0.data):n.compressedTexImage2D(34069+Fe,h0,et,f0.width,f0.height,0,f0.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Et?n.texSubImage2D(34069+Fe,h0,0,0,f0.width,f0.height,D0,b0,f0.data):n.texImage2D(34069+Fe,h0,et,f0.width,f0.height,0,D0,b0,f0.data)}}}else{k0=$.mipmaps,Et&&xx&&(k0.length>0&&ye++,n.texStorage2D(34067,ye,et,Re[0].width,Re[0].height));for(let Fe=0;Fe<6;Fe++)if(K0){Et?n.texSubImage2D(34069+Fe,0,0,0,Re[Fe].width,Re[Fe].height,D0,b0,Re[Fe].data):n.texImage2D(34069+Fe,0,et,Re[Fe].width,Re[Fe].height,0,D0,b0,Re[Fe].data);for(let h0=0;h0<k0.length;h0++){const Y0=k0[h0].image[Fe].image;Et?n.texSubImage2D(34069+Fe,h0+1,0,0,Y0.width,Y0.height,D0,b0,Y0.data):n.texImage2D(34069+Fe,h0+1,et,Y0.width,Y0.height,0,D0,b0,Y0.data)}}else{Et?n.texSubImage2D(34069+Fe,0,0,0,D0,b0,Re[Fe]):n.texImage2D(34069+Fe,0,et,D0,b0,Re[Fe]);for(let h0=0;h0<k0.length;h0++){const f0=k0[h0];Et?n.texSubImage2D(34069+Fe,h0+1,0,0,D0,b0,f0.image[Fe]):n.texImage2D(34069+Fe,h0+1,et,D0,b0,f0.image[Fe])}}}M($,u0)&&I(34067),s0.__currentVersion=s0.version,$.onUpdate&&$.onUpdate($)}ie.__version=$.version}function We(ie,$,ke,Ge,s0){const p0=i.convert(ke.format,ke.encoding),K0=i.convert(ke.type),Re=C(ke.internalFormat,p0,K0,ke.encoding);r.get($).__hasExternalTextures||(s0===32879||s0===35866?n.texImage3D(s0,0,Re,$.width,$.height,$.depth,0,p0,K0,null):n.texImage2D(s0,0,Re,$.width,$.height,0,p0,K0,null)),n.bindFramebuffer(36160,ie),d0($)?m.framebufferTexture2DMultisampleEXT(36160,Ge,s0,r.get(ke).__webglTexture,0,m0($)):s.framebufferTexture2D(36160,Ge,s0,r.get(ke).__webglTexture,0),n.bindFramebuffer(36160,null)}function v0(ie,$,ke){if(s.bindRenderbuffer(36161,ie),$.depthBuffer&&!$.stencilBuffer){let Ge=33189;if(ke||d0($)){const s0=$.depthTexture;s0&&s0.isDepthTexture&&(s0.type===J2?Ge=36012:s0.type===Ma&&(Ge=33190));const p0=m0($);d0($)?m.renderbufferStorageMultisampleEXT(36161,p0,Ge,$.width,$.height):s.renderbufferStorageMultisample(36161,p0,Ge,$.width,$.height)}else s.renderbufferStorage(36161,Ge,$.width,$.height);s.framebufferRenderbuffer(36160,36096,36161,ie)}else if($.depthBuffer&&$.stencilBuffer){const Ge=m0($);ke&&d0($)===!1?s.renderbufferStorageMultisample(36161,Ge,35056,$.width,$.height):d0($)?m.renderbufferStorageMultisampleEXT(36161,Ge,35056,$.width,$.height):s.renderbufferStorage(36161,34041,$.width,$.height),s.framebufferRenderbuffer(36160,33306,36161,ie)}else{const Ge=$.isWebGLMultipleRenderTargets===!0?$.texture:[$.texture];for(let s0=0;s0<Ge.length;s0++){const p0=Ge[s0],K0=i.convert(p0.format,p0.encoding),Re=i.convert(p0.type),L0=C(p0.internalFormat,K0,Re,p0.encoding),u0=m0($);ke&&d0($)===!1?s.renderbufferStorageMultisample(36161,u0,L0,$.width,$.height):d0($)?m.renderbufferStorageMultisampleEXT(36161,u0,L0,$.width,$.height):s.renderbufferStorage(36161,L0,$.width,$.height)}}s.bindRenderbuffer(36161,null)}function Te(ie,$){if($&&$.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,ie),!($.depthTexture&&$.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get($.depthTexture).__webglTexture||$.depthTexture.image.width!==$.width||$.depthTexture.image.height!==$.height)&&($.depthTexture.image.width=$.width,$.depthTexture.image.height=$.height,$.depthTexture.needsUpdate=!0),le($.depthTexture,0);const Ge=r.get($.depthTexture).__webglTexture,s0=m0($);if($.depthTexture.format===Ia)d0($)?m.framebufferTexture2DMultisampleEXT(36160,36096,3553,Ge,0,s0):s.framebufferTexture2D(36160,36096,3553,Ge,0);else if($.depthTexture.format===Gi)d0($)?m.framebufferTexture2DMultisampleEXT(36160,33306,3553,Ge,0,s0):s.framebufferTexture2D(36160,33306,3553,Ge,0);else throw new Error("Unknown depthTexture format")}function Ie(ie){const $=r.get(ie),ke=ie.isWebGLCubeRenderTarget===!0;if(ie.depthTexture&&!$.__autoAllocateDepthBuffer){if(ke)throw new Error("target.depthTexture not supported in Cube render targets");Te($.__webglFramebuffer,ie)}else if(ke){$.__webglDepthbuffer=[];for(let Ge=0;Ge<6;Ge++)n.bindFramebuffer(36160,$.__webglFramebuffer[Ge]),$.__webglDepthbuffer[Ge]=s.createRenderbuffer(),v0($.__webglDepthbuffer[Ge],ie,!1)}else n.bindFramebuffer(36160,$.__webglFramebuffer),$.__webglDepthbuffer=s.createRenderbuffer(),v0($.__webglDepthbuffer,ie,!1);n.bindFramebuffer(36160,null)}function Xe(ie,$,ke){const Ge=r.get(ie);$!==void 0&&We(Ge.__webglFramebuffer,ie,ie.texture,36064,3553),ke!==void 0&&Ie(ie)}function c0(ie){const $=ie.texture,ke=r.get(ie),Ge=r.get($);ie.addEventListener("dispose",ee),ie.isWebGLMultipleRenderTargets!==!0&&(Ge.__webglTexture===void 0&&(Ge.__webglTexture=s.createTexture()),Ge.__version=$.version,o.memory.textures++);const s0=ie.isWebGLCubeRenderTarget===!0,p0=ie.isWebGLMultipleRenderTargets===!0,K0=A(ie)||l;if(s0){ke.__webglFramebuffer=[];for(let Re=0;Re<6;Re++)ke.__webglFramebuffer[Re]=s.createFramebuffer()}else{if(ke.__webglFramebuffer=s.createFramebuffer(),p0)if(a.drawBuffers){const Re=ie.texture;for(let L0=0,u0=Re.length;L0<u0;L0++){const D0=r.get(Re[L0]);D0.__webglTexture===void 0&&(D0.__webglTexture=s.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(l&&ie.samples>0&&d0(ie)===!1){const Re=p0?$:[$];ke.__webglMultisampledFramebuffer=s.createFramebuffer(),ke.__webglColorRenderbuffer=[],n.bindFramebuffer(36160,ke.__webglMultisampledFramebuffer);for(let L0=0;L0<Re.length;L0++){const u0=Re[L0];ke.__webglColorRenderbuffer[L0]=s.createRenderbuffer(),s.bindRenderbuffer(36161,ke.__webglColorRenderbuffer[L0]);const D0=i.convert(u0.format,u0.encoding),b0=i.convert(u0.type),et=C(u0.internalFormat,D0,b0,u0.encoding),Et=m0(ie);s.renderbufferStorageMultisample(36161,Et,et,ie.width,ie.height),s.framebufferRenderbuffer(36160,36064+L0,36161,ke.__webglColorRenderbuffer[L0])}s.bindRenderbuffer(36161,null),ie.depthBuffer&&(ke.__webglDepthRenderbuffer=s.createRenderbuffer(),v0(ke.__webglDepthRenderbuffer,ie,!0)),n.bindFramebuffer(36160,null)}}if(s0){n.bindTexture(34067,Ge.__webglTexture),we(34067,$,K0);for(let Re=0;Re<6;Re++)We(ke.__webglFramebuffer[Re],ie,$,36064,34069+Re);M($,K0)&&I(34067),n.unbindTexture()}else if(p0){const Re=ie.texture;for(let L0=0,u0=Re.length;L0<u0;L0++){const D0=Re[L0],b0=r.get(D0);n.bindTexture(3553,b0.__webglTexture),we(3553,D0,K0),We(ke.__webglFramebuffer,ie,D0,36064+L0,3553),M(D0,K0)&&I(3553)}n.unbindTexture()}else{let Re=3553;(ie.isWebGL3DRenderTarget||ie.isWebGLArrayRenderTarget)&&(l?Re=ie.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(Re,Ge.__webglTexture),we(Re,$,K0),We(ke.__webglFramebuffer,ie,$,36064,Re),M($,K0)&&I(Re),n.unbindTexture()}ie.depthBuffer&&Ie(ie)}function Ye(ie){const $=A(ie)||l,ke=ie.isWebGLMultipleRenderTargets===!0?ie.texture:[ie.texture];for(let Ge=0,s0=ke.length;Ge<s0;Ge++){const p0=ke[Ge];if(M(p0,$)){const K0=ie.isWebGLCubeRenderTarget?34067:3553,Re=r.get(p0).__webglTexture;n.bindTexture(K0,Re),I(K0),n.unbindTexture()}}}function I0(ie){if(l&&ie.samples>0&&d0(ie)===!1){const $=ie.isWebGLMultipleRenderTargets?ie.texture:[ie.texture],ke=ie.width,Ge=ie.height;let s0=16384;const p0=[],K0=ie.stencilBuffer?33306:36096,Re=r.get(ie),L0=ie.isWebGLMultipleRenderTargets===!0;if(L0)for(let u0=0;u0<$.length;u0++)n.bindFramebuffer(36160,Re.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+u0,36161,null),n.bindFramebuffer(36160,Re.__webglFramebuffer),s.framebufferTexture2D(36009,36064+u0,3553,null,0);n.bindFramebuffer(36008,Re.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,Re.__webglFramebuffer);for(let u0=0;u0<$.length;u0++){p0.push(36064+u0),ie.depthBuffer&&p0.push(K0);const D0=Re.__ignoreDepthValues!==void 0?Re.__ignoreDepthValues:!1;if(D0===!1&&(ie.depthBuffer&&(s0|=256),ie.stencilBuffer&&(s0|=1024)),L0&&s.framebufferRenderbuffer(36008,36064,36161,Re.__webglColorRenderbuffer[u0]),D0===!0&&(s.invalidateFramebuffer(36008,[K0]),s.invalidateFramebuffer(36009,[K0])),L0){const b0=r.get($[u0]).__webglTexture;s.framebufferTexture2D(36009,36064,3553,b0,0)}s.blitFramebuffer(0,0,ke,Ge,0,0,ke,Ge,s0,9728),g&&s.invalidateFramebuffer(36008,p0)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),L0)for(let u0=0;u0<$.length;u0++){n.bindFramebuffer(36160,Re.__webglMultisampledFramebuffer),s.framebufferRenderbuffer(36160,36064+u0,36161,Re.__webglColorRenderbuffer[u0]);const D0=r.get($[u0]).__webglTexture;n.bindFramebuffer(36160,Re.__webglFramebuffer),s.framebufferTexture2D(36009,36064+u0,3553,D0,0)}n.bindFramebuffer(36009,Re.__webglMultisampledFramebuffer)}}function m0(ie){return Math.min(p,ie.samples)}function d0(ie){const $=r.get(ie);return l&&ie.samples>0&&x.has("WEBGL_multisampled_render_to_texture")===!0&&$.__useRenderToTexture!==!1}function rt(ie){const $=o.render.frame;y.get(ie)!==$&&(y.set(ie,$),ie.update())}function ct(ie,$){const ke=ie.encoding,Ge=ie.format,s0=ie.type;return ie.isCompressedTexture===!0||ie.isVideoTexture===!0||ie.format===o1||ke!==Ss&&(ke===rx?l===!1?x.has("EXT_sRGB")===!0&&Ge===Q2?(ie.format=o1,ie.minFilter=Sx,ie.generateMipmaps=!1):$=vA.sRGBToLinear($):(Ge!==Q2||s0!==Ca)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",ke)),$}this.allocateTextureUnit=xe,this.resetTextureUnits=se,this.setTexture2D=le,this.setTexture2DArray=de,this.setTexture3D=ue,this.setTextureCube=ge,this.rebindTextures=Xe,this.setupRenderTarget=c0,this.updateRenderTargetMipmap=Ye,this.updateMultisampleRenderTarget=I0,this.setupDepthRenderbuffer=Ie,this.setupFrameBufferTexture=We,this.useMultisampledRTT=d0}function z0e(s,x,n){const r=n.isWebGL2;function a(i,o=null){let l;if(i===Ca)return 5121;if(i===ZZ)return 32819;if(i===JZ)return 32820;if(i===XZ)return 5120;if(i===KZ)return 5122;if(i===YT)return 5123;if(i===$Z)return 5124;if(i===Ma)return 5125;if(i===J2)return 5126;if(i===Gr)return r?5131:(l=x.get("OES_texture_half_float"),l!==null?l.HALF_FLOAT_OES:null);if(i===QZ)return 6406;if(i===Q2)return 6408;if(i===eJ)return 6409;if(i===tJ)return 6410;if(i===Ia)return 6402;if(i===Gi)return 34041;if(i===xJ)return 6403;if(i===jZ)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(i===o1)return l=x.get("EXT_sRGB"),l!==null?l.SRGB_ALPHA_EXT:null;if(i===nJ)return 36244;if(i===rJ)return 33319;if(i===sJ)return 33320;if(i===aJ)return 36249;if(i===t1||i===x1||i===n1||i===r1)if(o===rx)if(l=x.get("WEBGL_compressed_texture_s3tc_srgb"),l!==null){if(i===t1)return l.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===x1)return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===n1)return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===r1)return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(l=x.get("WEBGL_compressed_texture_s3tc"),l!==null){if(i===t1)return l.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===x1)return l.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===n1)return l.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===r1)return l.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===qT||i===XT||i===KT||i===$T)if(l=x.get("WEBGL_compressed_texture_pvrtc"),l!==null){if(i===qT)return l.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===XT)return l.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===KT)return l.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===$T)return l.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===iJ)return l=x.get("WEBGL_compressed_texture_etc1"),l!==null?l.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===ZT||i===JT)if(l=x.get("WEBGL_compressed_texture_etc"),l!==null){if(i===ZT)return o===rx?l.COMPRESSED_SRGB8_ETC2:l.COMPRESSED_RGB8_ETC2;if(i===JT)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:l.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===QT||i===jT||i===eA||i===tA||i===xA||i===nA||i===rA||i===sA||i===aA||i===iA||i===oA||i===lA||i===cA||i===uA)if(l=x.get("WEBGL_compressed_texture_astc"),l!==null){if(i===QT)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:l.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===jT)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:l.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===eA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:l.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===tA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:l.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===xA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:l.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===nA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:l.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===rA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:l.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===sA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:l.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===aA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:l.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===iA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:l.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===oA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:l.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===lA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:l.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===cA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:l.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===uA)return o===rx?l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:l.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===dA)if(l=x.get("EXT_texture_compression_bptc"),l!==null){if(i===dA)return o===rx?l.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:l.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return i===Wi?r?34042:(l=x.get("WEBGL_depth_texture"),l!==null?l.UNSIGNED_INT_24_8_WEBGL:null):s[i]!==void 0?s[i]:null}return{convert:a}}class W0e extends ln{constructor(x=[]){super(),this.isArrayCamera=!0,this.cameras=x}}class $r extends Px{constructor(){super(),this.isGroup=!0,this.type="Group"}}const G0e={type:"move"};class G1{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new $r,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new $r,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new K,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new K),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new $r,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new K,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new K),this._grip}dispatchEvent(x){return this._targetRay!==null&&this._targetRay.dispatchEvent(x),this._grip!==null&&this._grip.dispatchEvent(x),this._hand!==null&&this._hand.dispatchEvent(x),this}disconnect(x){return this.dispatchEvent({type:"disconnected",data:x}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(x,n,r){let a=null,i=null,o=null;const l=this._targetRay,c=this._grip,d=this._hand;if(x&&n.session.visibilityState!=="visible-blurred"){if(d&&x.hand){o=!0;for(const b of x.hand.values()){const v=n.getJointPose(b,r);if(d.joints[b.jointName]===void 0){const _=new $r;_.matrixAutoUpdate=!1,_.visible=!1,d.joints[b.jointName]=_,d.add(_)}const w=d.joints[b.jointName];v!==null&&(w.matrix.fromArray(v.transform.matrix),w.matrix.decompose(w.position,w.rotation,w.scale),w.jointRadius=v.radius),w.visible=v!==null}const h=d.joints["index-finger-tip"],p=d.joints["thumb-tip"],m=h.position.distanceTo(p.position),g=.02,y=.005;d.inputState.pinching&&m>g+y?(d.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:x.handedness,target:this})):!d.inputState.pinching&&m<=g-y&&(d.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:x.handedness,target:this}))}else c!==null&&x.gripSpace&&(i=n.getPose(x.gripSpace,r),i!==null&&(c.matrix.fromArray(i.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),i.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(i.linearVelocity)):c.hasLinearVelocity=!1,i.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(i.angularVelocity)):c.hasAngularVelocity=!1));l!==null&&(a=n.getPose(x.targetRaySpace,r),a===null&&i!==null&&(a=i),a!==null&&(l.matrix.fromArray(a.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),a.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(a.linearVelocity)):l.hasLinearVelocity=!1,a.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(a.angularVelocity)):l.hasAngularVelocity=!1,this.dispatchEvent(G0e)))}return l!==null&&(l.visible=a!==null),c!==null&&(c.visible=i!==null),d!==null&&(d.visible=o!==null),this}}class V0e extends Tn{constructor(x,n,r,a,i,o,l,c,d,h){if(h=h!==void 0?h:Ia,h!==Ia&&h!==Gi)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&h===Ia&&(r=Ma),r===void 0&&h===Gi&&(r=Wi),super(null,a,i,o,l,c,h,r,d),this.isDepthTexture=!0,this.image={width:x,height:n},this.magFilter=l!==void 0?l:Zx,this.minFilter=c!==void 0?c:Zx,this.flipY=!1,this.generateMipmaps=!1}}class H0e extends qi{constructor(x,n){super();const r=this;let a=null,i=1,o=null,l="local-floor",c=null,d=null,h=null,p=null,m=null,g=null;const y=n.getContextAttributes();let b=null,v=null;const w=[],_=[],T=new ln;T.layers.enable(1),T.viewport=new ix;const A=new ln;A.layers.enable(2),A.viewport=new ix;const E=[T,A],M=new W0e;M.layers.enable(1),M.layers.enable(2);let I=null,C=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ae){let le=w[ae];return le===void 0&&(le=new G1,w[ae]=le),le.getTargetRaySpace()},this.getControllerGrip=function(ae){let le=w[ae];return le===void 0&&(le=new G1,w[ae]=le),le.getGripSpace()},this.getHand=function(ae){let le=w[ae];return le===void 0&&(le=new G1,w[ae]=le),le.getHandSpace()};function k(ae){const le=_.indexOf(ae.inputSource);if(le===-1)return;const de=w[le];de!==void 0&&de.dispatchEvent({type:ae.type,data:ae.inputSource})}function O(){a.removeEventListener("select",k),a.removeEventListener("selectstart",k),a.removeEventListener("selectend",k),a.removeEventListener("squeeze",k),a.removeEventListener("squeezestart",k),a.removeEventListener("squeezeend",k),a.removeEventListener("end",O),a.removeEventListener("inputsourceschange",z);for(let ae=0;ae<w.length;ae++){const le=_[ae];le!==null&&(_[ae]=null,w[ae].disconnect(le))}I=null,C=null,x.setRenderTarget(b),m=null,p=null,h=null,a=null,v=null,xe.stop(),r.isPresenting=!1,r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ae){i=ae,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ae){l=ae,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(ae){c=ae},this.getBaseLayer=function(){return p!==null?p:m},this.getBinding=function(){return h},this.getFrame=function(){return g},this.getSession=function(){return a},this.setSession=async function(ae){if(a=ae,a!==null){if(b=x.getRenderTarget(),a.addEventListener("select",k),a.addEventListener("selectstart",k),a.addEventListener("selectend",k),a.addEventListener("squeeze",k),a.addEventListener("squeezestart",k),a.addEventListener("squeezeend",k),a.addEventListener("end",O),a.addEventListener("inputsourceschange",z),y.xrCompatible!==!0&&await n.makeXRCompatible(),a.renderState.layers===void 0||x.capabilities.isWebGL2===!1){const le={antialias:a.renderState.layers===void 0?y.antialias:!0,alpha:y.alpha,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:i};m=new XRWebGLLayer(a,n,le),a.updateRenderState({baseLayer:m}),v=new La(m.framebufferWidth,m.framebufferHeight,{format:Q2,type:Ca,encoding:x.outputEncoding})}else{let le=null,de=null,ue=null;y.depth&&(ue=y.stencil?35056:33190,le=y.stencil?Gi:Ia,de=y.stencil?Wi:Ma);const ge={colorFormat:32856,depthFormat:ue,scaleFactor:i};h=new XRWebGLBinding(a,n),p=h.createProjectionLayer(ge),a.updateRenderState({layers:[p]}),v=new La(p.textureWidth,p.textureHeight,{format:Q2,type:Ca,depthTexture:new V0e(p.textureWidth,p.textureHeight,de,void 0,void 0,void 0,void 0,void 0,void 0,le),stencilBuffer:y.stencil,encoding:x.outputEncoding,samples:y.antialias?4:0});const pe=x.properties.get(v);pe.__ignoreDepthValues=p.ignoreDepthValues}v.isXRRenderTarget=!0,this.setFoveation(1),c=null,o=await a.requestReferenceSpace(l),xe.setContext(a),xe.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}};function z(ae){for(let le=0;le<ae.removed.length;le++){const de=ae.removed[le],ue=_.indexOf(de);ue>=0&&(_[ue]=null,w[ue].dispatchEvent({type:"disconnected",data:de}))}for(let le=0;le<ae.added.length;le++){const de=ae.added[le];let ue=_.indexOf(de);if(ue===-1){for(let pe=0;pe<w.length;pe++)if(pe>=_.length){_.push(de),ue=pe;break}else if(_[pe]===null){_[pe]=de,ue=pe;break}if(ue===-1)break}const ge=w[ue];ge&&ge.dispatchEvent({type:"connected",data:de})}}const ee=new K,re=new K;function Y(ae,le,de){ee.setFromMatrixPosition(le.matrixWorld),re.setFromMatrixPosition(de.matrixWorld);const ue=ee.distanceTo(re),ge=le.projectionMatrix.elements,pe=de.projectionMatrix.elements,Le=ge[14]/(ge[10]-1),we=ge[14]/(ge[10]+1),e0=(ge[9]+1)/ge[5],Ze=(ge[9]-1)/ge[5],i0=(ge[8]-1)/ge[0],We=(pe[8]+1)/pe[0],v0=Le*i0,Te=Le*We,Ie=ue/(-i0+We),Xe=Ie*-i0;le.matrixWorld.decompose(ae.position,ae.quaternion,ae.scale),ae.translateX(Xe),ae.translateZ(Ie),ae.matrixWorld.compose(ae.position,ae.quaternion,ae.scale),ae.matrixWorldInverse.copy(ae.matrixWorld).invert();const c0=Le+Ie,Ye=we+Ie,I0=v0-Xe,m0=Te+(ue-Xe),d0=e0*we/Ye*c0,rt=Ze*we/Ye*c0;ae.projectionMatrix.makePerspective(I0,m0,d0,rt,c0,Ye)}function Q(ae,le){le===null?ae.matrixWorld.copy(ae.matrix):ae.matrixWorld.multiplyMatrices(le.matrixWorld,ae.matrix),ae.matrixWorldInverse.copy(ae.matrixWorld).invert()}this.updateCamera=function(ae){if(a===null)return;M.near=A.near=T.near=ae.near,M.far=A.far=T.far=ae.far,(I!==M.near||C!==M.far)&&(a.updateRenderState({depthNear:M.near,depthFar:M.far}),I=M.near,C=M.far);const le=ae.parent,de=M.cameras;Q(M,le);for(let ge=0;ge<de.length;ge++)Q(de[ge],le);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),ae.position.copy(M.position),ae.quaternion.copy(M.quaternion),ae.scale.copy(M.scale),ae.matrix.copy(M.matrix),ae.matrixWorld.copy(M.matrixWorld);const ue=ae.children;for(let ge=0,pe=ue.length;ge<pe;ge++)ue[ge].updateMatrixWorld(!0);de.length===2?Y(M,T,A):M.projectionMatrix.copy(T.projectionMatrix)},this.getCamera=function(){return M},this.getFoveation=function(){if(p!==null)return p.fixedFoveation;if(m!==null)return m.fixedFoveation},this.setFoveation=function(ae){p!==null&&(p.fixedFoveation=ae),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=ae)};let te=null;function se(ae,le){if(d=le.getViewerPose(c||o),g=le,d!==null){const de=d.views;m!==null&&(x.setRenderTargetFramebuffer(v,m.framebuffer),x.setRenderTarget(v));let ue=!1;de.length!==M.cameras.length&&(M.cameras.length=0,ue=!0);for(let ge=0;ge<de.length;ge++){const pe=de[ge];let Le=null;if(m!==null)Le=m.getViewport(pe);else{const e0=h.getViewSubImage(p,pe);Le=e0.viewport,ge===0&&(x.setRenderTargetTextures(v,e0.colorTexture,p.ignoreDepthValues?void 0:e0.depthStencilTexture),x.setRenderTarget(v))}let we=E[ge];we===void 0&&(we=new ln,we.layers.enable(ge),we.viewport=new ix,E[ge]=we),we.matrix.fromArray(pe.transform.matrix),we.projectionMatrix.fromArray(pe.projectionMatrix),we.viewport.set(Le.x,Le.y,Le.width,Le.height),ge===0&&M.matrix.copy(we.matrix),ue===!0&&M.cameras.push(we)}}for(let de=0;de<w.length;de++){const ue=_[de],ge=w[de];ue!==null&&ge!==void 0&&ge.update(ue,le,c||o)}te&&te(ae,le),g=null}const xe=new DA;xe.setAnimationLoop(se),this.setAnimationLoop=function(ae){te=ae},this.dispose=function(){}}}function Y0e(s,x){function n(b,v){b.fogColor.value.copy(v.color),v.isFog?(b.fogNear.value=v.near,b.fogFar.value=v.far):v.isFogExp2&&(b.fogDensity.value=v.density)}function r(b,v,w,_,T){v.isMeshBasicMaterial||v.isMeshLambertMaterial?a(b,v):v.isMeshToonMaterial?(a(b,v),h(b,v)):v.isMeshPhongMaterial?(a(b,v),d(b,v)):v.isMeshStandardMaterial?(a(b,v),p(b,v),v.isMeshPhysicalMaterial&&m(b,v,T)):v.isMeshMatcapMaterial?(a(b,v),g(b,v)):v.isMeshDepthMaterial?a(b,v):v.isMeshDistanceMaterial?(a(b,v),y(b,v)):v.isMeshNormalMaterial?a(b,v):v.isLineBasicMaterial?(i(b,v),v.isLineDashedMaterial&&o(b,v)):v.isPointsMaterial?l(b,v,w,_):v.isSpriteMaterial?c(b,v):v.isShadowMaterial?(b.color.value.copy(v.color),b.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function a(b,v){b.opacity.value=v.opacity,v.color&&b.diffuse.value.copy(v.color),v.emissive&&b.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(b.map.value=v.map),v.alphaMap&&(b.alphaMap.value=v.alphaMap),v.bumpMap&&(b.bumpMap.value=v.bumpMap,b.bumpScale.value=v.bumpScale,v.side===Z2&&(b.bumpScale.value*=-1)),v.displacementMap&&(b.displacementMap.value=v.displacementMap,b.displacementScale.value=v.displacementScale,b.displacementBias.value=v.displacementBias),v.emissiveMap&&(b.emissiveMap.value=v.emissiveMap),v.normalMap&&(b.normalMap.value=v.normalMap,b.normalScale.value.copy(v.normalScale),v.side===Z2&&b.normalScale.value.negate()),v.specularMap&&(b.specularMap.value=v.specularMap),v.alphaTest>0&&(b.alphaTest.value=v.alphaTest);const w=x.get(v).envMap;if(w&&(b.envMap.value=w,b.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,b.reflectivity.value=v.reflectivity,b.ior.value=v.ior,b.refractionRatio.value=v.refractionRatio),v.lightMap){b.lightMap.value=v.lightMap;const A=s.physicallyCorrectLights!==!0?Math.PI:1;b.lightMapIntensity.value=v.lightMapIntensity*A}v.aoMap&&(b.aoMap.value=v.aoMap,b.aoMapIntensity.value=v.aoMapIntensity);let _;v.map?_=v.map:v.specularMap?_=v.specularMap:v.displacementMap?_=v.displacementMap:v.normalMap?_=v.normalMap:v.bumpMap?_=v.bumpMap:v.roughnessMap?_=v.roughnessMap:v.metalnessMap?_=v.metalnessMap:v.alphaMap?_=v.alphaMap:v.emissiveMap?_=v.emissiveMap:v.clearcoatMap?_=v.clearcoatMap:v.clearcoatNormalMap?_=v.clearcoatNormalMap:v.clearcoatRoughnessMap?_=v.clearcoatRoughnessMap:v.iridescenceMap?_=v.iridescenceMap:v.iridescenceThicknessMap?_=v.iridescenceThicknessMap:v.specularIntensityMap?_=v.specularIntensityMap:v.specularColorMap?_=v.specularColorMap:v.transmissionMap?_=v.transmissionMap:v.thicknessMap?_=v.thicknessMap:v.sheenColorMap?_=v.sheenColorMap:v.sheenRoughnessMap&&(_=v.sheenRoughnessMap),_!==void 0&&(_.isWebGLRenderTarget&&(_=_.texture),_.matrixAutoUpdate===!0&&_.updateMatrix(),b.uvTransform.value.copy(_.matrix));let T;v.aoMap?T=v.aoMap:v.lightMap&&(T=v.lightMap),T!==void 0&&(T.isWebGLRenderTarget&&(T=T.texture),T.matrixAutoUpdate===!0&&T.updateMatrix(),b.uv2Transform.value.copy(T.matrix))}function i(b,v){b.diffuse.value.copy(v.color),b.opacity.value=v.opacity}function o(b,v){b.dashSize.value=v.dashSize,b.totalSize.value=v.dashSize+v.gapSize,b.scale.value=v.scale}function l(b,v,w,_){b.diffuse.value.copy(v.color),b.opacity.value=v.opacity,b.size.value=v.size*w,b.scale.value=_*.5,v.map&&(b.map.value=v.map),v.alphaMap&&(b.alphaMap.value=v.alphaMap),v.alphaTest>0&&(b.alphaTest.value=v.alphaTest);let T;v.map?T=v.map:v.alphaMap&&(T=v.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),b.uvTransform.value.copy(T.matrix))}function c(b,v){b.diffuse.value.copy(v.color),b.opacity.value=v.opacity,b.rotation.value=v.rotation,v.map&&(b.map.value=v.map),v.alphaMap&&(b.alphaMap.value=v.alphaMap),v.alphaTest>0&&(b.alphaTest.value=v.alphaTest);let w;v.map?w=v.map:v.alphaMap&&(w=v.alphaMap),w!==void 0&&(w.matrixAutoUpdate===!0&&w.updateMatrix(),b.uvTransform.value.copy(w.matrix))}function d(b,v){b.specular.value.copy(v.specular),b.shininess.value=Math.max(v.shininess,1e-4)}function h(b,v){v.gradientMap&&(b.gradientMap.value=v.gradientMap)}function p(b,v){b.roughness.value=v.roughness,b.metalness.value=v.metalness,v.roughnessMap&&(b.roughnessMap.value=v.roughnessMap),v.metalnessMap&&(b.metalnessMap.value=v.metalnessMap),x.get(v).envMap&&(b.envMapIntensity.value=v.envMapIntensity)}function m(b,v,w){b.ior.value=v.ior,v.sheen>0&&(b.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),b.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(b.sheenColorMap.value=v.sheenColorMap),v.sheenRoughnessMap&&(b.sheenRoughnessMap.value=v.sheenRoughnessMap)),v.clearcoat>0&&(b.clearcoat.value=v.clearcoat,b.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(b.clearcoatMap.value=v.clearcoatMap),v.clearcoatRoughnessMap&&(b.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap),v.clearcoatNormalMap&&(b.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),b.clearcoatNormalMap.value=v.clearcoatNormalMap,v.side===Z2&&b.clearcoatNormalScale.value.negate())),v.iridescence>0&&(b.iridescence.value=v.iridescence,b.iridescenceIOR.value=v.iridescenceIOR,b.iridescenceThicknessMinimum.value=v.iridescenceThicknessRange[0],b.iridescenceThicknessMaximum.value=v.iridescenceThicknessRange[1],v.iridescenceMap&&(b.iridescenceMap.value=v.iridescenceMap),v.iridescenceThicknessMap&&(b.iridescenceThicknessMap.value=v.iridescenceThicknessMap)),v.transmission>0&&(b.transmission.value=v.transmission,b.transmissionSamplerMap.value=w.texture,b.transmissionSamplerSize.value.set(w.width,w.height),v.transmissionMap&&(b.transmissionMap.value=v.transmissionMap),b.thickness.value=v.thickness,v.thicknessMap&&(b.thicknessMap.value=v.thicknessMap),b.attenuationDistance.value=v.attenuationDistance,b.attenuationColor.value.copy(v.attenuationColor)),b.specularIntensity.value=v.specularIntensity,b.specularColor.value.copy(v.specularColor),v.specularIntensityMap&&(b.specularIntensityMap.value=v.specularIntensityMap),v.specularColorMap&&(b.specularColorMap.value=v.specularColorMap)}function g(b,v){v.matcap&&(b.matcap.value=v.matcap)}function y(b,v){b.referencePosition.value.copy(v.referencePosition),b.nearDistance.value=v.nearDistance,b.farDistance.value=v.farDistance}return{refreshFogUniforms:n,refreshMaterialUniforms:r}}function q0e(s,x,n,r){let a={},i={},o=[];const l=n.isWebGL2?s.getParameter(35375):0;function c(_,T){const A=T.program;r.uniformBlockBinding(_,A)}function d(_,T){let A=a[_.id];A===void 0&&(y(_),A=h(_),a[_.id]=A,_.addEventListener("dispose",v));const E=T.program;r.updateUBOMapping(_,E);const M=x.render.frame;i[_.id]!==M&&(m(_),i[_.id]=M)}function h(_){const T=p();_.__bindingPointIndex=T;const A=s.createBuffer(),E=_.__size,M=_.usage;return s.bindBuffer(35345,A),s.bufferData(35345,E,M),s.bindBuffer(35345,null),s.bindBufferBase(35345,T,A),A}function p(){for(let _=0;_<l;_++)if(o.indexOf(_)===-1)return o.push(_),_;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function m(_){const T=a[_.id],A=_.uniforms,E=_.__cache;s.bindBuffer(35345,T);for(let M=0,I=A.length;M<I;M++){const C=A[M];if(g(C,M,E)===!0){const k=C.value,O=C.__offset;typeof k=="number"?(C.__data[0]=k,s.bufferSubData(35345,O,C.__data)):(C.value.isMatrix3?(C.__data[0]=C.value.elements[0],C.__data[1]=C.value.elements[1],C.__data[2]=C.value.elements[2],C.__data[3]=C.value.elements[0],C.__data[4]=C.value.elements[3],C.__data[5]=C.value.elements[4],C.__data[6]=C.value.elements[5],C.__data[7]=C.value.elements[0],C.__data[8]=C.value.elements[6],C.__data[9]=C.value.elements[7],C.__data[10]=C.value.elements[8],C.__data[11]=C.value.elements[0]):k.toArray(C.__data),s.bufferSubData(35345,O,C.__data))}}s.bindBuffer(35345,null)}function g(_,T,A){const E=_.value;if(A[T]===void 0)return typeof E=="number"?A[T]=E:A[T]=E.clone(),!0;if(typeof E=="number"){if(A[T]!==E)return A[T]=E,!0}else{const M=A[T];if(M.equals(E)===!1)return M.copy(E),!0}return!1}function y(_){const T=_.uniforms;let A=0;const E=16;let M=0;for(let I=0,C=T.length;I<C;I++){const k=T[I],O=b(k);if(k.__data=new Float32Array(O.storage/Float32Array.BYTES_PER_ELEMENT),k.__offset=A,I>0){M=A%E;const z=E-M;M!==0&&z-O.boundary<0&&(A+=E-M,k.__offset=A)}A+=O.storage}return M=A%E,M>0&&(A+=E-M),_.__size=A,_.__cache={},this}function b(_){const T=_.value,A={boundary:0,storage:0};return typeof T=="number"?(A.boundary=4,A.storage=4):T.isVector2?(A.boundary=8,A.storage=8):T.isVector3||T.isColor?(A.boundary=16,A.storage=12):T.isVector4?(A.boundary=16,A.storage=16):T.isMatrix3?(A.boundary=48,A.storage=48):T.isMatrix4?(A.boundary=64,A.storage=64):T.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",T),A}function v(_){const T=_.target;T.removeEventListener("dispose",v);const A=o.indexOf(T.__bindingPointIndex);o.splice(A,1),s.deleteBuffer(a[T.id]),delete a[T.id],delete i[T.id]}function w(){for(const _ in a)s.deleteBuffer(a[_]);o=[],a={},i={}}return{bind:c,update:d,dispose:w}}function X0e(){const s=Ml("canvas");return s.style.display="block",s}function uE(s={}){this.isWebGLRenderer=!0;const x=s.canvas!==void 0?s.canvas:X0e(),n=s.context!==void 0?s.context:null,r=s.depth!==void 0?s.depth:!0,a=s.stencil!==void 0?s.stencil:!0,i=s.antialias!==void 0?s.antialias:!1,o=s.premultipliedAlpha!==void 0?s.premultipliedAlpha:!0,l=s.preserveDrawingBuffer!==void 0?s.preserveDrawingBuffer:!1,c=s.powerPreference!==void 0?s.powerPreference:"default",d=s.failIfMajorPerformanceCaveat!==void 0?s.failIfMajorPerformanceCaveat:!1;let h;n!==null?h=n.getContextAttributes().alpha:h=s.alpha!==void 0?s.alpha:!1;let p=null,m=null;const g=[],y=[];this.domElement=x,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Ss,this.physicallyCorrectLights=!1,this.toneMapping=Wr,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const b=this;let v=!1,w=0,_=0,T=null,A=-1,E=null;const M=new ix,I=new ix;let C=null,k=x.width,O=x.height,z=1,ee=null,re=null;const Y=new ix(0,0,k,O),Q=new ix(0,0,k,O);let te=!1;const se=new D1;let xe=!1,ae=!1,le=null;const de=new wt,ue=new n0,ge=new K,pe={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Le(){return T===null?z:1}let we=n;function e0(ne,Ee){for(let De=0;De<ne.length;De++){const Ne=ne[De],qe=x.getContext(Ne,Ee);if(qe!==null)return qe}return null}try{const ne={alpha:!0,depth:r,stencil:a,antialias:i,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:d};if("setAttribute"in x&&x.setAttribute("data-engine",`three.js r${Jg}`),x.addEventListener("webglcontextlost",et,!1),x.addEventListener("webglcontextrestored",Et,!1),x.addEventListener("webglcontextcreationerror",xx,!1),we===null){const Ee=["webgl2","webgl","experimental-webgl"];if(b.isWebGL1Renderer===!0&&Ee.shift(),we=e0(Ee,ne),we===null)throw e0(Ee)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}we.getShaderPrecisionFormat===void 0&&(we.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(ne){throw console.error("THREE.WebGLRenderer: "+ne.message),ne}let Ze,i0,We,v0,Te,Ie,Xe,c0,Ye,I0,m0,d0,rt,ct,ie,$,ke,Ge,s0,p0,K0,Re,L0,u0;function D0(){Ze=new see(we),i0=new jj(we,Ze,s),Ze.init(i0),Re=new z0e(we,Ze,i0),We=new U0e(we,Ze,i0),v0=new oee,Te=new E0e,Ie=new B0e(we,Ze,We,Te,i0,Re,v0),Xe=new tee(b),c0=new ree(b),Ye=new QJ(we,i0),L0=new Jj(we,Ze,Ye,i0),I0=new aee(we,Ye,v0,L0),m0=new dee(we,I0,Ye,v0),s0=new uee(we,i0,Ie),$=new eee(Te),d0=new A0e(b,Xe,c0,Ze,i0,L0,$),rt=new Y0e(b,Te),ct=new M0e,ie=new L0e(Ze,i0),Ge=new Zj(b,Xe,We,m0,h,o),ke=new F0e(b,m0,i0),u0=new q0e(we,v0,i0,We),p0=new Qj(we,Ze,v0,i0),K0=new iee(we,Ze,v0,i0),v0.programs=d0.programs,b.capabilities=i0,b.extensions=Ze,b.properties=Te,b.renderLists=ct,b.shadowMap=ke,b.state=We,b.info=v0}D0();const b0=new H0e(b,we);this.xr=b0,this.getContext=function(){return we},this.getContextAttributes=function(){return we.getContextAttributes()},this.forceContextLoss=function(){const ne=Ze.get("WEBGL_lose_context");ne&&ne.loseContext()},this.forceContextRestore=function(){const ne=Ze.get("WEBGL_lose_context");ne&&ne.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(ne){ne!==void 0&&(z=ne,this.setSize(k,O,!1))},this.getSize=function(ne){return ne.set(k,O)},this.setSize=function(ne,Ee,De){if(b0.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}k=ne,O=Ee,x.width=Math.floor(ne*z),x.height=Math.floor(Ee*z),De!==!1&&(x.style.width=ne+"px",x.style.height=Ee+"px"),this.setViewport(0,0,ne,Ee)},this.getDrawingBufferSize=function(ne){return ne.set(k*z,O*z).floor()},this.setDrawingBufferSize=function(ne,Ee,De){k=ne,O=Ee,z=De,x.width=Math.floor(ne*De),x.height=Math.floor(Ee*De),this.setViewport(0,0,ne,Ee)},this.getCurrentViewport=function(ne){return ne.copy(M)},this.getViewport=function(ne){return ne.copy(Y)},this.setViewport=function(ne,Ee,De,Ne){ne.isVector4?Y.set(ne.x,ne.y,ne.z,ne.w):Y.set(ne,Ee,De,Ne),We.viewport(M.copy(Y).multiplyScalar(z).floor())},this.getScissor=function(ne){return ne.copy(Q)},this.setScissor=function(ne,Ee,De,Ne){ne.isVector4?Q.set(ne.x,ne.y,ne.z,ne.w):Q.set(ne,Ee,De,Ne),We.scissor(I.copy(Q).multiplyScalar(z).floor())},this.getScissorTest=function(){return te},this.setScissorTest=function(ne){We.setScissorTest(te=ne)},this.setOpaqueSort=function(ne){ee=ne},this.setTransparentSort=function(ne){re=ne},this.getClearColor=function(ne){return ne.copy(Ge.getClearColor())},this.setClearColor=function(){Ge.setClearColor.apply(Ge,arguments)},this.getClearAlpha=function(){return Ge.getClearAlpha()},this.setClearAlpha=function(){Ge.setClearAlpha.apply(Ge,arguments)},this.clear=function(ne=!0,Ee=!0,De=!0){let Ne=0;ne&&(Ne|=16384),Ee&&(Ne|=256),De&&(Ne|=1024),we.clear(Ne)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){x.removeEventListener("webglcontextlost",et,!1),x.removeEventListener("webglcontextrestored",Et,!1),x.removeEventListener("webglcontextcreationerror",xx,!1),ct.dispose(),ie.dispose(),Te.dispose(),Xe.dispose(),c0.dispose(),m0.dispose(),L0.dispose(),u0.dispose(),d0.dispose(),b0.dispose(),b0.removeEventListener("sessionstart",Y0),b0.removeEventListener("sessionend",ox),le&&(le.dispose(),le=null),qt.stop()};function et(ne){ne.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Et(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const ne=v0.autoReset,Ee=ke.enabled,De=ke.autoUpdate,Ne=ke.needsUpdate,qe=ke.type;D0(),v0.autoReset=ne,ke.enabled=Ee,ke.autoUpdate=De,ke.needsUpdate=Ne,ke.type=qe}function xx(ne){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",ne.statusMessage)}function ye(ne){const Ee=ne.target;Ee.removeEventListener("dispose",ye),k0(Ee)}function k0(ne){Fe(ne),Te.remove(ne)}function Fe(ne){const Ee=Te.get(ne).programs;Ee!==void 0&&(Ee.forEach(function(De){d0.releaseProgram(De)}),ne.isShaderMaterial&&d0.releaseShaderCache(ne))}this.renderBufferDirect=function(ne,Ee,De,Ne,qe,at){Ee===null&&(Ee=pe);const lt=qe.isMesh&&qe.matrixWorld.determinant()<0,ht=ut(ne,Ee,De,Ne,qe);We.setMaterial(Ne,lt);let dt=De.index;const kt=De.attributes.position;if(dt===null){if(kt===void 0||kt.count===0)return}else if(dt.count===0)return;let Mt=1;Ne.wireframe===!0&&(dt=I0.getWireframeAttribute(De),Mt=2),L0.setup(qe,Ne,ht,De,dt);let pt,Xt=p0;dt!==null&&(pt=Ye.get(dt),Xt=K0,Xt.setIndex(pt));const cn=dt!==null?dt.count:kt.count,tn=De.drawRange.start*Mt,z2=De.drawRange.count*Mt,xn=at!==null?at.start*Mt:0,_t=at!==null?at.count*Mt:1/0,W2=Math.max(tn,xn),Qt=Math.min(cn,tn+z2,xn+_t)-1,Hx=Math.max(0,Qt-W2+1);if(Hx!==0){if(qe.isMesh)Ne.wireframe===!0?(We.setLineWidth(Ne.wireframeLinewidth*Le()),Xt.setMode(1)):Xt.setMode(4);else if(qe.isLine){let bn=Ne.linewidth;bn===void 0&&(bn=1),We.setLineWidth(bn*Le()),qe.isLineSegments?Xt.setMode(1):qe.isLineLoop?Xt.setMode(2):Xt.setMode(3)}else qe.isPoints?Xt.setMode(0):qe.isSprite&&Xt.setMode(4);if(qe.isInstancedMesh)Xt.renderInstances(W2,Hx,qe.count);else if(De.isInstancedBufferGeometry){const bn=Math.min(De.instanceCount,De._maxInstanceCount);Xt.renderInstances(W2,Hx,bn)}else Xt.render(W2,Hx)}},this.compile=function(ne,Ee){m=ie.get(ne),m.init(),y.push(m),ne.traverseVisible(function(De){De.isLight&&De.layers.test(Ee.layers)&&(m.pushLight(De),De.castShadow&&m.pushShadow(De))}),m.setupLights(b.physicallyCorrectLights),ne.traverse(function(De){const Ne=De.material;if(Ne)if(Array.isArray(Ne))for(let qe=0;qe<Ne.length;qe++){const at=Ne[qe];o0(at,ne,De)}else o0(Ne,ne,De)}),y.pop(),m=null};let h0=null;function f0(ne){h0&&h0(ne)}function Y0(){qt.stop()}function ox(){qt.start()}const qt=new DA;qt.setAnimationLoop(f0),typeof self<"u"&&qt.setContext(self),this.setAnimationLoop=function(ne){h0=ne,b0.setAnimationLoop(ne),ne===null?qt.stop():qt.start()},b0.addEventListener("sessionstart",Y0),b0.addEventListener("sessionend",ox),this.render=function(ne,Ee){if(Ee!==void 0&&Ee.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(v===!0)return;ne.autoUpdate===!0&&ne.updateMatrixWorld(),Ee.parent===null&&Ee.updateMatrixWorld(),b0.enabled===!0&&b0.isPresenting===!0&&(b0.cameraAutoUpdate===!0&&b0.updateCamera(Ee),Ee=b0.getCamera()),ne.isScene===!0&&ne.onBeforeRender(b,ne,Ee,T),m=ie.get(ne,y.length),m.init(),y.push(m),de.multiplyMatrices(Ee.projectionMatrix,Ee.matrixWorldInverse),se.setFromProjectionMatrix(de),ae=this.localClippingEnabled,xe=$.init(this.clippingPlanes,ae,Ee),p=ct.get(ne,g.length),p.init(),g.push(p),jx(ne,Ee,0,b.sortObjects),p.finish(),b.sortObjects===!0&&p.sort(ee,re),xe===!0&&$.beginShadows();const De=m.state.shadowsArray;if(ke.render(De,ne,Ee),xe===!0&&$.endShadows(),this.info.autoReset===!0&&this.info.reset(),Ge.render(p,ne),m.setupLights(b.physicallyCorrectLights),Ee.isArrayCamera){const Ne=Ee.cameras;for(let qe=0,at=Ne.length;qe<at;qe++){const lt=Ne[qe];Jt(p,ne,lt,lt.viewport)}}else Jt(p,ne,Ee);T!==null&&(Ie.updateMultisampleRenderTarget(T),Ie.updateRenderTargetMipmap(T)),ne.isScene===!0&&ne.onAfterRender(b,ne,Ee),L0.resetDefaultState(),A=-1,E=null,y.pop(),y.length>0?m=y[y.length-1]:m=null,g.pop(),g.length>0?p=g[g.length-1]:p=null};function jx(ne,Ee,De,Ne){if(ne.visible===!1)return;if(ne.layers.test(Ee.layers)){if(ne.isGroup)De=ne.renderOrder;else if(ne.isLOD)ne.autoUpdate===!0&&ne.update(Ee);else if(ne.isLight)m.pushLight(ne),ne.castShadow&&m.pushShadow(ne);else if(ne.isSprite){if(!ne.frustumCulled||se.intersectsSprite(ne)){Ne&&ge.setFromMatrixPosition(ne.matrixWorld).applyMatrix4(de);const lt=m0.update(ne),ht=ne.material;ht.visible&&p.push(ne,lt,ht,De,ge.z,null)}}else if((ne.isMesh||ne.isLine||ne.isPoints)&&(ne.isSkinnedMesh&&ne.skeleton.frame!==v0.render.frame&&(ne.skeleton.update(),ne.skeleton.frame=v0.render.frame),!ne.frustumCulled||se.intersectsObject(ne))){Ne&&ge.setFromMatrixPosition(ne.matrixWorld).applyMatrix4(de);const lt=m0.update(ne),ht=ne.material;if(Array.isArray(ht)){const dt=lt.groups;for(let kt=0,Mt=dt.length;kt<Mt;kt++){const pt=dt[kt],Xt=ht[pt.materialIndex];Xt&&Xt.visible&&p.push(ne,lt,Xt,De,ge.z,pt)}}else ht.visible&&p.push(ne,lt,ht,De,ge.z,null)}}const at=ne.children;for(let lt=0,ht=at.length;lt<ht;lt++)jx(at[lt],Ee,De,Ne)}function Jt(ne,Ee,De,Ne){const qe=ne.opaque,at=ne.transmissive,lt=ne.transparent;m.setupLightsView(De),at.length>0&&Dx(qe,Ee,De),Ne&&We.viewport(M.copy(Ne)),qe.length>0&&zt(qe,Ee,De),at.length>0&&zt(at,Ee,De),lt.length>0&&zt(lt,Ee,De),We.buffers.depth.setTest(!0),We.buffers.depth.setMask(!0),We.buffers.color.setMask(!0),We.setPolygonOffset(!1)}function Dx(ne,Ee,De){const Ne=i0.isWebGL2;le===null&&(le=new La(1,1,{generateMipmaps:!0,type:Ze.has("EXT_color_buffer_half_float")?Gr:Ca,minFilter:_s,samples:Ne&&i===!0?4:0})),b.getDrawingBufferSize(ue),Ne?le.setSize(ue.x,ue.y):le.setSize(Fd(ue.x),Fd(ue.y));const qe=b.getRenderTarget();b.setRenderTarget(le),b.clear();const at=b.toneMapping;b.toneMapping=Wr,zt(ne,Ee,De),b.toneMapping=at,Ie.updateMultisampleRenderTarget(le),Ie.updateRenderTargetMipmap(le),b.setRenderTarget(qe)}function zt(ne,Ee,De){const Ne=Ee.isScene===!0?Ee.overrideMaterial:null;for(let qe=0,at=ne.length;qe<at;qe++){const lt=ne[qe],ht=lt.object,dt=lt.geometry,kt=Ne===null?lt.material:Ne,Mt=lt.group;ht.layers.test(De.layers)&&en(ht,Ee,De,dt,kt,Mt)}}function en(ne,Ee,De,Ne,qe,at){ne.onBeforeRender(b,Ee,De,Ne,qe,at),ne.modelViewMatrix.multiplyMatrices(De.matrixWorldInverse,ne.matrixWorld),ne.normalMatrix.getNormalMatrix(ne.modelViewMatrix),qe.onBeforeRender(b,Ee,De,Ne,ne,at),qe.transparent===!0&&qe.side===Sa?(qe.side=Z2,qe.needsUpdate=!0,b.renderBufferDirect(De,Ee,Ne,qe,ne,at),qe.side=Ui,qe.needsUpdate=!0,b.renderBufferDirect(De,Ee,Ne,qe,ne,at),qe.side=Sa):b.renderBufferDirect(De,Ee,Ne,qe,ne,at),ne.onAfterRender(b,Ee,De,Ne,qe,at)}function o0(ne,Ee,De){Ee.isScene!==!0&&(Ee=pe);const Ne=Te.get(ne),qe=m.state.lights,at=m.state.shadowsArray,lt=qe.state.version,ht=d0.getParameters(ne,qe.state,at,Ee,De),dt=d0.getProgramCacheKey(ht);let kt=Ne.programs;Ne.environment=ne.isMeshStandardMaterial?Ee.environment:null,Ne.fog=Ee.fog,Ne.envMap=(ne.isMeshStandardMaterial?c0:Xe).get(ne.envMap||Ne.environment),kt===void 0&&(ne.addEventListener("dispose",ye),kt=new Map,Ne.programs=kt);let Mt=kt.get(dt);if(Mt!==void 0){if(Ne.currentProgram===Mt&&Ne.lightsStateVersion===lt)return yx(ne,ht),Mt}else ht.uniforms=d0.getUniforms(ne),ne.onBuild(De,ht,b),ne.onBeforeCompile(ht,b),Mt=d0.acquireProgram(ht,dt),kt.set(dt,Mt),Ne.uniforms=ht.uniforms;const pt=Ne.uniforms;(!ne.isShaderMaterial&&!ne.isRawShaderMaterial||ne.clipping===!0)&&(pt.clippingPlanes=$.uniform),yx(ne,ht),Ne.needsLights=Ox(ne),Ne.lightsStateVersion=lt,Ne.needsLights&&(pt.ambientLightColor.value=qe.state.ambient,pt.lightProbe.value=qe.state.probe,pt.directionalLights.value=qe.state.directional,pt.directionalLightShadows.value=qe.state.directionalShadow,pt.spotLights.value=qe.state.spot,pt.spotLightShadows.value=qe.state.spotShadow,pt.rectAreaLights.value=qe.state.rectArea,pt.ltc_1.value=qe.state.rectAreaLTC1,pt.ltc_2.value=qe.state.rectAreaLTC2,pt.pointLights.value=qe.state.point,pt.pointLightShadows.value=qe.state.pointShadow,pt.hemisphereLights.value=qe.state.hemi,pt.directionalShadowMap.value=qe.state.directionalShadowMap,pt.directionalShadowMatrix.value=qe.state.directionalShadowMatrix,pt.spotShadowMap.value=qe.state.spotShadowMap,pt.spotShadowMatrix.value=qe.state.spotShadowMatrix,pt.pointShadowMap.value=qe.state.pointShadowMap,pt.pointShadowMatrix.value=qe.state.pointShadowMatrix);const Xt=Mt.getUniforms(),cn=oh.seqWithValue(Xt.seq,pt);return Ne.currentProgram=Mt,Ne.uniformsList=cn,Mt}function yx(ne,Ee){const De=Te.get(ne);De.outputEncoding=Ee.outputEncoding,De.instancing=Ee.instancing,De.skinning=Ee.skinning,De.morphTargets=Ee.morphTargets,De.morphNormals=Ee.morphNormals,De.morphColors=Ee.morphColors,De.morphTargetsCount=Ee.morphTargetsCount,De.numClippingPlanes=Ee.numClippingPlanes,De.numIntersection=Ee.numClipIntersection,De.vertexAlphas=Ee.vertexAlphas,De.vertexTangents=Ee.vertexTangents,De.toneMapping=Ee.toneMapping}function ut(ne,Ee,De,Ne,qe){Ee.isScene!==!0&&(Ee=pe),Ie.resetTextureUnits();const at=Ee.fog,lt=Ne.isMeshStandardMaterial?Ee.environment:null,ht=T===null?b.outputEncoding:T.isXRRenderTarget===!0?T.texture.encoding:Ss,dt=(Ne.isMeshStandardMaterial?c0:Xe).get(Ne.envMap||lt),kt=Ne.vertexColors===!0&&!!De.attributes.color&&De.attributes.color.itemSize===4,Mt=!!Ne.normalMap&&!!De.attributes.tangent,pt=!!De.morphAttributes.position,Xt=!!De.morphAttributes.normal,cn=!!De.morphAttributes.color,tn=Ne.toneMapped?b.toneMapping:Wr,z2=De.morphAttributes.position||De.morphAttributes.normal||De.morphAttributes.color,xn=z2!==void 0?z2.length:0,_t=Te.get(Ne),W2=m.state.lights;if(xe===!0&&(ae===!0||ne!==E)){const mx=ne===E&&Ne.id===A;$.setState(Ne,ne,mx)}let Qt=!1;Ne.version===_t.__version?(_t.needsLights&&_t.lightsStateVersion!==W2.state.version||_t.outputEncoding!==ht||qe.isInstancedMesh&&_t.instancing===!1||!qe.isInstancedMesh&&_t.instancing===!0||qe.isSkinnedMesh&&_t.skinning===!1||!qe.isSkinnedMesh&&_t.skinning===!0||_t.envMap!==dt||Ne.fog===!0&&_t.fog!==at||_t.numClippingPlanes!==void 0&&(_t.numClippingPlanes!==$.numPlanes||_t.numIntersection!==$.numIntersection)||_t.vertexAlphas!==kt||_t.vertexTangents!==Mt||_t.morphTargets!==pt||_t.morphNormals!==Xt||_t.morphColors!==cn||_t.toneMapping!==tn||i0.isWebGL2===!0&&_t.morphTargetsCount!==xn)&&(Qt=!0):(Qt=!0,_t.__version=Ne.version);let Hx=_t.currentProgram;Qt===!0&&(Hx=o0(Ne,Ee,qe));let bn=!1,e2=!1,xs=!1;const Yx=Hx.getUniforms(),vn=_t.uniforms;if(We.useProgram(Hx.program)&&(bn=!0,e2=!0,xs=!0),Ne.id!==A&&(A=Ne.id,e2=!0),bn||E!==ne){if(Yx.setValue(we,"projectionMatrix",ne.projectionMatrix),i0.logarithmicDepthBuffer&&Yx.setValue(we,"logDepthBufFC",2/(Math.log(ne.far+1)/Math.LN2)),E!==ne&&(E=ne,e2=!0,xs=!0),Ne.isShaderMaterial||Ne.isMeshPhongMaterial||Ne.isMeshToonMaterial||Ne.isMeshStandardMaterial||Ne.envMap){const mx=Yx.map.cameraPosition;mx!==void 0&&mx.setValue(we,ge.setFromMatrixPosition(ne.matrixWorld))}(Ne.isMeshPhongMaterial||Ne.isMeshToonMaterial||Ne.isMeshLambertMaterial||Ne.isMeshBasicMaterial||Ne.isMeshStandardMaterial||Ne.isShaderMaterial)&&Yx.setValue(we,"isOrthographic",ne.isOrthographicCamera===!0),(Ne.isMeshPhongMaterial||Ne.isMeshToonMaterial||Ne.isMeshLambertMaterial||Ne.isMeshBasicMaterial||Ne.isMeshStandardMaterial||Ne.isShaderMaterial||Ne.isShadowMaterial||qe.isSkinnedMesh)&&Yx.setValue(we,"viewMatrix",ne.matrixWorldInverse)}if(qe.isSkinnedMesh){Yx.setOptional(we,qe,"bindMatrix"),Yx.setOptional(we,qe,"bindMatrixInverse");const mx=qe.skeleton;mx&&(i0.floatVertexTextures?(mx.boneTexture===null&&mx.computeBoneTexture(),Yx.setValue(we,"boneTexture",mx.boneTexture,Ie),Yx.setValue(we,"boneTextureSize",mx.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const br=De.morphAttributes;if((br.position!==void 0||br.normal!==void 0||br.color!==void 0&&i0.isWebGL2===!0)&&s0.update(qe,De,Ne,Hx),(e2||_t.receiveShadow!==qe.receiveShadow)&&(_t.receiveShadow=qe.receiveShadow,Yx.setValue(we,"receiveShadow",qe.receiveShadow)),e2&&(Yx.setValue(we,"toneMappingExposure",b.toneMappingExposure),_t.needsLights&&Cx(vn,xs),at&&Ne.fog===!0&&rt.refreshFogUniforms(vn,at),rt.refreshMaterialUniforms(vn,Ne,z,O,le),oh.upload(we,_t.uniformsList,vn,Ie)),Ne.isShaderMaterial&&Ne.uniformsNeedUpdate===!0&&(oh.upload(we,_t.uniformsList,vn,Ie),Ne.uniformsNeedUpdate=!1),Ne.isSpriteMaterial&&Yx.setValue(we,"center",qe.center),Yx.setValue(we,"modelViewMatrix",qe.modelViewMatrix),Yx.setValue(we,"normalMatrix",qe.normalMatrix),Yx.setValue(we,"modelMatrix",qe.matrixWorld),Ne.isShaderMaterial||Ne.isRawShaderMaterial){const mx=Ne.uniformsGroups;for(let An=0,sr=mx.length;An<sr;An++)if(i0.isWebGL2){const Us=mx[An];u0.update(Us,Hx),u0.bind(Us,Hx)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Hx}function Cx(ne,Ee){ne.ambientLightColor.needsUpdate=Ee,ne.lightProbe.needsUpdate=Ee,ne.directionalLights.needsUpdate=Ee,ne.directionalLightShadows.needsUpdate=Ee,ne.pointLights.needsUpdate=Ee,ne.pointLightShadows.needsUpdate=Ee,ne.spotLights.needsUpdate=Ee,ne.spotLightShadows.needsUpdate=Ee,ne.rectAreaLights.needsUpdate=Ee,ne.hemisphereLights.needsUpdate=Ee}function Ox(ne){return ne.isMeshLambertMaterial||ne.isMeshToonMaterial||ne.isMeshPhongMaterial||ne.isMeshStandardMaterial||ne.isShadowMaterial||ne.isShaderMaterial&&ne.lights===!0}this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(ne,Ee,De){Te.get(ne.texture).__webglTexture=Ee,Te.get(ne.depthTexture).__webglTexture=De;const Ne=Te.get(ne);Ne.__hasExternalTextures=!0,Ne.__hasExternalTextures&&(Ne.__autoAllocateDepthBuffer=De===void 0,Ne.__autoAllocateDepthBuffer||Ze.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Ne.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(ne,Ee){const De=Te.get(ne);De.__webglFramebuffer=Ee,De.__useDefaultFramebuffer=Ee===void 0},this.setRenderTarget=function(ne,Ee=0,De=0){T=ne,w=Ee,_=De;let Ne=!0;if(ne){const dt=Te.get(ne);dt.__useDefaultFramebuffer!==void 0?(We.bindFramebuffer(36160,null),Ne=!1):dt.__webglFramebuffer===void 0?Ie.setupRenderTarget(ne):dt.__hasExternalTextures&&Ie.rebindTextures(ne,Te.get(ne.texture).__webglTexture,Te.get(ne.depthTexture).__webglTexture)}let qe=null,at=!1,lt=!1;if(ne){const dt=ne.texture;(dt.isData3DTexture||dt.isDataArrayTexture)&&(lt=!0);const kt=Te.get(ne).__webglFramebuffer;ne.isWebGLCubeRenderTarget?(qe=kt[Ee],at=!0):i0.isWebGL2&&ne.samples>0&&Ie.useMultisampledRTT(ne)===!1?qe=Te.get(ne).__webglMultisampledFramebuffer:qe=kt,M.copy(ne.viewport),I.copy(ne.scissor),C=ne.scissorTest}else M.copy(Y).multiplyScalar(z).floor(),I.copy(Q).multiplyScalar(z).floor(),C=te;if(We.bindFramebuffer(36160,qe)&&i0.drawBuffers&&Ne&&We.drawBuffers(ne,qe),We.viewport(M),We.scissor(I),We.setScissorTest(C),at){const dt=Te.get(ne.texture);we.framebufferTexture2D(36160,36064,34069+Ee,dt.__webglTexture,De)}else if(lt){const dt=Te.get(ne.texture),kt=Ee||0;we.framebufferTextureLayer(36160,36064,dt.__webglTexture,De||0,kt)}A=-1},this.readRenderTargetPixels=function(ne,Ee,De,Ne,qe,at,lt){if(!(ne&&ne.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ht=Te.get(ne).__webglFramebuffer;if(ne.isWebGLCubeRenderTarget&&lt!==void 0&&(ht=ht[lt]),ht){We.bindFramebuffer(36160,ht);try{const dt=ne.texture,kt=dt.format,Mt=dt.type;if(kt!==Q2&&Re.convert(kt)!==we.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const pt=Mt===Gr&&(Ze.has("EXT_color_buffer_half_float")||i0.isWebGL2&&Ze.has("EXT_color_buffer_float"));if(Mt!==Ca&&Re.convert(Mt)!==we.getParameter(35738)&&!(Mt===J2&&(i0.isWebGL2||Ze.has("OES_texture_float")||Ze.has("WEBGL_color_buffer_float")))&&!pt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Ee>=0&&Ee<=ne.width-Ne&&De>=0&&De<=ne.height-qe&&we.readPixels(Ee,De,Ne,qe,Re.convert(kt),Re.convert(Mt),at)}finally{const dt=T!==null?Te.get(T).__webglFramebuffer:null;We.bindFramebuffer(36160,dt)}}},this.copyFramebufferToTexture=function(ne,Ee,De=0){const Ne=Math.pow(2,-De),qe=Math.floor(Ee.image.width*Ne),at=Math.floor(Ee.image.height*Ne);Ie.setTexture2D(Ee,0),we.copyTexSubImage2D(3553,De,0,0,ne.x,ne.y,qe,at),We.unbindTexture()},this.copyTextureToTexture=function(ne,Ee,De,Ne=0){const qe=Ee.image.width,at=Ee.image.height,lt=Re.convert(De.format),ht=Re.convert(De.type);Ie.setTexture2D(De,0),we.pixelStorei(37440,De.flipY),we.pixelStorei(37441,De.premultiplyAlpha),we.pixelStorei(3317,De.unpackAlignment),Ee.isDataTexture?we.texSubImage2D(3553,Ne,ne.x,ne.y,qe,at,lt,ht,Ee.image.data):Ee.isCompressedTexture?we.compressedTexSubImage2D(3553,Ne,ne.x,ne.y,Ee.mipmaps[0].width,Ee.mipmaps[0].height,lt,Ee.mipmaps[0].data):we.texSubImage2D(3553,Ne,ne.x,ne.y,lt,ht,Ee.image),Ne===0&&De.generateMipmaps&&we.generateMipmap(3553),We.unbindTexture()},this.copyTextureToTexture3D=function(ne,Ee,De,Ne,qe=0){if(b.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const at=ne.max.x-ne.min.x+1,lt=ne.max.y-ne.min.y+1,ht=ne.max.z-ne.min.z+1,dt=Re.convert(Ne.format),kt=Re.convert(Ne.type);let Mt;if(Ne.isData3DTexture)Ie.setTexture3D(Ne,0),Mt=32879;else if(Ne.isDataArrayTexture)Ie.setTexture2DArray(Ne,0),Mt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}we.pixelStorei(37440,Ne.flipY),we.pixelStorei(37441,Ne.premultiplyAlpha),we.pixelStorei(3317,Ne.unpackAlignment);const pt=we.getParameter(3314),Xt=we.getParameter(32878),cn=we.getParameter(3316),tn=we.getParameter(3315),z2=we.getParameter(32877),xn=De.isCompressedTexture?De.mipmaps[0]:De.image;we.pixelStorei(3314,xn.width),we.pixelStorei(32878,xn.height),we.pixelStorei(3316,ne.min.x),we.pixelStorei(3315,ne.min.y),we.pixelStorei(32877,ne.min.z),De.isDataTexture||De.isData3DTexture?we.texSubImage3D(Mt,qe,Ee.x,Ee.y,Ee.z,at,lt,ht,dt,kt,xn.data):De.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),we.compressedTexSubImage3D(Mt,qe,Ee.x,Ee.y,Ee.z,at,lt,ht,dt,xn.data)):we.texSubImage3D(Mt,qe,Ee.x,Ee.y,Ee.z,at,lt,ht,dt,kt,xn),we.pixelStorei(3314,pt),we.pixelStorei(32878,Xt),we.pixelStorei(3316,cn),we.pixelStorei(3315,tn),we.pixelStorei(32877,z2),qe===0&&Ne.generateMipmaps&&we.generateMipmap(Mt),We.unbindTexture()},this.initTexture=function(ne){ne.isCubeTexture?Ie.setTextureCube(ne,0):ne.isData3DTexture?Ie.setTexture3D(ne,0):ne.isDataArrayTexture?Ie.setTexture2DArray(ne,0):Ie.setTexture2D(ne,0),We.unbindTexture()},this.resetState=function(){w=0,_=0,T=null,We.reset(),L0.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class K0e extends uE{}K0e.prototype.isWebGL1Renderer=!0;class V1{constructor(x,n=25e-5){this.isFogExp2=!0,this.name="",this.color=new M0(x),this.density=n}clone(){return new V1(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class H1{constructor(x,n=1,r=1e3){this.isFog=!0,this.name="",this.color=new M0(x),this.near=n,this.far=r}clone(){return new H1(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class dE extends Px{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(x,n){return super.copy(x,n),x.background!==null&&(this.background=x.background.clone()),x.environment!==null&&(this.environment=x.environment.clone()),x.fog!==null&&(this.fog=x.fog.clone()),x.overrideMaterial!==null&&(this.overrideMaterial=x.overrideMaterial.clone()),this.autoUpdate=x.autoUpdate,this.matrixAutoUpdate=x.matrixAutoUpdate,this}toJSON(x){const n=super.toJSON(x);return this.fog!==null&&(n.object.fog=this.fog.toJSON()),n}}class Y1{constructor(x,n){this.isInterleavedBuffer=!0,this.array=x,this.stride=n,this.count=x!==void 0?x.length/n:0,this.usage=Od,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=f2()}onUploadCallback(){}set needsUpdate(x){x===!0&&this.version++}setUsage(x){return this.usage=x,this}copy(x){return this.array=new x.array.constructor(x.array),this.count=x.count,this.stride=x.stride,this.usage=x.usage,this}copyAt(x,n,r){x*=this.stride,r*=n.stride;for(let a=0,i=this.stride;a<i;a++)this.array[x+a]=n.array[r+a];return this}set(x,n=0){return this.array.set(x,n),this}clone(x){x.arrayBuffers===void 0&&(x.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=f2()),x.arrayBuffers[this.array.buffer._uuid]===void 0&&(x.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new this.array.constructor(x.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(n,this.stride);return r.setUsage(this.usage),r}onUpload(x){return this.onUploadCallback=x,this}toJSON(x){return x.arrayBuffers===void 0&&(x.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=f2()),x.arrayBuffers[this.array.buffer._uuid]===void 0&&(x.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const jn=new K;class Ha{constructor(x,n,r,a=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=x,this.itemSize=n,this.offset=r,this.normalized=a===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(x){this.data.needsUpdate=x}applyMatrix4(x){for(let n=0,r=this.data.count;n<r;n++)jn.fromBufferAttribute(this,n),jn.applyMatrix4(x),this.setXYZ(n,jn.x,jn.y,jn.z);return this}applyNormalMatrix(x){for(let n=0,r=this.count;n<r;n++)jn.fromBufferAttribute(this,n),jn.applyNormalMatrix(x),this.setXYZ(n,jn.x,jn.y,jn.z);return this}transformDirection(x){for(let n=0,r=this.count;n<r;n++)jn.fromBufferAttribute(this,n),jn.transformDirection(x),this.setXYZ(n,jn.x,jn.y,jn.z);return this}setX(x,n){return this.data.array[x*this.data.stride+this.offset]=n,this}setY(x,n){return this.data.array[x*this.data.stride+this.offset+1]=n,this}setZ(x,n){return this.data.array[x*this.data.stride+this.offset+2]=n,this}setW(x,n){return this.data.array[x*this.data.stride+this.offset+3]=n,this}getX(x){return this.data.array[x*this.data.stride+this.offset]}getY(x){return this.data.array[x*this.data.stride+this.offset+1]}getZ(x){return this.data.array[x*this.data.stride+this.offset+2]}getW(x){return this.data.array[x*this.data.stride+this.offset+3]}setXY(x,n,r){return x=x*this.data.stride+this.offset,this.data.array[x+0]=n,this.data.array[x+1]=r,this}setXYZ(x,n,r,a){return x=x*this.data.stride+this.offset,this.data.array[x+0]=n,this.data.array[x+1]=r,this.data.array[x+2]=a,this}setXYZW(x,n,r,a,i){return x=x*this.data.stride+this.offset,this.data.array[x+0]=n,this.data.array[x+1]=r,this.data.array[x+2]=a,this.data.array[x+3]=i,this}clone(x){if(x===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const a=r*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)n.push(this.data.array[a+i])}return new Qx(new this.array.constructor(n),this.itemSize,this.normalized)}else return x.interleavedBuffers===void 0&&(x.interleavedBuffers={}),x.interleavedBuffers[this.data.uuid]===void 0&&(x.interleavedBuffers[this.data.uuid]=this.data.clone(x)),new Ha(x.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(x){if(x===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const a=r*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)n.push(this.data.array[a+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}else return x.interleavedBuffers===void 0&&(x.interleavedBuffers={}),x.interleavedBuffers[this.data.uuid]===void 0&&(x.interleavedBuffers[this.data.uuid]=this.data.toJSON(x)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class hE extends null{constructor(x){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new M0(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.map=x.map,this.alphaMap=x.alphaMap,this.rotation=x.rotation,this.sizeAttenuation=x.sizeAttenuation,this.fog=x.fog,this}}let ho;const Ol=new K,po=new K,fo=new K,mo=new n0,Fl=new n0,pE=new wt,lh=new K,Ul=new K,ch=new K,fE=new n0,q1=new n0,mE=new n0;class $0e extends null{constructor(x){if(super(),this.isSprite=!0,this.type="Sprite",ho===void 0){ho=new Rt;const n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new Y1(n,5);ho.setIndex([0,1,2,0,2,3]),ho.setAttribute("position",new Ha(r,3,0,!1)),ho.setAttribute("uv",new Ha(r,2,3,!1))}this.geometry=ho,this.material=x!==void 0?x:new hE,this.center=new n0(.5,.5)}raycast(x,n){x.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),po.setFromMatrixScale(this.matrixWorld),pE.copy(x.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(x.camera.matrixWorldInverse,this.matrixWorld),fo.setFromMatrixPosition(this.modelViewMatrix),x.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&po.multiplyScalar(-fo.z);const r=this.material.rotation;let a,i;r!==0&&(i=Math.cos(r),a=Math.sin(r));const o=this.center;uh(lh.set(-.5,-.5,0),fo,o,po,a,i),uh(Ul.set(.5,-.5,0),fo,o,po,a,i),uh(ch.set(.5,.5,0),fo,o,po,a,i),fE.set(0,0),q1.set(1,0),mE.set(1,1);let l=x.ray.intersectTriangle(lh,Ul,ch,!1,Ol);if(l===null&&(uh(Ul.set(-.5,.5,0),fo,o,po,a,i),q1.set(0,1),l=x.ray.intersectTriangle(lh,ch,Ul,!1,Ol),l===null))return;const c=x.ray.origin.distanceTo(Ol);c<x.near||c>x.far||n.push({distance:c,point:Ol.clone(),uv:nr.getUV(Ol,lh,Ul,ch,fE,q1,mE,new n0),face:null,object:this})}copy(x,n){return super.copy(x,n),x.center!==void 0&&this.center.copy(x.center),this.material=x.material,this}}function uh(s,x,n,r,a,i){mo.subVectors(s,n).addScalar(.5).multiply(r),a!==void 0?(Fl.x=i*mo.x-a*mo.y,Fl.y=a*mo.x+i*mo.y):Fl.copy(mo),s.copy(x),s.x+=Fl.x,s.y+=Fl.y,s.applyMatrix4(pE)}const dh=new K,gE=new K;class Z0e extends null{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(x){super.copy(x,!1);const n=x.levels;for(let r=0,a=n.length;r<a;r++){const i=n[r];this.addLevel(i.object.clone(),i.distance)}return this.autoUpdate=x.autoUpdate,this}addLevel(x,n=0){n=Math.abs(n);const r=this.levels;let a;for(a=0;a<r.length&&!(n<r[a].distance);a++);return r.splice(a,0,{distance:n,object:x}),this.add(x),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(x){const n=this.levels;if(n.length>0){let r,a;for(r=1,a=n.length;r<a&&!(x<n[r].distance);r++);return n[r-1].object}return null}raycast(x,n){if(this.levels.length>0){dh.setFromMatrixPosition(this.matrixWorld);const a=x.ray.origin.distanceTo(dh);this.getObjectForDistance(a).raycast(x,n)}}update(x){const n=this.levels;if(n.length>1){dh.setFromMatrixPosition(x.matrixWorld),gE.setFromMatrixPosition(this.matrixWorld);const r=dh.distanceTo(gE)/x.zoom;n[0].object.visible=!0;let a,i;for(a=1,i=n.length;a<i&&r>=n[a].distance;a++)n[a-1].object.visible=!1,n[a].object.visible=!0;for(this._currentLevel=a-1;a<i;a++)n[a].object.visible=!1}}toJSON(x){const n=super.toJSON(x);this.autoUpdate===!1&&(n.object.autoUpdate=!1),n.object.levels=[];const r=this.levels;for(let a=0,i=r.length;a<i;a++){const o=r[a];n.object.levels.push({object:o.object.uuid,distance:o.distance})}return n}}const yE=new K,bE=new ix,vE=new ix,J0e=new K,wE=new wt;class X1 extends yn{constructor(x,n){super(x,n),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new wt,this.bindMatrixInverse=new wt}copy(x,n){return super.copy(x,n),this.bindMode=x.bindMode,this.bindMatrix.copy(x.bindMatrix),this.bindMatrixInverse.copy(x.bindMatrixInverse),this.skeleton=x.skeleton,this}bind(x,n){this.skeleton=x,n===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),n=this.matrixWorld),this.bindMatrix.copy(n),this.bindMatrixInverse.copy(n).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const x=new ix,n=this.geometry.attributes.skinWeight;for(let r=0,a=n.count;r<a;r++){x.fromBufferAttribute(n,r);const i=1/x.manhattanLength();i!==1/0?x.multiplyScalar(i):x.set(1,0,0,0),n.setXYZW(r,x.x,x.y,x.z,x.w)}}updateMatrixWorld(x){super.updateMatrixWorld(x),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(x,n){const r=this.skeleton,a=this.geometry;bE.fromBufferAttribute(a.attributes.skinIndex,x),vE.fromBufferAttribute(a.attributes.skinWeight,x),yE.copy(n).applyMatrix4(this.bindMatrix),n.set(0,0,0);for(let i=0;i<4;i++){const o=vE.getComponent(i);if(o!==0){const l=bE.getComponent(i);wE.multiplyMatrices(r.bones[l].matrixWorld,r.boneInverses[l]),n.addScaledVector(J0e.copy(yE).applyMatrix4(wE),o)}}return n.applyMatrix4(this.bindMatrixInverse)}}class hh extends Px{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Bl extends Tn{constructor(x=null,n=1,r=1,a,i,o,l,c,d=Zx,h=Zx,p,m){super(null,o,l,c,d,h,a,i,p,m),this.isDataTexture=!0,this.image={data:x,width:n,height:r},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _E=new wt,Q0e=new wt;class ph{constructor(x=[],n=[]){this.uuid=f2(),this.bones=x.slice(0),this.boneInverses=n,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const x=this.bones,n=this.boneInverses;if(this.boneMatrices=new Float32Array(x.length*16),n.length===0)this.calculateInverses();else if(x.length!==n.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,a=this.bones.length;r<a;r++)this.boneInverses.push(new wt)}}calculateInverses(){this.boneInverses.length=0;for(let x=0,n=this.bones.length;x<n;x++){const r=new wt;this.bones[x]&&r.copy(this.bones[x].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let x=0,n=this.bones.length;x<n;x++){const r=this.bones[x];r&&r.matrixWorld.copy(this.boneInverses[x]).invert()}for(let x=0,n=this.bones.length;x<n;x++){const r=this.bones[x];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const x=this.bones,n=this.boneInverses,r=this.boneMatrices,a=this.boneTexture;for(let i=0,o=x.length;i<o;i++){const l=x[i]?x[i].matrixWorld:Q0e;_E.multiplyMatrices(l,n[i]),_E.toArray(r,i*16)}a!==null&&(a.needsUpdate=!0)}clone(){return new ph(this.bones,this.boneInverses)}computeBoneTexture(){let x=Math.sqrt(this.bones.length*4);x=gA(x),x=Math.max(x,4);const n=new Float32Array(x*x*4);n.set(this.boneMatrices);const r=new Bl(n,x,x,Q2,J2);return r.needsUpdate=!0,this.boneMatrices=n,this.boneTexture=r,this.boneTextureSize=x,this}getBoneByName(x){for(let n=0,r=this.bones.length;n<r;n++){const a=this.bones[n];if(a.name===x)return a}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(x,n){this.uuid=x.uuid;for(let r=0,a=x.bones.length;r<a;r++){const i=x.bones[r];let o=n[i];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new hh),this.bones.push(o),this.boneInverses.push(new wt().fromArray(x.boneInverses[r]))}return this.init(),this}toJSON(){const x={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};x.uuid=this.uuid;const n=this.bones,r=this.boneInverses;for(let a=0,i=n.length;a<i;a++){const o=n[a];x.bones.push(o.uuid);const l=r[a];x.boneInverses.push(l.toArray())}return x}}class zl extends null{constructor(x,n,r,a=1){typeof r=="number"&&(a=r,r=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(x,n,r),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=a}copy(x){return super.copy(x),this.meshPerAttribute=x.meshPerAttribute,this}toJSON(){const x=super.toJSON();return x.meshPerAttribute=this.meshPerAttribute,x.isInstancedBufferAttribute=!0,x}}const SE=new wt,TE=new wt,fh=null,Wl=new yn;class j0e extends null{constructor(x,n,r){super(x,n),this.isInstancedMesh=!0,this.instanceMatrix=new zl(new Float32Array(r*16),16),this.instanceColor=null,this.count=r,this.frustumCulled=!1}copy(x,n){return super.copy(x,n),this.instanceMatrix.copy(x.instanceMatrix),x.instanceColor!==null&&(this.instanceColor=x.instanceColor.clone()),this.count=x.count,this}getColorAt(x,n){n.fromArray(this.instanceColor.array,x*3)}getMatrixAt(x,n){n.fromArray(this.instanceMatrix.array,x*16)}raycast(x,n){const r=this.matrixWorld,a=this.count;if(Wl.geometry=this.geometry,Wl.material=this.material,Wl.material!==void 0)for(let i=0;i<a;i++){this.getMatrixAt(i,SE),TE.multiplyMatrices(r,SE),Wl.matrixWorld=TE,Wl.raycast(x,fh);for(let o=0,l=fh.length;o<l;o++){const c=fh[o];c.instanceId=i,c.object=this,n.push(c)}fh.length=0}}setColorAt(x,n){this.instanceColor===null&&(this.instanceColor=new zl(new Float32Array(this.instanceMatrix.count*3),3)),n.toArray(this.instanceColor.array,x*3)}setMatrixAt(x,n){n.toArray(this.instanceMatrix.array,x*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class i2 extends y2{constructor(x){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new M0(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.linewidth=x.linewidth,this.linecap=x.linecap,this.linejoin=x.linejoin,this.fog=x.fog,this}}const AE=new K,EE=new K,CE=new wt,K1=new qd,mh=new Ba;class Ya extends Px{constructor(x=new Rt,n=new i2){super(),this.isLine=!0,this.type="Line",this.geometry=x,this.material=n,this.updateMorphTargets()}copy(x,n){return super.copy(x,n),this.material=x.material,this.geometry=x.geometry,this}computeLineDistances(){const x=this.geometry;if(x.index===null){const n=x.attributes.position,r=[0];for(let a=1,i=n.count;a<i;a++)AE.fromBufferAttribute(n,a-1),EE.fromBufferAttribute(n,a),r[a]=r[a-1],r[a]+=AE.distanceTo(EE);x.setAttribute("lineDistance",new q0(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(x,n){const r=this.geometry,a=this.matrixWorld,i=x.params.Line.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),mh.copy(r.boundingSphere),mh.applyMatrix4(a),mh.radius+=i,x.ray.intersectsSphere(mh)===!1)return;CE.copy(a).invert(),K1.copy(x.ray).applyMatrix4(CE);const l=i/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l,d=new K,h=new K,p=new K,m=new K,g=this.isLineSegments?2:1,y=r.index,v=r.attributes.position;if(y!==null){const w=Math.max(0,o.start),_=Math.min(y.count,o.start+o.count);for(let T=w,A=_-1;T<A;T+=g){const E=y.getX(T),M=y.getX(T+1);if(d.fromBufferAttribute(v,E),h.fromBufferAttribute(v,M),K1.distanceSqToSegment(d,h,m,p)>c)continue;m.applyMatrix4(this.matrixWorld);const C=x.ray.origin.distanceTo(m);C<x.near||C>x.far||n.push({distance:C,point:p.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}else{const w=Math.max(0,o.start),_=Math.min(v.count,o.start+o.count);for(let T=w,A=_-1;T<A;T+=g){if(d.fromBufferAttribute(v,T),h.fromBufferAttribute(v,T+1),K1.distanceSqToSegment(d,h,m,p)>c)continue;m.applyMatrix4(this.matrixWorld);const M=x.ray.origin.distanceTo(m);M<x.near||M>x.far||n.push({distance:M,point:p.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const a=n[r[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=a.length;i<o;i++){const l=a[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=i}}}}}const ME=new K,IE=new K;class $1 extends Ya{constructor(x,n){super(x,n),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const x=this.geometry;if(x.index===null){const n=x.attributes.position,r=[];for(let a=0,i=n.count;a<i;a+=2)ME.fromBufferAttribute(n,a),IE.fromBufferAttribute(n,a+1),r[a]=a===0?0:r[a-1],r[a+1]=r[a]+ME.distanceTo(IE);x.setAttribute("lineDistance",new q0(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class kE extends Ya{constructor(x,n){super(x,n),this.isLineLoop=!0,this.type="LineLoop"}}class Z1 extends y2{constructor(x){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new M0(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.map=x.map,this.alphaMap=x.alphaMap,this.size=x.size,this.sizeAttenuation=x.sizeAttenuation,this.fog=x.fog,this}}const NE=new wt,J1=new qd,gh=new Ba,yh=new K;class RE extends Px{constructor(x=new Rt,n=new Z1){super(),this.isPoints=!0,this.type="Points",this.geometry=x,this.material=n,this.updateMorphTargets()}copy(x,n){return super.copy(x,n),this.material=x.material,this.geometry=x.geometry,this}raycast(x,n){const r=this.geometry,a=this.matrixWorld,i=x.params.Points.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),gh.copy(r.boundingSphere),gh.applyMatrix4(a),gh.radius+=i,x.ray.intersectsSphere(gh)===!1)return;NE.copy(a).invert(),J1.copy(x.ray).applyMatrix4(NE);const l=i/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l,d=r.index,p=r.attributes.position;if(d!==null){const m=Math.max(0,o.start),g=Math.min(d.count,o.start+o.count);for(let y=m,b=g;y<b;y++){const v=d.getX(y);yh.fromBufferAttribute(p,v),PE(yh,v,c,a,x,n,this)}}else{const m=Math.max(0,o.start),g=Math.min(p.count,o.start+o.count);for(let y=m,b=g;y<b;y++)yh.fromBufferAttribute(p,y),PE(yh,y,c,a,x,n,this)}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const a=n[r[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=a.length;i<o;i++){const l=a[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=i}}}}}function PE(s,x,n,r,a,i,o){const l=J1.distanceSqToPoint(s);if(l<n){const c=new K;J1.closestPointToPoint(s,c),c.applyMatrix4(r);const d=a.ray.origin.distanceTo(c);if(d<a.near||d>a.far)return;i.push({distance:d,distanceToRay:Math.sqrt(l),point:c,index:x,face:null,object:o})}}class Cre extends null{constructor(x,n,r,a,i,o,l,c,d){super(x,n,r,a,i,o,l,c,d),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:Sx,this.magFilter=i!==void 0?i:Sx,this.generateMipmaps=!1;const h=this;function p(){h.needsUpdate=!0,x.requestVideoFrameCallback(p)}"requestVideoFrameCallback"in x&&x.requestVideoFrameCallback(p)}clone(){return new this.constructor(this.image).copy(this)}update(){const x=this.image;"requestVideoFrameCallback"in x===!1&&x.readyState>=x.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class Mre extends null{constructor(x,n,r){super({width:x,height:n}),this.isFramebufferTexture=!0,this.format=r,this.magFilter=Zx,this.minFilter=Zx,this.generateMipmaps=!1,this.needsUpdate=!0}}class ete extends null{constructor(x,n,r,a,i,o,l,c,d,h,p,m){super(null,o,l,c,d,h,a,i,p,m),this.isCompressedTexture=!0,this.image={width:n,height:r},this.mipmaps=x,this.flipY=!1,this.generateMipmaps=!1}}class Ire extends null{constructor(x,n,r,a,i,o,l,c,d){super(x,n,r,a,i,o,l,c,d),this.isCanvasTexture=!0,this.needsUpdate=!0}}class gr{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(x,n){const r=this.getUtoTmapping(x);return this.getPoint(r,n)}getPoints(x=5){const n=[];for(let r=0;r<=x;r++)n.push(this.getPoint(r/x));return n}getSpacedPoints(x=5){const n=[];for(let r=0;r<=x;r++)n.push(this.getPointAt(r/x));return n}getLength(){const x=this.getLengths();return x[x.length-1]}getLengths(x=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===x+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const n=[];let r,a=this.getPoint(0),i=0;n.push(0);for(let o=1;o<=x;o++)r=this.getPoint(o/x),i+=r.distanceTo(a),n.push(i),a=r;return this.cacheArcLengths=n,n}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(x,n){const r=this.getLengths();let a=0;const i=r.length;let o;n?o=n:o=x*r[i-1];let l=0,c=i-1,d;for(;l<=c;)if(a=Math.floor(l+(c-l)/2),d=r[a]-o,d<0)l=a+1;else if(d>0)c=a-1;else{c=a;break}if(a=c,r[a]===o)return a/(i-1);const h=r[a],m=r[a+1]-h,g=(o-h)/m;return(a+g)/(i-1)}getTangent(x,n){let a=x-1e-4,i=x+1e-4;a<0&&(a=0),i>1&&(i=1);const o=this.getPoint(a),l=this.getPoint(i),c=n||(o.isVector2?new n0:new K);return c.copy(l).sub(o).normalize(),c}getTangentAt(x,n){const r=this.getUtoTmapping(x);return this.getTangent(r,n)}computeFrenetFrames(x,n){const r=new K,a=[],i=[],o=[],l=new K,c=new wt;for(let g=0;g<=x;g++){const y=g/x;a[g]=this.getTangentAt(y,new K)}i[0]=new K,o[0]=new K;let d=Number.MAX_VALUE;const h=Math.abs(a[0].x),p=Math.abs(a[0].y),m=Math.abs(a[0].z);h<=d&&(d=h,r.set(1,0,0)),p<=d&&(d=p,r.set(0,1,0)),m<=d&&r.set(0,0,1),l.crossVectors(a[0],r).normalize(),i[0].crossVectors(a[0],l),o[0].crossVectors(a[0],i[0]);for(let g=1;g<=x;g++){if(i[g]=i[g-1].clone(),o[g]=o[g-1].clone(),l.crossVectors(a[g-1],a[g]),l.length()>Number.EPSILON){l.normalize();const y=Math.acos(Gx(a[g-1].dot(a[g]),-1,1));i[g].applyMatrix4(c.makeRotationAxis(l,y))}o[g].crossVectors(a[g],i[g])}if(n===!0){let g=Math.acos(Gx(i[0].dot(i[x]),-1,1));g/=x,a[0].dot(l.crossVectors(i[0],i[x]))>0&&(g=-g);for(let y=1;y<=x;y++)i[y].applyMatrix4(c.makeRotationAxis(a[y],g*y)),o[y].crossVectors(a[y],i[y])}return{tangents:a,normals:i,binormals:o}}clone(){return new this.constructor().copy(this)}copy(x){return this.arcLengthDivisions=x.arcLengthDivisions,this}toJSON(){const x={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return x.arcLengthDivisions=this.arcLengthDivisions,x.type=this.type,x}fromJSON(x){return this.arcLengthDivisions=x.arcLengthDivisions,this}}class Q1 extends gr{constructor(x=0,n=0,r=1,a=1,i=0,o=Math.PI*2,l=!1,c=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=x,this.aY=n,this.xRadius=r,this.yRadius=a,this.aStartAngle=i,this.aEndAngle=o,this.aClockwise=l,this.aRotation=c}getPoint(x,n){const r=n||new n0,a=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const o=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=a;for(;i>a;)i-=a;i<Number.EPSILON&&(o?i=0:i=a),this.aClockwise===!0&&!o&&(i===a?i=-a:i=i-a);const l=this.aStartAngle+x*i;let c=this.aX+this.xRadius*Math.cos(l),d=this.aY+this.yRadius*Math.sin(l);if(this.aRotation!==0){const h=Math.cos(this.aRotation),p=Math.sin(this.aRotation),m=c-this.aX,g=d-this.aY;c=m*h-g*p+this.aX,d=m*p+g*h+this.aY}return r.set(c,d)}copy(x){return super.copy(x),this.aX=x.aX,this.aY=x.aY,this.xRadius=x.xRadius,this.yRadius=x.yRadius,this.aStartAngle=x.aStartAngle,this.aEndAngle=x.aEndAngle,this.aClockwise=x.aClockwise,this.aRotation=x.aRotation,this}toJSON(){const x=super.toJSON();return x.aX=this.aX,x.aY=this.aY,x.xRadius=this.xRadius,x.yRadius=this.yRadius,x.aStartAngle=this.aStartAngle,x.aEndAngle=this.aEndAngle,x.aClockwise=this.aClockwise,x.aRotation=this.aRotation,x}fromJSON(x){return super.fromJSON(x),this.aX=x.aX,this.aY=x.aY,this.xRadius=x.xRadius,this.yRadius=x.yRadius,this.aStartAngle=x.aStartAngle,this.aEndAngle=x.aEndAngle,this.aClockwise=x.aClockwise,this.aRotation=x.aRotation,this}}class tte extends Q1{constructor(x,n,r,a,i,o){super(x,n,r,r,a,i,o),this.isArcCurve=!0,this.type="ArcCurve"}}function j1(){let s=0,x=0,n=0,r=0;function a(i,o,l,c){s=i,x=l,n=-3*i+3*o-2*l-c,r=2*i-2*o+l+c}return{initCatmullRom:function(i,o,l,c,d){a(o,l,d*(l-i),d*(c-o))},initNonuniformCatmullRom:function(i,o,l,c,d,h,p){let m=(o-i)/d-(l-i)/(d+h)+(l-o)/h,g=(l-o)/h-(c-o)/(h+p)+(c-l)/p;m*=h,g*=h,a(o,l,m,g)},calc:function(i){const o=i*i,l=o*i;return s+x*i+n*o+r*l}}}const bh=new K,ey=new j1,ty=new j1,xy=new j1;class xte extends gr{constructor(x=[],n=!1,r="centripetal",a=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=x,this.closed=n,this.curveType=r,this.tension=a}getPoint(x,n=new K){const r=n,a=this.points,i=a.length,o=(i-(this.closed?0:1))*x;let l=Math.floor(o),c=o-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:c===0&&l===i-1&&(l=i-2,c=1);let d,h;this.closed||l>0?d=a[(l-1)%i]:(bh.subVectors(a[0],a[1]).add(a[0]),d=bh);const p=a[l%i],m=a[(l+1)%i];if(this.closed||l+2<i?h=a[(l+2)%i]:(bh.subVectors(a[i-1],a[i-2]).add(a[i-1]),h=bh),this.curveType==="centripetal"||this.curveType==="chordal"){const g=this.curveType==="chordal"?.5:.25;let y=Math.pow(d.distanceToSquared(p),g),b=Math.pow(p.distanceToSquared(m),g),v=Math.pow(m.distanceToSquared(h),g);b<1e-4&&(b=1),y<1e-4&&(y=b),v<1e-4&&(v=b),ey.initNonuniformCatmullRom(d.x,p.x,m.x,h.x,y,b,v),ty.initNonuniformCatmullRom(d.y,p.y,m.y,h.y,y,b,v),xy.initNonuniformCatmullRom(d.z,p.z,m.z,h.z,y,b,v)}else this.curveType==="catmullrom"&&(ey.initCatmullRom(d.x,p.x,m.x,h.x,this.tension),ty.initCatmullRom(d.y,p.y,m.y,h.y,this.tension),xy.initCatmullRom(d.z,p.z,m.z,h.z,this.tension));return r.set(ey.calc(c),ty.calc(c),xy.calc(c)),r}copy(x){super.copy(x),this.points=[];for(let n=0,r=x.points.length;n<r;n++){const a=x.points[n];this.points.push(a.clone())}return this.closed=x.closed,this.curveType=x.curveType,this.tension=x.tension,this}toJSON(){const x=super.toJSON();x.points=[];for(let n=0,r=this.points.length;n<r;n++){const a=this.points[n];x.points.push(a.toArray())}return x.closed=this.closed,x.curveType=this.curveType,x.tension=this.tension,x}fromJSON(x){super.fromJSON(x),this.points=[];for(let n=0,r=x.points.length;n<r;n++){const a=x.points[n];this.points.push(new K().fromArray(a))}return this.closed=x.closed,this.curveType=x.curveType,this.tension=x.tension,this}}function LE(s,x,n,r,a){const i=(r-x)*.5,o=(a-n)*.5,l=s*s,c=s*l;return(2*n-2*r+i+o)*c+(-3*n+3*r-2*i-o)*l+i*s+n}function nte(s,x){const n=1-s;return n*n*x}function rte(s,x){return 2*(1-s)*s*x}function ste(s,x){return s*s*x}function Gl(s,x,n,r){return nte(s,x)+rte(s,n)+ste(s,r)}function ate(s,x){const n=1-s;return n*n*n*x}function ite(s,x){const n=1-s;return 3*n*n*s*x}function ote(s,x){return 3*(1-s)*s*s*x}function lte(s,x){return s*s*s*x}function Vl(s,x,n,r,a){return ate(s,x)+ite(s,n)+ote(s,r)+lte(s,a)}class DE extends gr{constructor(x=new n0,n=new n0,r=new n0,a=new n0){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=x,this.v1=n,this.v2=r,this.v3=a}getPoint(x,n=new n0){const r=n,a=this.v0,i=this.v1,o=this.v2,l=this.v3;return r.set(Vl(x,a.x,i.x,o.x,l.x),Vl(x,a.y,i.y,o.y,l.y)),r}copy(x){return super.copy(x),this.v0.copy(x.v0),this.v1.copy(x.v1),this.v2.copy(x.v2),this.v3.copy(x.v3),this}toJSON(){const x=super.toJSON();return x.v0=this.v0.toArray(),x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x.v3=this.v3.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v0.fromArray(x.v0),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this.v3.fromArray(x.v3),this}}class cte extends gr{constructor(x=new K,n=new K,r=new K,a=new K){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=x,this.v1=n,this.v2=r,this.v3=a}getPoint(x,n=new K){const r=n,a=this.v0,i=this.v1,o=this.v2,l=this.v3;return r.set(Vl(x,a.x,i.x,o.x,l.x),Vl(x,a.y,i.y,o.y,l.y),Vl(x,a.z,i.z,o.z,l.z)),r}copy(x){return super.copy(x),this.v0.copy(x.v0),this.v1.copy(x.v1),this.v2.copy(x.v2),this.v3.copy(x.v3),this}toJSON(){const x=super.toJSON();return x.v0=this.v0.toArray(),x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x.v3=this.v3.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v0.fromArray(x.v0),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this.v3.fromArray(x.v3),this}}class ny extends gr{constructor(x=new n0,n=new n0){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=x,this.v2=n}getPoint(x,n=new n0){const r=n;return x===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(x).add(this.v1)),r}getPointAt(x,n){return this.getPoint(x,n)}getTangent(x,n){const r=n||new n0;return r.copy(this.v2).sub(this.v1).normalize(),r}copy(x){return super.copy(x),this.v1.copy(x.v1),this.v2.copy(x.v2),this}toJSON(){const x=super.toJSON();return x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this}}class ute extends gr{constructor(x=new K,n=new K){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=x,this.v2=n}getPoint(x,n=new K){const r=n;return x===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(x).add(this.v1)),r}getPointAt(x,n){return this.getPoint(x,n)}copy(x){return super.copy(x),this.v1.copy(x.v1),this.v2.copy(x.v2),this}toJSON(){const x=super.toJSON();return x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this}}class OE extends gr{constructor(x=new n0,n=new n0,r=new n0){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=x,this.v1=n,this.v2=r}getPoint(x,n=new n0){const r=n,a=this.v0,i=this.v1,o=this.v2;return r.set(Gl(x,a.x,i.x,o.x),Gl(x,a.y,i.y,o.y)),r}copy(x){return super.copy(x),this.v0.copy(x.v0),this.v1.copy(x.v1),this.v2.copy(x.v2),this}toJSON(){const x=super.toJSON();return x.v0=this.v0.toArray(),x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v0.fromArray(x.v0),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this}}class FE extends gr{constructor(x=new K,n=new K,r=new K){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=x,this.v1=n,this.v2=r}getPoint(x,n=new K){const r=n,a=this.v0,i=this.v1,o=this.v2;return r.set(Gl(x,a.x,i.x,o.x),Gl(x,a.y,i.y,o.y),Gl(x,a.z,i.z,o.z)),r}copy(x){return super.copy(x),this.v0.copy(x.v0),this.v1.copy(x.v1),this.v2.copy(x.v2),this}toJSON(){const x=super.toJSON();return x.v0=this.v0.toArray(),x.v1=this.v1.toArray(),x.v2=this.v2.toArray(),x}fromJSON(x){return super.fromJSON(x),this.v0.fromArray(x.v0),this.v1.fromArray(x.v1),this.v2.fromArray(x.v2),this}}class UE extends gr{constructor(x=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=x}getPoint(x,n=new n0){const r=n,a=this.points,i=(a.length-1)*x,o=Math.floor(i),l=i-o,c=a[o===0?o:o-1],d=a[o],h=a[o>a.length-2?a.length-1:o+1],p=a[o>a.length-3?a.length-1:o+2];return r.set(LE(l,c.x,d.x,h.x,p.x),LE(l,c.y,d.y,h.y,p.y)),r}copy(x){super.copy(x),this.points=[];for(let n=0,r=x.points.length;n<r;n++){const a=x.points[n];this.points.push(a.clone())}return this}toJSON(){const x=super.toJSON();x.points=[];for(let n=0,r=this.points.length;n<r;n++){const a=this.points[n];x.points.push(a.toArray())}return x}fromJSON(x){super.fromJSON(x),this.points=[];for(let n=0,r=x.points.length;n<r;n++){const a=x.points[n];this.points.push(new n0().fromArray(a))}return this}}var ry=Object.freeze({__proto__:null,ArcCurve:tte,CatmullRomCurve3:xte,CubicBezierCurve:DE,CubicBezierCurve3:cte,EllipseCurve:Q1,LineCurve:ny,LineCurve3:ute,QuadraticBezierCurve:OE,QuadraticBezierCurve3:FE,SplineCurve:UE});class dte extends gr{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(x){this.curves.push(x)}closePath(){const x=this.curves[0].getPoint(0),n=this.curves[this.curves.length-1].getPoint(1);x.equals(n)||this.curves.push(new ny(n,x))}getPoint(x,n){const r=x*this.getLength(),a=this.getCurveLengths();let i=0;for(;i<a.length;){if(a[i]>=r){const o=a[i]-r,l=this.curves[i],c=l.getLength(),d=c===0?0:1-o/c;return l.getPointAt(d,n)}i++}return null}getLength(){const x=this.getCurveLengths();return x[x.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const x=[];let n=0;for(let r=0,a=this.curves.length;r<a;r++)n+=this.curves[r].getLength(),x.push(n);return this.cacheLengths=x,x}getSpacedPoints(x=40){const n=[];for(let r=0;r<=x;r++)n.push(this.getPoint(r/x));return this.autoClose&&n.push(n[0]),n}getPoints(x=12){const n=[];let r;for(let a=0,i=this.curves;a<i.length;a++){const o=i[a],l=o.isEllipseCurve?x*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?x*o.points.length:x,c=o.getPoints(l);for(let d=0;d<c.length;d++){const h=c[d];r&&r.equals(h)||(n.push(h),r=h)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n}copy(x){super.copy(x),this.curves=[];for(let n=0,r=x.curves.length;n<r;n++){const a=x.curves[n];this.curves.push(a.clone())}return this.autoClose=x.autoClose,this}toJSON(){const x=super.toJSON();x.autoClose=this.autoClose,x.curves=[];for(let n=0,r=this.curves.length;n<r;n++){const a=this.curves[n];x.curves.push(a.toJSON())}return x}fromJSON(x){super.fromJSON(x),this.autoClose=x.autoClose,this.curves=[];for(let n=0,r=x.curves.length;n<r;n++){const a=x.curves[n];this.curves.push(new ry[a.type]().fromJSON(a))}return this}}class vh extends dte{constructor(x){super(),this.type="Path",this.currentPoint=new n0,x&&this.setFromPoints(x)}setFromPoints(x){this.moveTo(x[0].x,x[0].y);for(let n=1,r=x.length;n<r;n++)this.lineTo(x[n].x,x[n].y);return this}moveTo(x,n){return this.currentPoint.set(x,n),this}lineTo(x,n){const r=new ny(this.currentPoint.clone(),new n0(x,n));return this.curves.push(r),this.currentPoint.set(x,n),this}quadraticCurveTo(x,n,r,a){const i=new OE(this.currentPoint.clone(),new n0(x,n),new n0(r,a));return this.curves.push(i),this.currentPoint.set(r,a),this}bezierCurveTo(x,n,r,a,i,o){const l=new DE(this.currentPoint.clone(),new n0(x,n),new n0(r,a),new n0(i,o));return this.curves.push(l),this.currentPoint.set(i,o),this}splineThru(x){const n=[this.currentPoint.clone()].concat(x),r=new UE(n);return this.curves.push(r),this.currentPoint.copy(x[x.length-1]),this}arc(x,n,r,a,i,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absarc(x+l,n+c,r,a,i,o),this}absarc(x,n,r,a,i,o){return this.absellipse(x,n,r,r,a,i,o),this}ellipse(x,n,r,a,i,o,l,c){const d=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(x+d,n+h,r,a,i,o,l,c),this}absellipse(x,n,r,a,i,o,l,c){const d=new Q1(x,n,r,a,i,o,l,c);if(this.curves.length>0){const p=d.getPoint(0);p.equals(this.currentPoint)||this.lineTo(p.x,p.y)}this.curves.push(d);const h=d.getPoint(1);return this.currentPoint.copy(h),this}copy(x){return super.copy(x),this.currentPoint.copy(x.currentPoint),this}toJSON(){const x=super.toJSON();return x.currentPoint=this.currentPoint.toArray(),x}fromJSON(x){return super.fromJSON(x),this.currentPoint.fromArray(x.currentPoint),this}}class Hl extends Rt{constructor(x=[new n0(0,-.5),new n0(.5,0),new n0(0,.5)],n=12,r=0,a=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:x,segments:n,phiStart:r,phiLength:a},n=Math.floor(n),a=Gx(a,0,Math.PI*2);const i=[],o=[],l=[],c=[],d=[],h=1/n,p=new K,m=new n0,g=new K,y=new K,b=new K;let v=0,w=0;for(let _=0;_<=x.length-1;_++)switch(_){case 0:v=x[_+1].x-x[_].x,w=x[_+1].y-x[_].y,g.x=w*1,g.y=-v,g.z=w*0,b.copy(g),g.normalize(),c.push(g.x,g.y,g.z);break;case x.length-1:c.push(b.x,b.y,b.z);break;default:v=x[_+1].x-x[_].x,w=x[_+1].y-x[_].y,g.x=w*1,g.y=-v,g.z=w*0,y.copy(g),g.x+=b.x,g.y+=b.y,g.z+=b.z,g.normalize(),c.push(g.x,g.y,g.z),b.copy(y)}for(let _=0;_<=n;_++){const T=r+_*h*a,A=Math.sin(T),E=Math.cos(T);for(let M=0;M<=x.length-1;M++){p.x=x[M].x*A,p.y=x[M].y,p.z=x[M].x*E,o.push(p.x,p.y,p.z),m.x=_/n,m.y=M/(x.length-1),l.push(m.x,m.y);const I=c[3*M+0]*A,C=c[3*M+1],k=c[3*M+0]*E;d.push(I,C,k)}}for(let _=0;_<n;_++)for(let T=0;T<x.length-1;T++){const A=T+_*x.length,E=A,M=A+x.length,I=A+x.length+1,C=A+1;i.push(E,M,C),i.push(I,C,M)}this.setIndex(i),this.setAttribute("position",new q0(o,3)),this.setAttribute("uv",new q0(l,2)),this.setAttribute("normal",new q0(d,3))}static fromJSON(x){return new Hl(x.points,x.segments,x.phiStart,x.phiLength)}}class wh extends Hl{constructor(x=1,n=1,r=4,a=8){const i=new vh;i.absarc(0,-n/2,x,Math.PI*1.5,0),i.absarc(0,n/2,x,0,Math.PI*.5),super(i.getPoints(r),a),this.type="CapsuleGeometry",this.parameters={radius:x,height:n,capSegments:r,radialSegments:a}}static fromJSON(x){return new wh(x.radius,x.length,x.capSegments,x.radialSegments)}}class _h extends Rt{constructor(x=1,n=8,r=0,a=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:x,segments:n,thetaStart:r,thetaLength:a},n=Math.max(3,n);const i=[],o=[],l=[],c=[],d=new K,h=new n0;o.push(0,0,0),l.push(0,0,1),c.push(.5,.5);for(let p=0,m=3;p<=n;p++,m+=3){const g=r+p/n*a;d.x=x*Math.cos(g),d.y=x*Math.sin(g),o.push(d.x,d.y,d.z),l.push(0,0,1),h.x=(o[m]/x+1)/2,h.y=(o[m+1]/x+1)/2,c.push(h.x,h.y)}for(let p=1;p<=n;p++)i.push(p,p+1,0);this.setIndex(i),this.setAttribute("position",new q0(o,3)),this.setAttribute("normal",new q0(l,3)),this.setAttribute("uv",new q0(c,2))}static fromJSON(x){return new _h(x.radius,x.segments,x.thetaStart,x.thetaLength)}}class go extends Rt{constructor(x=1,n=1,r=1,a=8,i=1,o=!1,l=0,c=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:x,radiusBottom:n,height:r,radialSegments:a,heightSegments:i,openEnded:o,thetaStart:l,thetaLength:c};const d=this;a=Math.floor(a),i=Math.floor(i);const h=[],p=[],m=[],g=[];let y=0;const b=[],v=r/2;let w=0;_(),o===!1&&(x>0&&T(!0),n>0&&T(!1)),this.setIndex(h),this.setAttribute("position",new q0(p,3)),this.setAttribute("normal",new q0(m,3)),this.setAttribute("uv",new q0(g,2));function _(){const A=new K,E=new K;let M=0;const I=(n-x)/r;for(let C=0;C<=i;C++){const k=[],O=C/i,z=O*(n-x)+x;for(let ee=0;ee<=a;ee++){const re=ee/a,Y=re*c+l,Q=Math.sin(Y),te=Math.cos(Y);E.x=z*Q,E.y=-O*r+v,E.z=z*te,p.push(E.x,E.y,E.z),A.set(Q,I,te).normalize(),m.push(A.x,A.y,A.z),g.push(re,1-O),k.push(y++)}b.push(k)}for(let C=0;C<a;C++)for(let k=0;k<i;k++){const O=b[k][C],z=b[k+1][C],ee=b[k+1][C+1],re=b[k][C+1];h.push(O,z,re),h.push(z,ee,re),M+=6}d.addGroup(w,M,0),w+=M}function T(A){const E=y,M=new n0,I=new K;let C=0;const k=A===!0?x:n,O=A===!0?1:-1;for(let ee=1;ee<=a;ee++)p.push(0,v*O,0),m.push(0,O,0),g.push(.5,.5),y++;const z=y;for(let ee=0;ee<=a;ee++){const Y=ee/a*c+l,Q=Math.cos(Y),te=Math.sin(Y);I.x=k*te,I.y=v*O,I.z=k*Q,p.push(I.x,I.y,I.z),m.push(0,O,0),M.x=Q*.5+.5,M.y=te*.5*O+.5,g.push(M.x,M.y),y++}for(let ee=0;ee<a;ee++){const re=E+ee,Y=z+ee;A===!0?h.push(Y,Y+1,re):h.push(Y+1,Y,re),C+=3}d.addGroup(w,C,A===!0?1:2),w+=C}}static fromJSON(x){return new go(x.radiusTop,x.radiusBottom,x.height,x.radialSegments,x.heightSegments,x.openEnded,x.thetaStart,x.thetaLength)}}class Sh extends go{constructor(x=1,n=1,r=8,a=1,i=!1,o=0,l=Math.PI*2){super(0,x,n,r,a,i,o,l),this.type="ConeGeometry",this.parameters={radius:x,height:n,radialSegments:r,heightSegments:a,openEnded:i,thetaStart:o,thetaLength:l}}static fromJSON(x){return new Sh(x.radius,x.height,x.radialSegments,x.heightSegments,x.openEnded,x.thetaStart,x.thetaLength)}}class Rs extends Rt{constructor(x=[],n=[],r=1,a=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:x,indices:n,radius:r,detail:a};const i=[],o=[];l(a),d(r),h(),this.setAttribute("position",new q0(i,3)),this.setAttribute("normal",new q0(i.slice(),3)),this.setAttribute("uv",new q0(o,2)),a===0?this.computeVertexNormals():this.normalizeNormals();function l(_){const T=new K,A=new K,E=new K;for(let M=0;M<n.length;M+=3)g(n[M+0],T),g(n[M+1],A),g(n[M+2],E),c(T,A,E,_)}function c(_,T,A,E){const M=E+1,I=[];for(let C=0;C<=M;C++){I[C]=[];const k=_.clone().lerp(A,C/M),O=T.clone().lerp(A,C/M),z=M-C;for(let ee=0;ee<=z;ee++)ee===0&&C===M?I[C][ee]=k:I[C][ee]=k.clone().lerp(O,ee/z)}for(let C=0;C<M;C++)for(let k=0;k<2*(M-C)-1;k++){const O=Math.floor(k/2);k%2===0?(m(I[C][O+1]),m(I[C+1][O]),m(I[C][O])):(m(I[C][O+1]),m(I[C+1][O+1]),m(I[C+1][O]))}}function d(_){const T=new K;for(let A=0;A<i.length;A+=3)T.x=i[A+0],T.y=i[A+1],T.z=i[A+2],T.normalize().multiplyScalar(_),i[A+0]=T.x,i[A+1]=T.y,i[A+2]=T.z}function h(){const _=new K;for(let T=0;T<i.length;T+=3){_.x=i[T+0],_.y=i[T+1],_.z=i[T+2];const A=v(_)/2/Math.PI+.5,E=w(_)/Math.PI+.5;o.push(A,1-E)}y(),p()}function p(){for(let _=0;_<o.length;_+=6){const T=o[_+0],A=o[_+2],E=o[_+4],M=Math.max(T,A,E),I=Math.min(T,A,E);M>.9&&I<.1&&(T<.2&&(o[_+0]+=1),A<.2&&(o[_+2]+=1),E<.2&&(o[_+4]+=1))}}function m(_){i.push(_.x,_.y,_.z)}function g(_,T){const A=_*3;T.x=x[A+0],T.y=x[A+1],T.z=x[A+2]}function y(){const _=new K,T=new K,A=new K,E=new K,M=new n0,I=new n0,C=new n0;for(let k=0,O=0;k<i.length;k+=9,O+=6){_.set(i[k+0],i[k+1],i[k+2]),T.set(i[k+3],i[k+4],i[k+5]),A.set(i[k+6],i[k+7],i[k+8]),M.set(o[O+0],o[O+1]),I.set(o[O+2],o[O+3]),C.set(o[O+4],o[O+5]),E.copy(_).add(T).add(A).divideScalar(3);const z=v(E);b(M,O+0,_,z),b(I,O+2,T,z),b(C,O+4,A,z)}}function b(_,T,A,E){E<0&&_.x===1&&(o[T]=_.x-1),A.x===0&&A.z===0&&(o[T]=E/2/Math.PI+.5)}function v(_){return Math.atan2(_.z,-_.x)}function w(_){return Math.atan2(-_.y,Math.sqrt(_.x*_.x+_.z*_.z))}}static fromJSON(x){return new Rs(x.vertices,x.indices,x.radius,x.details)}}class Th extends Rs{constructor(x=1,n=0){const r=(1+Math.sqrt(5))/2,a=1/r,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-a,-r,0,-a,r,0,a,-r,0,a,r,-a,-r,0,-a,r,0,a,-r,0,a,r,0,-r,0,-a,r,0,-a,-r,0,a,r,0,a],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,x,n),this.type="DodecahedronGeometry",this.parameters={radius:x,detail:n}}static fromJSON(x){return new Th(x.radius,x.detail)}}const Ah=new K,Eh=new K,sy=new K,Ch=new nr;class hte extends Rt{constructor(x=null,n=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:x,thresholdAngle:n},x!==null){const a=Math.pow(10,4),i=Math.cos(Ra*n),o=x.getIndex(),l=x.getAttribute("position"),c=o?o.count:l.count,d=[0,0,0],h=["a","b","c"],p=new Array(3),m={},g=[];for(let y=0;y<c;y+=3){o?(d[0]=o.getX(y),d[1]=o.getX(y+1),d[2]=o.getX(y+2)):(d[0]=y,d[1]=y+1,d[2]=y+2);const{a:b,b:v,c:w}=Ch;if(b.fromBufferAttribute(l,d[0]),v.fromBufferAttribute(l,d[1]),w.fromBufferAttribute(l,d[2]),Ch.getNormal(sy),p[0]=`${Math.round(b.x*a)},${Math.round(b.y*a)},${Math.round(b.z*a)}`,p[1]=`${Math.round(v.x*a)},${Math.round(v.y*a)},${Math.round(v.z*a)}`,p[2]=`${Math.round(w.x*a)},${Math.round(w.y*a)},${Math.round(w.z*a)}`,!(p[0]===p[1]||p[1]===p[2]||p[2]===p[0]))for(let _=0;_<3;_++){const T=(_+1)%3,A=p[_],E=p[T],M=Ch[h[_]],I=Ch[h[T]],C=`${A}_${E}`,k=`${E}_${A}`;k in m&&m[k]?(sy.dot(m[k].normal)<=i&&(g.push(M.x,M.y,M.z),g.push(I.x,I.y,I.z)),m[k]=null):C in m||(m[C]={index0:d[_],index1:d[T],normal:sy.clone()})}}for(const y in m)if(m[y]){const{index0:b,index1:v}=m[y];Ah.fromBufferAttribute(l,b),Eh.fromBufferAttribute(l,v),g.push(Ah.x,Ah.y,Ah.z),g.push(Eh.x,Eh.y,Eh.z)}this.setAttribute("position",new q0(g,3))}}}class yo extends vh{constructor(x){super(x),this.uuid=f2(),this.type="Shape",this.holes=[]}getPointsHoles(x){const n=[];for(let r=0,a=this.holes.length;r<a;r++)n[r]=this.holes[r].getPoints(x);return n}extractPoints(x){return{shape:this.getPoints(x),holes:this.getPointsHoles(x)}}copy(x){super.copy(x),this.holes=[];for(let n=0,r=x.holes.length;n<r;n++){const a=x.holes[n];this.holes.push(a.clone())}return this}toJSON(){const x=super.toJSON();x.uuid=this.uuid,x.holes=[];for(let n=0,r=this.holes.length;n<r;n++){const a=this.holes[n];x.holes.push(a.toJSON())}return x}fromJSON(x){super.fromJSON(x),this.uuid=x.uuid,this.holes=[];for(let n=0,r=x.holes.length;n<r;n++){const a=x.holes[n];this.holes.push(new vh().fromJSON(a))}return this}}const pte={triangulate:function(s,x,n=2){const r=x&&x.length,a=r?x[0]*n:s.length;let i=BE(s,0,a,n,!0);const o=[];if(!i||i.next===i.prev)return o;let l,c,d,h,p,m,g;if(r&&(i=bte(s,x,i,n)),s.length>80*n){l=d=s[0],c=h=s[1];for(let y=n;y<a;y+=n)p=s[y],m=s[y+1],p<l&&(l=p),m<c&&(c=m),p>d&&(d=p),m>h&&(h=m);g=Math.max(d-l,h-c),g=g!==0?1/g:0}return Yl(i,o,n,l,c,g),o}};function BE(s,x,n,r,a){let i,o;if(a===kte(s,x,n,r)>0)for(i=x;i<n;i+=r)o=GE(i,s[i],s[i+1],o);else for(i=n-r;i>=x;i-=r)o=GE(i,s[i],s[i+1],o);return o&&Mh(o,o.next)&&(Xl(o),o=o.next),o}function Ps(s,x){if(!s)return s;x||(x=s);let n=s,r;do if(r=!1,!n.steiner&&(Mh(n,n.next)||Ex(n.prev,n,n.next)===0)){if(Xl(n),n=x=n.prev,n===n.next)break;r=!0}else n=n.next;while(r||n!==x);return x}function Yl(s,x,n,r,a,i,o){if(!s)return;!o&&i&&Tte(s,r,a,i);let l=s,c,d;for(;s.prev!==s.next;){if(c=s.prev,d=s.next,i?mte(s,r,a,i):fte(s)){x.push(c.i/n),x.push(s.i/n),x.push(d.i/n),Xl(s),s=d.next,l=d.next;continue}if(s=d,s===l){o?o===1?(s=gte(Ps(s),x,n),Yl(s,x,n,r,a,i,2)):o===2&&yte(s,x,n,r,a,i):Yl(Ps(s),x,n,r,a,i,1);break}}}function fte(s){const x=s.prev,n=s,r=s.next;if(Ex(x,n,r)>=0)return!1;let a=s.next.next;for(;a!==s.prev;){if(bo(x.x,x.y,n.x,n.y,r.x,r.y,a.x,a.y)&&Ex(a.prev,a,a.next)>=0)return!1;a=a.next}return!0}function mte(s,x,n,r){const a=s.prev,i=s,o=s.next;if(Ex(a,i,o)>=0)return!1;const l=a.x<i.x?a.x<o.x?a.x:o.x:i.x<o.x?i.x:o.x,c=a.y<i.y?a.y<o.y?a.y:o.y:i.y<o.y?i.y:o.y,d=a.x>i.x?a.x>o.x?a.x:o.x:i.x>o.x?i.x:o.x,h=a.y>i.y?a.y>o.y?a.y:o.y:i.y>o.y?i.y:o.y,p=ay(l,c,x,n,r),m=ay(d,h,x,n,r);let g=s.prevZ,y=s.nextZ;for(;g&&g.z>=p&&y&&y.z<=m;){if(g!==s.prev&&g!==s.next&&bo(a.x,a.y,i.x,i.y,o.x,o.y,g.x,g.y)&&Ex(g.prev,g,g.next)>=0||(g=g.prevZ,y!==s.prev&&y!==s.next&&bo(a.x,a.y,i.x,i.y,o.x,o.y,y.x,y.y)&&Ex(y.prev,y,y.next)>=0))return!1;y=y.nextZ}for(;g&&g.z>=p;){if(g!==s.prev&&g!==s.next&&bo(a.x,a.y,i.x,i.y,o.x,o.y,g.x,g.y)&&Ex(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;y&&y.z<=m;){if(y!==s.prev&&y!==s.next&&bo(a.x,a.y,i.x,i.y,o.x,o.y,y.x,y.y)&&Ex(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function gte(s,x,n){let r=s;do{const a=r.prev,i=r.next.next;!Mh(a,i)&&zE(a,r,r.next,i)&&ql(a,i)&&ql(i,a)&&(x.push(a.i/n),x.push(r.i/n),x.push(i.i/n),Xl(r),Xl(r.next),r=s=i),r=r.next}while(r!==s);return Ps(r)}function yte(s,x,n,r,a,i){let o=s;do{let l=o.next.next;for(;l!==o.prev;){if(o.i!==l.i&&Cte(o,l)){let c=WE(o,l);o=Ps(o,o.next),c=Ps(c,c.next),Yl(o,x,n,r,a,i),Yl(c,x,n,r,a,i);return}l=l.next}o=o.next}while(o!==s)}function bte(s,x,n,r){const a=[];let i,o,l,c,d;for(i=0,o=x.length;i<o;i++)l=x[i]*r,c=i<o-1?x[i+1]*r:s.length,d=BE(s,l,c,r,!1),d===d.next&&(d.steiner=!0),a.push(Ete(d));for(a.sort(vte),i=0;i<a.length;i++)wte(a[i],n),n=Ps(n,n.next);return n}function vte(s,x){return s.x-x.x}function wte(s,x){if(x=_te(s,x),x){const n=WE(x,s);Ps(x,x.next),Ps(n,n.next)}}function _te(s,x){let n=x;const r=s.x,a=s.y;let i=-1/0,o;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){const m=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(m<=r&&m>i){if(i=m,m===r){if(a===n.y)return n;if(a===n.next.y)return n.next}o=n.x<n.next.x?n:n.next}}n=n.next}while(n!==x);if(!o)return null;if(r===i)return o;const l=o,c=o.x,d=o.y;let h=1/0,p;n=o;do r>=n.x&&n.x>=c&&r!==n.x&&bo(a<d?r:i,a,c,d,a<d?i:r,a,n.x,n.y)&&(p=Math.abs(a-n.y)/(r-n.x),ql(n,s)&&(p<h||p===h&&(n.x>o.x||n.x===o.x&&Ste(o,n)))&&(o=n,h=p)),n=n.next;while(n!==l);return o}function Ste(s,x){return Ex(s.prev,s,x.prev)<0&&Ex(x.next,s,s.next)<0}function Tte(s,x,n,r){let a=s;do a.z===null&&(a.z=ay(a.x,a.y,x,n,r)),a.prevZ=a.prev,a.nextZ=a.next,a=a.next;while(a!==s);a.prevZ.nextZ=null,a.prevZ=null,Ate(a)}function Ate(s){let x,n,r,a,i,o,l,c,d=1;do{for(n=s,s=null,i=null,o=0;n;){for(o++,r=n,l=0,x=0;x<d&&(l++,r=r.nextZ,!!r);x++);for(c=d;l>0||c>0&&r;)l!==0&&(c===0||!r||n.z<=r.z)?(a=n,n=n.nextZ,l--):(a=r,r=r.nextZ,c--),i?i.nextZ=a:s=a,a.prevZ=i,i=a;n=r}i.nextZ=null,d*=2}while(o>1);return s}function ay(s,x,n,r,a){return s=32767*(s-n)*a,x=32767*(x-r)*a,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,x=(x|x<<8)&16711935,x=(x|x<<4)&252645135,x=(x|x<<2)&858993459,x=(x|x<<1)&1431655765,s|x<<1}function Ete(s){let x=s,n=s;do(x.x<n.x||x.x===n.x&&x.y<n.y)&&(n=x),x=x.next;while(x!==s);return n}function bo(s,x,n,r,a,i,o,l){return(a-o)*(x-l)-(s-o)*(i-l)>=0&&(s-o)*(r-l)-(n-o)*(x-l)>=0&&(n-o)*(i-l)-(a-o)*(r-l)>=0}function Cte(s,x){return s.next.i!==x.i&&s.prev.i!==x.i&&!Mte(s,x)&&(ql(s,x)&&ql(x,s)&&Ite(s,x)&&(Ex(s.prev,s,x.prev)||Ex(s,x.prev,x))||Mh(s,x)&&Ex(s.prev,s,s.next)>0&&Ex(x.prev,x,x.next)>0)}function Ex(s,x,n){return(x.y-s.y)*(n.x-x.x)-(x.x-s.x)*(n.y-x.y)}function Mh(s,x){return s.x===x.x&&s.y===x.y}function zE(s,x,n,r){const a=kh(Ex(s,x,n)),i=kh(Ex(s,x,r)),o=kh(Ex(n,r,s)),l=kh(Ex(n,r,x));return!!(a!==i&&o!==l||a===0&&Ih(s,n,x)||i===0&&Ih(s,r,x)||o===0&&Ih(n,s,r)||l===0&&Ih(n,x,r))}function Ih(s,x,n){return x.x<=Math.max(s.x,n.x)&&x.x>=Math.min(s.x,n.x)&&x.y<=Math.max(s.y,n.y)&&x.y>=Math.min(s.y,n.y)}function kh(s){return s>0?1:s<0?-1:0}function Mte(s,x){let n=s;do{if(n.i!==s.i&&n.next.i!==s.i&&n.i!==x.i&&n.next.i!==x.i&&zE(n,n.next,s,x))return!0;n=n.next}while(n!==s);return!1}function ql(s,x){return Ex(s.prev,s,s.next)<0?Ex(s,x,s.next)>=0&&Ex(s,s.prev,x)>=0:Ex(s,x,s.prev)<0||Ex(s,s.next,x)<0}function Ite(s,x){let n=s,r=!1;const a=(s.x+x.x)/2,i=(s.y+x.y)/2;do n.y>i!=n.next.y>i&&n.next.y!==n.y&&a<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next;while(n!==s);return r}function WE(s,x){const n=new iy(s.i,s.x,s.y),r=new iy(x.i,x.x,x.y),a=s.next,i=x.prev;return s.next=x,x.prev=s,n.next=a,a.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function GE(s,x,n,r){const a=new iy(s,x,n);return r?(a.next=r.next,a.prev=r,r.next.prev=a,r.next=a):(a.prev=a,a.next=a),a}function Xl(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function iy(s,x,n){this.i=s,this.x=x,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function kte(s,x,n,r){let a=0;for(let i=x,o=n-r;i<n;i+=r)a+=(s[o]-s[i])*(s[i+1]+s[o+1]),o=i;return a}class Zr{static area(x){const n=x.length;let r=0;for(let a=n-1,i=0;i<n;a=i++)r+=x[a].x*x[i].y-x[i].x*x[a].y;return r*.5}static isClockWise(x){return Zr.area(x)<0}static triangulateShape(x,n){const r=[],a=[],i=[];VE(x),HE(r,x);let o=x.length;n.forEach(VE);for(let c=0;c<n.length;c++)a.push(o),o+=n[c].length,HE(r,n[c]);const l=pte.triangulate(r,a);for(let c=0;c<l.length;c+=3)i.push(l.slice(c,c+3));return i}}function VE(s){const x=s.length;x>2&&s[x-1].equals(s[0])&&s.pop()}function HE(s,x){for(let n=0;n<x.length;n++)s.push(x[n].x),s.push(x[n].y)}class Kl extends Rt{constructor(x=new yo([new n0(.5,.5),new n0(-.5,.5),new n0(-.5,-.5),new n0(.5,-.5)]),n={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:x,options:n},x=Array.isArray(x)?x:[x];const r=this,a=[],i=[];for(let l=0,c=x.length;l<c;l++){const d=x[l];o(d)}this.setAttribute("position",new q0(a,3)),this.setAttribute("uv",new q0(i,2)),this.computeVertexNormals();function o(l){const c=[],d=n.curveSegments!==void 0?n.curveSegments:12,h=n.steps!==void 0?n.steps:1,p=n.depth!==void 0?n.depth:1;let m=n.bevelEnabled!==void 0?n.bevelEnabled:!0,g=n.bevelThickness!==void 0?n.bevelThickness:.2,y=n.bevelSize!==void 0?n.bevelSize:g-.1,b=n.bevelOffset!==void 0?n.bevelOffset:0,v=n.bevelSegments!==void 0?n.bevelSegments:3;const w=n.extrudePath,_=n.UVGenerator!==void 0?n.UVGenerator:Nte;let T,A=!1,E,M,I,C;w&&(T=w.getSpacedPoints(h),A=!0,m=!1,E=w.computeFrenetFrames(h,!1),M=new K,I=new K,C=new K),m||(v=0,g=0,y=0,b=0);const k=l.extractPoints(d);let O=k.shape;const z=k.holes;if(!Zr.isClockWise(O)){O=O.reverse();for(let Te=0,Ie=z.length;Te<Ie;Te++){const Xe=z[Te];Zr.isClockWise(Xe)&&(z[Te]=Xe.reverse())}}const re=Zr.triangulateShape(O,z),Y=O;for(let Te=0,Ie=z.length;Te<Ie;Te++){const Xe=z[Te];O=O.concat(Xe)}function Q(Te,Ie,Xe){return Ie||console.error("THREE.ExtrudeGeometry: vec does not exist"),Ie.clone().multiplyScalar(Xe).add(Te)}const te=O.length,se=re.length;function xe(Te,Ie,Xe){let c0,Ye,I0;const m0=Te.x-Ie.x,d0=Te.y-Ie.y,rt=Xe.x-Te.x,ct=Xe.y-Te.y,ie=m0*m0+d0*d0,$=m0*ct-d0*rt;if(Math.abs($)>Number.EPSILON){const ke=Math.sqrt(ie),Ge=Math.sqrt(rt*rt+ct*ct),s0=Ie.x-d0/ke,p0=Ie.y+m0/ke,K0=Xe.x-ct/Ge,Re=Xe.y+rt/Ge,L0=((K0-s0)*ct-(Re-p0)*rt)/(m0*ct-d0*rt);c0=s0+m0*L0-Te.x,Ye=p0+d0*L0-Te.y;const u0=c0*c0+Ye*Ye;if(u0<=2)return new n0(c0,Ye);I0=Math.sqrt(u0/2)}else{let ke=!1;m0>Number.EPSILON?rt>Number.EPSILON&&(ke=!0):m0<-Number.EPSILON?rt<-Number.EPSILON&&(ke=!0):Math.sign(d0)===Math.sign(ct)&&(ke=!0),ke?(c0=-d0,Ye=m0,I0=Math.sqrt(ie)):(c0=m0,Ye=d0,I0=Math.sqrt(ie/2))}return new n0(c0/I0,Ye/I0)}const ae=[];for(let Te=0,Ie=Y.length,Xe=Ie-1,c0=Te+1;Te<Ie;Te++,Xe++,c0++)Xe===Ie&&(Xe=0),c0===Ie&&(c0=0),ae[Te]=xe(Y[Te],Y[Xe],Y[c0]);const le=[];let de,ue=ae.concat();for(let Te=0,Ie=z.length;Te<Ie;Te++){const Xe=z[Te];de=[];for(let c0=0,Ye=Xe.length,I0=Ye-1,m0=c0+1;c0<Ye;c0++,I0++,m0++)I0===Ye&&(I0=0),m0===Ye&&(m0=0),de[c0]=xe(Xe[c0],Xe[I0],Xe[m0]);le.push(de),ue=ue.concat(de)}for(let Te=0;Te<v;Te++){const Ie=Te/v,Xe=g*Math.cos(Ie*Math.PI/2),c0=y*Math.sin(Ie*Math.PI/2)+b;for(let Ye=0,I0=Y.length;Ye<I0;Ye++){const m0=Q(Y[Ye],ae[Ye],c0);e0(m0.x,m0.y,-Xe)}for(let Ye=0,I0=z.length;Ye<I0;Ye++){const m0=z[Ye];de=le[Ye];for(let d0=0,rt=m0.length;d0<rt;d0++){const ct=Q(m0[d0],de[d0],c0);e0(ct.x,ct.y,-Xe)}}}const ge=y+b;for(let Te=0;Te<te;Te++){const Ie=m?Q(O[Te],ue[Te],ge):O[Te];A?(I.copy(E.normals[0]).multiplyScalar(Ie.x),M.copy(E.binormals[0]).multiplyScalar(Ie.y),C.copy(T[0]).add(I).add(M),e0(C.x,C.y,C.z)):e0(Ie.x,Ie.y,0)}for(let Te=1;Te<=h;Te++)for(let Ie=0;Ie<te;Ie++){const Xe=m?Q(O[Ie],ue[Ie],ge):O[Ie];A?(I.copy(E.normals[Te]).multiplyScalar(Xe.x),M.copy(E.binormals[Te]).multiplyScalar(Xe.y),C.copy(T[Te]).add(I).add(M),e0(C.x,C.y,C.z)):e0(Xe.x,Xe.y,p/h*Te)}for(let Te=v-1;Te>=0;Te--){const Ie=Te/v,Xe=g*Math.cos(Ie*Math.PI/2),c0=y*Math.sin(Ie*Math.PI/2)+b;for(let Ye=0,I0=Y.length;Ye<I0;Ye++){const m0=Q(Y[Ye],ae[Ye],c0);e0(m0.x,m0.y,p+Xe)}for(let Ye=0,I0=z.length;Ye<I0;Ye++){const m0=z[Ye];de=le[Ye];for(let d0=0,rt=m0.length;d0<rt;d0++){const ct=Q(m0[d0],de[d0],c0);A?e0(ct.x,ct.y+T[h-1].y,T[h-1].x+Xe):e0(ct.x,ct.y,p+Xe)}}}pe(),Le();function pe(){const Te=a.length/3;if(m){let Ie=0,Xe=te*Ie;for(let c0=0;c0<se;c0++){const Ye=re[c0];Ze(Ye[2]+Xe,Ye[1]+Xe,Ye[0]+Xe)}Ie=h+v*2,Xe=te*Ie;for(let c0=0;c0<se;c0++){const Ye=re[c0];Ze(Ye[0]+Xe,Ye[1]+Xe,Ye[2]+Xe)}}else{for(let Ie=0;Ie<se;Ie++){const Xe=re[Ie];Ze(Xe[2],Xe[1],Xe[0])}for(let Ie=0;Ie<se;Ie++){const Xe=re[Ie];Ze(Xe[0]+te*h,Xe[1]+te*h,Xe[2]+te*h)}}r.addGroup(Te,a.length/3-Te,0)}function Le(){const Te=a.length/3;let Ie=0;we(Y,Ie),Ie+=Y.length;for(let Xe=0,c0=z.length;Xe<c0;Xe++){const Ye=z[Xe];we(Ye,Ie),Ie+=Ye.length}r.addGroup(Te,a.length/3-Te,1)}function we(Te,Ie){let Xe=Te.length;for(;--Xe>=0;){const c0=Xe;let Ye=Xe-1;Ye<0&&(Ye=Te.length-1);for(let I0=0,m0=h+v*2;I0<m0;I0++){const d0=te*I0,rt=te*(I0+1),ct=Ie+c0+d0,ie=Ie+Ye+d0,$=Ie+Ye+rt,ke=Ie+c0+rt;i0(ct,ie,$,ke)}}}function e0(Te,Ie,Xe){c.push(Te),c.push(Ie),c.push(Xe)}function Ze(Te,Ie,Xe){We(Te),We(Ie),We(Xe);const c0=a.length/3,Ye=_.generateTopUV(r,a,c0-3,c0-2,c0-1);v0(Ye[0]),v0(Ye[1]),v0(Ye[2])}function i0(Te,Ie,Xe,c0){We(Te),We(Ie),We(c0),We(Ie),We(Xe),We(c0);const Ye=a.length/3,I0=_.generateSideWallUV(r,a,Ye-6,Ye-3,Ye-2,Ye-1);v0(I0[0]),v0(I0[1]),v0(I0[3]),v0(I0[1]),v0(I0[2]),v0(I0[3])}function We(Te){a.push(c[Te*3+0]),a.push(c[Te*3+1]),a.push(c[Te*3+2])}function v0(Te){i.push(Te.x),i.push(Te.y)}}}toJSON(){const x=super.toJSON(),n=this.parameters.shapes,r=this.parameters.options;return Rte(n,r,x)}static fromJSON(x,n){const r=[];for(let i=0,o=x.shapes.length;i<o;i++){const l=n[x.shapes[i]];r.push(l)}const a=x.options.extrudePath;return a!==void 0&&(x.options.extrudePath=new ry[a.type]().fromJSON(a)),new Kl(r,x.options)}}const Nte={generateTopUV:function(s,x,n,r,a){const i=x[n*3],o=x[n*3+1],l=x[r*3],c=x[r*3+1],d=x[a*3],h=x[a*3+1];return[new n0(i,o),new n0(l,c),new n0(d,h)]},generateSideWallUV:function(s,x,n,r,a,i){const o=x[n*3],l=x[n*3+1],c=x[n*3+2],d=x[r*3],h=x[r*3+1],p=x[r*3+2],m=x[a*3],g=x[a*3+1],y=x[a*3+2],b=x[i*3],v=x[i*3+1],w=x[i*3+2];return Math.abs(l-h)<Math.abs(o-d)?[new n0(o,1-c),new n0(d,1-p),new n0(m,1-y),new n0(b,1-w)]:[new n0(l,1-c),new n0(h,1-p),new n0(g,1-y),new n0(v,1-w)]}};function Rte(s,x,n){if(n.shapes=[],Array.isArray(s))for(let r=0,a=s.length;r<a;r++){const i=s[r];n.shapes.push(i.uuid)}else n.shapes.push(s.uuid);return n.options=Object.assign({},x),x.extrudePath!==void 0&&(n.options.extrudePath=x.extrudePath.toJSON()),n}class Nh extends Rs{constructor(x=1,n=0){const r=(1+Math.sqrt(5))/2,a=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(a,i,x,n),this.type="IcosahedronGeometry",this.parameters={radius:x,detail:n}}static fromJSON(x){return new Nh(x.radius,x.detail)}}class $l extends Rs{constructor(x=1,n=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],a=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,a,x,n),this.type="OctahedronGeometry",this.parameters={radius:x,detail:n}}static fromJSON(x){return new $l(x.radius,x.detail)}}class Rh extends Rt{constructor(x=.5,n=1,r=8,a=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:x,outerRadius:n,thetaSegments:r,phiSegments:a,thetaStart:i,thetaLength:o},r=Math.max(3,r),a=Math.max(1,a);const l=[],c=[],d=[],h=[];let p=x;const m=(n-x)/a,g=new K,y=new n0;for(let b=0;b<=a;b++){for(let v=0;v<=r;v++){const w=i+v/r*o;g.x=p*Math.cos(w),g.y=p*Math.sin(w),c.push(g.x,g.y,g.z),d.push(0,0,1),y.x=(g.x/n+1)/2,y.y=(g.y/n+1)/2,h.push(y.x,y.y)}p+=m}for(let b=0;b<a;b++){const v=b*(r+1);for(let w=0;w<r;w++){const _=w+v,T=_,A=_+r+1,E=_+r+2,M=_+1;l.push(T,A,M),l.push(A,E,M)}}this.setIndex(l),this.setAttribute("position",new q0(c,3)),this.setAttribute("normal",new q0(d,3)),this.setAttribute("uv",new q0(h,2))}static fromJSON(x){return new Rh(x.innerRadius,x.outerRadius,x.thetaSegments,x.phiSegments,x.thetaStart,x.thetaLength)}}class Ph extends Rt{constructor(x=new yo([new n0(0,.5),new n0(-.5,-.5),new n0(.5,-.5)]),n=12){super(),this.type="ShapeGeometry",this.parameters={shapes:x,curveSegments:n};const r=[],a=[],i=[],o=[];let l=0,c=0;if(Array.isArray(x)===!1)d(x);else for(let h=0;h<x.length;h++)d(x[h]),this.addGroup(l,c,h),l+=c,c=0;this.setIndex(r),this.setAttribute("position",new q0(a,3)),this.setAttribute("normal",new q0(i,3)),this.setAttribute("uv",new q0(o,2));function d(h){const p=a.length/3,m=h.extractPoints(n);let g=m.shape;const y=m.holes;Zr.isClockWise(g)===!1&&(g=g.reverse());for(let v=0,w=y.length;v<w;v++){const _=y[v];Zr.isClockWise(_)===!0&&(y[v]=_.reverse())}const b=Zr.triangulateShape(g,y);for(let v=0,w=y.length;v<w;v++){const _=y[v];g=g.concat(_)}for(let v=0,w=g.length;v<w;v++){const _=g[v];a.push(_.x,_.y,0),i.push(0,0,1),o.push(_.x,_.y)}for(let v=0,w=b.length;v<w;v++){const _=b[v],T=_[0]+p,A=_[1]+p,E=_[2]+p;r.push(T,A,E),c+=3}}}toJSON(){const x=super.toJSON(),n=this.parameters.shapes;return Pte(n,x)}static fromJSON(x,n){const r=[];for(let a=0,i=x.shapes.length;a<i;a++){const o=n[x.shapes[a]];r.push(o)}return new Ph(r,x.curveSegments)}}function Pte(s,x){if(x.shapes=[],Array.isArray(s))for(let n=0,r=s.length;n<r;n++){const a=s[n];x.shapes.push(a.uuid)}else x.shapes.push(s.uuid);return x}class Zl extends Rt{constructor(x=1,n=32,r=16,a=0,i=Math.PI*2,o=0,l=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:x,widthSegments:n,heightSegments:r,phiStart:a,phiLength:i,thetaStart:o,thetaLength:l},n=Math.max(3,Math.floor(n)),r=Math.max(2,Math.floor(r));const c=Math.min(o+l,Math.PI);let d=0;const h=[],p=new K,m=new K,g=[],y=[],b=[],v=[];for(let w=0;w<=r;w++){const _=[],T=w/r;let A=0;w==0&&o==0?A=.5/n:w==r&&c==Math.PI&&(A=-.5/n);for(let E=0;E<=n;E++){const M=E/n;p.x=-x*Math.cos(a+M*i)*Math.sin(o+T*l),p.y=x*Math.cos(o+T*l),p.z=x*Math.sin(a+M*i)*Math.sin(o+T*l),y.push(p.x,p.y,p.z),m.copy(p).normalize(),b.push(m.x,m.y,m.z),v.push(M+A,1-T),_.push(d++)}h.push(_)}for(let w=0;w<r;w++)for(let _=0;_<n;_++){const T=h[w][_+1],A=h[w][_],E=h[w+1][_],M=h[w+1][_+1];(w!==0||o>0)&&g.push(T,A,M),(w!==r-1||c<Math.PI)&&g.push(A,E,M)}this.setIndex(g),this.setAttribute("position",new q0(y,3)),this.setAttribute("normal",new q0(b,3)),this.setAttribute("uv",new q0(v,2))}static fromJSON(x){return new Zl(x.radius,x.widthSegments,x.heightSegments,x.phiStart,x.phiLength,x.thetaStart,x.thetaLength)}}class Lh extends Rs{constructor(x=1,n=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],a=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,a,x,n),this.type="TetrahedronGeometry",this.parameters={radius:x,detail:n}}static fromJSON(x){return new Lh(x.radius,x.detail)}}class Dh extends Rt{constructor(x=1,n=.4,r=8,a=6,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:x,tube:n,radialSegments:r,tubularSegments:a,arc:i},r=Math.floor(r),a=Math.floor(a);const o=[],l=[],c=[],d=[],h=new K,p=new K,m=new K;for(let g=0;g<=r;g++)for(let y=0;y<=a;y++){const b=y/a*i,v=g/r*Math.PI*2;p.x=(x+n*Math.cos(v))*Math.cos(b),p.y=(x+n*Math.cos(v))*Math.sin(b),p.z=n*Math.sin(v),l.push(p.x,p.y,p.z),h.x=x*Math.cos(b),h.y=x*Math.sin(b),m.subVectors(p,h).normalize(),c.push(m.x,m.y,m.z),d.push(y/a),d.push(g/r)}for(let g=1;g<=r;g++)for(let y=1;y<=a;y++){const b=(a+1)*g+y-1,v=(a+1)*(g-1)+y-1,w=(a+1)*(g-1)+y,_=(a+1)*g+y;o.push(b,v,_),o.push(v,w,_)}this.setIndex(o),this.setAttribute("position",new q0(l,3)),this.setAttribute("normal",new q0(c,3)),this.setAttribute("uv",new q0(d,2))}static fromJSON(x){return new Dh(x.radius,x.tube,x.radialSegments,x.tubularSegments,x.arc)}}class Oh extends Rt{constructor(x=1,n=.4,r=64,a=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:x,tube:n,tubularSegments:r,radialSegments:a,p:i,q:o},r=Math.floor(r),a=Math.floor(a);const l=[],c=[],d=[],h=[],p=new K,m=new K,g=new K,y=new K,b=new K,v=new K,w=new K;for(let T=0;T<=r;++T){const A=T/r*i*Math.PI*2;_(A,i,o,x,g),_(A+.01,i,o,x,y),v.subVectors(y,g),w.addVectors(y,g),b.crossVectors(v,w),w.crossVectors(b,v),b.normalize(),w.normalize();for(let E=0;E<=a;++E){const M=E/a*Math.PI*2,I=-n*Math.cos(M),C=n*Math.sin(M);p.x=g.x+(I*w.x+C*b.x),p.y=g.y+(I*w.y+C*b.y),p.z=g.z+(I*w.z+C*b.z),c.push(p.x,p.y,p.z),m.subVectors(p,g).normalize(),d.push(m.x,m.y,m.z),h.push(T/r),h.push(E/a)}}for(let T=1;T<=r;T++)for(let A=1;A<=a;A++){const E=(a+1)*(T-1)+(A-1),M=(a+1)*T+(A-1),I=(a+1)*T+A,C=(a+1)*(T-1)+A;l.push(E,M,C),l.push(M,I,C)}this.setIndex(l),this.setAttribute("position",new q0(c,3)),this.setAttribute("normal",new q0(d,3)),this.setAttribute("uv",new q0(h,2));function _(T,A,E,M,I){const C=Math.cos(T),k=Math.sin(T),O=E/A*T,z=Math.cos(O);I.x=M*(2+z)*.5*C,I.y=M*(2+z)*k*.5,I.z=M*Math.sin(O)*.5}}static fromJSON(x){return new Oh(x.radius,x.tube,x.tubularSegments,x.radialSegments,x.p,x.q)}}class Fh extends Rt{constructor(x=new FE(new K(-1,-1,0),new K(-1,1,0),new K(1,1,0)),n=64,r=1,a=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:x,tubularSegments:n,radius:r,radialSegments:a,closed:i};const o=x.computeFrenetFrames(n,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const l=new K,c=new K,d=new n0;let h=new K;const p=[],m=[],g=[],y=[];b(),this.setIndex(y),this.setAttribute("position",new q0(p,3)),this.setAttribute("normal",new q0(m,3)),this.setAttribute("uv",new q0(g,2));function b(){for(let T=0;T<n;T++)v(T);v(i===!1?n:0),_(),w()}function v(T){h=x.getPointAt(T/n,h);const A=o.normals[T],E=o.binormals[T];for(let M=0;M<=a;M++){const I=M/a*Math.PI*2,C=Math.sin(I),k=-Math.cos(I);c.x=k*A.x+C*E.x,c.y=k*A.y+C*E.y,c.z=k*A.z+C*E.z,c.normalize(),m.push(c.x,c.y,c.z),l.x=h.x+r*c.x,l.y=h.y+r*c.y,l.z=h.z+r*c.z,p.push(l.x,l.y,l.z)}}function w(){for(let T=1;T<=n;T++)for(let A=1;A<=a;A++){const E=(a+1)*(T-1)+(A-1),M=(a+1)*T+(A-1),I=(a+1)*T+A,C=(a+1)*(T-1)+A;y.push(E,M,C),y.push(M,I,C)}}function _(){for(let T=0;T<=n;T++)for(let A=0;A<=a;A++)d.x=T/n,d.y=A/a,g.push(d.x,d.y)}}toJSON(){const x=super.toJSON();return x.path=this.parameters.path.toJSON(),x}static fromJSON(x){return new Fh(new ry[x.path.type]().fromJSON(x.path),x.tubularSegments,x.radius,x.radialSegments,x.closed)}}class Lte extends Rt{constructor(x=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:x},x!==null){const n=[],r=new Set,a=new K,i=new K;if(x.index!==null){const o=x.attributes.position,l=x.index;let c=x.groups;c.length===0&&(c=[{start:0,count:l.count,materialIndex:0}]);for(let d=0,h=c.length;d<h;++d){const p=c[d],m=p.start,g=p.count;for(let y=m,b=m+g;y<b;y+=3)for(let v=0;v<3;v++){const w=l.getX(y+v),_=l.getX(y+(v+1)%3);a.fromBufferAttribute(o,w),i.fromBufferAttribute(o,_),YE(a,i,r)===!0&&(n.push(a.x,a.y,a.z),n.push(i.x,i.y,i.z))}}}else{const o=x.attributes.position;for(let l=0,c=o.count/3;l<c;l++)for(let d=0;d<3;d++){const h=3*l+d,p=3*l+(d+1)%3;a.fromBufferAttribute(o,h),i.fromBufferAttribute(o,p),YE(a,i,r)===!0&&(n.push(a.x,a.y,a.z),n.push(i.x,i.y,i.z))}}this.setAttribute("position",new q0(n,3))}}}function YE(s,x,n){const r=`${s.x},${s.y},${s.z}-${x.x},${x.y},${x.z}`,a=`${x.x},${x.y},${x.z}-${s.x},${s.y},${s.z}`;return n.has(r)===!0||n.has(a)===!0?!1:(n.add(r),n.add(a),!0)}var qE=Object.freeze({__proto__:null,BoxGeometry:za,BoxBufferGeometry:za,CapsuleGeometry:wh,CapsuleBufferGeometry:wh,CircleGeometry:_h,CircleBufferGeometry:_h,ConeGeometry:Sh,ConeBufferGeometry:Sh,CylinderGeometry:go,CylinderBufferGeometry:go,DodecahedronGeometry:Th,DodecahedronBufferGeometry:Th,EdgesGeometry:hte,ExtrudeGeometry:Kl,ExtrudeBufferGeometry:Kl,IcosahedronGeometry:Nh,IcosahedronBufferGeometry:Nh,LatheGeometry:Hl,LatheBufferGeometry:Hl,OctahedronGeometry:$l,OctahedronBufferGeometry:$l,PlaneGeometry:Pl,PlaneBufferGeometry:Pl,PolyhedronGeometry:Rs,PolyhedronBufferGeometry:Rs,RingGeometry:Rh,RingBufferGeometry:Rh,ShapeGeometry:Ph,ShapeBufferGeometry:Ph,SphereGeometry:Zl,SphereBufferGeometry:Zl,TetrahedronGeometry:Lh,TetrahedronBufferGeometry:Lh,TorusGeometry:Dh,TorusBufferGeometry:Dh,TorusKnotGeometry:Oh,TorusKnotBufferGeometry:Oh,TubeGeometry:Fh,TubeBufferGeometry:Fh,WireframeGeometry:Lte});class Dte extends null{constructor(x){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new M0(0),this.transparent=!0,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.fog=x.fog,this}}class Ote extends null{constructor(x){super(x),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class qa extends y2{constructor(x){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new M0(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new M0(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ka,this.normalScale=new n0(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.defines={STANDARD:""},this.color.copy(x.color),this.roughness=x.roughness,this.metalness=x.metalness,this.map=x.map,this.lightMap=x.lightMap,this.lightMapIntensity=x.lightMapIntensity,this.aoMap=x.aoMap,this.aoMapIntensity=x.aoMapIntensity,this.emissive.copy(x.emissive),this.emissiveMap=x.emissiveMap,this.emissiveIntensity=x.emissiveIntensity,this.bumpMap=x.bumpMap,this.bumpScale=x.bumpScale,this.normalMap=x.normalMap,this.normalMapType=x.normalMapType,this.normalScale.copy(x.normalScale),this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.roughnessMap=x.roughnessMap,this.metalnessMap=x.metalnessMap,this.alphaMap=x.alphaMap,this.envMap=x.envMap,this.envMapIntensity=x.envMapIntensity,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.wireframeLinecap=x.wireframeLinecap,this.wireframeLinejoin=x.wireframeLinejoin,this.flatShading=x.flatShading,this.fog=x.fog,this}}class Ls extends qa{constructor(x){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new n0(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Gx(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new M0(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new M0(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new M0(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(x)}get sheen(){return this._sheen}set sheen(x){this._sheen>0!=x>0&&this.version++,this._sheen=x}get clearcoat(){return this._clearcoat}set clearcoat(x){this._clearcoat>0!=x>0&&this.version++,this._clearcoat=x}get iridescence(){return this._iridescence}set iridescence(x){this._iridescence>0!=x>0&&this.version++,this._iridescence=x}get transmission(){return this._transmission}set transmission(x){this._transmission>0!=x>0&&this.version++,this._transmission=x}copy(x){return super.copy(x),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=x.clearcoat,this.clearcoatMap=x.clearcoatMap,this.clearcoatRoughness=x.clearcoatRoughness,this.clearcoatRoughnessMap=x.clearcoatRoughnessMap,this.clearcoatNormalMap=x.clearcoatNormalMap,this.clearcoatNormalScale.copy(x.clearcoatNormalScale),this.ior=x.ior,this.iridescence=x.iridescence,this.iridescenceMap=x.iridescenceMap,this.iridescenceIOR=x.iridescenceIOR,this.iridescenceThicknessRange=[...x.iridescenceThicknessRange],this.iridescenceThicknessMap=x.iridescenceThicknessMap,this.sheen=x.sheen,this.sheenColor.copy(x.sheenColor),this.sheenColorMap=x.sheenColorMap,this.sheenRoughness=x.sheenRoughness,this.sheenRoughnessMap=x.sheenRoughnessMap,this.transmission=x.transmission,this.transmissionMap=x.transmissionMap,this.thickness=x.thickness,this.thicknessMap=x.thicknessMap,this.attenuationDistance=x.attenuationDistance,this.attenuationColor.copy(x.attenuationColor),this.specularIntensity=x.specularIntensity,this.specularIntensityMap=x.specularIntensityMap,this.specularColor.copy(x.specularColor),this.specularColorMap=x.specularColorMap,this}}class Fte extends null{constructor(x){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new M0(16777215),this.specular=new M0(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new M0(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ka,this.normalScale=new n0(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Nd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.specular.copy(x.specular),this.shininess=x.shininess,this.map=x.map,this.lightMap=x.lightMap,this.lightMapIntensity=x.lightMapIntensity,this.aoMap=x.aoMap,this.aoMapIntensity=x.aoMapIntensity,this.emissive.copy(x.emissive),this.emissiveMap=x.emissiveMap,this.emissiveIntensity=x.emissiveIntensity,this.bumpMap=x.bumpMap,this.bumpScale=x.bumpScale,this.normalMap=x.normalMap,this.normalMapType=x.normalMapType,this.normalScale.copy(x.normalScale),this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.specularMap=x.specularMap,this.alphaMap=x.alphaMap,this.envMap=x.envMap,this.combine=x.combine,this.reflectivity=x.reflectivity,this.refractionRatio=x.refractionRatio,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.wireframeLinecap=x.wireframeLinecap,this.wireframeLinejoin=x.wireframeLinejoin,this.flatShading=x.flatShading,this.fog=x.fog,this}}class Ute extends null{constructor(x){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new M0(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new M0(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ka,this.normalScale=new n0(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.map=x.map,this.gradientMap=x.gradientMap,this.lightMap=x.lightMap,this.lightMapIntensity=x.lightMapIntensity,this.aoMap=x.aoMap,this.aoMapIntensity=x.aoMapIntensity,this.emissive.copy(x.emissive),this.emissiveMap=x.emissiveMap,this.emissiveIntensity=x.emissiveIntensity,this.bumpMap=x.bumpMap,this.bumpScale=x.bumpScale,this.normalMap=x.normalMap,this.normalMapType=x.normalMapType,this.normalScale.copy(x.normalScale),this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.alphaMap=x.alphaMap,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.wireframeLinecap=x.wireframeLinecap,this.wireframeLinejoin=x.wireframeLinejoin,this.fog=x.fog,this}}class Bte extends null{constructor(x){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ka,this.normalScale=new n0(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(x)}copy(x){return super.copy(x),this.bumpMap=x.bumpMap,this.bumpScale=x.bumpScale,this.normalMap=x.normalMap,this.normalMapType=x.normalMapType,this.normalScale.copy(x.normalScale),this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.flatShading=x.flatShading,this}}class zte extends null{constructor(x){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new M0(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new M0(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Nd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.color.copy(x.color),this.map=x.map,this.lightMap=x.lightMap,this.lightMapIntensity=x.lightMapIntensity,this.aoMap=x.aoMap,this.aoMapIntensity=x.aoMapIntensity,this.emissive.copy(x.emissive),this.emissiveMap=x.emissiveMap,this.emissiveIntensity=x.emissiveIntensity,this.specularMap=x.specularMap,this.alphaMap=x.alphaMap,this.envMap=x.envMap,this.combine=x.combine,this.reflectivity=x.reflectivity,this.refractionRatio=x.refractionRatio,this.wireframe=x.wireframe,this.wireframeLinewidth=x.wireframeLinewidth,this.wireframeLinecap=x.wireframeLinecap,this.wireframeLinejoin=x.wireframeLinejoin,this.fog=x.fog,this}}class Wte extends null{constructor(x){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new M0(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ka,this.normalScale=new n0(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(x)}copy(x){return super.copy(x),this.defines={MATCAP:""},this.color.copy(x.color),this.matcap=x.matcap,this.map=x.map,this.bumpMap=x.bumpMap,this.bumpScale=x.bumpScale,this.normalMap=x.normalMap,this.normalMapType=x.normalMapType,this.normalScale.copy(x.normalScale),this.displacementMap=x.displacementMap,this.displacementScale=x.displacementScale,this.displacementBias=x.displacementBias,this.alphaMap=x.alphaMap,this.flatShading=x.flatShading,this.fog=x.fog,this}}class Gte extends null{constructor(x){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(x)}copy(x){return super.copy(x),this.scale=x.scale,this.dashSize=x.dashSize,this.gapSize=x.gapSize,this}}function B2(s,x,n){return oy(s)?new s.constructor(s.subarray(x,n!==void 0?n:s.length)):s.slice(x,n)}function Xa(s,x,n){return!s||!n&&s.constructor===x?s:typeof x.BYTES_PER_ELEMENT=="number"?new x(s):Array.prototype.slice.call(s)}function oy(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function XE(s){function x(a,i){return s[a]-s[i]}const n=s.length,r=new Array(n);for(let a=0;a!==n;++a)r[a]=a;return r.sort(x),r}function ly(s,x,n){const r=s.length,a=new s.constructor(r);for(let i=0,o=0;o!==r;++i){const l=n[i]*x;for(let c=0;c!==x;++c)a[o++]=s[l+c]}return a}function cy(s,x,n,r){let a=1,i=s[0];for(;i!==void 0&&i[r]===void 0;)i=s[a++];if(i===void 0)return;let o=i[r];if(o!==void 0)if(Array.isArray(o))do o=i[r],o!==void 0&&(x.push(i.time),n.push.apply(n,o)),i=s[a++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[r],o!==void 0&&(x.push(i.time),o.toArray(n,n.length)),i=s[a++];while(i!==void 0);else do o=i[r],o!==void 0&&(x.push(i.time),n.push(o)),i=s[a++];while(i!==void 0)}function Vte(s,x,n,r,a=30){const i=s.clone();i.name=x;const o=[];for(let c=0;c<i.tracks.length;++c){const d=i.tracks[c],h=d.getValueSize(),p=[],m=[];for(let g=0;g<d.times.length;++g){const y=d.times[g]*a;if(!(y<n||y>=r)){p.push(d.times[g]);for(let b=0;b<h;++b)m.push(d.values[g*h+b])}}p.length!==0&&(d.times=Xa(p,d.times.constructor),d.values=Xa(m,d.values.constructor),o.push(d))}i.tracks=o;let l=1/0;for(let c=0;c<i.tracks.length;++c)l>i.tracks[c].times[0]&&(l=i.tracks[c].times[0]);for(let c=0;c<i.tracks.length;++c)i.tracks[c].shift(-1*l);return i.resetDuration(),i}function Hte(s,x=0,n=s,r=30){r<=0&&(r=30);const a=n.tracks.length,i=x/r;for(let o=0;o<a;++o){const l=n.tracks[o],c=l.ValueTypeName;if(c==="bool"||c==="string")continue;const d=s.tracks.find(function(w){return w.name===l.name&&w.ValueTypeName===c});if(d===void 0)continue;let h=0;const p=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=p/3);let m=0;const g=d.getValueSize();d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=g/3);const y=l.times.length-1;let b;if(i<=l.times[0]){const w=h,_=p-h;b=B2(l.values,w,_)}else if(i>=l.times[y]){const w=y*p+h,_=w+p-h;b=B2(l.values,w,_)}else{const w=l.createInterpolant(),_=h,T=p-h;w.evaluate(i),b=B2(w.resultBuffer,_,T)}c==="quaternion"&&new Bn().fromArray(b).normalize().conjugate().toArray(b);const v=d.times.length;for(let w=0;w<v;++w){const _=w*g+m;if(c==="quaternion")Bn.multiplyQuaternionsFlat(d.values,_,b,0,d.values,_);else{const T=g-m*2;for(let A=0;A<T;++A)d.values[_+A]-=b[A]}}}return s.blendMode=hA,s}var kre=Object.freeze({__proto__:null,arraySlice:B2,convertArray:Xa,isTypedArray:oy,getKeyframeOrder:XE,sortedArray:ly,flattenJSON:cy,subclip:Vte,makeClipAdditive:Hte});class Jl{constructor(x,n,r,a){this.parameterPositions=x,this._cachedIndex=0,this.resultBuffer=a!==void 0?a:new n.constructor(r),this.sampleValues=n,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(x){const n=this.parameterPositions;let r=this._cachedIndex,a=n[r],i=n[r-1];e:{t:{let o;x:{n:if(!(x<a)){for(let l=r+2;;){if(a===void 0){if(x<i)break n;return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===l)break;if(i=a,a=n[++r],x<a)break t}o=n.length;break x}if(!(x>=i)){const l=n[1];x<l&&(r=2,i=l);for(let c=r-2;;){if(i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===c)break;if(a=i,i=n[--r-1],x>=i)break t}o=r,r=0;break x}break e}for(;r<o;){const l=r+o>>>1;x<n[l]?o=l:r=l+1}if(a=n[r],i=n[r-1],i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(a===void 0)return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,i,a)}return this.interpolate_(r,i,x,a)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(x){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,i=x*a;for(let o=0;o!==a;++o)n[o]=r[i+o];return n}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Yte extends Jl{constructor(x,n,r,a){super(x,n,r,a),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Hi,endingEnd:Hi}}intervalChanged_(x,n,r){const a=this.parameterPositions;let i=x-2,o=x+1,l=a[i],c=a[o];if(l===void 0)switch(this.getSettings_().endingStart){case Yi:i=x,l=2*n-r;break;case Dd:i=a.length-2,l=n+a[i]-a[i+1];break;default:i=x,l=r}if(c===void 0)switch(this.getSettings_().endingEnd){case Yi:o=x,c=2*r-n;break;case Dd:o=1,c=r+a[1]-a[0];break;default:o=x-1,c=n}const d=(r-n)*.5,h=this.valueSize;this._weightPrev=d/(n-l),this._weightNext=d/(c-r),this._offsetPrev=i*h,this._offsetNext=o*h}interpolate_(x,n,r,a){const i=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=x*l,d=c-l,h=this._offsetPrev,p=this._offsetNext,m=this._weightPrev,g=this._weightNext,y=(r-n)/(a-n),b=y*y,v=b*y,w=-m*v+2*m*b-m*y,_=(1+m)*v+(-1.5-2*m)*b+(-.5+m)*y+1,T=(-1-g)*v+(1.5+g)*b+.5*y,A=g*v-g*b;for(let E=0;E!==l;++E)i[E]=w*o[h+E]+_*o[d+E]+T*o[c+E]+A*o[p+E];return i}}class KE extends Jl{constructor(x,n,r,a){super(x,n,r,a)}interpolate_(x,n,r,a){const i=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=x*l,d=c-l,h=(r-n)/(a-n),p=1-h;for(let m=0;m!==l;++m)i[m]=o[d+m]*p+o[c+m]*h;return i}}class qte extends Jl{constructor(x,n,r,a){super(x,n,r,a)}interpolate_(x){return this.copySampleValue_(x-1)}}class yr{constructor(x,n,r,a){if(x===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(n===void 0||n.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+x);this.name=x,this.times=Xa(n,this.TimeBufferType),this.values=Xa(r,this.ValueBufferType),this.setInterpolation(a||this.DefaultInterpolation)}static toJSON(x){const n=x.constructor;let r;if(n.toJSON!==this.toJSON)r=n.toJSON(x);else{r={name:x.name,times:Xa(x.times,Array),values:Xa(x.values,Array)};const a=x.getInterpolation();a!==x.DefaultInterpolation&&(r.interpolation=a)}return r.type=x.ValueTypeName,r}InterpolantFactoryMethodDiscrete(x){return new qte(this.times,this.values,this.getValueSize(),x)}InterpolantFactoryMethodLinear(x){return new KE(this.times,this.values,this.getValueSize(),x)}InterpolantFactoryMethodSmooth(x){return new Yte(this.times,this.values,this.getValueSize(),x)}setInterpolation(x){let n;switch(x){case Al:n=this.InterpolantFactoryMethodDiscrete;break;case Vi:n=this.InterpolantFactoryMethodLinear;break;case s1:n=this.InterpolantFactoryMethodSmooth;break}if(n===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(x!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(r);return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=n,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Al;case this.InterpolantFactoryMethodLinear:return Vi;case this.InterpolantFactoryMethodSmooth:return s1}}getValueSize(){return this.values.length/this.times.length}shift(x){if(x!==0){const n=this.times;for(let r=0,a=n.length;r!==a;++r)n[r]+=x}return this}scale(x){if(x!==1){const n=this.times;for(let r=0,a=n.length;r!==a;++r)n[r]*=x}return this}trim(x,n){const r=this.times,a=r.length;let i=0,o=a-1;for(;i!==a&&r[i]<x;)++i;for(;o!==-1&&r[o]>n;)--o;if(++o,i!==0||o!==a){i>=o&&(o=Math.max(o,1),i=o-1);const l=this.getValueSize();this.times=B2(r,i,o),this.values=B2(this.values,i*l,o*l)}return this}validate(){let x=!0;const n=this.getValueSize();n-Math.floor(n)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),x=!1);const r=this.times,a=this.values,i=r.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),x=!1);let o=null;for(let l=0;l!==i;l++){const c=r[l];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,l,c),x=!1;break}if(o!==null&&o>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,l,c,o),x=!1;break}o=c}if(a!==void 0&&oy(a))for(let l=0,c=a.length;l!==c;++l){const d=a[l];if(isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,d),x=!1;break}}return x}optimize(){const x=B2(this.times),n=B2(this.values),r=this.getValueSize(),a=this.getInterpolation()===s1,i=x.length-1;let o=1;for(let l=1;l<i;++l){let c=!1;const d=x[l],h=x[l+1];if(d!==h&&(l!==1||d!==x[0]))if(a)c=!0;else{const p=l*r,m=p-r,g=p+r;for(let y=0;y!==r;++y){const b=n[p+y];if(b!==n[m+y]||b!==n[g+y]){c=!0;break}}}if(c){if(l!==o){x[o]=x[l];const p=l*r,m=o*r;for(let g=0;g!==r;++g)n[m+g]=n[p+g]}++o}}if(i>0){x[o]=x[i];for(let l=i*r,c=o*r,d=0;d!==r;++d)n[c+d]=n[l+d];++o}return o!==x.length?(this.times=B2(x,0,o),this.values=B2(n,0,o*r)):(this.times=x,this.values=n),this}clone(){const x=B2(this.times,0),n=B2(this.values,0),r=this.constructor,a=new r(this.name,x,n);return a.createInterpolant=this.createInterpolant,a}}yr.prototype.TimeBufferType=Float32Array,yr.prototype.ValueBufferType=Float32Array,yr.prototype.DefaultInterpolation=Vi;class vo extends yr{}vo.prototype.ValueTypeName="bool",vo.prototype.ValueBufferType=Array,vo.prototype.DefaultInterpolation=Al,vo.prototype.InterpolantFactoryMethodLinear=void 0,vo.prototype.InterpolantFactoryMethodSmooth=void 0;class $E extends yr{}$E.prototype.ValueTypeName="color";class Ql extends yr{}Ql.prototype.ValueTypeName="number";class Xte extends Jl{constructor(x,n,r,a){super(x,n,r,a)}interpolate_(x,n,r,a){const i=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=(r-n)/(a-n);let d=x*l;for(let h=d+l;d!==h;d+=4)Bn.slerpFlat(i,0,o,d-l,o,d,c);return i}}class Ka extends yr{InterpolantFactoryMethodLinear(x){return new Xte(this.times,this.values,this.getValueSize(),x)}}Ka.prototype.ValueTypeName="quaternion",Ka.prototype.DefaultInterpolation=Vi,Ka.prototype.InterpolantFactoryMethodSmooth=void 0;class wo extends yr{}wo.prototype.ValueTypeName="string",wo.prototype.ValueBufferType=Array,wo.prototype.DefaultInterpolation=Al,wo.prototype.InterpolantFactoryMethodLinear=void 0,wo.prototype.InterpolantFactoryMethodSmooth=void 0;class jl extends yr{}jl.prototype.ValueTypeName="vector";class ec{constructor(x,n=-1,r,a=a1){this.name=x,this.tracks=r,this.duration=n,this.blendMode=a,this.uuid=f2(),this.duration<0&&this.resetDuration()}static parse(x){const n=[],r=x.tracks,a=1/(x.fps||1);for(let o=0,l=r.length;o!==l;++o)n.push($te(r[o]).scale(a));const i=new this(x.name,x.duration,n,x.blendMode);return i.uuid=x.uuid,i}static toJSON(x){const n=[],r=x.tracks,a={name:x.name,duration:x.duration,tracks:n,uuid:x.uuid,blendMode:x.blendMode};for(let i=0,o=r.length;i!==o;++i)n.push(yr.toJSON(r[i]));return a}static CreateFromMorphTargetSequence(x,n,r,a){const i=n.length,o=[];for(let l=0;l<i;l++){let c=[],d=[];c.push((l+i-1)%i,l,(l+1)%i),d.push(0,1,0);const h=XE(c);c=ly(c,1,h),d=ly(d,1,h),!a&&c[0]===0&&(c.push(i),d.push(d[0])),o.push(new Ql(".morphTargetInfluences["+n[l].name+"]",c,d).scale(1/r))}return new this(x,-1,o)}static findByName(x,n){let r=x;if(!Array.isArray(x)){const a=x;r=a.geometry&&a.geometry.animations||a.animations}for(let a=0;a<r.length;a++)if(r[a].name===n)return r[a];return null}static CreateClipsFromMorphTargetSequences(x,n,r){const a={},i=/^([\w-]*?)([\d]+)$/;for(let l=0,c=x.length;l<c;l++){const d=x[l],h=d.name.match(i);if(h&&h.length>1){const p=h[1];let m=a[p];m||(a[p]=m=[]),m.push(d)}}const o=[];for(const l in a)o.push(this.CreateFromMorphTargetSequence(l,a[l],n,r));return o}static parseAnimation(x,n){if(!x)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(p,m,g,y,b){if(g.length!==0){const v=[],w=[];cy(g,v,w,y),v.length!==0&&b.push(new p(m,v,w))}},a=[],i=x.name||"default",o=x.fps||30,l=x.blendMode;let c=x.length||-1;const d=x.hierarchy||[];for(let p=0;p<d.length;p++){const m=d[p].keys;if(!(!m||m.length===0))if(m[0].morphTargets){const g={};let y;for(y=0;y<m.length;y++)if(m[y].morphTargets)for(let b=0;b<m[y].morphTargets.length;b++)g[m[y].morphTargets[b]]=-1;for(const b in g){const v=[],w=[];for(let _=0;_!==m[y].morphTargets.length;++_){const T=m[y];v.push(T.time),w.push(T.morphTarget===b?1:0)}a.push(new Ql(".morphTargetInfluence["+b+"]",v,w))}c=g.length*o}else{const g=".bones["+n[p].name+"]";r(jl,g+".position",m,"pos",a),r(Ka,g+".quaternion",m,"rot",a),r(jl,g+".scale",m,"scl",a)}}return a.length===0?null:new this(i,c,a,l)}resetDuration(){const x=this.tracks;let n=0;for(let r=0,a=x.length;r!==a;++r){const i=this.tracks[r];n=Math.max(n,i.times[i.times.length-1])}return this.duration=n,this}trim(){for(let x=0;x<this.tracks.length;x++)this.tracks[x].trim(0,this.duration);return this}validate(){let x=!0;for(let n=0;n<this.tracks.length;n++)x=x&&this.tracks[n].validate();return x}optimize(){for(let x=0;x<this.tracks.length;x++)this.tracks[x].optimize();return this}clone(){const x=[];for(let n=0;n<this.tracks.length;n++)x.push(this.tracks[n].clone());return new this.constructor(this.name,this.duration,x,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Kte(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ql;case"vector":case"vector2":case"vector3":case"vector4":return jl;case"color":return $E;case"quaternion":return Ka;case"bool":case"boolean":return vo;case"string":return wo}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function $te(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const x=Kte(s.type);if(s.times===void 0){const n=[],r=[];cy(s.keys,n,r,"value"),s.times=n,s.values=r}return x.parse!==void 0?x.parse(s):new x(s.name,s.times,s.values,s.interpolation)}const _o={enabled:!1,files:{},add:function(s,x){this.enabled!==!1&&(this.files[s]=x)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class ZE{constructor(x,n,r){const a=this;let i=!1,o=0,l=0,c;const d=[];this.onStart=void 0,this.onLoad=x,this.onProgress=n,this.onError=r,this.itemStart=function(h){l++,i===!1&&a.onStart!==void 0&&a.onStart(h,o,l),i=!0},this.itemEnd=function(h){o++,a.onProgress!==void 0&&a.onProgress(h,o,l),o===l&&(i=!1,a.onLoad!==void 0&&a.onLoad())},this.itemError=function(h){a.onError!==void 0&&a.onError(h)},this.resolveURL=function(h){return c?c(h):h},this.setURLModifier=function(h){return c=h,this},this.addHandler=function(h,p){return d.push(h,p),this},this.removeHandler=function(h){const p=d.indexOf(h);return p!==-1&&d.splice(p,2),this},this.getHandler=function(h){for(let p=0,m=d.length;p<m;p+=2){const g=d[p],y=d[p+1];if(g.global&&(g.lastIndex=0),g.test(h))return y}return null}}}const Zte=new ZE;class $a{constructor(x){this.manager=x!==void 0?x:Zte,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(x,n){const r=this;return new Promise(function(a,i){r.load(x,a,n,i)})}parse(){}setCrossOrigin(x){return this.crossOrigin=x,this}setWithCredentials(x){return this.withCredentials=x,this}setPath(x){return this.path=x,this}setResourcePath(x){return this.resourcePath=x,this}setRequestHeader(x){return this.requestHeader=x,this}}const Jr={};class Jte extends Error{constructor(x,n){super(x),this.response=n}}class rr extends $a{constructor(x){super(x)}load(x,n,r,a){x===void 0&&(x=""),this.path!==void 0&&(x=this.path+x),x=this.manager.resolveURL(x);const i=_o.get(x);if(i!==void 0)return this.manager.itemStart(x),setTimeout(()=>{n&&n(i),this.manager.itemEnd(x)},0),i;if(Jr[x]!==void 0){Jr[x].push({onLoad:n,onProgress:r,onError:a});return}Jr[x]=[],Jr[x].push({onLoad:n,onProgress:r,onError:a});const o=new Request(x,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),l=this.mimeType,c=this.responseType;fetch(o).then(d=>{if(d.status===200||d.status===0){if(d.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||d.body===void 0||d.body.getReader===void 0)return d;const h=Jr[x],p=d.body.getReader(),m=d.headers.get("Content-Length"),g=m?parseInt(m):0,y=g!==0;let b=0;const v=new ReadableStream({start(w){_();function _(){p.read().then(({done:T,value:A})=>{if(T)w.close();else{b+=A.byteLength;const E=new ProgressEvent("progress",{lengthComputable:y,loaded:b,total:g});for(let M=0,I=h.length;M<I;M++){const C=h[M];C.onProgress&&C.onProgress(E)}w.enqueue(A),_()}})}}});return new Response(v)}else throw new Jte(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,d)}).then(d=>{switch(c){case"arraybuffer":return d.arrayBuffer();case"blob":return d.blob();case"document":return d.text().then(h=>new DOMParser().parseFromString(h,l));case"json":return d.json();default:if(l===void 0)return d.text();{const p=/charset="?([^;"\s]*)"?/i.exec(l),m=p&&p[1]?p[1].toLowerCase():void 0,g=new TextDecoder(m);return d.arrayBuffer().then(y=>g.decode(y))}}}).then(d=>{_o.add(x,d);const h=Jr[x];delete Jr[x];for(let p=0,m=h.length;p<m;p++){const g=h[p];g.onLoad&&g.onLoad(d)}}).catch(d=>{const h=Jr[x];if(h===void 0)throw this.manager.itemError(x),d;delete Jr[x];for(let p=0,m=h.length;p<m;p++){const g=h[p];g.onError&&g.onError(d)}this.manager.itemError(x)}).finally(()=>{this.manager.itemEnd(x)}),this.manager.itemStart(x)}setResponseType(x){return this.responseType=x,this}setMimeType(x){return this.mimeType=x,this}}class Nre extends null{constructor(x){super(x)}load(x,n,r,a){const i=this,o=new rr(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(x,function(l){try{n(i.parse(JSON.parse(l)))}catch(c){a?a(c):console.error(c),i.manager.itemError(x)}},r,a)}parse(x){const n=[];for(let r=0;r<x.length;r++){const a=ec.parse(x[r]);n.push(a)}return n}}class Rre extends null{constructor(x){super(x)}load(x,n,r,a){const i=this,o=[],l=new ete,c=new rr(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(i.withCredentials);let d=0;function h(p){c.load(x[p],function(m){const g=i.parse(m,!0);o[p]={width:g.width,height:g.height,format:g.format,mipmaps:g.mipmaps},d+=1,d===6&&(g.mipmapCount===1&&(l.minFilter=Sx),l.image=o,l.format=g.format,l.needsUpdate=!0,n&&n(l))},r,a)}if(Array.isArray(x))for(let p=0,m=x.length;p<m;++p)h(p);else c.load(x,function(p){const m=i.parse(p,!0);if(m.isCubemap){const g=m.mipmaps.length/m.mipmapCount;for(let y=0;y<g;y++){o[y]={mipmaps:[]};for(let b=0;b<m.mipmapCount;b++)o[y].mipmaps.push(m.mipmaps[y*m.mipmapCount+b]),o[y].format=m.format,o[y].width=m.width,o[y].height=m.height}l.image=o}else l.image.width=m.width,l.image.height=m.height,l.mipmaps=m.mipmaps;m.mipmapCount===1&&(l.minFilter=Sx),l.format=m.format,l.needsUpdate=!0,n&&n(l)},r,a);return l}}class Uh extends $a{constructor(x){super(x)}load(x,n,r,a){this.path!==void 0&&(x=this.path+x),x=this.manager.resolveURL(x);const i=this,o=_o.get(x);if(o!==void 0)return i.manager.itemStart(x),setTimeout(function(){n&&n(o),i.manager.itemEnd(x)},0),o;const l=Ml("img");function c(){h(),_o.add(x,this),n&&n(this),i.manager.itemEnd(x)}function d(p){h(),a&&a(p),i.manager.itemError(x),i.manager.itemEnd(x)}function h(){l.removeEventListener("load",c,!1),l.removeEventListener("error",d,!1)}return l.addEventListener("load",c,!1),l.addEventListener("error",d,!1),x.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(l.crossOrigin=this.crossOrigin),i.manager.itemStart(x),l.src=x,l}}class Pre extends null{constructor(x){super(x)}load(x,n,r,a){const i=new rh,o=new Uh(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let l=0;function c(d){o.load(x[d],function(h){i.images[d]=h,l++,l===6&&(i.needsUpdate=!0,n&&n(i))},void 0,a)}for(let d=0;d<x.length;++d)c(d);return i}}class Qte extends $a{constructor(x){super(x)}load(x,n,r,a){const i=this,o=new Bl,l=new rr(this.manager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(i.withCredentials),l.load(x,function(c){const d=i.parse(c);!d||(d.image!==void 0?o.image=d.image:d.data!==void 0&&(o.image.width=d.width,o.image.height=d.height,o.image.data=d.data),o.wrapS=d.wrapS!==void 0?d.wrapS:Zn,o.wrapT=d.wrapT!==void 0?d.wrapT:Zn,o.magFilter=d.magFilter!==void 0?d.magFilter:Sx,o.minFilter=d.minFilter!==void 0?d.minFilter:Sx,o.anisotropy=d.anisotropy!==void 0?d.anisotropy:1,d.encoding!==void 0&&(o.encoding=d.encoding),d.flipY!==void 0&&(o.flipY=d.flipY),d.format!==void 0&&(o.format=d.format),d.type!==void 0&&(o.type=d.type),d.mipmaps!==void 0&&(o.mipmaps=d.mipmaps,o.minFilter=_s),d.mipmapCount===1&&(o.minFilter=Sx),d.generateMipmaps!==void 0&&(o.generateMipmaps=d.generateMipmaps),o.needsUpdate=!0,n&&n(o,d))},r,a),o}}class jte extends $a{constructor(x){super(x)}load(x,n,r,a){const i=new Tn,o=new Uh(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(x,function(l){i.image=l,i.needsUpdate=!0,n!==void 0&&n(i)},r,a),i}}class Bh extends Px{constructor(x,n=1){super(),this.isLight=!0,this.type="Light",this.color=new M0(x),this.intensity=n}dispose(){}copy(x,n){return super.copy(x,n),this.color.copy(x.color),this.intensity=x.intensity,this}toJSON(x){const n=super.toJSON(x);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),n}}class exe extends null{constructor(x,n,r){super(x,r),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Px.DefaultUp),this.updateMatrix(),this.groundColor=new M0(n)}copy(x,n){return super.copy(x,n),this.groundColor.copy(x.groundColor),this}}const JE=new wt,QE=new K,jE=new K;class uy{constructor(x){this.camera=x,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new n0(512,512),this.map=null,this.mapPass=null,this.matrix=new wt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new D1,this._frameExtents=new n0(1,1),this._viewportCount=1,this._viewports=[new ix(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(x){const n=this.camera,r=this.matrix;QE.setFromMatrixPosition(x.matrixWorld),n.position.copy(QE),jE.setFromMatrixPosition(x.target.matrixWorld),n.lookAt(jE),n.updateMatrixWorld(),JE.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(JE),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(n.projectionMatrix),r.multiply(n.matrixWorldInverse)}getViewport(x){return this._viewports[x]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(x){return this.camera=x.camera.clone(),this.bias=x.bias,this.radius=x.radius,this.mapSize.copy(x.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const x={};return this.bias!==0&&(x.bias=this.bias),this.normalBias!==0&&(x.normalBias=this.normalBias),this.radius!==1&&(x.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(x.mapSize=this.mapSize.toArray()),x.camera=this.camera.toJSON(!1).object,delete x.camera.matrix,x}}class txe extends uy{constructor(){super(new ln(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(x){const n=this.camera,r=El*2*x.angle*this.focus,a=this.mapSize.width/this.mapSize.height,i=x.distance||n.far;(r!==n.fov||a!==n.aspect||i!==n.far)&&(n.fov=r,n.aspect=a,n.far=i,n.updateProjectionMatrix()),super.updateMatrices(x)}copy(x){return super.copy(x),this.focus=x.focus,this}}class eC extends Bh{constructor(x,n,r=0,a=Math.PI/3,i=0,o=1){super(x,n),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Px.DefaultUp),this.updateMatrix(),this.target=new Px,this.distance=r,this.angle=a,this.penumbra=i,this.decay=o,this.shadow=new txe}get power(){return this.intensity*Math.PI}set power(x){this.intensity=x/Math.PI}dispose(){this.shadow.dispose()}copy(x,n){return super.copy(x,n),this.distance=x.distance,this.angle=x.angle,this.penumbra=x.penumbra,this.decay=x.decay,this.target=x.target.clone(),this.shadow=x.shadow.clone(),this}}const tC=new wt,tc=new K,dy=new K;class xxe extends uy{constructor(){super(new ln(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new n0(4,2),this._viewportCount=6,this._viewports=[new ix(2,1,1,1),new ix(0,1,1,1),new ix(3,1,1,1),new ix(1,1,1,1),new ix(3,0,1,1),new ix(1,0,1,1)],this._cubeDirections=[new K(1,0,0),new K(-1,0,0),new K(0,0,1),new K(0,0,-1),new K(0,1,0),new K(0,-1,0)],this._cubeUps=[new K(0,1,0),new K(0,1,0),new K(0,1,0),new K(0,1,0),new K(0,0,1),new K(0,0,-1)]}updateMatrices(x,n=0){const r=this.camera,a=this.matrix,i=x.distance||r.far;i!==r.far&&(r.far=i,r.updateProjectionMatrix()),tc.setFromMatrixPosition(x.matrixWorld),r.position.copy(tc),dy.copy(r.position),dy.add(this._cubeDirections[n]),r.up.copy(this._cubeUps[n]),r.lookAt(dy),r.updateMatrixWorld(),a.makeTranslation(-tc.x,-tc.y,-tc.z),tC.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(tC)}}class hy extends Bh{constructor(x,n,r=0,a=1){super(x,n),this.isPointLight=!0,this.type="PointLight",this.distance=r,this.decay=a,this.shadow=new xxe}get power(){return this.intensity*4*Math.PI}set power(x){this.intensity=x/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(x,n){return super.copy(x,n),this.distance=x.distance,this.decay=x.decay,this.shadow=x.shadow.clone(),this}}class nxe extends uy{constructor(){super(new Ll(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class xC extends Bh{constructor(x,n){super(x,n),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Px.DefaultUp),this.updateMatrix(),this.target=new Px,this.shadow=new nxe}dispose(){this.shadow.dispose()}copy(x){return super.copy(x),this.target=x.target.clone(),this.shadow=x.shadow.clone(),this}}class nC extends Bh{constructor(x,n){super(x,n),this.isAmbientLight=!0,this.type="AmbientLight"}}class rxe extends null{constructor(x,n,r=10,a=10){super(x,n),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=r,this.height=a}get power(){return this.intensity*this.width*this.height*Math.PI}set power(x){this.intensity=x/(this.width*this.height*Math.PI)}copy(x){return super.copy(x),this.width=x.width,this.height=x.height,this}toJSON(x){const n=super.toJSON(x);return n.object.width=this.width,n.object.height=this.height,n}}class sxe{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let x=0;x<9;x++)this.coefficients.push(new K)}set(x){for(let n=0;n<9;n++)this.coefficients[n].copy(x[n]);return this}zero(){for(let x=0;x<9;x++)this.coefficients[x].set(0,0,0);return this}getAt(x,n){const r=x.x,a=x.y,i=x.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.282095),n.addScaledVector(o[1],.488603*a),n.addScaledVector(o[2],.488603*i),n.addScaledVector(o[3],.488603*r),n.addScaledVector(o[4],1.092548*(r*a)),n.addScaledVector(o[5],1.092548*(a*i)),n.addScaledVector(o[6],.315392*(3*i*i-1)),n.addScaledVector(o[7],1.092548*(r*i)),n.addScaledVector(o[8],.546274*(r*r-a*a)),n}getIrradianceAt(x,n){const r=x.x,a=x.y,i=x.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.886227),n.addScaledVector(o[1],2*.511664*a),n.addScaledVector(o[2],2*.511664*i),n.addScaledVector(o[3],2*.511664*r),n.addScaledVector(o[4],2*.429043*r*a),n.addScaledVector(o[5],2*.429043*a*i),n.addScaledVector(o[6],.743125*i*i-.247708),n.addScaledVector(o[7],2*.429043*r*i),n.addScaledVector(o[8],.429043*(r*r-a*a)),n}add(x){for(let n=0;n<9;n++)this.coefficients[n].add(x.coefficients[n]);return this}addScaledSH(x,n){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(x.coefficients[r],n);return this}scale(x){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(x);return this}lerp(x,n){for(let r=0;r<9;r++)this.coefficients[r].lerp(x.coefficients[r],n);return this}equals(x){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(x.coefficients[n]))return!1;return!0}copy(x){return this.set(x.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(x,n=0){const r=this.coefficients;for(let a=0;a<9;a++)r[a].fromArray(x,n+a*3);return this}toArray(x=[],n=0){const r=this.coefficients;for(let a=0;a<9;a++)r[a].toArray(x,n+a*3);return x}static getBasisAt(x,n){const r=x.x,a=x.y,i=x.z;n[0]=.282095,n[1]=.488603*a,n[2]=.488603*i,n[3]=.488603*r,n[4]=1.092548*r*a,n[5]=1.092548*a*i,n[6]=.315392*(3*i*i-1),n[7]=1.092548*r*i,n[8]=.546274*(r*r-a*a)}}class axe extends null{constructor(x=new sxe,n=1){super(void 0,n),this.isLightProbe=!0,this.sh=x}copy(x){return super.copy(x),this.sh.copy(x.sh),this}fromJSON(x){return this.intensity=x.intensity,this.sh.fromArray(x.sh),this}toJSON(x){const n=super.toJSON(x);return n.object.sh=this.sh.toArray(),n}}class py extends null{constructor(x){super(x),this.textures={}}load(x,n,r,a){const i=this,o=new rr(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(x,function(l){try{n(i.parse(JSON.parse(l)))}catch(c){a?a(c):console.error(c),i.manager.itemError(x)}},r,a)}parse(x){const n=this.textures;function r(i){return n[i]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",i),n[i]}const a=py.createMaterialFromType(x.type);if(x.uuid!==void 0&&(a.uuid=x.uuid),x.name!==void 0&&(a.name=x.name),x.color!==void 0&&a.color!==void 0&&a.color.setHex(x.color),x.roughness!==void 0&&(a.roughness=x.roughness),x.metalness!==void 0&&(a.metalness=x.metalness),x.sheen!==void 0&&(a.sheen=x.sheen),x.sheenColor!==void 0&&(a.sheenColor=new M0().setHex(x.sheenColor)),x.sheenRoughness!==void 0&&(a.sheenRoughness=x.sheenRoughness),x.emissive!==void 0&&a.emissive!==void 0&&a.emissive.setHex(x.emissive),x.specular!==void 0&&a.specular!==void 0&&a.specular.setHex(x.specular),x.specularIntensity!==void 0&&(a.specularIntensity=x.specularIntensity),x.specularColor!==void 0&&a.specularColor!==void 0&&a.specularColor.setHex(x.specularColor),x.shininess!==void 0&&(a.shininess=x.shininess),x.clearcoat!==void 0&&(a.clearcoat=x.clearcoat),x.clearcoatRoughness!==void 0&&(a.clearcoatRoughness=x.clearcoatRoughness),x.iridescence!==void 0&&(a.iridescence=x.iridescence),x.iridescenceIOR!==void 0&&(a.iridescenceIOR=x.iridescenceIOR),x.iridescenceThicknessRange!==void 0&&(a.iridescenceThicknessRange=x.iridescenceThicknessRange),x.transmission!==void 0&&(a.transmission=x.transmission),x.thickness!==void 0&&(a.thickness=x.thickness),x.attenuationDistance!==void 0&&(a.attenuationDistance=x.attenuationDistance),x.attenuationColor!==void 0&&a.attenuationColor!==void 0&&a.attenuationColor.setHex(x.attenuationColor),x.fog!==void 0&&(a.fog=x.fog),x.flatShading!==void 0&&(a.flatShading=x.flatShading),x.blending!==void 0&&(a.blending=x.blending),x.combine!==void 0&&(a.combine=x.combine),x.side!==void 0&&(a.side=x.side),x.shadowSide!==void 0&&(a.shadowSide=x.shadowSide),x.opacity!==void 0&&(a.opacity=x.opacity),x.transparent!==void 0&&(a.transparent=x.transparent),x.alphaTest!==void 0&&(a.alphaTest=x.alphaTest),x.depthTest!==void 0&&(a.depthTest=x.depthTest),x.depthWrite!==void 0&&(a.depthWrite=x.depthWrite),x.colorWrite!==void 0&&(a.colorWrite=x.colorWrite),x.stencilWrite!==void 0&&(a.stencilWrite=x.stencilWrite),x.stencilWriteMask!==void 0&&(a.stencilWriteMask=x.stencilWriteMask),x.stencilFunc!==void 0&&(a.stencilFunc=x.stencilFunc),x.stencilRef!==void 0&&(a.stencilRef=x.stencilRef),x.stencilFuncMask!==void 0&&(a.stencilFuncMask=x.stencilFuncMask),x.stencilFail!==void 0&&(a.stencilFail=x.stencilFail),x.stencilZFail!==void 0&&(a.stencilZFail=x.stencilZFail),x.stencilZPass!==void 0&&(a.stencilZPass=x.stencilZPass),x.wireframe!==void 0&&(a.wireframe=x.wireframe),x.wireframeLinewidth!==void 0&&(a.wireframeLinewidth=x.wireframeLinewidth),x.wireframeLinecap!==void 0&&(a.wireframeLinecap=x.wireframeLinecap),x.wireframeLinejoin!==void 0&&(a.wireframeLinejoin=x.wireframeLinejoin),x.rotation!==void 0&&(a.rotation=x.rotation),x.linewidth!==1&&(a.linewidth=x.linewidth),x.dashSize!==void 0&&(a.dashSize=x.dashSize),x.gapSize!==void 0&&(a.gapSize=x.gapSize),x.scale!==void 0&&(a.scale=x.scale),x.polygonOffset!==void 0&&(a.polygonOffset=x.polygonOffset),x.polygonOffsetFactor!==void 0&&(a.polygonOffsetFactor=x.polygonOffsetFactor),x.polygonOffsetUnits!==void 0&&(a.polygonOffsetUnits=x.polygonOffsetUnits),x.dithering!==void 0&&(a.dithering=x.dithering),x.alphaToCoverage!==void 0&&(a.alphaToCoverage=x.alphaToCoverage),x.premultipliedAlpha!==void 0&&(a.premultipliedAlpha=x.premultipliedAlpha),x.visible!==void 0&&(a.visible=x.visible),x.toneMapped!==void 0&&(a.toneMapped=x.toneMapped),x.userData!==void 0&&(a.userData=x.userData),x.vertexColors!==void 0&&(typeof x.vertexColors=="number"?a.vertexColors=x.vertexColors>0:a.vertexColors=x.vertexColors),x.uniforms!==void 0)for(const i in x.uniforms){const o=x.uniforms[i];switch(a.uniforms[i]={},o.type){case"t":a.uniforms[i].value=r(o.value);break;case"c":a.uniforms[i].value=new M0().setHex(o.value);break;case"v2":a.uniforms[i].value=new n0().fromArray(o.value);break;case"v3":a.uniforms[i].value=new K().fromArray(o.value);break;case"v4":a.uniforms[i].value=new ix().fromArray(o.value);break;case"m3":a.uniforms[i].value=new m2().fromArray(o.value);break;case"m4":a.uniforms[i].value=new wt().fromArray(o.value);break;default:a.uniforms[i].value=o.value}}if(x.defines!==void 0&&(a.defines=x.defines),x.vertexShader!==void 0&&(a.vertexShader=x.vertexShader),x.fragmentShader!==void 0&&(a.fragmentShader=x.fragmentShader),x.extensions!==void 0)for(const i in x.extensions)a.extensions[i]=x.extensions[i];if(x.shading!==void 0&&(a.flatShading=x.shading===1),x.size!==void 0&&(a.size=x.size),x.sizeAttenuation!==void 0&&(a.sizeAttenuation=x.sizeAttenuation),x.map!==void 0&&(a.map=r(x.map)),x.matcap!==void 0&&(a.matcap=r(x.matcap)),x.alphaMap!==void 0&&(a.alphaMap=r(x.alphaMap)),x.bumpMap!==void 0&&(a.bumpMap=r(x.bumpMap)),x.bumpScale!==void 0&&(a.bumpScale=x.bumpScale),x.normalMap!==void 0&&(a.normalMap=r(x.normalMap)),x.normalMapType!==void 0&&(a.normalMapType=x.normalMapType),x.normalScale!==void 0){let i=x.normalScale;Array.isArray(i)===!1&&(i=[i,i]),a.normalScale=new n0().fromArray(i)}return x.displacementMap!==void 0&&(a.displacementMap=r(x.displacementMap)),x.displacementScale!==void 0&&(a.displacementScale=x.displacementScale),x.displacementBias!==void 0&&(a.displacementBias=x.displacementBias),x.roughnessMap!==void 0&&(a.roughnessMap=r(x.roughnessMap)),x.metalnessMap!==void 0&&(a.metalnessMap=r(x.metalnessMap)),x.emissiveMap!==void 0&&(a.emissiveMap=r(x.emissiveMap)),x.emissiveIntensity!==void 0&&(a.emissiveIntensity=x.emissiveIntensity),x.specularMap!==void 0&&(a.specularMap=r(x.specularMap)),x.specularIntensityMap!==void 0&&(a.specularIntensityMap=r(x.specularIntensityMap)),x.specularColorMap!==void 0&&(a.specularColorMap=r(x.specularColorMap)),x.envMap!==void 0&&(a.envMap=r(x.envMap)),x.envMapIntensity!==void 0&&(a.envMapIntensity=x.envMapIntensity),x.reflectivity!==void 0&&(a.reflectivity=x.reflectivity),x.refractionRatio!==void 0&&(a.refractionRatio=x.refractionRatio),x.lightMap!==void 0&&(a.lightMap=r(x.lightMap)),x.lightMapIntensity!==void 0&&(a.lightMapIntensity=x.lightMapIntensity),x.aoMap!==void 0&&(a.aoMap=r(x.aoMap)),x.aoMapIntensity!==void 0&&(a.aoMapIntensity=x.aoMapIntensity),x.gradientMap!==void 0&&(a.gradientMap=r(x.gradientMap)),x.clearcoatMap!==void 0&&(a.clearcoatMap=r(x.clearcoatMap)),x.clearcoatRoughnessMap!==void 0&&(a.clearcoatRoughnessMap=r(x.clearcoatRoughnessMap)),x.clearcoatNormalMap!==void 0&&(a.clearcoatNormalMap=r(x.clearcoatNormalMap)),x.clearcoatNormalScale!==void 0&&(a.clearcoatNormalScale=new n0().fromArray(x.clearcoatNormalScale)),x.iridescenceMap!==void 0&&(a.iridescenceMap=r(x.iridescenceMap)),x.iridescenceThicknessMap!==void 0&&(a.iridescenceThicknessMap=r(x.iridescenceThicknessMap)),x.transmissionMap!==void 0&&(a.transmissionMap=r(x.transmissionMap)),x.thicknessMap!==void 0&&(a.thicknessMap=r(x.thicknessMap)),x.sheenColorMap!==void 0&&(a.sheenColorMap=r(x.sheenColorMap)),x.sheenRoughnessMap!==void 0&&(a.sheenRoughnessMap=r(x.sheenRoughnessMap)),a}setTextures(x){return this.textures=x,this}static createMaterialFromType(x){const n={ShadowMaterial:Dte,SpriteMaterial:hE,RawShaderMaterial:Ote,ShaderMaterial:Ns,PointsMaterial:Z1,MeshPhysicalMaterial:Ls,MeshStandardMaterial:qa,MeshPhongMaterial:Fte,MeshToonMaterial:Ute,MeshNormalMaterial:Bte,MeshLambertMaterial:zte,MeshDepthMaterial:lE,MeshDistanceMaterial:cE,MeshBasicMaterial:F2,MeshMatcapMaterial:Wte,LineDashedMaterial:Gte,LineBasicMaterial:i2,Material:y2};return new n[x]}}class Qr{static decodeText(x){if(typeof TextDecoder<"u")return new TextDecoder().decode(x);let n="";for(let r=0,a=x.length;r<a;r++)n+=String.fromCharCode(x[r]);try{return decodeURIComponent(escape(n))}catch{return n}}static extractUrlBase(x){const n=x.lastIndexOf("/");return n===-1?"./":x.slice(0,n+1)}static resolveURL(x,n){return typeof x!="string"||x===""?"":(/^https?:\/\//i.test(n)&&/^\//.test(x)&&(n=n.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(x)||/^data:.*,.*$/i.test(x)||/^blob:.*$/i.test(x)?x:n+x)}}class ixe extends null{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(x){return super.copy(x),this.instanceCount=x.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const x=super.toJSON(this);return x.instanceCount=this.instanceCount,x.isInstancedBufferGeometry=!0,x}}class oxe extends null{constructor(x){super(x)}load(x,n,r,a){const i=this,o=new rr(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(x,function(l){try{n(i.parse(JSON.parse(l)))}catch(c){a?a(c):console.error(c),i.manager.itemError(x)}},r,a)}parse(x){const n={},r={};function a(g,y){if(n[y]!==void 0)return n[y];const v=g.interleavedBuffers[y],w=i(g,v.buffer),_=Xi(v.type,w),T=new Y1(_,v.stride);return T.uuid=v.uuid,n[y]=T,T}function i(g,y){if(r[y]!==void 0)return r[y];const v=g.arrayBuffers[y],w=new Uint32Array(v).buffer;return r[y]=w,w}const o=x.isInstancedBufferGeometry?new ixe:new Rt,l=x.data.index;if(l!==void 0){const g=Xi(l.type,l.array);o.setIndex(new Qx(g,1))}const c=x.data.attributes;for(const g in c){const y=c[g];let b;if(y.isInterleavedBufferAttribute){const v=a(x.data,y.data);b=new Ha(v,y.itemSize,y.offset,y.normalized)}else{const v=Xi(y.type,y.array),w=y.isInstancedBufferAttribute?zl:Qx;b=new w(v,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),y.usage!==void 0&&b.setUsage(y.usage),y.updateRange!==void 0&&(b.updateRange.offset=y.updateRange.offset,b.updateRange.count=y.updateRange.count),o.setAttribute(g,b)}const d=x.data.morphAttributes;if(d)for(const g in d){const y=d[g],b=[];for(let v=0,w=y.length;v<w;v++){const _=y[v];let T;if(_.isInterleavedBufferAttribute){const A=a(x.data,_.data);T=new Ha(A,_.itemSize,_.offset,_.normalized)}else{const A=Xi(_.type,_.array);T=new Qx(A,_.itemSize,_.normalized)}_.name!==void 0&&(T.name=_.name),b.push(T)}o.morphAttributes[g]=b}x.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const p=x.data.groups||x.data.drawcalls||x.data.offsets;if(p!==void 0)for(let g=0,y=p.length;g!==y;++g){const b=p[g];o.addGroup(b.start,b.count,b.materialIndex)}const m=x.data.boundingSphere;if(m!==void 0){const g=new K;m.center!==void 0&&g.fromArray(m.center),o.boundingSphere=new Ba(g,m.radius)}return x.name&&(o.name=x.name),x.userData&&(o.userData=x.userData),o}}class Lre extends null{constructor(x){super(x)}load(x,n,r,a){const i=this,o=this.path===""?Qr.extractUrlBase(x):this.path;this.resourcePath=this.resourcePath||o;const l=new rr(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(x,function(c){let d=null;try{d=JSON.parse(c)}catch(p){a!==void 0&&a(p),console.error("THREE:ObjectLoader: Can't parse "+x+".",p.message);return}const h=d.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+x);return}i.parse(d,n)},r,a)}async loadAsync(x,n){const r=this,a=this.path===""?Qr.extractUrlBase(x):this.path;this.resourcePath=this.resourcePath||a;const i=new rr(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const o=await i.loadAsync(x,n),l=JSON.parse(o),c=l.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+x);return await r.parseAsync(l)}parse(x,n){const r=this.parseAnimations(x.animations),a=this.parseShapes(x.shapes),i=this.parseGeometries(x.geometries,a),o=this.parseImages(x.images,function(){n!==void 0&&n(d)}),l=this.parseTextures(x.textures,o),c=this.parseMaterials(x.materials,l),d=this.parseObject(x.object,i,c,l,r),h=this.parseSkeletons(x.skeletons,d);if(this.bindSkeletons(d,h),n!==void 0){let p=!1;for(const m in o)if(o[m].data instanceof HTMLImageElement){p=!0;break}p===!1&&n(d)}return d}async parseAsync(x){const n=this.parseAnimations(x.animations),r=this.parseShapes(x.shapes),a=this.parseGeometries(x.geometries,r),i=await this.parseImagesAsync(x.images),o=this.parseTextures(x.textures,i),l=this.parseMaterials(x.materials,o),c=this.parseObject(x.object,a,l,o,n),d=this.parseSkeletons(x.skeletons,c);return this.bindSkeletons(c,d),c}parseShapes(x){const n={};if(x!==void 0)for(let r=0,a=x.length;r<a;r++){const i=new yo().fromJSON(x[r]);n[i.uuid]=i}return n}parseSkeletons(x,n){const r={},a={};if(n.traverse(function(i){i.isBone&&(a[i.uuid]=i)}),x!==void 0)for(let i=0,o=x.length;i<o;i++){const l=new ph().fromJSON(x[i],a);r[l.uuid]=l}return r}parseGeometries(x,n){const r={};if(x!==void 0){const a=new oxe;for(let i=0,o=x.length;i<o;i++){let l;const c=x[i];switch(c.type){case"BufferGeometry":case"InstancedBufferGeometry":l=a.parse(c);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:c.type in qE?l=qE[c.type].fromJSON(c,n):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),r[c.uuid]=l}}return r}parseMaterials(x,n){const r={},a={};if(x!==void 0){const i=new py;i.setTextures(n);for(let o=0,l=x.length;o<l;o++){const c=x[o];if(c.type==="MultiMaterial"){const d=[];for(let h=0;h<c.materials.length;h++){const p=c.materials[h];r[p.uuid]===void 0&&(r[p.uuid]=i.parse(p)),d.push(r[p.uuid])}a[c.uuid]=d}else r[c.uuid]===void 0&&(r[c.uuid]=i.parse(c)),a[c.uuid]=r[c.uuid]}}return a}parseAnimations(x){const n={};if(x!==void 0)for(let r=0;r<x.length;r++){const a=x[r],i=ec.parse(a);n[i.uuid]=i}return n}parseImages(x,n){const r=this,a={};let i;function o(c){return r.manager.itemStart(c),i.load(c,function(){r.manager.itemEnd(c)},void 0,function(){r.manager.itemError(c),r.manager.itemEnd(c)})}function l(c){if(typeof c=="string"){const d=c,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)?d:r.resourcePath+d;return o(h)}else return c.data?{data:Xi(c.type,c.data),width:c.width,height:c.height}:null}if(x!==void 0&&x.length>0){const c=new ZE(n);i=new Uh(c),i.setCrossOrigin(this.crossOrigin);for(let d=0,h=x.length;d<h;d++){const p=x[d],m=p.url;if(Array.isArray(m)){const g=[];for(let y=0,b=m.length;y<b;y++){const v=m[y],w=l(v);w!==null&&(w instanceof HTMLImageElement?g.push(w):g.push(new Bl(w.data,w.width,w.height)))}a[p.uuid]=new $i(g)}else{const g=l(p.url);a[p.uuid]=new $i(g)}}}return a}async parseImagesAsync(x){const n=this,r={};let a;async function i(o){if(typeof o=="string"){const l=o,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:n.resourcePath+l;return await a.loadAsync(c)}else return o.data?{data:Xi(o.type,o.data),width:o.width,height:o.height}:null}if(x!==void 0&&x.length>0){a=new Uh(this.manager),a.setCrossOrigin(this.crossOrigin);for(let o=0,l=x.length;o<l;o++){const c=x[o],d=c.url;if(Array.isArray(d)){const h=[];for(let p=0,m=d.length;p<m;p++){const g=d[p],y=await i(g);y!==null&&(y instanceof HTMLImageElement?h.push(y):h.push(new Bl(y.data,y.width,y.height)))}r[c.uuid]=new $i(h)}else{const h=await i(c.url);r[c.uuid]=new $i(h)}}}return r}parseTextures(x,n){function r(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const a={};if(x!==void 0)for(let i=0,o=x.length;i<o;i++){const l=x[i];l.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',l.uuid),n[l.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",l.image);const c=n[l.image],d=c.data;let h;Array.isArray(d)?(h=new rh,d.length===6&&(h.needsUpdate=!0)):(d&&d.data?h=new Bl:h=new Tn,d&&(h.needsUpdate=!0)),h.source=c,h.uuid=l.uuid,l.name!==void 0&&(h.name=l.name),l.mapping!==void 0&&(h.mapping=r(l.mapping,lxe)),l.offset!==void 0&&h.offset.fromArray(l.offset),l.repeat!==void 0&&h.repeat.fromArray(l.repeat),l.center!==void 0&&h.center.fromArray(l.center),l.rotation!==void 0&&(h.rotation=l.rotation),l.wrap!==void 0&&(h.wrapS=r(l.wrap[0],rC),h.wrapT=r(l.wrap[1],rC)),l.format!==void 0&&(h.format=l.format),l.type!==void 0&&(h.type=l.type),l.encoding!==void 0&&(h.encoding=l.encoding),l.minFilter!==void 0&&(h.minFilter=r(l.minFilter,sC)),l.magFilter!==void 0&&(h.magFilter=r(l.magFilter,sC)),l.anisotropy!==void 0&&(h.anisotropy=l.anisotropy),l.flipY!==void 0&&(h.flipY=l.flipY),l.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=l.premultiplyAlpha),l.unpackAlignment!==void 0&&(h.unpackAlignment=l.unpackAlignment),l.userData!==void 0&&(h.userData=l.userData),a[l.uuid]=h}return a}parseObject(x,n,r,a,i){let o;function l(m){return n[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",m),n[m]}function c(m){if(m!==void 0){if(Array.isArray(m)){const g=[];for(let y=0,b=m.length;y<b;y++){const v=m[y];r[v]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",v),g.push(r[v])}return g}return r[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",m),r[m]}}function d(m){return a[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",m),a[m]}let h,p;switch(x.type){case"Scene":o=new dE,x.background!==void 0&&(Number.isInteger(x.background)?o.background=new M0(x.background):o.background=d(x.background)),x.environment!==void 0&&(o.environment=d(x.environment)),x.fog!==void 0&&(x.fog.type==="Fog"?o.fog=new H1(x.fog.color,x.fog.near,x.fog.far):x.fog.type==="FogExp2"&&(o.fog=new V1(x.fog.color,x.fog.density)));break;case"PerspectiveCamera":o=new ln(x.fov,x.aspect,x.near,x.far),x.focus!==void 0&&(o.focus=x.focus),x.zoom!==void 0&&(o.zoom=x.zoom),x.filmGauge!==void 0&&(o.filmGauge=x.filmGauge),x.filmOffset!==void 0&&(o.filmOffset=x.filmOffset),x.view!==void 0&&(o.view=Object.assign({},x.view));break;case"OrthographicCamera":o=new Ll(x.left,x.right,x.top,x.bottom,x.near,x.far),x.zoom!==void 0&&(o.zoom=x.zoom),x.view!==void 0&&(o.view=Object.assign({},x.view));break;case"AmbientLight":o=new nC(x.color,x.intensity);break;case"DirectionalLight":o=new xC(x.color,x.intensity);break;case"PointLight":o=new hy(x.color,x.intensity,x.distance,x.decay);break;case"RectAreaLight":o=new rxe(x.color,x.intensity,x.width,x.height);break;case"SpotLight":o=new eC(x.color,x.intensity,x.distance,x.angle,x.penumbra,x.decay);break;case"HemisphereLight":o=new exe(x.color,x.groundColor,x.intensity);break;case"LightProbe":o=new axe().fromJSON(x);break;case"SkinnedMesh":h=l(x.geometry),p=c(x.material),o=new X1(h,p),x.bindMode!==void 0&&(o.bindMode=x.bindMode),x.bindMatrix!==void 0&&o.bindMatrix.fromArray(x.bindMatrix),x.skeleton!==void 0&&(o.skeleton=x.skeleton);break;case"Mesh":h=l(x.geometry),p=c(x.material),o=new yn(h,p);break;case"InstancedMesh":h=l(x.geometry),p=c(x.material);const m=x.count,g=x.instanceMatrix,y=x.instanceColor;o=new j0e(h,p,m),o.instanceMatrix=new zl(new Float32Array(g.array),16),y!==void 0&&(o.instanceColor=new zl(new Float32Array(y.array),y.itemSize));break;case"LOD":o=new Z0e;break;case"Line":o=new Ya(l(x.geometry),c(x.material));break;case"LineLoop":o=new kE(l(x.geometry),c(x.material));break;case"LineSegments":o=new $1(l(x.geometry),c(x.material));break;case"PointCloud":case"Points":o=new RE(l(x.geometry),c(x.material));break;case"Sprite":o=new $0e(c(x.material));break;case"Group":o=new $r;break;case"Bone":o=new hh;break;default:o=new Px}if(o.uuid=x.uuid,x.name!==void 0&&(o.name=x.name),x.matrix!==void 0?(o.matrix.fromArray(x.matrix),x.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=x.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(x.position!==void 0&&o.position.fromArray(x.position),x.rotation!==void 0&&o.rotation.fromArray(x.rotation),x.quaternion!==void 0&&o.quaternion.fromArray(x.quaternion),x.scale!==void 0&&o.scale.fromArray(x.scale)),x.castShadow!==void 0&&(o.castShadow=x.castShadow),x.receiveShadow!==void 0&&(o.receiveShadow=x.receiveShadow),x.shadow&&(x.shadow.bias!==void 0&&(o.shadow.bias=x.shadow.bias),x.shadow.normalBias!==void 0&&(o.shadow.normalBias=x.shadow.normalBias),x.shadow.radius!==void 0&&(o.shadow.radius=x.shadow.radius),x.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(x.shadow.mapSize),x.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(x.shadow.camera))),x.visible!==void 0&&(o.visible=x.visible),x.frustumCulled!==void 0&&(o.frustumCulled=x.frustumCulled),x.renderOrder!==void 0&&(o.renderOrder=x.renderOrder),x.userData!==void 0&&(o.userData=x.userData),x.layers!==void 0&&(o.layers.mask=x.layers),x.children!==void 0){const m=x.children;for(let g=0;g<m.length;g++)o.add(this.parseObject(m[g],n,r,a,i))}if(x.animations!==void 0){const m=x.animations;for(let g=0;g<m.length;g++){const y=m[g];o.animations.push(i[y])}}if(x.type==="LOD"){x.autoUpdate!==void 0&&(o.autoUpdate=x.autoUpdate);const m=x.levels;for(let g=0;g<m.length;g++){const y=m[g],b=o.getObjectByProperty("uuid",y.object);b!==void 0&&o.addLevel(b,y.distance)}}return o}bindSkeletons(x,n){Object.keys(n).length!==0&&x.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const a=n[r.skeleton];a===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(a,r.bindMatrix)}})}}const lxe={UVMapping:jg,CubeReflectionMapping:Ta,CubeRefractionMapping:Aa,EquirectangularReflectionMapping:_l,EquirectangularRefractionMapping:Rd,CubeUVReflectionMapping:Sl},rC={RepeatWrapping:Ea,ClampToEdgeWrapping:Zn,MirroredRepeatWrapping:Tl},sC={NearestFilter:Zx,NearestMipmapNearestFilter:Pd,NearestMipmapLinearFilter:Ld,LinearFilter:Sx,LinearMipmapNearestFilter:e1,LinearMipmapLinearFilter:_s};class cxe extends $a{constructor(x){super(x),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(x){return this.options=x,this}load(x,n,r,a){x===void 0&&(x=""),this.path!==void 0&&(x=this.path+x),x=this.manager.resolveURL(x);const i=this,o=_o.get(x);if(o!==void 0)return i.manager.itemStart(x),setTimeout(function(){n&&n(o),i.manager.itemEnd(x)},0),o;const l={};l.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",l.headers=this.requestHeader,fetch(x,l).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(c){_o.add(x,c),n&&n(c),i.manager.itemEnd(x)}).catch(function(c){a&&a(c),i.manager.itemError(x),i.manager.itemEnd(x)}),i.manager.itemStart(x)}}let zh;const aC={getContext:function(){return zh===void 0&&(zh=new(window.AudioContext||window.webkitAudioContext)),zh},setContext:function(s){zh=s}};class Dre extends null{constructor(x){super(x)}load(x,n,r,a){const i=this,o=new rr(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(x,function(l){try{const c=l.slice(0);aC.getContext().decodeAudioData(c,function(h){n(h)})}catch(c){a?a(c):console.error(c),i.manager.itemError(x)}},r,a)}}class Ore extends null{constructor(x,n,r=1){super(void 0,r),this.isHemisphereLightProbe=!0;const a=new M0().set(x),i=new M0().set(n),o=new K(a.r,a.g,a.b),l=new K(i.r,i.g,i.b),c=Math.sqrt(Math.PI),d=c*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(l).multiplyScalar(c),this.sh.coefficients[1].copy(o).sub(l).multiplyScalar(d)}}class Fre extends null{constructor(x,n=1){super(void 0,n),this.isAmbientLightProbe=!0;const r=new M0().set(x);this.sh.coefficients[0].set(r.r,r.g,r.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const iC=new wt,oC=new wt,Za=new wt;class Ure{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ln,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ln,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(x){const n=this._cache;if(n.focus!==x.focus||n.fov!==x.fov||n.aspect!==x.aspect*this.aspect||n.near!==x.near||n.far!==x.far||n.zoom!==x.zoom||n.eyeSep!==this.eyeSep){n.focus=x.focus,n.fov=x.fov,n.aspect=x.aspect*this.aspect,n.near=x.near,n.far=x.far,n.zoom=x.zoom,n.eyeSep=this.eyeSep,Za.copy(x.projectionMatrix);const a=n.eyeSep/2,i=a*n.near/n.focus,o=n.near*Math.tan(Ra*n.fov*.5)/n.zoom;let l,c;oC.elements[12]=-a,iC.elements[12]=a,l=-o*n.aspect+i,c=o*n.aspect+i,Za.elements[0]=2*n.near/(c-l),Za.elements[8]=(c+l)/(c-l),this.cameraL.projectionMatrix.copy(Za),l=-o*n.aspect-i,c=o*n.aspect-i,Za.elements[0]=2*n.near/(c-l),Za.elements[8]=(c+l)/(c-l),this.cameraR.projectionMatrix.copy(Za)}this.cameraL.matrixWorld.copy(x.matrixWorld).multiply(oC),this.cameraR.matrixWorld.copy(x.matrixWorld).multiply(iC)}}class uxe{constructor(x=!0){this.autoStart=x,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=lC(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let x=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=lC();x=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=x}return x}}function lC(){return(typeof performance>"u"?Date:performance).now()}const Ja=new K,cC=new Bn,dxe=new K,Qa=new K;class Bre extends null{constructor(){super(),this.type="AudioListener",this.context=aC.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new uxe}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(x){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=x,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(x){return this.gain.gain.setTargetAtTime(x,this.context.currentTime,.01),this}updateMatrixWorld(x){super.updateMatrixWorld(x);const n=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ja,cC,dxe),Qa.set(0,0,-1).applyQuaternion(cC),n.positionX){const a=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(Ja.x,a),n.positionY.linearRampToValueAtTime(Ja.y,a),n.positionZ.linearRampToValueAtTime(Ja.z,a),n.forwardX.linearRampToValueAtTime(Qa.x,a),n.forwardY.linearRampToValueAtTime(Qa.y,a),n.forwardZ.linearRampToValueAtTime(Qa.z,a),n.upX.linearRampToValueAtTime(r.x,a),n.upY.linearRampToValueAtTime(r.y,a),n.upZ.linearRampToValueAtTime(r.z,a)}else n.setPosition(Ja.x,Ja.y,Ja.z),n.setOrientation(Qa.x,Qa.y,Qa.z,r.x,r.y,r.z)}}class zre extends null{constructor(x){super(),this.type="Audio",this.listener=x,this.context=x.context,this.gain=this.context.createGain(),this.gain.connect(x.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(x){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=x,this.connect(),this}setMediaElementSource(x){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(x),this.connect(),this}setMediaStreamSource(x){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(x),this.connect(),this}setBuffer(x){return this.buffer=x,this.sourceType="buffer",this.autoplay&&this.play(),this}play(x=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+x;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let x=1,n=this.filters.length;x<n;x++)this.filters[x-1].connect(this.filters[x]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let x=1,n=this.filters.length;x<n;x++)this.filters[x-1].disconnect(this.filters[x]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(x){return x||(x=[]),this._connected===!0?(this.disconnect(),this.filters=x.slice(),this.connect()):this.filters=x.slice(),this}setDetune(x){if(this.detune=x,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(x){return this.setFilters(x?[x]:[])}setPlaybackRate(x){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=x,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(x){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=x,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(x){return this.loopStart=x,this}setLoopEnd(x){return this.loopEnd=x,this}getVolume(){return this.gain.gain.value}setVolume(x){return this.gain.gain.setTargetAtTime(x,this.context.currentTime,.01),this}}const ja=new K,uC=new Bn,hxe=new K,ei=new K;class Wre extends null{constructor(x){super(x),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(x){return this.panner.refDistance=x,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(x){return this.panner.rolloffFactor=x,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(x){return this.panner.distanceModel=x,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(x){return this.panner.maxDistance=x,this}setDirectionalCone(x,n,r){return this.panner.coneInnerAngle=x,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=r,this}updateMatrixWorld(x){if(super.updateMatrixWorld(x),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(ja,uC,hxe),ei.set(0,0,1).applyQuaternion(uC);const n=this.panner;if(n.positionX){const r=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(ja.x,r),n.positionY.linearRampToValueAtTime(ja.y,r),n.positionZ.linearRampToValueAtTime(ja.z,r),n.orientationX.linearRampToValueAtTime(ei.x,r),n.orientationY.linearRampToValueAtTime(ei.y,r),n.orientationZ.linearRampToValueAtTime(ei.z,r)}else n.setPosition(ja.x,ja.y,ja.z),n.setOrientation(ei.x,ei.y,ei.z)}}class Gre{constructor(x,n=2048){this.analyser=x.context.createAnalyser(),this.analyser.fftSize=n,this.data=new Uint8Array(this.analyser.frequencyBinCount),x.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let x=0;const n=this.getFrequencyData();for(let r=0;r<n.length;r++)x+=n[r];return x/n.length}}class pxe{constructor(x,n,r){this.binding=x,this.valueSize=r;let a,i,o;switch(n){case"quaternion":a=this._slerp,i=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(r*6),this._workIndex=5;break;case"string":case"bool":a=this._select,i=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(r*5);break;default:a=this._lerp,i=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(r*5)}this._mixBufferRegion=a,this._mixBufferRegionAdditive=i,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(x,n){const r=this.buffer,a=this.valueSize,i=x*a+a;let o=this.cumulativeWeight;if(o===0){for(let l=0;l!==a;++l)r[i+l]=r[l];o=n}else{o+=n;const l=n/o;this._mixBufferRegion(r,i,0,l,a)}this.cumulativeWeight=o}accumulateAdditive(x){const n=this.buffer,r=this.valueSize,a=r*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(n,a,0,x,r),this.cumulativeWeightAdditive+=x}apply(x){const n=this.valueSize,r=this.buffer,a=x*n+n,i=this.cumulativeWeight,o=this.cumulativeWeightAdditive,l=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const c=n*this._origIndex;this._mixBufferRegion(r,a,c,1-i,n)}o>0&&this._mixBufferRegionAdditive(r,a,this._addIndex*n,1,n);for(let c=n,d=n+n;c!==d;++c)if(r[c]!==r[c+n]){l.setValue(r,a);break}}saveOriginalState(){const x=this.binding,n=this.buffer,r=this.valueSize,a=r*this._origIndex;x.getValue(n,a);for(let i=r,o=a;i!==o;++i)n[i]=n[a+i%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const x=this.valueSize*3;this.binding.setValue(this.buffer,x)}_setAdditiveIdentityNumeric(){const x=this._addIndex*this.valueSize,n=x+this.valueSize;for(let r=x;r<n;r++)this.buffer[r]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const x=this._origIndex*this.valueSize,n=this._addIndex*this.valueSize;for(let r=0;r<this.valueSize;r++)this.buffer[n+r]=this.buffer[x+r]}_select(x,n,r,a,i){if(a>=.5)for(let o=0;o!==i;++o)x[n+o]=x[r+o]}_slerp(x,n,r,a){Bn.slerpFlat(x,n,x,n,x,r,a)}_slerpAdditive(x,n,r,a,i){const o=this._workIndex*i;Bn.multiplyQuaternionsFlat(x,o,x,n,x,r),Bn.slerpFlat(x,n,x,n,x,o,a)}_lerp(x,n,r,a,i){const o=1-a;for(let l=0;l!==i;++l){const c=n+l;x[c]=x[c]*o+x[r+l]*a}}_lerpAdditive(x,n,r,a,i){for(let o=0;o!==i;++o){const l=n+o;x[l]=x[l]+x[r+o]*a}}}const fy="\\[\\]\\.:\\/",fxe=new RegExp("["+fy+"]","g"),my="[^"+fy+"]",mxe="[^"+fy.replace("\\.","")+"]",gxe=/((?:WC+[\/:])*)/.source.replace("WC",my),yxe=/(WCOD+)?/.source.replace("WCOD",mxe),bxe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",my),vxe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",my),wxe=new RegExp("^"+gxe+yxe+bxe+vxe+"$"),_xe=["material","materials","bones"];class Sxe{constructor(x,n,r){const a=r||Zt.parseTrackName(n);this._targetGroup=x,this._bindings=x.subscribe_(n,a)}getValue(x,n){this.bind();const r=this._targetGroup.nCachedObjects_,a=this._bindings[r];a!==void 0&&a.getValue(x,n)}setValue(x,n){const r=this._bindings;for(let a=this._targetGroup.nCachedObjects_,i=r.length;a!==i;++a)r[a].setValue(x,n)}bind(){const x=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=x.length;n!==r;++n)x[n].bind()}unbind(){const x=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=x.length;n!==r;++n)x[n].unbind()}}class Zt{constructor(x,n,r){this.path=n,this.parsedPath=r||Zt.parseTrackName(n),this.node=Zt.findNode(x,this.parsedPath.nodeName)||x,this.rootNode=x,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(x,n,r){return x&&x.isAnimationObjectGroup?new Zt.Composite(x,n,r):new Zt(x,n,r)}static sanitizeNodeName(x){return x.replace(/\s/g,"_").replace(fxe,"")}static parseTrackName(x){const n=wxe.exec(x);if(n===null)throw new Error("PropertyBinding: Cannot parse trackName: "+x);const r={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},a=r.nodeName&&r.nodeName.lastIndexOf(".");if(a!==void 0&&a!==-1){const i=r.nodeName.substring(a+1);_xe.indexOf(i)!==-1&&(r.nodeName=r.nodeName.substring(0,a),r.objectName=i)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+x);return r}static findNode(x,n){if(n===void 0||n===""||n==="."||n===-1||n===x.name||n===x.uuid)return x;if(x.skeleton){const r=x.skeleton.getBoneByName(n);if(r!==void 0)return r}if(x.children){const r=function(i){for(let o=0;o<i.length;o++){const l=i[o];if(l.name===n||l.uuid===n)return l;const c=r(l.children);if(c)return c}return null},a=r(x.children);if(a)return a}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(x,n){x[n]=this.targetObject[this.propertyName]}_getValue_array(x,n){const r=this.resolvedProperty;for(let a=0,i=r.length;a!==i;++a)x[n++]=r[a]}_getValue_arrayElement(x,n){x[n]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(x,n){this.resolvedProperty.toArray(x,n)}_setValue_direct(x,n){this.targetObject[this.propertyName]=x[n]}_setValue_direct_setNeedsUpdate(x,n){this.targetObject[this.propertyName]=x[n],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(x,n){this.targetObject[this.propertyName]=x[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(x,n){const r=this.resolvedProperty;for(let a=0,i=r.length;a!==i;++a)r[a]=x[n++]}_setValue_array_setNeedsUpdate(x,n){const r=this.resolvedProperty;for(let a=0,i=r.length;a!==i;++a)r[a]=x[n++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(x,n){const r=this.resolvedProperty;for(let a=0,i=r.length;a!==i;++a)r[a]=x[n++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(x,n){this.resolvedProperty[this.propertyIndex]=x[n]}_setValue_arrayElement_setNeedsUpdate(x,n){this.resolvedProperty[this.propertyIndex]=x[n],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(x,n){this.resolvedProperty[this.propertyIndex]=x[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(x,n){this.resolvedProperty.fromArray(x,n)}_setValue_fromArray_setNeedsUpdate(x,n){this.resolvedProperty.fromArray(x,n),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(x,n){this.resolvedProperty.fromArray(x,n),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(x,n){this.bind(),this.getValue(x,n)}_setValue_unbound(x,n){this.bind(),this.setValue(x,n)}bind(){let x=this.node;const n=this.parsedPath,r=n.objectName,a=n.propertyName;let i=n.propertyIndex;if(x||(x=Zt.findNode(this.rootNode,n.nodeName)||this.rootNode,this.node=x),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!x){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(r){let d=n.objectIndex;switch(r){case"materials":if(!x.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!x.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}x=x.material.materials;break;case"bones":if(!x.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}x=x.skeleton.bones;for(let h=0;h<x.length;h++)if(x[h].name===d){d=h;break}break;default:if(x[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}x=x[r]}if(d!==void 0){if(x[d]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,x);return}x=x[d]}}const o=x[a];if(o===void 0){const d=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+d+"."+a+" but it wasn't found.",x);return}let l=this.Versioning.None;this.targetObject=x,x.needsUpdate!==void 0?l=this.Versioning.NeedsUpdate:x.matrixWorldNeedsUpdate!==void 0&&(l=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(i!==void 0){if(a==="morphTargetInfluences"){if(!x.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!x.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}x.morphTargetDictionary[i]!==void 0&&(i=x.morphTargetDictionary[i])}c=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=i}else o.fromArray!==void 0&&o.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(c=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=a;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][l]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Zt.Composite=Sxe,Zt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Zt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Zt.prototype.GetterByBindingType=[Zt.prototype._getValue_direct,Zt.prototype._getValue_array,Zt.prototype._getValue_arrayElement,Zt.prototype._getValue_toArray],Zt.prototype.SetterByBindingTypeAndVersioning=[[Zt.prototype._setValue_direct,Zt.prototype._setValue_direct_setNeedsUpdate,Zt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Zt.prototype._setValue_array,Zt.prototype._setValue_array_setNeedsUpdate,Zt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Zt.prototype._setValue_arrayElement,Zt.prototype._setValue_arrayElement_setNeedsUpdate,Zt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Zt.prototype._setValue_fromArray,Zt.prototype._setValue_fromArray_setNeedsUpdate,Zt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Vre{constructor(){this.isAnimationObjectGroup=!0,this.uuid=f2(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const x={};this._indicesByUUID=x;for(let r=0,a=arguments.length;r!==a;++r)x[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}add(){const x=this._objects,n=this._indicesByUUID,r=this._paths,a=this._parsedPaths,i=this._bindings,o=i.length;let l,c=x.length,d=this.nCachedObjects_;for(let h=0,p=arguments.length;h!==p;++h){const m=arguments[h],g=m.uuid;let y=n[g];if(y===void 0){y=c++,n[g]=y,x.push(m);for(let b=0,v=o;b!==v;++b)i[b].push(new Zt(m,r[b],a[b]))}else if(y<d){l=x[y];const b=--d,v=x[b];n[v.uuid]=y,x[y]=v,n[g]=b,x[b]=m;for(let w=0,_=o;w!==_;++w){const T=i[w],A=T[b];let E=T[y];T[y]=A,E===void 0&&(E=new Zt(m,r[w],a[w])),T[b]=E}}else x[y]!==l&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=d}remove(){const x=this._objects,n=this._indicesByUUID,r=this._bindings,a=r.length;let i=this.nCachedObjects_;for(let o=0,l=arguments.length;o!==l;++o){const c=arguments[o],d=c.uuid,h=n[d];if(h!==void 0&&h>=i){const p=i++,m=x[p];n[m.uuid]=h,x[h]=m,n[d]=p,x[p]=c;for(let g=0,y=a;g!==y;++g){const b=r[g],v=b[p],w=b[h];b[h]=v,b[p]=w}}}this.nCachedObjects_=i}uncache(){const x=this._objects,n=this._indicesByUUID,r=this._bindings,a=r.length;let i=this.nCachedObjects_,o=x.length;for(let l=0,c=arguments.length;l!==c;++l){const d=arguments[l],h=d.uuid,p=n[h];if(p!==void 0)if(delete n[h],p<i){const m=--i,g=x[m],y=--o,b=x[y];n[g.uuid]=p,x[p]=g,n[b.uuid]=m,x[m]=b,x.pop();for(let v=0,w=a;v!==w;++v){const _=r[v],T=_[m],A=_[y];_[p]=T,_[m]=A,_.pop()}}else{const m=--o,g=x[m];m>0&&(n[g.uuid]=p),x[p]=g,x.pop();for(let y=0,b=a;y!==b;++y){const v=r[y];v[p]=v[m],v.pop()}}}this.nCachedObjects_=i}subscribe_(x,n){const r=this._bindingsIndicesByPath;let a=r[x];const i=this._bindings;if(a!==void 0)return i[a];const o=this._paths,l=this._parsedPaths,c=this._objects,d=c.length,h=this.nCachedObjects_,p=new Array(d);a=i.length,r[x]=a,o.push(x),l.push(n),i.push(p);for(let m=h,g=c.length;m!==g;++m){const y=c[m];p[m]=new Zt(y,x,n)}return p}unsubscribe_(x){const n=this._bindingsIndicesByPath,r=n[x];if(r!==void 0){const a=this._paths,i=this._parsedPaths,o=this._bindings,l=o.length-1,c=o[l],d=x[l];n[d]=r,o[r]=c,o.pop(),i[r]=i[l],i.pop(),a[r]=a[l],a.pop()}}}class Txe{constructor(x,n,r=null,a=n.blendMode){this._mixer=x,this._clip=n,this._localRoot=r,this.blendMode=a;const i=n.tracks,o=i.length,l=new Array(o),c={endingStart:Hi,endingEnd:Hi};for(let d=0;d!==o;++d){const h=i[d].createInterpolant(null);l[d]=h,h.settings=c}this._interpolantSettings=c,this._interpolants=l,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=lJ,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(x){return this._startTime=x,this}setLoop(x,n){return this.loop=x,this.repetitions=n,this}setEffectiveWeight(x){return this.weight=x,this._effectiveWeight=this.enabled?x:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(x){return this._scheduleFading(x,0,1)}fadeOut(x){return this._scheduleFading(x,1,0)}crossFadeFrom(x,n,r){if(x.fadeOut(n),this.fadeIn(n),r){const a=this._clip.duration,i=x._clip.duration,o=i/a,l=a/i;x.warp(1,o,n),this.warp(l,1,n)}return this}crossFadeTo(x,n,r){return x.crossFadeFrom(this,n,r)}stopFading(){const x=this._weightInterpolant;return x!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(x)),this}setEffectiveTimeScale(x){return this.timeScale=x,this._effectiveTimeScale=this.paused?0:x,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(x){return this.timeScale=this._clip.duration/x,this.stopWarping()}syncWith(x){return this.time=x.time,this.timeScale=x.timeScale,this.stopWarping()}halt(x){return this.warp(this._effectiveTimeScale,0,x)}warp(x,n,r){const a=this._mixer,i=a.time,o=this.timeScale;let l=this._timeScaleInterpolant;l===null&&(l=a._lendControlInterpolant(),this._timeScaleInterpolant=l);const c=l.parameterPositions,d=l.sampleValues;return c[0]=i,c[1]=i+r,d[0]=x/o,d[1]=n/o,this}stopWarping(){const x=this._timeScaleInterpolant;return x!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(x)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(x,n,r,a){if(!this.enabled){this._updateWeight(x);return}const i=this._startTime;if(i!==null){const c=(x-i)*r;if(c<0||r===0)return;this._startTime=null,n=r*c}n*=this._updateTimeScale(x);const o=this._updateTime(n),l=this._updateWeight(x);if(l>0){const c=this._interpolants,d=this._propertyBindings;switch(this.blendMode){case hA:for(let h=0,p=c.length;h!==p;++h)c[h].evaluate(o),d[h].accumulateAdditive(l);break;case a1:default:for(let h=0,p=c.length;h!==p;++h)c[h].evaluate(o),d[h].accumulate(a,l)}}}_updateWeight(x){let n=0;if(this.enabled){n=this.weight;const r=this._weightInterpolant;if(r!==null){const a=r.evaluate(x)[0];n*=a,x>r.parameterPositions[1]&&(this.stopFading(),a===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(x){let n=0;if(!this.paused){n=this.timeScale;const r=this._timeScaleInterpolant;r!==null&&(n*=r.evaluate(x)[0],x>r.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n))}return this._effectiveTimeScale=n,n}_updateTime(x){const n=this._clip.duration,r=this.loop;let a=this.time+x,i=this._loopCount;const o=r===cJ;if(x===0)return i===-1?a:o&&(i&1)===1?n-a:a;if(r===oJ){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(a>=n)a=n;else if(a<0)a=0;else{this.time=a;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:x<0?-1:1})}}else{if(i===-1&&(x>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),a>=n||a<0){const l=Math.floor(a/n);a-=n*l,i+=Math.abs(l);const c=this.repetitions-i;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,a=x>0?n:0,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:x>0?1:-1});else{if(c===1){const d=x<0;this._setEndings(d,!d,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=a,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:l})}}else this.time=a;if(o&&(i&1)===1)return n-a}return a}_setEndings(x,n,r){const a=this._interpolantSettings;r?(a.endingStart=Yi,a.endingEnd=Yi):(x?a.endingStart=this.zeroSlopeAtStart?Yi:Hi:a.endingStart=Dd,n?a.endingEnd=this.zeroSlopeAtEnd?Yi:Hi:a.endingEnd=Dd)}_scheduleFading(x,n,r){const a=this._mixer,i=a.time;let o=this._weightInterpolant;o===null&&(o=a._lendControlInterpolant(),this._weightInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=i,c[0]=n,l[1]=i+x,c[1]=r,this}}const Axe=new Float32Array(1);class Hre extends null{constructor(x){super(),this._root=x,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(x,n){const r=x._localRoot||this._root,a=x._clip.tracks,i=a.length,o=x._propertyBindings,l=x._interpolants,c=r.uuid,d=this._bindingsByRootAndName;let h=d[c];h===void 0&&(h={},d[c]=h);for(let p=0;p!==i;++p){const m=a[p],g=m.name;let y=h[g];if(y!==void 0)++y.referenceCount,o[p]=y;else{if(y=o[p],y!==void 0){y._cacheIndex===null&&(++y.referenceCount,this._addInactiveBinding(y,c,g));continue}const b=n&&n._propertyBindings[p].binding.parsedPath;y=new pxe(Zt.create(r,g,b),m.ValueTypeName,m.getValueSize()),++y.referenceCount,this._addInactiveBinding(y,c,g),o[p]=y}l[p].resultBuffer=y.buffer}}_activateAction(x){if(!this._isActiveAction(x)){if(x._cacheIndex===null){const r=(x._localRoot||this._root).uuid,a=x._clip.uuid,i=this._actionsByClip[a];this._bindAction(x,i&&i.knownActions[0]),this._addInactiveAction(x,a,r)}const n=x._propertyBindings;for(let r=0,a=n.length;r!==a;++r){const i=n[r];i.useCount++===0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(x)}}_deactivateAction(x){if(this._isActiveAction(x)){const n=x._propertyBindings;for(let r=0,a=n.length;r!==a;++r){const i=n[r];--i.useCount===0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(x)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const x=this;this.stats={actions:{get total(){return x._actions.length},get inUse(){return x._nActiveActions}},bindings:{get total(){return x._bindings.length},get inUse(){return x._nActiveBindings}},controlInterpolants:{get total(){return x._controlInterpolants.length},get inUse(){return x._nActiveControlInterpolants}}}}_isActiveAction(x){const n=x._cacheIndex;return n!==null&&n<this._nActiveActions}_addInactiveAction(x,n,r){const a=this._actions,i=this._actionsByClip;let o=i[n];if(o===void 0)o={knownActions:[x],actionByRoot:{}},x._byClipCacheIndex=0,i[n]=o;else{const l=o.knownActions;x._byClipCacheIndex=l.length,l.push(x)}x._cacheIndex=a.length,a.push(x),o.actionByRoot[r]=x}_removeInactiveAction(x){const n=this._actions,r=n[n.length-1],a=x._cacheIndex;r._cacheIndex=a,n[a]=r,n.pop(),x._cacheIndex=null;const i=x._clip.uuid,o=this._actionsByClip,l=o[i],c=l.knownActions,d=c[c.length-1],h=x._byClipCacheIndex;d._byClipCacheIndex=h,c[h]=d,c.pop(),x._byClipCacheIndex=null;const p=l.actionByRoot,m=(x._localRoot||this._root).uuid;delete p[m],c.length===0&&delete o[i],this._removeInactiveBindingsForAction(x)}_removeInactiveBindingsForAction(x){const n=x._propertyBindings;for(let r=0,a=n.length;r!==a;++r){const i=n[r];--i.referenceCount===0&&this._removeInactiveBinding(i)}}_lendAction(x){const n=this._actions,r=x._cacheIndex,a=this._nActiveActions++,i=n[a];x._cacheIndex=a,n[a]=x,i._cacheIndex=r,n[r]=i}_takeBackAction(x){const n=this._actions,r=x._cacheIndex,a=--this._nActiveActions,i=n[a];x._cacheIndex=a,n[a]=x,i._cacheIndex=r,n[r]=i}_addInactiveBinding(x,n,r){const a=this._bindingsByRootAndName,i=this._bindings;let o=a[n];o===void 0&&(o={},a[n]=o),o[r]=x,x._cacheIndex=i.length,i.push(x)}_removeInactiveBinding(x){const n=this._bindings,r=x.binding,a=r.rootNode.uuid,i=r.path,o=this._bindingsByRootAndName,l=o[a],c=n[n.length-1],d=x._cacheIndex;c._cacheIndex=d,n[d]=c,n.pop(),delete l[i],Object.keys(l).length===0&&delete o[a]}_lendBinding(x){const n=this._bindings,r=x._cacheIndex,a=this._nActiveBindings++,i=n[a];x._cacheIndex=a,n[a]=x,i._cacheIndex=r,n[r]=i}_takeBackBinding(x){const n=this._bindings,r=x._cacheIndex,a=--this._nActiveBindings,i=n[a];x._cacheIndex=a,n[a]=x,i._cacheIndex=r,n[r]=i}_lendControlInterpolant(){const x=this._controlInterpolants,n=this._nActiveControlInterpolants++;let r=x[n];return r===void 0&&(r=new KE(new Float32Array(2),new Float32Array(2),1,Axe),r.__cacheIndex=n,x[n]=r),r}_takeBackControlInterpolant(x){const n=this._controlInterpolants,r=x.__cacheIndex,a=--this._nActiveControlInterpolants,i=n[a];x.__cacheIndex=a,n[a]=x,i.__cacheIndex=r,n[r]=i}clipAction(x,n,r){const a=n||this._root,i=a.uuid;let o=typeof x=="string"?ec.findByName(a,x):x;const l=o!==null?o.uuid:x,c=this._actionsByClip[l];let d=null;if(r===void 0&&(o!==null?r=o.blendMode:r=a1),c!==void 0){const p=c.actionByRoot[i];if(p!==void 0&&p.blendMode===r)return p;d=c.knownActions[0],o===null&&(o=d._clip)}if(o===null)return null;const h=new Txe(this,o,n,r);return this._bindAction(h,d),this._addInactiveAction(h,l,i),h}existingAction(x,n){const r=n||this._root,a=r.uuid,i=typeof x=="string"?ec.findByName(r,x):x,o=i?i.uuid:x,l=this._actionsByClip[o];return l!==void 0&&l.actionByRoot[a]||null}stopAllAction(){const x=this._actions,n=this._nActiveActions;for(let r=n-1;r>=0;--r)x[r].stop();return this}update(x){x*=this.timeScale;const n=this._actions,r=this._nActiveActions,a=this.time+=x,i=Math.sign(x),o=this._accuIndex^=1;for(let d=0;d!==r;++d)n[d]._update(a,x,i,o);const l=this._bindings,c=this._nActiveBindings;for(let d=0;d!==c;++d)l[d].apply(o);return this}setTime(x){this.time=0;for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;return this.update(x)}getRoot(){return this._root}uncacheClip(x){const n=this._actions,r=x.uuid,a=this._actionsByClip,i=a[r];if(i!==void 0){const o=i.knownActions;for(let l=0,c=o.length;l!==c;++l){const d=o[l];this._deactivateAction(d);const h=d._cacheIndex,p=n[n.length-1];d._cacheIndex=null,d._byClipCacheIndex=null,p._cacheIndex=h,n[h]=p,n.pop(),this._removeInactiveBindingsForAction(d)}delete a[r]}}uncacheRoot(x){const n=x.uuid,r=this._actionsByClip;for(const o in r){const l=r[o].actionByRoot,c=l[n];c!==void 0&&(this._deactivateAction(c),this._removeInactiveAction(c))}const a=this._bindingsByRootAndName,i=a[n];if(i!==void 0)for(const o in i){const l=i[o];l.restoreOriginalState(),this._removeInactiveBinding(l)}}uncacheAction(x,n){const r=this.existingAction(x,n);r!==null&&(this._deactivateAction(r),this._removeInactiveAction(r))}}class dC{constructor(x){typeof x=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),x=arguments[1]),this.value=x}clone(){return new dC(this.value.clone===void 0?this.value:this.value.clone())}}let Exe=0;class Yre extends null{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Exe++}),this.name="",this.usage=Od,this.uniforms=[]}add(x){return this.uniforms.push(x),this}remove(x){const n=this.uniforms.indexOf(x);return n!==-1&&this.uniforms.splice(n,1),this}setName(x){return this.name=x,this}setUsage(x){return this.usage=x,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(x){this.name=x.name,this.usage=x.usage;const n=x.uniforms;this.uniforms.length=0;for(let r=0,a=n.length;r<a;r++)this.uniforms.push(n[r].clone());return this}clone(){return new this.constructor().copy(this)}}class qre extends null{constructor(x,n,r=1){super(x,n),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=r}copy(x){return super.copy(x),this.meshPerAttribute=x.meshPerAttribute,this}clone(x){const n=super.clone(x);return n.meshPerAttribute=this.meshPerAttribute,n}toJSON(x){const n=super.toJSON(x);return n.isInstancedInterleavedBuffer=!0,n.meshPerAttribute=this.meshPerAttribute,n}}class Xre{constructor(x,n,r,a,i){this.isGLBufferAttribute=!0,this.buffer=x,this.type=n,this.itemSize=r,this.elementSize=a,this.count=i,this.version=0}set needsUpdate(x){x===!0&&this.version++}setBuffer(x){return this.buffer=x,this}setType(x,n){return this.type=x,this.elementSize=n,this}setItemSize(x){return this.itemSize=x,this}setCount(x){return this.count=x,this}}class Kre{constructor(x,n,r=0,a=1/0){this.ray=new qd(x,n),this.near=r,this.far=a,this.camera=null,this.layers=new _1,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(x,n){this.ray.set(x,n)}setFromCamera(x,n){n.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(n.matrixWorld),this.ray.direction.set(x.x,x.y,.5).unproject(n).sub(this.ray.origin).normalize(),this.camera=n):n.isOrthographicCamera?(this.ray.origin.set(x.x,x.y,(n.near+n.far)/(n.near-n.far)).unproject(n),this.ray.direction.set(0,0,-1).transformDirection(n.matrixWorld),this.camera=n):console.error("THREE.Raycaster: Unsupported camera type: "+n.type)}intersectObject(x,n=!0,r=[]){return gy(x,this,r,n),r.sort(hC),r}intersectObjects(x,n=!0,r=[]){for(let a=0,i=x.length;a<i;a++)gy(x[a],this,r,n);return r.sort(hC),r}}function hC(s,x){return s.distance-x.distance}function gy(s,x,n,r){if(s.layers.test(x.layers)&&s.raycast(x,n),r===!0){const a=s.children;for(let i=0,o=a.length;i<o;i++)gy(a[i],x,n,!0)}}class $re{constructor(x=1,n=0,r=0){return this.radius=x,this.phi=n,this.theta=r,this}set(x,n,r){return this.radius=x,this.phi=n,this.theta=r,this}copy(x){return this.radius=x.radius,this.phi=x.phi,this.theta=x.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(x){return this.setFromCartesianCoords(x.x,x.y,x.z)}setFromCartesianCoords(x,n,r){return this.radius=Math.sqrt(x*x+n*n+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(x,r),this.phi=Math.acos(Gx(n/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Zre{constructor(x=1,n=0,r=0){return this.radius=x,this.theta=n,this.y=r,this}set(x,n,r){return this.radius=x,this.theta=n,this.y=r,this}copy(x){return this.radius=x.radius,this.theta=x.theta,this.y=x.y,this}setFromVector3(x){return this.setFromCartesianCoords(x.x,x.y,x.z)}setFromCartesianCoords(x,n,r){return this.radius=Math.sqrt(x*x+r*r),this.theta=Math.atan2(x,r),this.y=n,this}clone(){return new this.constructor().copy(this)}}const pC=new n0;class Jre{constructor(x=new n0(1/0,1/0),n=new n0(-1/0,-1/0)){this.isBox2=!0,this.min=x,this.max=n}set(x,n){return this.min.copy(x),this.max.copy(n),this}setFromPoints(x){this.makeEmpty();for(let n=0,r=x.length;n<r;n++)this.expandByPoint(x[n]);return this}setFromCenterAndSize(x,n){const r=pC.copy(n).multiplyScalar(.5);return this.min.copy(x).sub(r),this.max.copy(x).add(r),this}clone(){return new this.constructor().copy(this)}copy(x){return this.min.copy(x.min),this.max.copy(x.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(x){return this.isEmpty()?x.set(0,0):x.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(x){return this.isEmpty()?x.set(0,0):x.subVectors(this.max,this.min)}expandByPoint(x){return this.min.min(x),this.max.max(x),this}expandByVector(x){return this.min.sub(x),this.max.add(x),this}expandByScalar(x){return this.min.addScalar(-x),this.max.addScalar(x),this}containsPoint(x){return!(x.x<this.min.x||x.x>this.max.x||x.y<this.min.y||x.y>this.max.y)}containsBox(x){return this.min.x<=x.min.x&&x.max.x<=this.max.x&&this.min.y<=x.min.y&&x.max.y<=this.max.y}getParameter(x,n){return n.set((x.x-this.min.x)/(this.max.x-this.min.x),(x.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(x){return!(x.max.x<this.min.x||x.min.x>this.max.x||x.max.y<this.min.y||x.min.y>this.max.y)}clampPoint(x,n){return n.copy(x).clamp(this.min,this.max)}distanceToPoint(x){return pC.copy(x).clamp(this.min,this.max).sub(x).length()}intersect(x){return this.min.max(x.min),this.max.min(x.max),this}union(x){return this.min.min(x.min),this.max.max(x.max),this}translate(x){return this.min.add(x),this.max.add(x),this}equals(x){return x.min.equals(this.min)&&x.max.equals(this.max)}}const fC=new K,Wh=new K;class Qre{constructor(x=new K,n=new K){this.start=x,this.end=n}set(x,n){return this.start.copy(x),this.end.copy(n),this}copy(x){return this.start.copy(x.start),this.end.copy(x.end),this}getCenter(x){return x.addVectors(this.start,this.end).multiplyScalar(.5)}delta(x){return x.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(x,n){return this.delta(n).multiplyScalar(x).add(this.start)}closestPointToPointParameter(x,n){fC.subVectors(x,this.start),Wh.subVectors(this.end,this.start);const r=Wh.dot(Wh);let i=Wh.dot(fC)/r;return n&&(i=Gx(i,0,1)),i}closestPointToPoint(x,n,r){const a=this.closestPointToPointParameter(x,n);return this.delta(r).multiplyScalar(a).add(this.start)}applyMatrix4(x){return this.start.applyMatrix4(x),this.end.applyMatrix4(x),this}equals(x){return x.start.equals(this.start)&&x.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const mC=new K;class jre extends null{constructor(x,n){super(),this.light=x,this.light.updateMatrixWorld(),this.matrix=x.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new Rt,a=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,l=1,c=32;o<c;o++,l++){const d=o/c*Math.PI*2,h=l/c*Math.PI*2;a.push(Math.cos(d),Math.sin(d),1,Math.cos(h),Math.sin(h),1)}r.setAttribute("position",new q0(a,3));const i=new i2({fog:!1,toneMapped:!1});this.cone=new $1(r,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const x=this.light.distance?this.light.distance:1e3,n=x*Math.tan(this.light.angle);this.cone.scale.set(n,n,x),mC.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(mC),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ds=new K,Gh=new wt,yy=new wt;class ese extends null{constructor(x){const n=gC(x),r=new Rt,a=[],i=[],o=new M0(0,0,1),l=new M0(0,1,0);for(let d=0;d<n.length;d++){const h=n[d];h.parent&&h.parent.isBone&&(a.push(0,0,0),a.push(0,0,0),i.push(o.r,o.g,o.b),i.push(l.r,l.g,l.b))}r.setAttribute("position",new q0(a,3)),r.setAttribute("color",new q0(i,3));const c=new i2({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,c),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=x,this.bones=n,this.matrix=x.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(x){const n=this.bones,r=this.geometry,a=r.getAttribute("position");yy.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<n.length;i++){const l=n[i];l.parent&&l.parent.isBone&&(Gh.multiplyMatrices(yy,l.matrixWorld),Ds.setFromMatrixPosition(Gh),a.setXYZ(o,Ds.x,Ds.y,Ds.z),Gh.multiplyMatrices(yy,l.parent.matrixWorld),Ds.setFromMatrixPosition(Gh),a.setXYZ(o+1,Ds.x,Ds.y,Ds.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(x)}}function gC(s){const x=[];s.isBone===!0&&x.push(s);for(let n=0;n<s.children.length;n++)x.push.apply(x,gC(s.children[n]));return x}class tse extends null{constructor(x,n,r){const a=new Zl(n,4,2),i=new F2({wireframe:!0,fog:!1,toneMapped:!1});super(a,i),this.light=x,this.light.updateMatrixWorld(),this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Cxe=new K,yC=new M0,bC=new M0;class xse extends null{constructor(x,n,r){super(),this.light=x,this.light.updateMatrixWorld(),this.matrix=x.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;const a=new $l(n);a.rotateY(Math.PI*.5),this.material=new F2({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=a.getAttribute("position"),o=new Float32Array(i.count*3);a.setAttribute("color",new Qx(o,3)),this.add(new yn(a,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const x=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const n=x.geometry.getAttribute("color");yC.copy(this.light.color),bC.copy(this.light.groundColor);for(let r=0,a=n.count;r<a;r++){const i=r<a/2?yC:bC;n.setXYZ(r,i.r,i.g,i.b)}n.needsUpdate=!0}x.lookAt(Cxe.setFromMatrixPosition(this.light.matrixWorld).negate())}}class nse extends null{constructor(x=10,n=10,r=4473924,a=8947848){r=new M0(r),a=new M0(a);const i=n/2,o=x/n,l=x/2,c=[],d=[];for(let m=0,g=0,y=-l;m<=n;m++,y+=o){c.push(-l,0,y,l,0,y),c.push(y,0,-l,y,0,l);const b=m===i?r:a;b.toArray(d,g),g+=3,b.toArray(d,g),g+=3,b.toArray(d,g),g+=3,b.toArray(d,g),g+=3}const h=new Rt;h.setAttribute("position",new q0(c,3)),h.setAttribute("color",new q0(d,3));const p=new i2({vertexColors:!0,toneMapped:!1});super(h,p),this.type="GridHelper"}}class rse extends null{constructor(x=10,n=16,r=8,a=64,i=4473924,o=8947848){i=new M0(i),o=new M0(o);const l=[],c=[];for(let p=0;p<=n;p++){const m=p/n*(Math.PI*2),g=Math.sin(m)*x,y=Math.cos(m)*x;l.push(0,0,0),l.push(g,0,y);const b=p&1?i:o;c.push(b.r,b.g,b.b),c.push(b.r,b.g,b.b)}for(let p=0;p<=r;p++){const m=p&1?i:o,g=x-x/r*p;for(let y=0;y<a;y++){let b=y/a*(Math.PI*2),v=Math.sin(b)*g,w=Math.cos(b)*g;l.push(v,0,w),c.push(m.r,m.g,m.b),b=(y+1)/a*(Math.PI*2),v=Math.sin(b)*g,w=Math.cos(b)*g,l.push(v,0,w),c.push(m.r,m.g,m.b)}}const d=new Rt;d.setAttribute("position",new q0(l,3)),d.setAttribute("color",new q0(c,3));const h=new i2({vertexColors:!0,toneMapped:!1});super(d,h),this.type="PolarGridHelper"}}const vC=new K,Vh=new K,wC=new K;class sse extends null{constructor(x,n,r){super(),this.light=x,this.light.updateMatrixWorld(),this.matrix=x.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,n===void 0&&(n=1);let a=new Rt;a.setAttribute("position",new q0([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const i=new i2({fog:!1,toneMapped:!1});this.lightPlane=new Ya(a,i),this.add(this.lightPlane),a=new Rt,a.setAttribute("position",new q0([0,0,0,0,0,1],3)),this.targetLine=new Ya(a,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){vC.setFromMatrixPosition(this.light.matrixWorld),Vh.setFromMatrixPosition(this.light.target.matrixWorld),wC.subVectors(Vh,vC),this.lightPlane.lookAt(Vh),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Vh),this.targetLine.scale.z=wC.length()}}const Hh=new K,Lx=new P1;class ase extends null{constructor(x){const n=new Rt,r=new i2({color:16777215,vertexColors:!0,toneMapped:!1}),a=[],i=[],o={};l("n1","n2"),l("n2","n4"),l("n4","n3"),l("n3","n1"),l("f1","f2"),l("f2","f4"),l("f4","f3"),l("f3","f1"),l("n1","f1"),l("n2","f2"),l("n3","f3"),l("n4","f4"),l("p","n1"),l("p","n2"),l("p","n3"),l("p","n4"),l("u1","u2"),l("u2","u3"),l("u3","u1"),l("c","t"),l("p","c"),l("cn1","cn2"),l("cn3","cn4"),l("cf1","cf2"),l("cf3","cf4");function l(y,b){c(y),c(b)}function c(y){a.push(0,0,0),i.push(0,0,0),o[y]===void 0&&(o[y]=[]),o[y].push(a.length/3-1)}n.setAttribute("position",new q0(a,3)),n.setAttribute("color",new q0(i,3)),super(n,r),this.type="CameraHelper",this.camera=x,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=x.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const d=new M0(16755200),h=new M0(16711680),p=new M0(43775),m=new M0(16777215),g=new M0(3355443);this.setColors(d,h,p,m,g)}setColors(x,n,r,a,i){const l=this.geometry.getAttribute("color");l.setXYZ(0,x.r,x.g,x.b),l.setXYZ(1,x.r,x.g,x.b),l.setXYZ(2,x.r,x.g,x.b),l.setXYZ(3,x.r,x.g,x.b),l.setXYZ(4,x.r,x.g,x.b),l.setXYZ(5,x.r,x.g,x.b),l.setXYZ(6,x.r,x.g,x.b),l.setXYZ(7,x.r,x.g,x.b),l.setXYZ(8,x.r,x.g,x.b),l.setXYZ(9,x.r,x.g,x.b),l.setXYZ(10,x.r,x.g,x.b),l.setXYZ(11,x.r,x.g,x.b),l.setXYZ(12,x.r,x.g,x.b),l.setXYZ(13,x.r,x.g,x.b),l.setXYZ(14,x.r,x.g,x.b),l.setXYZ(15,x.r,x.g,x.b),l.setXYZ(16,x.r,x.g,x.b),l.setXYZ(17,x.r,x.g,x.b),l.setXYZ(18,x.r,x.g,x.b),l.setXYZ(19,x.r,x.g,x.b),l.setXYZ(20,x.r,x.g,x.b),l.setXYZ(21,x.r,x.g,x.b),l.setXYZ(22,x.r,x.g,x.b),l.setXYZ(23,x.r,x.g,x.b),l.setXYZ(24,n.r,n.g,n.b),l.setXYZ(25,n.r,n.g,n.b),l.setXYZ(26,n.r,n.g,n.b),l.setXYZ(27,n.r,n.g,n.b),l.setXYZ(28,n.r,n.g,n.b),l.setXYZ(29,n.r,n.g,n.b),l.setXYZ(30,n.r,n.g,n.b),l.setXYZ(31,n.r,n.g,n.b),l.setXYZ(32,r.r,r.g,r.b),l.setXYZ(33,r.r,r.g,r.b),l.setXYZ(34,r.r,r.g,r.b),l.setXYZ(35,r.r,r.g,r.b),l.setXYZ(36,r.r,r.g,r.b),l.setXYZ(37,r.r,r.g,r.b),l.setXYZ(38,a.r,a.g,a.b),l.setXYZ(39,a.r,a.g,a.b),l.setXYZ(40,i.r,i.g,i.b),l.setXYZ(41,i.r,i.g,i.b),l.setXYZ(42,i.r,i.g,i.b),l.setXYZ(43,i.r,i.g,i.b),l.setXYZ(44,i.r,i.g,i.b),l.setXYZ(45,i.r,i.g,i.b),l.setXYZ(46,i.r,i.g,i.b),l.setXYZ(47,i.r,i.g,i.b),l.setXYZ(48,i.r,i.g,i.b),l.setXYZ(49,i.r,i.g,i.b),l.needsUpdate=!0}update(){const x=this.geometry,n=this.pointMap,r=1,a=1;Lx.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Vx("c",n,x,Lx,0,0,-1),Vx("t",n,x,Lx,0,0,1),Vx("n1",n,x,Lx,-r,-a,-1),Vx("n2",n,x,Lx,r,-a,-1),Vx("n3",n,x,Lx,-r,a,-1),Vx("n4",n,x,Lx,r,a,-1),Vx("f1",n,x,Lx,-r,-a,1),Vx("f2",n,x,Lx,r,-a,1),Vx("f3",n,x,Lx,-r,a,1),Vx("f4",n,x,Lx,r,a,1),Vx("u1",n,x,Lx,r*.7,a*1.1,-1),Vx("u2",n,x,Lx,-r*.7,a*1.1,-1),Vx("u3",n,x,Lx,0,a*2,-1),Vx("cf1",n,x,Lx,-r,0,1),Vx("cf2",n,x,Lx,r,0,1),Vx("cf3",n,x,Lx,0,-a,1),Vx("cf4",n,x,Lx,0,a,1),Vx("cn1",n,x,Lx,-r,0,-1),Vx("cn2",n,x,Lx,r,0,-1),Vx("cn3",n,x,Lx,0,-a,-1),Vx("cn4",n,x,Lx,0,a,-1),x.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Vx(s,x,n,r,a,i,o){Hh.set(a,i,o).unproject(r);const l=x[s];if(l!==void 0){const c=n.getAttribute("position");for(let d=0,h=l.length;d<h;d++)c.setXYZ(l[d],Hh.x,Hh.y,Hh.z)}}const Yh=new Da;class ise extends null{constructor(x,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),a=new Float32Array(8*3),i=new Rt;i.setIndex(new Qx(r,1)),i.setAttribute("position",new Qx(a,3)),super(i,new i2({color:n,toneMapped:!1})),this.object=x,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(x){if(x!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Yh.setFromObject(this.object),Yh.isEmpty())return;const n=Yh.min,r=Yh.max,a=this.geometry.attributes.position,i=a.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=n.x,i[4]=r.y,i[5]=r.z,i[6]=n.x,i[7]=n.y,i[8]=r.z,i[9]=r.x,i[10]=n.y,i[11]=r.z,i[12]=r.x,i[13]=r.y,i[14]=n.z,i[15]=n.x,i[16]=r.y,i[17]=n.z,i[18]=n.x,i[19]=n.y,i[20]=n.z,i[21]=r.x,i[22]=n.y,i[23]=n.z,a.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(x){return this.object=x,this.update(),this}copy(x,n){return super.copy(x,n),this.object=x.object,this}}class ose extends null{constructor(x,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),a=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new Rt;i.setIndex(new Qx(r,1)),i.setAttribute("position",new q0(a,3)),super(i,new i2({color:n,toneMapped:!1})),this.box=x,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(x){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(x))}}class lse extends null{constructor(x,n=1,r=16776960){const a=r,i=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new Rt;o.setAttribute("position",new q0(i,3)),o.computeBoundingSphere(),super(o,new i2({color:a,toneMapped:!1})),this.type="PlaneHelper",this.plane=x,this.size=n;const l=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],c=new Rt;c.setAttribute("position",new q0(l,3)),c.computeBoundingSphere(),this.add(new yn(c,new F2({color:a,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(x){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(x)}}const _C=new K;let qh,by;class cse extends null{constructor(x=new K(0,0,1),n=new K(0,0,0),r=1,a=16776960,i=r*.2,o=i*.2){super(),this.type="ArrowHelper",qh===void 0&&(qh=new Rt,qh.setAttribute("position",new q0([0,0,0,0,1,0],3)),by=new go(0,.5,1,5,1),by.translate(0,-.5,0)),this.position.copy(n),this.line=new Ya(qh,new i2({color:a,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new yn(by,new F2({color:a,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(x),this.setLength(r,i,o)}setDirection(x){if(x.y>.99999)this.quaternion.set(0,0,0,1);else if(x.y<-.99999)this.quaternion.set(1,0,0,0);else{_C.set(x.z,0,-x.x).normalize();const n=Math.acos(x.y);this.quaternion.setFromAxisAngle(_C,n)}}setLength(x,n=x*.2,r=n*.2){this.line.scale.set(1,Math.max(1e-4,x-n),1),this.line.updateMatrix(),this.cone.scale.set(r,n,r),this.cone.position.y=x,this.cone.updateMatrix()}setColor(x){this.line.material.color.set(x),this.cone.material.color.set(x)}copy(x){return super.copy(x,!1),this.line.copy(x.line),this.cone.copy(x.cone),this}}class use extends null{constructor(x=1){const n=[0,0,0,x,0,0,0,0,0,0,x,0,0,0,0,0,0,x],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],a=new Rt;a.setAttribute("position",new q0(n,3)),a.setAttribute("color",new q0(r,3));const i=new i2({vertexColors:!0,toneMapped:!1});super(a,i),this.type="AxesHelper"}setColors(x,n,r){const a=new M0,i=this.geometry.attributes.color.array;return a.set(x),a.toArray(i,0),a.toArray(i,3),a.set(n),a.toArray(i,6),a.toArray(i,9),a.set(r),a.toArray(i,12),a.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Mxe{constructor(){this.type="ShapePath",this.color=new M0,this.subPaths=[],this.currentPath=null}moveTo(x,n){return this.currentPath=new vh,this.subPaths.push(this.currentPath),this.currentPath.moveTo(x,n),this}lineTo(x,n){return this.currentPath.lineTo(x,n),this}quadraticCurveTo(x,n,r,a){return this.currentPath.quadraticCurveTo(x,n,r,a),this}bezierCurveTo(x,n,r,a,i,o){return this.currentPath.bezierCurveTo(x,n,r,a,i,o),this}splineThru(x){return this.currentPath.splineThru(x),this}toShapes(x,n){function r(_){const T=[];for(let A=0,E=_.length;A<E;A++){const M=_[A],I=new yo;I.curves=M.curves,T.push(I)}return T}function a(_,T){const A=T.length;let E=!1;for(let M=A-1,I=0;I<A;M=I++){let C=T[M],k=T[I],O=k.x-C.x,z=k.y-C.y;if(Math.abs(z)>Number.EPSILON){if(z<0&&(C=T[I],O=-O,k=T[M],z=-z),_.y<C.y||_.y>k.y)continue;if(_.y===C.y){if(_.x===C.x)return!0}else{const ee=z*(_.x-C.x)-O*(_.y-C.y);if(ee===0)return!0;if(ee<0)continue;E=!E}}else{if(_.y!==C.y)continue;if(k.x<=_.x&&_.x<=C.x||C.x<=_.x&&_.x<=k.x)return!0}}return E}const i=Zr.isClockWise,o=this.subPaths;if(o.length===0)return[];if(n===!0)return r(o);let l,c,d;const h=[];if(o.length===1)return c=o[0],d=new yo,d.curves=c.curves,h.push(d),h;let p=!i(o[0].getPoints());p=x?!p:p;const m=[],g=[];let y=[],b=0,v;g[b]=void 0,y[b]=[];for(let _=0,T=o.length;_<T;_++)c=o[_],v=c.getPoints(),l=i(v),l=x?!l:l,l?(!p&&g[b]&&b++,g[b]={s:new yo,p:v},g[b].s.curves=c.curves,p&&b++,y[b]=[]):y[b].push({h:c,p:v[0]});if(!g[0])return r(o);if(g.length>1){let _=!1,T=0;for(let A=0,E=g.length;A<E;A++)m[A]=[];for(let A=0,E=g.length;A<E;A++){const M=y[A];for(let I=0;I<M.length;I++){const C=M[I];let k=!0;for(let O=0;O<g.length;O++)a(C.p,g[O].p)&&(A!==O&&T++,k?(k=!1,m[O].push(C)):_=!0);k&&m[A].push(C)}}T>0&&_===!1&&(y=m)}let w;for(let _=0,T=g.length;_<T;_++){d=g[_].s,h.push(d),w=y[_];for(let A=0,E=w.length;A<E;A++)d.holes.push(w[A].h)}return h}}const jr=Ixe();function Ixe(){const s=new ArrayBuffer(4),x=new Float32Array(s),n=new Uint32Array(s),r=new Uint32Array(512),a=new Uint32Array(512);for(let c=0;c<256;++c){const d=c-127;d<-27?(r[c]=0,r[c|256]=32768,a[c]=24,a[c|256]=24):d<-14?(r[c]=1024>>-d-14,r[c|256]=1024>>-d-14|32768,a[c]=-d-1,a[c|256]=-d-1):d<=15?(r[c]=d+15<<10,r[c|256]=d+15<<10|32768,a[c]=13,a[c|256]=13):d<128?(r[c]=31744,r[c|256]=64512,a[c]=24,a[c|256]=24):(r[c]=31744,r[c|256]=64512,a[c]=13,a[c|256]=13)}const i=new Uint32Array(2048),o=new Uint32Array(64),l=new Uint32Array(64);for(let c=1;c<1024;++c){let d=c<<13,h=0;for(;(d&8388608)===0;)d<<=1,h-=8388608;d&=-8388609,h+=947912704,i[c]=d|h}for(let c=1024;c<2048;++c)i[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)o[c]=c<<23;o[31]=1199570944,o[32]=2147483648;for(let c=33;c<63;++c)o[c]=2147483648+(c-32<<23);o[63]=3347054592;for(let c=1;c<64;++c)c!==32&&(l[c]=1024);return{floatView:x,uint32View:n,baseTable:r,shiftTable:a,mantissaTable:i,exponentTable:o,offsetTable:l}}function kxe(s){Math.abs(s)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),s=Gx(s,-65504,65504),jr.floatView[0]=s;const x=jr.uint32View[0],n=x>>23&511;return jr.baseTable[n]+((x&8388607)>>jr.shiftTable[n])}function Nxe(s){const x=s>>10;return jr.uint32View[0]=jr.mantissaTable[jr.offsetTable[x]+(s&1023)]+jr.exponentTable[x],jr.floatView[0]}var Xh=Object.freeze({__proto__:null,toHalfFloat:kxe,fromHalfFloat:Nxe});class dse extends null{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}}class hse extends null{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}}function pse(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function fse(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function mse(){console.error("THREE.ImmediateRenderObject has been removed.")}class gse extends null{constructor(x,n,r){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(x,n,r),this.samples=4}}class yse extends null{constructor(x,n,r,a){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(x,n,r,a)}}class bse extends null{constructor(x,n,r,a){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(x,n,r,a)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Jg}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Jg);class Rxe extends PT{constructor(x,n,r){super({container:x,mode:n,layerCount:2,mirror:r}),this.cameraAngle=10/180*Math.PI;const a=this.canvas.layers[1];this.renderer=new uE({canvas:a,alpha:!0,preserveDrawingBuffer:!0}),this.renderer.setClearColor(0,0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(a.clientWidth,a.clientHeight),this.renderer.physicallyCorrectLights=!0,this.renderer.outputEncoding=rx,this.canvas.on("resize",()=>{this.renderer.setSize(a.clientWidth,a.clientHeight)}),this.scene=new dE,this.scene.background=null,this.camera=new ln(this.cameraAngle,1,.02,20)}updateScene(){this.scene&&this.renderer.render(this.scene,this.camera)}setupCamera(x,n){super.setupCamera(x,n),this.camera instanceof ln&&(this.camera.aspect=this.cameraRatio,this.camera.fov=this.cameraAngle/Math.PI*180,this.camera.updateProjectionMatrix())}setupVideo(x,n){super.setupVideo(x,n),this.camera instanceof Ll&&(this.camera.right=this.videoSize.width,this.camera.bottom=this.videoSize.height,this.camera.updateProjectionMatrix())}disposeObject(x){const n=(r,a)=>Array.isArray(r)&&r.every(i=>i instanceof a);x.removeFromParent(),x.traverse(r=>{r instanceof yn&&(r.geometry instanceof Rt&&r.geometry.dispose(),r.material instanceof y2&&r.material.dispose(),n(r.material,y2)&&r.material.forEach(a=>{a.dispose();for(const i in a){const o=a[i];o instanceof Tn&&o.dispose()}}))})}}class Pxe extends uZ{}class Lxe extends Rxe{}class Dxe extends Pxe{}class vse extends null{}class wse extends null{}class _se extends null{constructor(x,n=!1){super(),this.node=x,this.shapeScale=n}async update(x,n){if(!this.loaded)return;const r=x.faces&&x.faces.length>0?x.faces[0].transform:void 0;if(!r)return this.node.visible=!1,super.update(x,n);const a=new t.Vector3(...r.translation),i=new t.Vector3().setScalar(r.scale),o=new t.Vector3(...r.shapeScale).multiplyScalar(r.scale),l=new t.Quaternion(...r.rotation);return this.node.visible=!0,this.node.setRotationFromQuaternion(l),this.node.position.copy(a),this.node.scale.copy(this.shapeScale?o:i),super.update(x,n)}}class Sse extends null{constructor(x,n=0,r=!1){super(),this.node=x,this.facePoint=n,this.shapeScale=r}async update(x,n){if(!this.loaded)return;if(!this.node)return super.update(x,n);const{transform:r=void 0,metric:a=void 0}=x.faces&&x.faces.length>0?x.faces[0]:{};if(!r||!a)return this.node.visible=!1,super.update(x,n);const i=new t.Vector3(...a[this.facePoint]),o=new t.Vector3().setScalar(r.scale),l=new t.Vector3(...r.shapeScale).multiplyScalar(r.scale),c=new t.Quaternion(...r.rotation);return this.node.visible=!0,this.node.setRotationFromQuaternion(c),this.node.position.copy(i),this.node.scale.copy(this.shapeScale?l:o),super.update(x,n)}}class Tse extends null{constructor(x){super(),this.mesh=x,this.pointCont=S.length}async load(x){this.loaded||(await super.load(x),await this.setMesh(this.mesh))}async update(x,n){if(!this.loaded)return;if(!this.mesh)return super.update(x,n);const r=x.faces&&x.faces.length>0?x.faces[0].metric:void 0;if(!r)return this.mesh.visible=!1,super.update(x,n);this.mesh.visible=!0;let a=this.mesh.geometry.getAttribute("position");return r.slice(0,this.pointCont).forEach((i,o)=>a.setXYZ(o,i[0],i[1],i[2])),this.mesh.geometry.computeVertexNormals(),a.needsUpdate=!0,super.update(x,n)}async setMesh(x){if(delete this.mesh,this.mesh=x,!this.loaded||!x)return;const n=new t.BufferGeometry;n.setIndex(Z),n.setAttribute("position",new t.Float32BufferAttribute(S.flat(),3)),n.setAttribute("uv",new t.Float32BufferAttribute(u.flat(),2)),n.computeVertexNormals(),x.geometry=n}}class Ase extends null{async update(x,n){const r=x.faces&&x.faces.length>0?x.faces[0].mesh:void 0,{videoCtx:a}=this;if(!r||!a)return super.update(x,n);const{width:i,height:o}=a.canvas;r.keypoints.forEach(b=>a.fillRect(b[0]*i-2,b[1]*o-2,4,4)),a.lineWidth=4,a.strokeStyle="rgba(93, 111, 227, 0.75)";const l=[...H.lipsLowerOuter].reverse();this.drawPath(a,[...H.lipsUpperOuter,...l].map(b=>r.keypoints[b]),!0);const c=[...H.lipsLowerInner].reverse();this.drawPath(a,[...H.lipsUpperInner,...c].map(b=>r.keypoints[b]),!0),a.strokeStyle="rgba(172, 110, 255, 0.75)";const d=[...H.rightEyeLower0].reverse();this.drawPath(a,[...H.rightEyeUpper0,...d].map(b=>r.keypoints[b]),!0);const h=[...H.rightEyeLower1].reverse();this.drawPath(a,[...H.rightEyeUpper1,...h].map(b=>r.keypoints[b]),!0);const p=[...H.leftEyeLower0].reverse();this.drawPath(a,[...H.leftEyeUpper0,...p].map(b=>r.keypoints[b]),!0);const m=[...H.leftEyeLower1].reverse();this.drawPath(a,[...H.leftEyeUpper1,...m].map(b=>r.keypoints[b]),!0),a.strokeStyle="rgba(94, 214, 202, 0.75)";const g=[...H.rightEyebrowLower].reverse();this.drawPath(a,[...H.rightEyebrowUpper,...g].map(b=>r.keypoints[b]),!0);const y=[...H.leftEyebrowLower].reverse();if(this.drawPath(a,[...H.leftEyebrowUpper,...y].map(b=>r.keypoints[b]),!0),r.keypoints.length>468){a.strokeStyle="rgba(218, 60, 202, 0.75)",this.drawPath(a,[...H.rightEyeIris.slice(1)].map(T=>r.keypoints[T]),!0),this.drawPath(a,[...H.leftEyeIris.slice(1)].map(T=>r.keypoints[T]),!0);const b=r.keypoints[H.rightEyeIris[0]],v=r.keypoints[H.leftEyeIris[0]],{width:w,height:_}=a.canvas;a.beginPath(),a.ellipse(b[0]*w,b[1]*_,3,3,0,0,2*Math.PI),a.stroke(),a.beginPath(),a.ellipse(v[0]*w,v[1]*_,3,3,0,0,2*Math.PI),a.stroke()}a.lineWidth=.5,a.strokeStyle="rgba(180, 180, 180, 0.75)";for(let b=0;b<Z.length/3;b++){const v=[Z[b*3],Z[b*3+1],Z[b*3+2]].map(w=>r.keypoints[w]);this.drawPath(a,v,!0)}return super.update(x,n)}drawPath(x,n,r){const{width:a,height:i}=x.canvas,o=new Path2D;o.moveTo(n[0][0]*a,n[0][1]*i);for(let l=1;l<n.length;l++)o.lineTo(n[l][0]*a,n[l][1]*i);r&&o.closePath(),x.stroke(o)}}class Oxe extends Dxe{constructor(x,n={spineCurve:.5,neckAdjust:.01,headRatio:.32,shoulderDY:-.01,shoulderDZ:.005}){super(),this.node=x,this.tune=n,this.avatarLength=1,this.alignScore=.9,this.alignVisibility=.9}async load(x){this.loaded||(await super.load(x),await this.setNode(this.node))}unload(){!this.loaded||(delete this.node,delete this.skeleton,delete this.skeletonRef,delete this.spineRef,super.unload())}setNode(x){var n;if(delete this.skeleton,delete this.skeletonRef,delete this.spineRef,this.node=x,!this.loaded||!x)return;x.traverse(I=>{!this.skeletonRef&&I instanceof X1&&(this.skeletonRef=I.skeleton)});const r=(n=this.skeletonRef)==null?void 0:n.bones;if(!r)return;const a=I=>r.find(C=>C.name.toLowerCase().endsWith(I)),i={hips:a("hips"),spine:a("spine"),spine1:a("spine1"),spine2:a("spine2"),neck:a("neck"),head:a("head"),headEnd:a("headtop_end"),shoulderL:a("leftshoulder"),shoulderR:a("rightshoulder"),armL:a("leftarm"),armR:a("rightarm"),foreArmL:a("leftforearm"),foreArmR:a("rightforearm"),handL:a("lefthand"),handR:a("righthand"),upLegL:a("leftupleg"),upLegR:a("rightupleg"),legL:a("leftleg"),legR:a("rightleg"),footL:a("leftfoot"),footR:a("rightfoot"),toeL:a("lefttoebase"),toeR:a("righttoebase")};this.skeleton=i;const o=i.hips.getWorldPosition(new K),l=i.armL.getWorldPosition(new K),c=i.armR.getWorldPosition(new K),d=l.clone().lerp(c,.5).sub(o).length(),h=l.clone().sub(o),p=c.clone().sub(o).clone().cross(h).normalize(),m=i.spine.getWorldPosition(new K).sub(o),g=m.dot(p),y=m.clone().sub(p.clone().multiplyScalar(g)).length(),b=i.spine1.getWorldPosition(new K).sub(o),v=b.dot(p),w=b.clone().sub(p.clone().multiplyScalar(v)).length(),_=i.spine2.getWorldPosition(new K).sub(o),T=_.dot(p),A=_.clone().sub(p.clone().multiplyScalar(T)).length(),E=i.head.getWorldPosition(new K),M=i.headEnd.getWorldPosition(new K).clone().sub(E).length();this.avatarLength=d,this.spineRef={spine:[y/d,g/d],spine1:[w/d,v/d],spine2:[A/d,T/d],head:[M/d,0]},x.traverse(I=>{I.frustumCulled=!1})}async update(x,n){var r;const a=x.poses&&x.poses.length>0?x.poses[0].points:void 0,{node:i,skeleton:o,spineRef:l}=this;if(!i)return super.update(x,n);if(!o||!l||!a)return i.visible=!1,super.update(x,n);const c=this.estimateBones(a,l);return i.visible=!0,(r=this.skeletonRef)==null||r.pose(),this.updateSpine(c),this.updateHandL(c,a),this.updateHandR(c,a),this.updateLegL(c,a),this.updateLegR(c,a),super.update(x,n)}updateSpine(x){var n;const{skeleton:r,spineRef:a}=this;if(!r||!a)return;this.alignBone(x.hips,r.hips,!1),this.alignBone(x.spine,r.spine),this.alignBone(x.spine1,r.spine1),this.alignBone(x.spine2,r.spine2),this.alignBone(x.neck,r.neck,!1),this.alignBone(x.head,r.head,!1);const i=(n=this.skeletonRef)==null?void 0:n.bones.find(o=>o.name.endsWith("HeadEnd"));if(i){const{head:o,headEnd:l}=x,c=l.position.clone().sub(o.position).length();r.head.scale.setScalar(1.05*c/i.position.length())}this.alignBone(x.shoulderL,r.shoulderL,!1),this.alignBone(x.shoulderR,r.shoulderR,!1)}updateHandL(x,n){const{skeleton:r,spineRef:a}=this;if(!r||!a)return;const{alignScore:i,alignVisibility:o}=this;this.alignBone(x.armL,r.armL),!(n.elbowL.score<i&&n.elbowL.visibility<o)&&(this.alignBone(x.foreArmL,r.foreArmL),this.alignBone(x.handL,r.handL),r.handL.scale.setScalar(.95))}updateHandR(x,n){const{skeleton:r}=this;if(!r)return;const{alignScore:a,alignVisibility:i}=this;this.alignBone(x.armR,r.armR),!(n.elbowR.score<a&&n.elbowR.visibility<i)&&(this.alignBone(x.foreArmR,r.foreArmR),this.alignBone(x.handR,r.handR),r.handR.scale.setScalar(.95))}updateLegL(x,n){const{skeleton:r}=this;if(!r)return;const{alignScore:a,alignVisibility:i}=this;n.hipL.score<a&&n.hipL.visibility<i||(this.alignBone(x.upLegL,r.upLegL,!1),!(n.kneeL.score<a&&n.kneeL.visibility<i)&&(this.alignBone(x.legL,r.legL),!(n.ankleL.score<a&&n.ankleL.visibility<i)&&(this.alignBone(x.footL,r.footL),this.alignBone(x.toeL,r.toeL))))}updateLegR(x,n){const{skeleton:r}=this;if(!r)return;const{alignScore:a,alignVisibility:i}=this;n.hipR.score<a&&n.hipR.visibility<i||(this.alignBone(x.upLegR,r.upLegR,!1),!(n.kneeR.score<a&&n.kneeR.visibility<i)&&(this.alignBone(x.legR,r.legR),!(n.ankleR.score<a&&n.ankleR.visibility<i)&&(this.alignBone(x.footR,r.footR),this.alignBone(x.toeR,r.toeR))))}estimateBones(x,n){var r;const a=new K(...x.hipL.metric),i=new K(...x.hipR.metric),o=a.clone().lerp(i,.5),l=a.clone().sub(i).normalize(),c=l.clone().negate(),d=new K(...x.shoulderL.metric),h=new K(...x.shoulderR.metric),p=new K(...x.elbowL.metric),m=new K(...x.elbowR.metric),g=d.clone().lerp(h,.5),y=d.clone().sub(h).normalize(),b=d.clone().sub(o),v=h.clone().sub(o).clone().cross(b).normalize();if(this.tune.shoulderDX||this.tune.shoulderDY||this.tune.shoulderDZ){const Ox=y.clone().multiplyScalar(this.tune.shoulderDX||0),ne=g.clone().sub(o).normalize().multiplyScalar(this.tune.shoulderDY||0).add(v.clone().multiplyScalar(((r=this.tune)==null?void 0:r.shoulderDZ)||0));d.add(ne).add(Ox),h.add(ne).add(Ox.clone().negate())}const w=d.clone().lerp(h,.5),_=w.clone().sub(o).normalize(),T=p.clone().sub(d).normalize(),A=m.clone().sub(h).normalize();let E;if(this.tune.neckAdjust){const Ox=Math.abs(y.x);E=_.clone().multiplyScalar(Ox*(_.dot(T)*-this.tune.neckAdjust+_.dot(A)*-this.tune.neckAdjust)),w.add(E)}const M=w.clone().sub(o).length(),I=this.tune.shoulderOffset||.2,C=w.clone().lerp(d,I),k=w.clone().lerp(h,I),O=new K(...x.earL.metric),z=new K(...x.earR.metric),ee=O.clone().lerp(z,.5),re=new K(...x.nose.metric),Y=ee.clone().sub(re).normalize(),Q=O.clone().sub(z).normalize(),te=Q.clone().cross(Y).add(Y.clone().multiplyScalar(.05)).normalize(),se=this.tune.headRatio||.32,xe=n.head[0]*M,ae=ee.clone().add(te.clone().cross(Q).multiplyScalar(.025)),le=ae.clone().add(te.clone().multiplyScalar(-se*xe)),de=ae.clone().add(te.clone().multiplyScalar((1-se)*xe)),ue=le.clone().lerp(de,2),ge=y.clone().lerp(Q,.5),pe=E?d.clone().add(E):d.clone(),Le=E?h.clone().add(E):h.clone(),we=a.clone().lerp(pe,n.spine[0]),e0=i.clone().lerp(Le,n.spine[0]),Ze=we.clone().lerp(e0,.5),i0=we.clone().sub(e0),We=a.clone().lerp(pe,n.spine1[0]),v0=i.clone().lerp(Le,n.spine1[0]),Te=We.clone().lerp(v0,.5),Ie=We.clone().sub(v0),Xe=a.clone().lerp(pe,n.spine2[0]),c0=i.clone().lerp(Le,n.spine2[0]),Ye=Xe.clone().lerp(c0,.5),I0=We.clone().sub(c0);if(this.tune.spineCurve){const Ox=d.clone().sub(o),ne=h.clone().sub(o).clone().cross(Ox).normalize(),Ee=this.tune.spineCurve*M;Ze.add(ne.clone().multiplyScalar(n.spine[1]*Ee)),Te.add(ne.clone().multiplyScalar(n.spine1[1]*Ee)),Ye.add(ne.clone().multiplyScalar(n.spine2[1]*Ee))}const m0=new K(...x.wristL.metric),d0=m0.clone().sub(p).normalize().clone().sub(T).negate(),rt=v.clone(),ct=d0.clone().lerp(rt,.5),ie=new K(...x.indexL.metric),$=new K(...x.pinkyL.metric),ke=ie.clone().lerp($,.5),Ge=$.clone().sub(ie),s0=new K(...x.wristR.metric),p0=s0.clone().sub(m).normalize().clone().sub(A),K0=v.clone().negate(),Re=p0.clone().lerp(K0,.5),L0=new K(...x.indexR.metric),u0=new K(...x.pinkyR.metric),D0=L0.clone().lerp(u0,.5),b0=L0.clone().sub(u0),et=new K(...x.kneeL.metric),Et=new K(...x.ankleL.metric),xx=new K(...x.footIndexL.metric),ye=new K(...x.heelL.metric),k0=Et.clone().sub(et).normalize(),Fe=xx.clone().sub(ye).normalize(),h0=k0.clone().cross(Fe).normalize(),f0=ye.clone().lerp(xx,.8),Y0=c.clone().lerp(h0,.2),ox=c.clone().lerp(h0,.6),qt=new K(...x.kneeR.metric),jx=new K(...x.ankleR.metric),Jt=new K(...x.footIndexR.metric),Dx=new K(...x.heelR.metric),zt=jx.clone().sub(qt).normalize(),en=Jt.clone().sub(Dx).normalize(),o0=zt.clone().cross(en).normalize(),yx=Dx.clone().lerp(Jt,.8),ut=c.clone().lerp(o0,.2),Cx=c.clone().lerp(o0,.6);return{hips:this.estimateBone(o,Ze,l),spine:this.estimateBone(Ze,Te,i0),spine1:this.estimateBone(Te,Ye,Ie),spine2:this.estimateBone(Ye,w,I0),neck:this.estimateBone(w,le,ge),head:this.estimateBone(le,de,Q),headEnd:this.estimateBone(de,ue,Q),shoulderL:this.estimateBone(C,d,rt),armL:this.estimateBone(d,p,ct),foreArmL:this.estimateBone(p,m0,d0),handL:this.estimateBone(m0,ke,Ge),shoulderR:this.estimateBone(k,h,K0),armR:this.estimateBone(h,m,Re),foreArmR:this.estimateBone(m,s0,p0),handR:this.estimateBone(s0,D0,b0),upLegL:this.estimateBone(a,et,Y0),legL:this.estimateBone(et,Et,ox),footL:this.estimateBone(Et,f0,h0),toeL:this.estimateBone(f0,xx,h0),upLegR:this.estimateBone(i,qt,ut),legR:this.estimateBone(qt,jx,Cx),footR:this.estimateBone(jx,yx,o0),toeR:this.estimateBone(yx,Jt,o0)}}estimateBone(x,n,r){const a=n.clone().sub(x).normalize(),i=r.clone().normalize().cross(a).normalize(),o=a.clone().cross(i);return{position:x.clone(),rotation:new Bn().setFromRotationMatrix(new wt().makeBasis(o,a,i))}}alignBone(x,n,r=!0){let a=x.rotation.clone(),i=x.position.clone();n.parent&&(a=n.parent.getWorldQuaternion(new Bn).invert().multiply(a),i.applyMatrix4(n.parent.matrixWorld.clone().invert()),r&&n.parent instanceof hh&&(n.parent.scale.setScalar(i.length()/n.position.length()),n.parent.updateWorldMatrix(!0,!0),i=x.position.clone().applyMatrix4(n.parent.matrixWorld.clone().invert()))),n.setRotationFromQuaternion(a),n.position.copy(i),n.updateWorldMatrix(!0,!0)}}class Fxe extends Oxe{constructor(x,n,r={spineCurve:.5,neckAdjust:.01,headRatio:.32,shoulderDY:-.01,shoulderDZ:.005}){super(x,r),this.outfit=n}setNode(x){super.setNode(x);const{outfit:n,node:r}=this;!n||!r||r.traverse(a=>{if(!(a instanceof yn))return;const i=o=>o?.some(l=>typeof l=="string"?a.name===l:l.test(a.name));if(i(n.occluders)){a.material.colorWrite=!1,a.renderOrder=-1;return}if(i(n.hidden)){a.visible=!1;return}})}setOutfit(x,n){this.outfit=n,this.setNode(x)}}class Ese extends null{constructor(x,n,r,a,i={spineCurve:.5,neckAdjust:.01,headRatio:.32,shoulderDY:-.01,shoulderDZ:.005}){super(x,i),this.translation=n,this.rotation=r,this.scale=a}async update(x,n){await super.update(x,n);const r=x.poses&&x.poses.length>0?x.poses[0].points:void 0,{node:a,translation:i,rotation:o,scale:l}=this;if(!a||!r)return;const c=new t.Vector3(...r.hipL.metric),d=new t.Vector3(...r.hipR.metric),h=c.clone().lerp(d,.5);a.position.copy(i?h.add(i):h),o&&a.setRotationFromQuaternion(o),l&&a.scale.setScalar(l)}updateSpine(x){const{skeleton:n,spineRef:r}=this;!n||!r||(this.alignBone(x.hips,n.hips),this.alignBone(x.spine,n.spine),this.alignBone(x.spine1,n.spine1),this.alignBone(x.spine2,n.spine2),this.alignBone(x.neck,n.neck),this.alignBone(x.head,n.head),this.alignBone(x.shoulderL,n.shoulderL),this.alignBone(x.shoulderR,n.shoulderR))}alignBone(x,n){let r=x.rotation.clone();n.parent&&(r=n.parent.getWorldQuaternion(new t.Quaternion).invert().multiply(r)),n.setRotationFromQuaternion(r),n.updateWorldMatrix(!0,!0)}}class Cse extends null{constructor(x,n=-1){super(),this.node=x,this.renderOrder=n}async load(x){if(!this.loaded)return this.node.traverse(n=>{n instanceof t.Mesh&&(n.material.colorWrite=!1),n.renderOrder=this.renderOrder}),super.load(x)}}class Uxe extends $a{constructor(x){super(x),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new Vxe(n)}),this.register(function(n){return new Zxe(n)}),this.register(function(n){return new Jxe(n)}),this.register(function(n){return new Yxe(n)}),this.register(function(n){return new qxe(n)}),this.register(function(n){return new Xxe(n)}),this.register(function(n){return new Kxe(n)}),this.register(function(n){return new Gxe(n)}),this.register(function(n){return new $xe(n)}),this.register(function(n){return new Hxe(n)}),this.register(function(n){return new zxe(n)}),this.register(function(n){return new Qxe(n)})}load(x,n,r,a){const i=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=Qr.extractUrlBase(x),this.manager.itemStart(x);const l=function(d){a?a(d):console.error(d),i.manager.itemError(x),i.manager.itemEnd(x)},c=new rr(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(x,function(d){try{i.parse(d,o,function(h){n(h),i.manager.itemEnd(x)},l)}catch(h){l(h)}},r,l)}setDRACOLoader(x){return this.dracoLoader=x,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(x){return this.ktx2Loader=x,this}setMeshoptDecoder(x){return this.meshoptDecoder=x,this}register(x){return this.pluginCallbacks.indexOf(x)===-1&&this.pluginCallbacks.push(x),this}unregister(x){return this.pluginCallbacks.indexOf(x)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(x),1),this}parse(x,n,r,a){let i;const o={},l={};if(typeof x=="string")i=x;else if(Qr.decodeText(new Uint8Array(x,0,4))===SC){try{o[Ut.KHR_BINARY_GLTF]=new jxe(x)}catch(p){a&&a(p);return}i=o[Ut.KHR_BINARY_GLTF].content}else i=Qr.decodeText(new Uint8Array(x));const c=JSON.parse(i);if(c.asset===void 0||c.asset.version[0]<2){a&&a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const d=new dne(c,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});d.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const p=this.pluginCallbacks[h](d);l[p.name]=p,o[p.name]=!0}if(c.extensionsUsed)for(let h=0;h<c.extensionsUsed.length;++h){const p=c.extensionsUsed[h],m=c.extensionsRequired||[];switch(p){case Ut.KHR_MATERIALS_UNLIT:o[p]=new Wxe;break;case Ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:o[p]=new xne;break;case Ut.KHR_DRACO_MESH_COMPRESSION:o[p]=new ene(c,this.dracoLoader);break;case Ut.KHR_TEXTURE_TRANSFORM:o[p]=new tne;break;case Ut.KHR_MESH_QUANTIZATION:o[p]=new nne;break;default:m.indexOf(p)>=0&&l[p]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+p+'".')}}d.setExtensions(o),d.setPlugins(l),d.parse(r,a)}parseAsync(x,n){const r=this;return new Promise(function(a,i){r.parse(x,n,a,i)})}}function Bxe(){let s={};return{get:function(x){return s[x]},add:function(x,n){s[x]=n},remove:function(x){delete s[x]},removeAll:function(){s={}}}}const Ut={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class zxe{constructor(x){this.parser=x,this.name=Ut.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const x=this.parser,n=this.parser.json.nodes||[];for(let r=0,a=n.length;r<a;r++){const i=n[r];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&x._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(x){const n=this.parser,r="light:"+x;let a=n.cache.get(r);if(a)return a;const i=n.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[x];let d;const h=new M0(16777215);c.color!==void 0&&h.fromArray(c.color);const p=c.range!==void 0?c.range:0;switch(c.type){case"directional":d=new xC(h),d.target.position.set(0,0,-1),d.add(d.target);break;case"point":d=new hy(h),d.distance=p;break;case"spot":d=new eC(h),d.distance=p,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,d.angle=c.spot.outerConeAngle,d.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,d.target.position.set(0,0,-1),d.add(d.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return d.position.set(0,0,0),d.decay=2,c.intensity!==void 0&&(d.intensity=c.intensity),d.name=n.createUniqueName(c.name||"light_"+x),a=Promise.resolve(d),n.cache.add(r,a),a}createNodeAttachment(x){const n=this,r=this.parser,i=r.json.nodes[x],l=(i.extensions&&i.extensions[this.name]||{}).light;return l===void 0?null:this._loadLight(l).then(function(c){return r._getNodeRef(n.cache,l,c)})}}class Wxe{constructor(){this.name=Ut.KHR_MATERIALS_UNLIT}getMaterialType(){return F2}extendParams(x,n,r){const a=[];x.color=new M0(1,1,1),x.opacity=1;const i=n.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;x.color.fromArray(o),x.opacity=o[3]}i.baseColorTexture!==void 0&&a.push(r.assignTexture(x,"map",i.baseColorTexture,rx))}return Promise.all(a)}}class Gxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(x,n){const a=this.parser.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=a.extensions[this.name].emissiveStrength;return i!==void 0&&(n.emissiveIntensity=i),Promise.resolve()}}class Vxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_CLEARCOAT}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],o=a.extensions[this.name];if(o.clearcoatFactor!==void 0&&(n.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(r.assignTexture(n,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(r.assignTexture(n,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(r.assignTexture(n,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const l=o.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new n0(l,l)}return Promise.all(i)}}class Hxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_IRIDESCENCE}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],o=a.extensions[this.name];return o.iridescenceFactor!==void 0&&(n.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(r.assignTexture(n,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(n.iridescenceIOR=o.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(r.assignTexture(n,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}}class Yxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_SHEEN}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[];n.sheenColor=new M0(0,0,0),n.sheenRoughness=0,n.sheen=1;const o=a.extensions[this.name];return o.sheenColorFactor!==void 0&&n.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(r.assignTexture(n,"sheenColorMap",o.sheenColorTexture,rx)),o.sheenRoughnessTexture!==void 0&&i.push(r.assignTexture(n,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class qxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_TRANSMISSION}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],o=a.extensions[this.name];return o.transmissionFactor!==void 0&&(n.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(r.assignTexture(n,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class Xxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_VOLUME}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],o=a.extensions[this.name];n.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(r.assignTexture(n,"thicknessMap",o.thicknessTexture)),n.attenuationDistance=o.attenuationDistance||0;const l=o.attenuationColor||[1,1,1];return n.attenuationColor=new M0(l[0],l[1],l[2]),Promise.all(i)}}class Kxe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_IOR}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const a=this.parser.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=a.extensions[this.name];return n.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class $xe{constructor(x){this.parser=x,this.name=Ut.KHR_MATERIALS_SPECULAR}getMaterialType(x){const r=this.parser.json.materials[x];return!r.extensions||!r.extensions[this.name]?null:Ls}extendMaterialParams(x,n){const r=this.parser,a=r.json.materials[x];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],o=a.extensions[this.name];n.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(r.assignTexture(n,"specularIntensityMap",o.specularTexture));const l=o.specularColorFactor||[1,1,1];return n.specularColor=new M0(l[0],l[1],l[2]),o.specularColorTexture!==void 0&&i.push(r.assignTexture(n,"specularColorMap",o.specularColorTexture,rx)),Promise.all(i)}}class Zxe{constructor(x){this.parser=x,this.name=Ut.KHR_TEXTURE_BASISU}loadTexture(x){const n=this.parser,r=n.json,a=r.textures[x];if(!a.extensions||!a.extensions[this.name])return null;const i=a.extensions[this.name],o=n.options.ktx2Loader;if(!o){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(x,i.source,o)}}class Jxe{constructor(x){this.parser=x,this.name=Ut.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(x){const n=this.name,r=this.parser,a=r.json,i=a.textures[x];if(!i.extensions||!i.extensions[n])return null;const o=i.extensions[n],l=a.images[o.source];let c=r.textureLoader;if(l.uri){const d=r.options.manager.getHandler(l.uri);d!==null&&(c=d)}return this.detectSupport().then(function(d){if(d)return r.loadTextureImage(x,o.source,c);if(a.extensionsRequired&&a.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(x)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(x){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){x(n.height===1)}})),this.isSupported}}class Qxe{constructor(x){this.name=Ut.EXT_MESHOPT_COMPRESSION,this.parser=x}loadBufferView(x){const n=this.parser.json,r=n.bufferViews[x];if(r.extensions&&r.extensions[this.name]){const a=r.extensions[this.name],i=this.parser.getDependency("buffer",a.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,o.ready]).then(function(l){const c=a.byteOffset||0,d=a.byteLength||0,h=a.count,p=a.byteStride,m=new ArrayBuffer(h*p),g=new Uint8Array(l[0],c,d);return o.decodeGltfBuffer(new Uint8Array(m),h,p,g,a.mode,a.filter),m})}else return null}}const SC="glTF",xc=12,TC={JSON:1313821514,BIN:5130562};class jxe{constructor(x){this.name=Ut.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(x,0,xc);if(this.header={magic:Qr.decodeText(new Uint8Array(x.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==SC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-xc,a=new DataView(x,xc);let i=0;for(;i<r;){const o=a.getUint32(i,!0);i+=4;const l=a.getUint32(i,!0);if(i+=4,l===TC.JSON){const c=new Uint8Array(x,xc+i,o);this.content=Qr.decodeText(c)}else if(l===TC.BIN){const c=xc+i;this.body=x.slice(c,c+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ene{constructor(x,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Ut.KHR_DRACO_MESH_COMPRESSION,this.json=x,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(x,n){const r=this.json,a=this.dracoLoader,i=x.extensions[this.name].bufferView,o=x.extensions[this.name].attributes,l={},c={},d={};for(const h in o){const p=wy[h]||h.toLowerCase();l[p]=o[h]}for(const h in x.attributes){const p=wy[h]||h.toLowerCase();if(o[h]!==void 0){const m=r.accessors[x.attributes[h]],g=nc[m.componentType];d[p]=g,c[p]=m.normalized===!0}}return n.getDependency("bufferView",i).then(function(h){return new Promise(function(p){a.decodeDracoFile(h,function(m){for(const g in m.attributes){const y=m.attributes[g],b=c[g];b!==void 0&&(y.normalized=b)}p(m)},l,d)})})}}class tne{constructor(){this.name=Ut.KHR_TEXTURE_TRANSFORM}extendTexture(x,n){return n.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(x=x.clone(),n.offset!==void 0&&x.offset.fromArray(n.offset),n.rotation!==void 0&&(x.rotation=n.rotation),n.scale!==void 0&&x.repeat.fromArray(n.scale),x.needsUpdate=!0),x}}class vy extends qa{constructor(x){super(),this.isGLTFSpecularGlossinessMaterial=!0;const n=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),r=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),a=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),l={specular:{value:new M0().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=l,this.onBeforeCompile=function(c){for(const d in l)c.uniforms[d]=l[d];c.fragmentShader=c.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",n).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",a).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return l.specular.value},set:function(c){l.specular.value=c}},specularMap:{get:function(){return l.specularMap.value},set:function(c){l.specularMap.value=c,c?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return l.glossiness.value},set:function(c){l.glossiness.value=c}},glossinessMap:{get:function(){return l.glossinessMap.value},set:function(c){l.glossinessMap.value=c,c?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(x)}copy(x){return super.copy(x),this.specularMap=x.specularMap,this.specular.copy(x.specular),this.glossinessMap=x.glossinessMap,this.glossiness=x.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class xne{constructor(){this.name=Ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return vy}extendParams(x,n,r){const a=n.extensions[this.name];x.color=new M0(1,1,1),x.opacity=1;const i=[];if(Array.isArray(a.diffuseFactor)){const o=a.diffuseFactor;x.color.fromArray(o),x.opacity=o[3]}if(a.diffuseTexture!==void 0&&i.push(r.assignTexture(x,"map",a.diffuseTexture,rx)),x.emissive=new M0(0,0,0),x.glossiness=a.glossinessFactor!==void 0?a.glossinessFactor:1,x.specular=new M0(1,1,1),Array.isArray(a.specularFactor)&&x.specular.fromArray(a.specularFactor),a.specularGlossinessTexture!==void 0){const o=a.specularGlossinessTexture;i.push(r.assignTexture(x,"glossinessMap",o)),i.push(r.assignTexture(x,"specularMap",o,rx))}return Promise.all(i)}createMaterial(x){const n=new vy(x);return n.fog=!0,n.color=x.color,n.map=x.map===void 0?null:x.map,n.lightMap=null,n.lightMapIntensity=1,n.aoMap=x.aoMap===void 0?null:x.aoMap,n.aoMapIntensity=1,n.emissive=x.emissive,n.emissiveIntensity=x.emissiveIntensity===void 0?1:x.emissiveIntensity,n.emissiveMap=x.emissiveMap===void 0?null:x.emissiveMap,n.bumpMap=x.bumpMap===void 0?null:x.bumpMap,n.bumpScale=1,n.normalMap=x.normalMap===void 0?null:x.normalMap,n.normalMapType=ka,x.normalScale&&(n.normalScale=x.normalScale),n.displacementMap=null,n.displacementScale=1,n.displacementBias=0,n.specularMap=x.specularMap===void 0?null:x.specularMap,n.specular=x.specular,n.glossinessMap=x.glossinessMap===void 0?null:x.glossinessMap,n.glossiness=x.glossiness,n.alphaMap=null,n.envMap=x.envMap===void 0?null:x.envMap,n.envMapIntensity=1,n}}class nne{constructor(){this.name=Ut.KHR_MESH_QUANTIZATION}}class AC extends Jl{constructor(x,n,r,a){super(x,n,r,a)}copySampleValue_(x){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,i=x*a*3+a;for(let o=0;o!==a;o++)n[o]=r[i+o];return n}interpolate_(x,n,r,a){const i=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=l*2,d=l*3,h=a-n,p=(r-n)/h,m=p*p,g=m*p,y=x*d,b=y-d,v=-2*g+3*m,w=g-m,_=1-v,T=w-m+p;for(let A=0;A!==l;A++){const E=o[b+A+l],M=o[b+A+c]*h,I=o[y+A+l],C=o[y+A]*h;i[A]=_*E+T*M+v*I+w*C}return i}}const rne=new Bn;class sne extends AC{interpolate_(x,n,r,a){const i=super.interpolate_(x,n,r,a);return rne.fromArray(i).normalize().toArray(i),i}}const es={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},nc={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},EC={9728:Zx,9729:Sx,9984:Pd,9985:e1,9986:Ld,9987:_s},CC={33071:Zn,33648:Tl,10497:Ea},MC={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},wy={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Os={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ane={CUBICSPLINE:void 0,LINEAR:Vi,STEP:Al},_y={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function ine(s){return s.DefaultMaterial===void 0&&(s.DefaultMaterial=new qa({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ui})),s.DefaultMaterial}function rc(s,x,n){for(const r in n.extensions)s[r]===void 0&&(x.userData.gltfExtensions=x.userData.gltfExtensions||{},x.userData.gltfExtensions[r]=n.extensions[r])}function ti(s,x){x.extras!==void 0&&(typeof x.extras=="object"?Object.assign(s.userData,x.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+x.extras))}function one(s,x,n){let r=!1,a=!1,i=!1;for(let d=0,h=x.length;d<h;d++){const p=x[d];if(p.POSITION!==void 0&&(r=!0),p.NORMAL!==void 0&&(a=!0),p.COLOR_0!==void 0&&(i=!0),r&&a&&i)break}if(!r&&!a&&!i)return Promise.resolve(s);const o=[],l=[],c=[];for(let d=0,h=x.length;d<h;d++){const p=x[d];if(r){const m=p.POSITION!==void 0?n.getDependency("accessor",p.POSITION):s.attributes.position;o.push(m)}if(a){const m=p.NORMAL!==void 0?n.getDependency("accessor",p.NORMAL):s.attributes.normal;l.push(m)}if(i){const m=p.COLOR_0!==void 0?n.getDependency("accessor",p.COLOR_0):s.attributes.color;c.push(m)}}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(c)]).then(function(d){const h=d[0],p=d[1],m=d[2];return r&&(s.morphAttributes.position=h),a&&(s.morphAttributes.normal=p),i&&(s.morphAttributes.color=m),s.morphTargetsRelative=!0,s})}function lne(s,x){if(s.updateMorphTargets(),x.weights!==void 0)for(let n=0,r=x.weights.length;n<r;n++)s.morphTargetInfluences[n]=x.weights[n];if(x.extras&&Array.isArray(x.extras.targetNames)){const n=x.extras.targetNames;if(s.morphTargetInfluences.length===n.length){s.morphTargetDictionary={};for(let r=0,a=n.length;r<a;r++)s.morphTargetDictionary[n[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function cne(s){const x=s.extensions&&s.extensions[Ut.KHR_DRACO_MESH_COMPRESSION];let n;return x?n="draco:"+x.bufferView+":"+x.indices+":"+IC(x.attributes):n=s.indices+":"+IC(s.attributes)+":"+s.mode,n}function IC(s){let x="";const n=Object.keys(s).sort();for(let r=0,a=n.length;r<a;r++)x+=n[r]+":"+s[n[r]]+";";return x}function Sy(s){switch(s){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function une(s){return s.search(/\.jpe?g($|\?)/i)>0||s.search(/^data\:image\/jpeg/)===0?"image/jpeg":s.search(/\.webp($|\?)/i)>0||s.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}class dne{constructor(x={},n={}){this.json=x,this.extensions={},this.plugins={},this.options=n,this.cache=new Bxe,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,a=navigator.userAgent.indexOf("Firefox")>-1,i=a?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap>"u"||r||a&&i<98?this.textureLoader=new jte(this.options.manager):this.textureLoader=new cxe(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new rr(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(x){this.extensions=x}setPlugins(x){this.plugins=x}parse(x,n){const r=this,a=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(o){const l={scene:o[0][a.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:a.asset,parser:r,userData:{}};rc(i,l,a),ti(l,a),Promise.all(r._invokeAll(function(c){return c.afterRoot&&c.afterRoot(l)})).then(function(){x(l)})}).catch(n)}_markDefs(){const x=this.json.nodes||[],n=this.json.skins||[],r=this.json.meshes||[];for(let a=0,i=n.length;a<i;a++){const o=n[a].joints;for(let l=0,c=o.length;l<c;l++)x[o[l]].isBone=!0}for(let a=0,i=x.length;a<i;a++){const o=x[a];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(r[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(x,n){n!==void 0&&(x.refs[n]===void 0&&(x.refs[n]=x.uses[n]=0),x.refs[n]++)}_getNodeRef(x,n,r){if(x.refs[n]<=1)return r;const a=r.clone(),i=(o,l)=>{const c=this.associations.get(o);c!=null&&this.associations.set(l,c);for(const[d,h]of o.children.entries())i(h,l.children[d])};return i(r,a),a.name+="_instance_"+x.uses[n]++,a}_invokeOne(x){const n=Object.values(this.plugins);n.push(this);for(let r=0;r<n.length;r++){const a=x(n[r]);if(a)return a}return null}_invokeAll(x){const n=Object.values(this.plugins);n.unshift(this);const r=[];for(let a=0;a<n.length;a++){const i=x(n[a]);i&&r.push(i)}return r}getDependency(x,n){const r=x+":"+n;let a=this.cache.get(r);if(!a){switch(x){case"scene":a=this.loadScene(n);break;case"node":a=this.loadNode(n);break;case"mesh":a=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(n)});break;case"accessor":a=this.loadAccessor(n);break;case"bufferView":a=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(n)});break;case"buffer":a=this.loadBuffer(n);break;case"material":a=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(n)});break;case"texture":a=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(n)});break;case"skin":a=this.loadSkin(n);break;case"animation":a=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(n)});break;case"camera":a=this.loadCamera(n);break;default:throw new Error("Unknown type: "+x)}this.cache.add(r,a)}return a}getDependencies(x){let n=this.cache.get(x);if(!n){const r=this,a=this.json[x+(x==="mesh"?"es":"s")]||[];n=Promise.all(a.map(function(i,o){return r.getDependency(x,o)})),this.cache.add(x,n)}return n}loadBuffer(x){const n=this.json.buffers[x],r=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&x===0)return Promise.resolve(this.extensions[Ut.KHR_BINARY_GLTF].body);const a=this.options;return new Promise(function(i,o){r.load(Qr.resolveURL(n.uri,a.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(x){const n=this.json.bufferViews[x];return this.getDependency("buffer",n.buffer).then(function(r){const a=n.byteLength||0,i=n.byteOffset||0;return r.slice(i,i+a)})}loadAccessor(x){const n=this,r=this.json,a=this.json.accessors[x];if(a.bufferView===void 0&&a.sparse===void 0)return Promise.resolve(null);const i=[];return a.bufferView!==void 0?i.push(this.getDependency("bufferView",a.bufferView)):i.push(null),a.sparse!==void 0&&(i.push(this.getDependency("bufferView",a.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",a.sparse.values.bufferView))),Promise.all(i).then(function(o){const l=o[0],c=MC[a.type],d=nc[a.componentType],h=d.BYTES_PER_ELEMENT,p=h*c,m=a.byteOffset||0,g=a.bufferView!==void 0?r.bufferViews[a.bufferView].byteStride:void 0,y=a.normalized===!0;let b,v;if(g&&g!==p){const w=Math.floor(m/g),_="InterleavedBuffer:"+a.bufferView+":"+a.componentType+":"+w+":"+a.count;let T=n.cache.get(_);T||(b=new d(l,w*g,a.count*g/h),T=new Y1(b,g/h),n.cache.add(_,T)),v=new Ha(T,c,m%g/h,y)}else l===null?b=new d(a.count*c):b=new d(l,m,a.count*c),v=new Qx(b,c,y);if(a.sparse!==void 0){const w=MC.SCALAR,_=nc[a.sparse.indices.componentType],T=a.sparse.indices.byteOffset||0,A=a.sparse.values.byteOffset||0,E=new _(o[1],T,a.sparse.count*w),M=new d(o[2],A,a.sparse.count*c);l!==null&&(v=new Qx(v.array.slice(),v.itemSize,v.normalized));for(let I=0,C=E.length;I<C;I++){const k=E[I];if(v.setX(k,M[I*c]),c>=2&&v.setY(k,M[I*c+1]),c>=3&&v.setZ(k,M[I*c+2]),c>=4&&v.setW(k,M[I*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(x){const n=this.json,r=this.options,i=n.textures[x].source,o=n.images[i];let l=this.textureLoader;if(o.uri){const c=r.manager.getHandler(o.uri);c!==null&&(l=c)}return this.loadTextureImage(x,i,l)}loadTextureImage(x,n,r){const a=this,i=this.json,o=i.textures[x],l=i.images[n],c=(l.uri||l.bufferView)+":"+o.sampler;if(this.textureCache[c])return this.textureCache[c];const d=this.loadImageSource(n,r).then(function(h){h.flipY=!1,o.name&&(h.name=o.name);const m=(i.samplers||{})[o.sampler]||{};return h.magFilter=EC[m.magFilter]||Sx,h.minFilter=EC[m.minFilter]||_s,h.wrapS=CC[m.wrapS]||Ea,h.wrapT=CC[m.wrapT]||Ea,a.associations.set(h,{textures:x}),h}).catch(function(){return null});return this.textureCache[c]=d,d}loadImageSource(x,n){const r=this,a=this.json,i=this.options;if(this.sourceCache[x]!==void 0)return this.sourceCache[x].then(p=>p.clone());const o=a.images[x],l=self.URL||self.webkitURL;let c=o.uri||"",d=!1;if(o.bufferView!==void 0)c=r.getDependency("bufferView",o.bufferView).then(function(p){d=!0;const m=new Blob([p],{type:o.mimeType});return c=l.createObjectURL(m),c});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+x+" is missing URI and bufferView");const h=Promise.resolve(c).then(function(p){return new Promise(function(m,g){let y=m;n.isImageBitmapLoader===!0&&(y=function(b){const v=new Tn(b);v.needsUpdate=!0,m(v)}),n.load(Qr.resolveURL(p,i.path),y,void 0,g)})}).then(function(p){return d===!0&&l.revokeObjectURL(c),p.userData.mimeType=o.mimeType||une(o.uri),p}).catch(function(p){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),p});return this.sourceCache[x]=h,h}assignTexture(x,n,r,a){const i=this;return this.getDependency("texture",r.index).then(function(o){if(r.texCoord!==void 0&&r.texCoord!=0&&!(n==="aoMap"&&r.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+n+" not yet supported."),i.extensions[Ut.KHR_TEXTURE_TRANSFORM]){const l=r.extensions!==void 0?r.extensions[Ut.KHR_TEXTURE_TRANSFORM]:void 0;if(l){const c=i.associations.get(o);o=i.extensions[Ut.KHR_TEXTURE_TRANSFORM].extendTexture(o,l),i.associations.set(o,c)}}return a!==void 0&&(o.encoding=a),x[n]=o,o})}assignFinalMaterial(x){const n=x.geometry;let r=x.material;const a=n.attributes.tangent===void 0,i=n.attributes.color!==void 0,o=n.attributes.normal===void 0;if(x.isPoints){const l="PointsMaterial:"+r.uuid;let c=this.cache.get(l);c||(c=new Z1,y2.prototype.copy.call(c,r),c.color.copy(r.color),c.map=r.map,c.sizeAttenuation=!1,this.cache.add(l,c)),r=c}else if(x.isLine){const l="LineBasicMaterial:"+r.uuid;let c=this.cache.get(l);c||(c=new i2,y2.prototype.copy.call(c,r),c.color.copy(r.color),this.cache.add(l,c)),r=c}if(a||i||o){let l="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(l+="specular-glossiness:"),a&&(l+="derivative-tangents:"),i&&(l+="vertex-colors:"),o&&(l+="flat-shading:");let c=this.cache.get(l);c||(c=r.clone(),i&&(c.vertexColors=!0),o&&(c.flatShading=!0),a&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(l,c),this.associations.set(c,this.associations.get(r))),r=c}r.aoMap&&n.attributes.uv2===void 0&&n.attributes.uv!==void 0&&n.setAttribute("uv2",n.attributes.uv),x.material=r}getMaterialType(){return qa}loadMaterial(x){const n=this,r=this.json,a=this.extensions,i=r.materials[x];let o;const l={},c=i.extensions||{},d=[];if(c[Ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const p=a[Ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];o=p.getMaterialType(),d.push(p.extendParams(l,i,n))}else if(c[Ut.KHR_MATERIALS_UNLIT]){const p=a[Ut.KHR_MATERIALS_UNLIT];o=p.getMaterialType(),d.push(p.extendParams(l,i,n))}else{const p=i.pbrMetallicRoughness||{};if(l.color=new M0(1,1,1),l.opacity=1,Array.isArray(p.baseColorFactor)){const m=p.baseColorFactor;l.color.fromArray(m),l.opacity=m[3]}p.baseColorTexture!==void 0&&d.push(n.assignTexture(l,"map",p.baseColorTexture,rx)),l.metalness=p.metallicFactor!==void 0?p.metallicFactor:1,l.roughness=p.roughnessFactor!==void 0?p.roughnessFactor:1,p.metallicRoughnessTexture!==void 0&&(d.push(n.assignTexture(l,"metalnessMap",p.metallicRoughnessTexture)),d.push(n.assignTexture(l,"roughnessMap",p.metallicRoughnessTexture))),o=this._invokeOne(function(m){return m.getMaterialType&&m.getMaterialType(x)}),d.push(Promise.all(this._invokeAll(function(m){return m.extendMaterialParams&&m.extendMaterialParams(x,l)})))}i.doubleSided===!0&&(l.side=Sa);const h=i.alphaMode||_y.OPAQUE;if(h===_y.BLEND?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,h===_y.MASK&&(l.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==F2&&(d.push(n.assignTexture(l,"normalMap",i.normalTexture)),l.normalScale=new n0(1,1),i.normalTexture.scale!==void 0)){const p=i.normalTexture.scale;l.normalScale.set(p,p)}return i.occlusionTexture!==void 0&&o!==F2&&(d.push(n.assignTexture(l,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(l.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==F2&&(l.emissive=new M0().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&o!==F2&&d.push(n.assignTexture(l,"emissiveMap",i.emissiveTexture,rx)),Promise.all(d).then(function(){let p;return o===vy?p=a[Ut.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l):p=new o(l),i.name&&(p.name=i.name),ti(p,i),n.associations.set(p,{materials:x}),i.extensions&&rc(a,p,i),p})}createUniqueName(x){const n=Zt.sanitizeNodeName(x||"");let r=n;for(let a=1;this.nodeNamesUsed[r];++a)r=n+"_"+a;return this.nodeNamesUsed[r]=!0,r}loadGeometries(x){const n=this,r=this.extensions,a=this.primitiveCache;function i(l){return r[Ut.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l,n).then(function(c){return NC(c,l,n)})}const o=[];for(let l=0,c=x.length;l<c;l++){const d=x[l],h=cne(d),p=a[h];if(p)o.push(p.promise);else{let m;d.extensions&&d.extensions[Ut.KHR_DRACO_MESH_COMPRESSION]?m=i(d):m=NC(new Rt,d,n),a[h]={primitive:d,promise:m},o.push(m)}}return Promise.all(o)}loadMesh(x){const n=this,r=this.json,a=this.extensions,i=r.meshes[x],o=i.primitives,l=[];for(let c=0,d=o.length;c<d;c++){const h=o[c].material===void 0?ine(this.cache):this.getDependency("material",o[c].material);l.push(h)}return l.push(n.loadGeometries(o)),Promise.all(l).then(function(c){const d=c.slice(0,c.length-1),h=c[c.length-1],p=[];for(let g=0,y=h.length;g<y;g++){const b=h[g],v=o[g];let w;const _=d[g];if(v.mode===es.TRIANGLES||v.mode===es.TRIANGLE_STRIP||v.mode===es.TRIANGLE_FAN||v.mode===void 0)w=i.isSkinnedMesh===!0?new X1(b,_):new yn(b,_),w.isSkinnedMesh===!0&&!w.geometry.attributes.skinWeight.normalized&&w.normalizeSkinWeights(),v.mode===es.TRIANGLE_STRIP?w.geometry=RC(w.geometry,uJ):v.mode===es.TRIANGLE_FAN&&(w.geometry=RC(w.geometry,pA));else if(v.mode===es.LINES)w=new $1(b,_);else if(v.mode===es.LINE_STRIP)w=new Ya(b,_);else if(v.mode===es.LINE_LOOP)w=new kE(b,_);else if(v.mode===es.POINTS)w=new RE(b,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(w.geometry.morphAttributes).length>0&&lne(w,i),w.name=n.createUniqueName(i.name||"mesh_"+x),ti(w,i),v.extensions&&rc(a,w,v),n.assignFinalMaterial(w),p.push(w)}for(let g=0,y=p.length;g<y;g++)n.associations.set(p[g],{meshes:x,primitives:g});if(p.length===1)return p[0];const m=new $r;n.associations.set(m,{meshes:x});for(let g=0,y=p.length;g<y;g++)m.add(p[g]);return m})}loadCamera(x){let n;const r=this.json.cameras[x],a=r[r.type];if(!a){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return r.type==="perspective"?n=new ln(NJ.radToDeg(a.yfov),a.aspectRatio||1,a.znear||1,a.zfar||2e6):r.type==="orthographic"&&(n=new Ll(-a.xmag,a.xmag,a.ymag,-a.ymag,a.znear,a.zfar)),r.name&&(n.name=this.createUniqueName(r.name)),ti(n,r),Promise.resolve(n)}loadSkin(x){const n=this.json.skins[x],r={joints:n.joints};return n.inverseBindMatrices===void 0?Promise.resolve(r):this.getDependency("accessor",n.inverseBindMatrices).then(function(a){return r.inverseBindMatrices=a,r})}loadAnimation(x){const r=this.json.animations[x],a=[],i=[],o=[],l=[],c=[];for(let d=0,h=r.channels.length;d<h;d++){const p=r.channels[d],m=r.samplers[p.sampler],g=p.target,y=g.node!==void 0?g.node:g.id,b=r.parameters!==void 0?r.parameters[m.input]:m.input,v=r.parameters!==void 0?r.parameters[m.output]:m.output;a.push(this.getDependency("node",y)),i.push(this.getDependency("accessor",b)),o.push(this.getDependency("accessor",v)),l.push(m),c.push(g)}return Promise.all([Promise.all(a),Promise.all(i),Promise.all(o),Promise.all(l),Promise.all(c)]).then(function(d){const h=d[0],p=d[1],m=d[2],g=d[3],y=d[4],b=[];for(let w=0,_=h.length;w<_;w++){const T=h[w],A=p[w],E=m[w],M=g[w],I=y[w];if(T===void 0)continue;T.updateMatrix();let C;switch(Os[I.path]){case Os.weights:C=Ql;break;case Os.rotation:C=Ka;break;case Os.position:case Os.scale:default:C=jl;break}const k=T.name?T.name:T.uuid,O=M.interpolation!==void 0?ane[M.interpolation]:Vi,z=[];Os[I.path]===Os.weights?T.traverse(function(re){re.morphTargetInfluences&&z.push(re.name?re.name:re.uuid)}):z.push(k);let ee=E.array;if(E.normalized){const re=Sy(ee.constructor),Y=new Float32Array(ee.length);for(let Q=0,te=ee.length;Q<te;Q++)Y[Q]=ee[Q]*re;ee=Y}for(let re=0,Y=z.length;re<Y;re++){const Q=new C(z[re]+"."+Os[I.path],A.array,ee,O);M.interpolation==="CUBICSPLINE"&&(Q.createInterpolant=function(se){const xe=this instanceof Ka?sne:AC;return new xe(this.times,this.values,this.getValueSize()/3,se)},Q.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),b.push(Q)}}const v=r.name?r.name:"animation_"+x;return new ec(v,void 0,b)})}createNodeMesh(x){const n=this.json,r=this,a=n.nodes[x];return a.mesh===void 0?null:r.getDependency("mesh",a.mesh).then(function(i){const o=r._getNodeRef(r.meshCache,a.mesh,i);return a.weights!==void 0&&o.traverse(function(l){if(!!l.isMesh)for(let c=0,d=a.weights.length;c<d;c++)l.morphTargetInfluences[c]=a.weights[c]}),o})}loadNode(x){const n=this.json,r=this.extensions,a=this,i=n.nodes[x],o=i.name?a.createUniqueName(i.name):"";return function(){const l=[],c=a._invokeOne(function(d){return d.createNodeMesh&&d.createNodeMesh(x)});return c&&l.push(c),i.camera!==void 0&&l.push(a.getDependency("camera",i.camera).then(function(d){return a._getNodeRef(a.cameraCache,i.camera,d)})),a._invokeAll(function(d){return d.createNodeAttachment&&d.createNodeAttachment(x)}).forEach(function(d){l.push(d)}),Promise.all(l)}().then(function(l){let c;if(i.isBone===!0?c=new hh:l.length>1?c=new $r:l.length===1?c=l[0]:c=new Px,c!==l[0])for(let d=0,h=l.length;d<h;d++)c.add(l[d]);if(i.name&&(c.userData.name=i.name,c.name=o),ti(c,i),i.extensions&&rc(r,c,i),i.matrix!==void 0){const d=new wt;d.fromArray(i.matrix),c.applyMatrix4(d)}else i.translation!==void 0&&c.position.fromArray(i.translation),i.rotation!==void 0&&c.quaternion.fromArray(i.rotation),i.scale!==void 0&&c.scale.fromArray(i.scale);return a.associations.has(c)||a.associations.set(c,{}),a.associations.get(c).nodes=x,c})}loadScene(x){const n=this.json,r=this.extensions,a=this.json.scenes[x],i=this,o=new $r;a.name&&(o.name=i.createUniqueName(a.name)),ti(o,a),a.extensions&&rc(r,o,a);const l=a.nodes||[],c=[];for(let d=0,h=l.length;d<h;d++)c.push(kC(l[d],o,n,i));return Promise.all(c).then(function(){const d=h=>{const p=new Map;for(const[m,g]of i.associations)(m instanceof y2||m instanceof Tn)&&p.set(m,g);return h.traverse(m=>{const g=i.associations.get(m);g!=null&&p.set(m,g)}),p};return i.associations=d(o),o})}}function kC(s,x,n,r){const a=n.nodes[s];return r.getDependency("node",s).then(function(i){if(a.skin===void 0)return i;let o;return r.getDependency("skin",a.skin).then(function(l){o=l;const c=[];for(let d=0,h=o.joints.length;d<h;d++)c.push(r.getDependency("node",o.joints[d]));return Promise.all(c)}).then(function(l){return i.traverse(function(c){if(!c.isMesh)return;const d=[],h=[];for(let p=0,m=l.length;p<m;p++){const g=l[p];if(g){d.push(g);const y=new wt;o.inverseBindMatrices!==void 0&&y.fromArray(o.inverseBindMatrices.array,p*16),h.push(y)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[p])}c.bind(new ph(d,h),c.matrixWorld)}),i})}).then(function(i){x.add(i);const o=[];if(a.children){const l=a.children;for(let c=0,d=l.length;c<d;c++){const h=l[c];o.push(kC(h,i,n,r))}}return Promise.all(o)})}function hne(s,x,n){const r=x.attributes,a=new Da;if(r.POSITION!==void 0){const l=n.json.accessors[r.POSITION],c=l.min,d=l.max;if(c!==void 0&&d!==void 0){if(a.set(new K(c[0],c[1],c[2]),new K(d[0],d[1],d[2])),l.normalized){const h=Sy(nc[l.componentType]);a.min.multiplyScalar(h),a.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=x.targets;if(i!==void 0){const l=new K,c=new K;for(let d=0,h=i.length;d<h;d++){const p=i[d];if(p.POSITION!==void 0){const m=n.json.accessors[p.POSITION],g=m.min,y=m.max;if(g!==void 0&&y!==void 0){if(c.setX(Math.max(Math.abs(g[0]),Math.abs(y[0]))),c.setY(Math.max(Math.abs(g[1]),Math.abs(y[1]))),c.setZ(Math.max(Math.abs(g[2]),Math.abs(y[2]))),m.normalized){const b=Sy(nc[m.componentType]);c.multiplyScalar(b)}l.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}a.expandByVector(l)}s.boundingBox=a;const o=new Ba;a.getCenter(o.center),o.radius=a.min.distanceTo(a.max)/2,s.boundingSphere=o}function NC(s,x,n){const r=x.attributes,a=[];function i(o,l){return n.getDependency("accessor",o).then(function(c){s.setAttribute(l,c)})}for(const o in r){const l=wy[o]||o.toLowerCase();l in s.attributes||a.push(i(r[o],l))}if(x.indices!==void 0&&!s.index){const o=n.getDependency("accessor",x.indices).then(function(l){s.setIndex(l)});a.push(o)}return ti(s,x),hne(s,x,n),Promise.all(a).then(function(){return x.targets!==void 0?one(s,x.targets,n):s})}function RC(s,x){let n=s.getIndex();if(n===null){const o=[],l=s.getAttribute("position");if(l!==void 0){for(let c=0;c<l.count;c++)o.push(c);s.setIndex(o),n=s.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),s}const r=n.count-2,a=[];if(x===pA)for(let o=1;o<=r;o++)a.push(n.getX(0)),a.push(n.getX(o)),a.push(n.getX(o+1));else for(let o=0;o<r;o++)o%2===0?(a.push(n.getX(o)),a.push(n.getX(o+1)),a.push(n.getX(o+2))):(a.push(n.getX(o+2)),a.push(n.getX(o+1)),a.push(n.getX(o)));a.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=s.clone();return i.setIndex(a),i}class pne extends Qte{constructor(x){super(x),this.type=Gr}parse(x){const l=function(T,A){switch(T){case 1:console.error("THREE.RGBELoader Read Error: "+(A||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(A||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(A||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(A||""))}return-1},p=`
`,m=function(T,A,E){A=A||1024;let I=T.pos,C=-1,k=0,O="",z=String.fromCharCode.apply(null,new Uint16Array(T.subarray(I,I+128)));for(;0>(C=z.indexOf(p))&&k<A&&I<T.byteLength;)O+=z,k+=z.length,I+=128,z+=String.fromCharCode.apply(null,new Uint16Array(T.subarray(I,I+128)));return-1<C?(E!==!1&&(T.pos+=k+C+1),O+z.slice(0,C)):!1},g=function(T){const A=/^#\?(\S+)/,E=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,M=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,I=/^\s*FORMAT=(\S+)\s*$/,C=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,k={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let O,z;if(T.pos>=T.byteLength||!(O=m(T)))return l(1,"no header found");if(!(z=O.match(A)))return l(3,"bad initial token");for(k.valid|=1,k.programtype=z[1],k.string+=O+`
`;O=m(T),O!==!1;){if(k.string+=O+`
`,O.charAt(0)==="#"){k.comments+=O+`
`;continue}if((z=O.match(E))&&(k.gamma=parseFloat(z[1])),(z=O.match(M))&&(k.exposure=parseFloat(z[1])),(z=O.match(I))&&(k.valid|=2,k.format=z[1]),(z=O.match(C))&&(k.valid|=4,k.height=parseInt(z[1],10),k.width=parseInt(z[2],10)),k.valid&2&&k.valid&4)break}return k.valid&2?k.valid&4?k:l(3,"missing image size specifier"):l(3,"missing format specifier")},y=function(T,A,E){const M=A;if(M<8||M>32767||T[0]!==2||T[1]!==2||T[2]&128)return new Uint8Array(T);if(M!==(T[2]<<8|T[3]))return l(3,"wrong scanline width");const I=new Uint8Array(4*A*E);if(!I.length)return l(4,"unable to allocate buffer space");let C=0,k=0;const O=4*M,z=new Uint8Array(4),ee=new Uint8Array(O);let re=E;for(;re>0&&k<T.byteLength;){if(k+4>T.byteLength)return l(1);if(z[0]=T[k++],z[1]=T[k++],z[2]=T[k++],z[3]=T[k++],z[0]!=2||z[1]!=2||(z[2]<<8|z[3])!=M)return l(3,"bad rgbe scanline format");let Y=0,Q;for(;Y<O&&k<T.byteLength;){Q=T[k++];const se=Q>128;if(se&&(Q-=128),Q===0||Y+Q>O)return l(3,"bad scanline data");if(se){const xe=T[k++];for(let ae=0;ae<Q;ae++)ee[Y++]=xe}else ee.set(T.subarray(k,k+Q),Y),Y+=Q,k+=Q}const te=M;for(let se=0;se<te;se++){let xe=0;I[C]=ee[se+xe],xe+=M,I[C+1]=ee[se+xe],xe+=M,I[C+2]=ee[se+xe],xe+=M,I[C+3]=ee[se+xe],C+=4}re--}return I},b=function(T,A,E,M){const I=T[A+3],C=Math.pow(2,I-128)/255;E[M+0]=T[A+0]*C,E[M+1]=T[A+1]*C,E[M+2]=T[A+2]*C,E[M+3]=1},v=function(T,A,E,M){const I=T[A+3],C=Math.pow(2,I-128)/255;E[M+0]=Xh.toHalfFloat(Math.min(T[A+0]*C,65504)),E[M+1]=Xh.toHalfFloat(Math.min(T[A+1]*C,65504)),E[M+2]=Xh.toHalfFloat(Math.min(T[A+2]*C,65504)),E[M+3]=Xh.toHalfFloat(1)},w=new Uint8Array(x);w.pos=0;const _=g(w);if(_!==-1){const T=_.width,A=_.height,E=y(w.subarray(w.pos),T,A);if(E!==-1){let M,I,C;switch(this.type){case J2:C=E.length/4;const k=new Float32Array(C*4);for(let z=0;z<C;z++)b(E,z*4,k,z*4);M=k,I=J2;break;case Gr:C=E.length/4;const O=new Uint16Array(C*4);for(let z=0;z<C;z++)v(E,z*4,O,z*4);M=O,I=Gr;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:T,height:A,data:M,header:_.string,gamma:_.gamma,exposure:_.exposure,type:I}}}return null}setDataType(x){return this.type=x,this}load(x,n,r,a){function i(o,l){switch(o.type){case J2:case Gr:o.encoding=Ss,o.minFilter=Sx,o.magFilter=Sx,o.generateMipmaps=!1,o.flipY=!0;break}n&&n(o,l)}return super.load(x,i,r,a)}}class fne extends $a{constructor(x){super(x)}load(x,n,r,a){const i=this,o=new rr(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(i.withCredentials),o.load(x,function(l){let c;try{c=JSON.parse(l)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),c=JSON.parse(l.substring(65,l.length-2))}const d=i.parse(c);n&&n(d)},r,a)}parse(x){return new mne(x)}}class mne{constructor(x){this.isFont=!0,this.type="Font",this.data=x}generateShapes(x,n=100){const r=[],a=gne(x,n,this.data);for(let i=0,o=a.length;i<o;i++)r.push(...a[i].toShapes());return r}}function gne(s,x,n){const r=Array.from(s),a=x/n.resolution,i=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*a,o=[];let l=0,c=0;for(let d=0;d<r.length;d++){const h=r[d];if(h===`
`)l=0,c-=i;else{const p=yne(h,a,l,c,n);l+=p.offsetX,o.push(p.path)}}return o}function yne(s,x,n,r,a){const i=a.glyphs[s]||a.glyphs["?"];if(!i){console.error('THREE.Font: character "'+s+'" does not exists in font family '+a.familyName+".");return}const o=new Mxe;let l,c,d,h,p,m,g,y;if(i.o){const b=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let v=0,w=b.length;v<w;)switch(b[v++]){case"m":l=b[v++]*x+n,c=b[v++]*x+r,o.moveTo(l,c);break;case"l":l=b[v++]*x+n,c=b[v++]*x+r,o.lineTo(l,c);break;case"q":d=b[v++]*x+n,h=b[v++]*x+r,p=b[v++]*x+n,m=b[v++]*x+r,o.quadraticCurveTo(p,m,d,h);break;case"b":d=b[v++]*x+n,h=b[v++]*x+r,p=b[v++]*x+n,m=b[v++]*x+r,g=b[v++]*x+n,y=b[v++]*x+r,o.bezierCurveTo(p,m,g,y,d,h);break}}return{offsetX:i.ha*x,path:o}}class bne extends Kl{constructor(x,n={}){const r=n.font;if(r===void 0)super();else{const a=r.generateShapes(x,n.size);n.depth=n.height!==void 0?n.height:50,n.bevelThickness===void 0&&(n.bevelThickness=10),n.bevelSize===void 0&&(n.bevelSize=8),n.bevelEnabled===void 0&&(n.bevelEnabled=!1),super(a,n)}this.type="TextGeometry"}}class vne extends Lxe{constructor(x,n,r,a="onesie.glb",i){super(x,n,r),this.url=a,this.outfit=i,this.plugin=new Fxe(void 0,i),this.addPlugin(this.plugin)}plugin;model;light;ambient;lightInt=.75;ambientInt=1.25;handsUp=!1;textModel;async load(){if(!(this.loaded||!this.scene))return await this.setupScene(this.scene),super.load()}async setupScene(x){await this.setModel(this.url),this.light=new hy(16777215,this.lightInt),this.ambient=new nC(16777215,this.ambientInt),x.add(this.light),x.add(this.ambient);const n=await new pne().loadAsync("environment.hdr");n.mapping=_l,x.environment=n;const r=await new fne().loadAsync("font.json"),a=new bne("HOORAY!!!",{font:r,size:5,height:2,bevelSize:.3,bevelThickness:1,bevelSegments:10,bevelEnabled:!0});a.scale(.01,.01,.01),a.computeBoundingBox();const i=a.boundingBox;i&&a.translate(...i.max.sub(i.min).multiplyScalar(-.5).toArray()),a.rotateY(Math.PI);const o=new yn(a,[new qa({color:3922843,flatShading:!0}),new qa({color:3922843})]);this.textModel=new $r,this.textModel.visible=!1,this.textModel.add(o),this.scene?.add(this.textModel)}async setModel(x){return this.setOutfit(x,this.outfit)}async setOutfit(x,n){this.model&&this.disposeObject(this.model),delete this.model,this.url=x,this.outfit=n;const r=await new Uxe().loadAsync(x);this.model=r.scene,this.scene?.add(this.model),this.plugin.setOutfit(this.model,n)}async update(x,n){const r=x.poses&&x.poses.length>0?x.poses[0]:void 0;if(!r)return this.handsUp=!1,super.update(x,n);const{points:a}=r,i=new K(...a.hipL.metric),o=new K(...a.hipR.metric),l=new K(...a.shoulderL.metric),c=new K(...a.shoulderR.metric),d=new K(...a.elbowL.metric),h=new K(...a.elbowR.metric),p=new K(...a.wristL.metric),m=new K(...a.wristR.metric),g=l.clone().sub(i).normalize(),y=c.clone().sub(o).normalize(),b=d.clone().sub(l).normalize(),v=h.clone().sub(c).normalize(),w=p.clone().sub(d).normalize(),_=m.clone().sub(h).normalize(),T=g.dot(b),A=y.dot(v),E=w.dot(b),M=_.dot(v),I=Math.min(T,A,E,M);I>.8&&(this.handsUp=!0),I<.7&&(this.handsUp=!1);const{textModel:C}=this;if(C){const k=p.clone().lerp(m,.5);C.position.copy(k),C.visible=this.handsUp}await super.update(x,n)}}const So=new fZ,wne=(location.hostname==="localhost","localhost_sdk_token");let To=new URLSearchParams(window.location.search).has("rear");const ts={onesie:{file:"onesie.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Footwear/]}},jacket:{file:"jacket.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Bottom/,/Footwear/,/Glasses/]}}};let Fs="onesie",xi=ts.onesie.avatar;function PC(){const s=document.createElement("div");s.className="spinner-container",s.id="spinner";const x=document.createElement("div");x.className="spinner";for(let n=0;n<6;n++){const r=document.createElement("div");r.className="spinner-dot",x.appendChild(r)}return s.appendChild(x),s}async function _ne(){const s=document.getElementById("root");if(!s)return;const x=new vne(s,"crop",!To,ts[Fs].file,xi?void 0:ts[Fs].outfit),n=document.getElementById("camera-switch");n&&(n.onclick=async()=>{n.disabled=!0,To=!To,await So.setup({size:{width:1920,height:1080},rear:To}),await So.start(),x.setMirror(!To),n.disabled=!1});const r=document.getElementById("outfit-switch");r.checked=xi,r.onchange=async()=>{c.forEach(h=>{h.disabled=!0}),r.disabled=!0;const d=PC();document.body.appendChild(d),xi=r.checked,await x.setOutfit(ts[Fs].file,xi?void 0:ts[Fs].outfit),document.body.removeChild(d),c.forEach(h=>{h.disabled=!1}),r.disabled=!1};const i=navigator.userAgent.indexOf("Safari")>-1&&navigator.userAgent.indexOf("Chrome")<=-1?"mp4":"webm",o=new dZ(x,"video/"+i),l=document.getElementById("record");l&&(l.onclick=()=>{o?.start(),setTimeout(async()=>{const d=await o?.stop();if(!d)return;const h=URL.createObjectURL(d),p=document.createElement("a");p.hidden=!0,p.href=h,p.download="capture."+i,p.click(),p.remove(),URL.revokeObjectURL(h)},1e4)});const c=document.getElementsByName("model");c.forEach(d=>{d.onchange=async()=>{if(d.checked&&ts[d.value]){c.forEach(p=>{p.disabled=!0}),r.disabled=!0;const h=PC();document.body.appendChild(h),Fs=d.value,xi=ts[Fs].avatar,await x.setOutfit(ts[Fs].file,xi?void 0:ts[Fs].outfit),r.checked=xi,document.body.removeChild(h),c.forEach(p=>{p.disabled=!1}),r.disabled=!1}}}),await Promise.all([So.addRenderer(x),So.init({token:wne})]),await So.setup({size:{width:1920,height:1080},rear:To}),await So.start(),document.getElementById("dots")?.remove()}_ne()})()})();
